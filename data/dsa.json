{
  "topic": "DSA (Data Structures & Algorithms)",
  "questions": [
    {
      "id": 1,
      "question": "What is a data structure and why is it important?",
      "answer": "A data structure is a way of organizing and storing data in a computer so that it can be accessed and modified efficiently.\n\nKey Points:\n• Provides a means to manage large amounts of data efficiently\n• Enables fast data retrieval and manipulation\n• Forms the foundation for algorithm design\n• Different structures suit different types of operations\n\nCommon Data Structures:\n• Arrays - for sequential storage\n• Linked Lists - for dynamic insertions/deletions\n• Stacks - for LIFO operations\n• Queues - for FIFO operations\n• Trees - for hierarchical data\n• Graphs - for network relationships\n• Hash Tables - for fast lookups",
      "explanation": "Data structures are specialized formats for organizing, storing, and managing data efficiently to enable fast access and modification operations.",
      "difficulty": "Easy"
    },
    {
      "id": 2,
      "question": "What is time complexity and Big O notation?",
      "answer": "Time complexity measures the amount of time an algorithm takes to run as a function of the input size. Big O notation describes the upper bound of time complexity in the worst-case scenario.\n\nCommon Time Complexities (Best to Worst):\n• O(1) - Constant: array access, hash lookup\n• O(log n) - Logarithmic: binary search\n• O(n) - Linear: linear search, array traversal\n• O(n log n) - Linearithmic: merge sort, heap sort\n• O(n²) - Quadratic: bubble sort, selection sort\n• O(2^n) - Exponential: recursive fibonacci\n• O(n!) - Factorial: permutations generation\n\nImportance:\n• Helps compare algorithm efficiency\n• Predicts scalability\n• Guides optimization decisions",
      "explanation": "Big O notation describes the worst-case time complexity of an algorithm, showing how runtime grows relative to input size.",
      "difficulty": "Easy",
      "code": "// Examples of different time complexities\n\n// O(1) - Constant\npublic int getFirst(int[] arr) {\n    return arr[0]; // Always one operation\n}\n\n// O(n) - Linear\npublic int sum(int[] arr) {\n    int total = 0;\n    for (int num : arr) {\n        total += num; // n operations\n    }\n    return total;\n}\n\n// O(n²) - Quadratic\npublic void printPairs(int[] arr) {\n    for (int i = 0; i < arr.length; i++) {\n        for (int j = 0; j < arr.length; j++) {\n            System.out.println(arr[i] + \", \" + arr[j]);\n        }\n    }\n}\n\n// O(log n) - Logarithmic\npublic int binarySearch(int[] arr, int target) {\n    int left = 0, right = arr.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) return mid;\n        if (arr[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1;\n}"
    },
    {
      "id": 3,
      "question": "What is the difference between an array and a linked list?",
      "answer": "Arrays and linked lists are both linear data structures, but they differ significantly in memory allocation, access patterns, and performance characteristics.\n\nArray Characteristics:\n• Contiguous memory allocation\n• Fixed size (in most languages)\n• O(1) random access by index\n• O(n) insertion/deletion (requires shifting)\n• Better cache locality\n• Less memory overhead\n\nLinked List Characteristics:\n• Non-contiguous memory allocation\n• Dynamic size\n• O(n) access by position\n• O(1) insertion/deletion (if position is known)\n• Poor cache performance\n• Extra memory for pointers\n\nWhen to Use:\n• Array: frequent access, known size, memory efficiency\n• Linked List: frequent insertions/deletions, unknown size",
      "explanation": "Arrays provide fast random access with contiguous memory, while linked lists enable efficient insertions and deletions with dynamic memory allocation.",
      "difficulty": "Easy",
      "code": "// Array Implementation\npublic class ArrayExample {\n    int[] arr = new int[5]; // Fixed size\n    \n    public int get(int index) {\n        return arr[index]; // O(1) access\n    }\n}\n\n// Linked List Node\nclass Node {\n    int data;\n    Node next;\n    \n    Node(int data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\n// Linked List Implementation\nclass LinkedList {\n    Node head;\n    \n    // Insert at beginning - O(1)\n    public void insertFirst(int data) {\n        Node newNode = new Node(data);\n        newNode.next = head;\n        head = newNode;\n    }\n    \n    // Access by position - O(n)\n    public int get(int index) {\n        Node current = head;\n        for (int i = 0; i < index && current != null; i++) {\n            current = current.next;\n        }\n        return current != null ? current.data : -1;\n    }\n}"
    },
    {
      "id": 4,
      "question": "What is a stack and what are its common applications?",
      "answer": "A stack is a linear data structure that follows the Last-In-First-Out (LIFO) principle, where elements are added and removed from the same end called the top.\n\nCore Operations:\n• Push - Add element to top - O(1)\n• Pop - Remove element from top - O(1)\n• Peek/Top - View top element without removing - O(1)\n• isEmpty - Check if stack is empty - O(1)\n\nCommon Applications:\n• Function call management (call stack)\n• Expression evaluation and conversion\n• Undo/Redo operations\n• Backtracking algorithms\n• Browser history navigation\n• Parentheses matching\n• Depth-First Search (DFS)\n\nImplementation Options:\n• Array-based (fixed size)\n• Dynamic array (ArrayList)\n• Linked list (unlimited size)",
      "explanation": "A stack is a LIFO data structure where elements are added and removed from the top, commonly used for function calls, expression evaluation, and backtracking.",
      "difficulty": "Easy",
      "code": "// Stack implementation using array\nclass Stack {\n    private int[] arr;\n    private int top;\n    private int capacity;\n    \n    public Stack(int size) {\n        arr = new int[size];\n        capacity = size;\n        top = -1;\n    }\n    \n    // Push element - O(1)\n    public void push(int value) {\n        if (isFull()) {\n            throw new RuntimeException(\"Stack Overflow\");\n        }\n        arr[++top] = value;\n    }\n    \n    // Pop element - O(1)\n    public int pop() {\n        if (isEmpty()) {\n            throw new RuntimeException(\"Stack Underflow\");\n        }\n        return arr[top--];\n    }\n    \n    // Peek top element - O(1)\n    public int peek() {\n        if (isEmpty()) {\n            throw new RuntimeException(\"Stack is empty\");\n        }\n        return arr[top];\n    }\n    \n    public boolean isEmpty() {\n        return top == -1;\n    }\n    \n    public boolean isFull() {\n        return top == capacity - 1;\n    }\n}\n\n// Using Java's built-in Stack\nimport java.util.Stack;\n\nStack<Integer> stack = new Stack<>();\nstack.push(10);\nstack.push(20);\nint top = stack.pop(); // Returns 20"
    },
    {
      "id": 5,
      "question": "What is a queue and what are its types?",
      "answer": "A queue is a linear data structure that follows the First-In-First-Out (FIFO) principle, where elements are added at the rear and removed from the front.\n\nBasic Operations:\n• Enqueue - Add element at rear - O(1)\n• Dequeue - Remove element from front - O(1)\n• Front/Peek - View front element - O(1)\n• isEmpty - Check if queue is empty - O(1)\n\nTypes of Queues:\n• Simple Queue - Standard FIFO queue\n• Circular Queue - Last position connects to first, efficient space usage\n• Priority Queue - Elements have priorities, highest priority dequeued first\n• Deque (Double-ended Queue) - Insert/delete from both ends\n\nCommon Applications:\n• Task scheduling in operating systems\n• Breadth-First Search (BFS)\n• Print job spooling\n• Request handling in web servers\n• Message queues in distributed systems",
      "explanation": "A queue is a FIFO data structure where elements are added at the rear and removed from the front, commonly used for scheduling and breadth-first traversals.",
      "difficulty": "Easy",
      "code": "// Queue implementation using array\nclass Queue {\n    private int[] arr;\n    private int front, rear, size, capacity;\n    \n    public Queue(int capacity) {\n        this.capacity = capacity;\n        arr = new int[capacity];\n        front = 0;\n        rear = -1;\n        size = 0;\n    }\n    \n    // Enqueue - O(1)\n    public void enqueue(int value) {\n        if (isFull()) {\n            throw new RuntimeException(\"Queue is full\");\n        }\n        rear = (rear + 1) % capacity; // Circular\n        arr[rear] = value;\n        size++;\n    }\n    \n    // Dequeue - O(1)\n    public int dequeue() {\n        if (isEmpty()) {\n            throw new RuntimeException(\"Queue is empty\");\n        }\n        int value = arr[front];\n        front = (front + 1) % capacity;\n        size--;\n        return value;\n    }\n    \n    public int peek() {\n        if (isEmpty()) {\n            throw new RuntimeException(\"Queue is empty\");\n        }\n        return arr[front];\n    }\n    \n    public boolean isEmpty() {\n        return size == 0;\n    }\n    \n    public boolean isFull() {\n        return size == capacity;\n    }\n}\n\n// Using Java's Queue interface\nimport java.util.Queue;\nimport java.util.LinkedList;\n\nQueue<Integer> queue = new LinkedList<>();\nqueue.offer(10);\nqueue.offer(20);\nint front = queue.poll(); // Returns 10"
    },
    {
      "id": 6,
      "question": "What is a binary tree and what are its types?",
      "answer": "A binary tree is a hierarchical data structure where each node has at most two children, referred to as left child and right child.\n\nBinary Tree Types:\n• Full Binary Tree - Every node has 0 or 2 children\n• Complete Binary Tree - All levels filled except possibly last, filled left to right\n• Perfect Binary Tree - All internal nodes have 2 children, all leaves at same level\n• Balanced Binary Tree - Height difference between left and right subtrees is at most 1\n• Binary Search Tree (BST) - Left child < parent < right child\n\nKey Properties:\n• Maximum nodes at level i = 2^i\n• Maximum nodes in tree of height h = 2^(h+1) - 1\n• Minimum height for n nodes = log₂(n+1) - 1\n\nTraversal Methods:\n• Inorder (Left-Root-Right)\n• Preorder (Root-Left-Right)\n• Postorder (Left-Right-Root)\n• Level Order (BFS)",
      "explanation": "A binary tree is a hierarchical structure where each node has at most two children, with various types based on structure and ordering properties.",
      "difficulty": "Easy",
      "code": "// Binary Tree Node\nclass TreeNode {\n    int data;\n    TreeNode left, right;\n    \n    TreeNode(int data) {\n        this.data = data;\n        left = right = null;\n    }\n}\n\n// Binary Tree Operations\nclass BinaryTree {\n    TreeNode root;\n    \n    // Inorder Traversal (Left-Root-Right)\n    public void inorder(TreeNode node) {\n        if (node == null) return;\n        inorder(node.left);\n        System.out.print(node.data + \" \");\n        inorder(node.right);\n    }\n    \n    // Preorder Traversal (Root-Left-Right)\n    public void preorder(TreeNode node) {\n        if (node == null) return;\n        System.out.print(node.data + \" \");\n        preorder(node.left);\n        preorder(node.right);\n    }\n    \n    // Postorder Traversal (Left-Right-Root)\n    public void postorder(TreeNode node) {\n        if (node == null) return;\n        postorder(node.left);\n        postorder(node.right);\n        System.out.print(node.data + \" \");\n    }\n    \n    // Tree height\n    public int height(TreeNode node) {\n        if (node == null) return -1;\n        return 1 + Math.max(height(node.left), height(node.right));\n    }\n}"
    },
    {
      "id": 7,
      "question": "What is a Binary Search Tree (BST) and what are its operations?",
      "answer": "A Binary Search Tree is a binary tree where for each node, all values in the left subtree are smaller and all values in the right subtree are larger than the node's value.\n\nBST Properties:\n• Left subtree contains only nodes with keys less than node's key\n• Right subtree contains only nodes with keys greater than node's key\n• Both left and right subtrees are also BSTs\n• No duplicate nodes (typically)\n\nCore Operations:\n• Search - O(h) where h is height, O(log n) average, O(n) worst\n• Insert - O(h) time complexity\n• Delete - O(h) time complexity\n• Find Min/Max - O(h) time complexity\n\nAdvantages:\n• Faster search than linked list\n• Maintains sorted order\n• Efficient insertion and deletion\n\nDisadvantages:\n• Can become unbalanced (skewed)\n• Worst case O(n) for all operations",
      "explanation": "A Binary Search Tree maintains ordered data where left children are smaller and right children are larger, enabling efficient O(log n) search, insert, and delete operations.",
      "difficulty": "Medium",
      "code": "class BST {\n    TreeNode root;\n    \n    // Search - O(h)\n    public boolean search(TreeNode node, int key) {\n        if (node == null) return false;\n        if (node.data == key) return true;\n        if (key < node.data) return search(node.left, key);\n        return search(node.right, key);\n    }\n    \n    // Insert - O(h)\n    public TreeNode insert(TreeNode node, int key) {\n        if (node == null) {\n            return new TreeNode(key);\n        }\n        if (key < node.data) {\n            node.left = insert(node.left, key);\n        } else if (key > node.data) {\n            node.right = insert(node.right, key);\n        }\n        return node;\n    }\n    \n    // Delete - O(h)\n    public TreeNode delete(TreeNode node, int key) {\n        if (node == null) return null;\n        \n        if (key < node.data) {\n            node.left = delete(node.left, key);\n        } else if (key > node.data) {\n            node.right = delete(node.right, key);\n        } else {\n            // Node with one or no child\n            if (node.left == null) return node.right;\n            if (node.right == null) return node.left;\n            \n            // Node with two children\n            node.data = findMin(node.right);\n            node.right = delete(node.right, node.data);\n        }\n        return node;\n    }\n    \n    // Find minimum value\n    private int findMin(TreeNode node) {\n        while (node.left != null) {\n            node = node.left;\n        }\n        return node.data;\n    }\n}"
    },
    {
      "id": 8,
      "question": "What is a hash table and how does it handle collisions?",
      "answer": "A hash table is a data structure that maps keys to values using a hash function, providing average O(1) time complexity for search, insert, and delete operations.\n\nCore Components:\n• Hash Function - Converts key to array index\n• Array/Buckets - Stores the actual data\n• Collision Resolution - Handles when multiple keys hash to same index\n\nHash Function Properties:\n• Deterministic - same input always produces same output\n• Uniform distribution - minimizes collisions\n• Fast to compute\n• Minimizes clustering\n\nCollision Resolution Techniques:\n• Chaining - Each bucket holds a linked list of entries\n• Open Addressing - Find next available slot\n  - Linear Probing - Check next slot sequentially\n  - Quadratic Probing - Check slots at quadratic intervals\n  - Double Hashing - Use second hash function\n\nLoad Factor:\n• Ratio of entries to buckets\n• Affects performance and collision rate\n• Typically rehash when load factor exceeds 0.75",
      "explanation": "Hash tables use hash functions to map keys to array indices for O(1) average access, with collision resolution techniques like chaining or open addressing.",
      "difficulty": "Medium",
      "code": "// Hash Table with Chaining\nclass HashNode {\n    int key, value;\n    HashNode next;\n    \n    HashNode(int key, int value) {\n        this.key = key;\n        this.value = value;\n    }\n}\n\nclass HashTable {\n    private HashNode[] buckets;\n    private int size;\n    private int capacity;\n    \n    public HashTable(int capacity) {\n        this.capacity = capacity;\n        buckets = new HashNode[capacity];\n        size = 0;\n    }\n    \n    // Hash function\n    private int hash(int key) {\n        return Math.abs(key) % capacity;\n    }\n    \n    // Insert - O(1) average\n    public void put(int key, int value) {\n        int index = hash(key);\n        HashNode head = buckets[index];\n        \n        // Check if key exists\n        while (head != null) {\n            if (head.key == key) {\n                head.value = value;\n                return;\n            }\n            head = head.next;\n        }\n        \n        // Insert new node at beginning\n        head = buckets[index];\n        HashNode newNode = new HashNode(key, value);\n        newNode.next = head;\n        buckets[index] = newNode;\n        size++;\n    }\n    \n    // Search - O(1) average\n    public Integer get(int key) {\n        int index = hash(key);\n        HashNode head = buckets[index];\n        \n        while (head != null) {\n            if (head.key == key) {\n                return head.value;\n            }\n            head = head.next;\n        }\n        return null;\n    }\n    \n    // Delete - O(1) average\n    public Integer remove(int key) {\n        int index = hash(key);\n        HashNode head = buckets[index];\n        HashNode prev = null;\n        \n        while (head != null) {\n            if (head.key == key) {\n                if (prev != null) {\n                    prev.next = head.next;\n                } else {\n                    buckets[index] = head.next;\n                }\n                size--;\n                return head.value;\n            }\n            prev = head;\n            head = head.next;\n        }\n        return null;\n    }\n}"
    },
    {
      "id": 9,
      "question": "What is recursion and what are its key components?",
      "answer": "Recursion is a programming technique where a function calls itself to solve a problem by breaking it down into smaller subproblems of the same type.\n\nKey Components:\n• Base Case - Termination condition that stops recursion\n• Recursive Case - Function calls itself with modified parameters\n• Progress Toward Base Case - Each call moves closer to termination\n\nTypes of Recursion:\n• Direct Recursion - Function calls itself\n• Indirect Recursion - Function calls another function that calls it back\n• Tail Recursion - Recursive call is the last operation\n• Head Recursion - Recursive call is the first operation\n\nAdvantages:\n• Simplifies complex problems\n• Natural for tree and graph traversal\n• Cleaner code for divide-and-conquer algorithms\n\nDisadvantages:\n• Stack overflow risk for deep recursion\n• Higher memory usage (call stack)\n• Usually slower than iteration\n• Can be harder to debug",
      "explanation": "Recursion is a technique where a function calls itself to solve problems by breaking them into smaller subproblems, requiring a base case and recursive case.",
      "difficulty": "Medium",
      "code": "// Basic recursion examples\n\n// Factorial - O(n) time, O(n) space\npublic int factorial(int n) {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}\n\n// Fibonacci - O(2^n) time without memoization\npublic int fibonacci(int n) {\n    if (n <= 1) return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n// Fibonacci with memoization - O(n) time, O(n) space\npublic int fibMemo(int n, int[] memo) {\n    if (n <= 1) return n;\n    if (memo[n] != 0) return memo[n];\n    memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo);\n    return memo[n];\n}\n\n// Sum of array - tail recursion\npublic int sum(int[] arr, int index) {\n    if (index >= arr.length) return 0;\n    return arr[index] + sum(arr, index + 1);\n}\n\n// Binary search - divide and conquer\npublic int binarySearch(int[] arr, int left, int right, int target) {\n    if (left > right) return -1;\n    \n    int mid = left + (right - left) / 2;\n    if (arr[mid] == target) return mid;\n    \n    if (arr[mid] > target) {\n        return binarySearch(arr, left, mid - 1, target);\n    }\n    return binarySearch(arr, mid + 1, right, target);\n}\n\n// Tower of Hanoi - classic recursion problem\npublic void towerOfHanoi(int n, char from, char to, char aux) {\n    if (n == 1) {\n        System.out.println(\"Move disk 1 from \" + from + \" to \" + to);\n        return;\n    }\n    towerOfHanoi(n - 1, from, aux, to);\n    System.out.println(\"Move disk \" + n + \" from \" + from + \" to \" + to);\n    towerOfHanoi(n - 1, aux, to, from);\n}"
    },
    {
      "id": 10,
      "question": "What is the difference between linear search and binary search?",
      "answer": "Linear search and binary search are fundamental search algorithms with different approaches, requirements, and performance characteristics.\n\nLinear Search:\n• Checks each element sequentially from start to end\n• Works on both sorted and unsorted arrays\n• Time Complexity - O(n) worst and average case\n• Space Complexity - O(1)\n• Simple to implement\n• Best for small or unsorted datasets\n\nBinary Search:\n• Divides search space in half repeatedly\n• Requires sorted array\n• Time Complexity - O(log n) worst and average case\n• Space Complexity - O(1) iterative, O(log n) recursive\n• More complex implementation\n• Much faster for large datasets\n\nWhen to Use:\n• Linear Search - Unsorted data, small datasets, single search\n• Binary Search - Sorted data, large datasets, multiple searches",
      "explanation": "Linear search checks elements sequentially in O(n) time on any array, while binary search divides the sorted array in half repeatedly for O(log n) time.",
      "difficulty": "Easy",
      "code": "// Linear Search - O(n)\npublic int linearSearch(int[] arr, int target) {\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i] == target) {\n            return i; // Found at index i\n        }\n    }\n    return -1; // Not found\n}\n\n// Binary Search - Iterative - O(log n)\npublic int binarySearchIterative(int[] arr, int target) {\n    int left = 0;\n    int right = arr.length - 1;\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2; // Avoid overflow\n        \n        if (arr[mid] == target) {\n            return mid; // Found\n        }\n        \n        if (arr[mid] < target) {\n            left = mid + 1; // Search right half\n        } else {\n            right = mid - 1; // Search left half\n        }\n    }\n    return -1; // Not found\n}\n\n// Binary Search - Recursive - O(log n)\npublic int binarySearchRecursive(int[] arr, int left, int right, int target) {\n    if (left > right) {\n        return -1; // Base case: not found\n    }\n    \n    int mid = left + (right - left) / 2;\n    \n    if (arr[mid] == target) {\n        return mid;\n    }\n    \n    if (arr[mid] < target) {\n        return binarySearchRecursive(arr, mid + 1, right, target);\n    }\n    return binarySearchRecursive(arr, left, mid - 1, target);\n}\n\n// Example usage\npublic static void main(String[] args) {\n    int[] unsorted = {64, 34, 25, 12, 22};\n    System.out.println(linearSearch(unsorted, 25)); // Works: returns 2\n    \n    int[] sorted = {12, 22, 25, 34, 64};\n    System.out.println(binarySearchIterative(sorted, 25)); // Returns 2\n}"
    },
    {
      "id": 11,
      "question": "What are the common sorting algorithms and their complexities?",
      "answer": "Sorting algorithms arrange elements in a specific order. Different algorithms have different performance characteristics and use cases.\n\nComparison-Based Sorts:\n• Bubble Sort - O(n²) time, O(1) space - Simple but slow\n• Selection Sort - O(n²) time, O(1) space - Minimizes swaps\n• Insertion Sort - O(n²) time, O(1) space - Good for nearly sorted data\n• Merge Sort - O(n log n) time, O(n) space - Stable, divide-and-conquer\n• Quick Sort - O(n log n) average, O(n²) worst, O(log n) space - Fast in practice\n• Heap Sort - O(n log n) time, O(1) space - Not stable\n\nNon-Comparison Based:\n• Counting Sort - O(n + k) time, O(k) space - For limited range\n• Radix Sort - O(d × n) time - For integers with d digits\n• Bucket Sort - O(n + k) average - For uniformly distributed data\n\nStability:\n• Stable sorts maintain relative order of equal elements\n• Stable: Merge, Insertion, Bubble, Counting\n• Unstable: Quick, Heap, Selection",
      "explanation": "Sorting algorithms range from simple O(n²) methods like bubble sort to efficient O(n log n) algorithms like merge and quick sort, each with different trade-offs.",
      "difficulty": "Medium",
      "code": "// Bubble Sort - O(n²) time, O(1) space\npublic void bubbleSort(int[] arr) {\n    int n = arr.length;\n    for (int i = 0; i < n - 1; i++) {\n        boolean swapped = false;\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n                swapped = true;\n            }\n        }\n        if (!swapped) break; // Optimization\n    }\n}\n\n// Merge Sort - O(n log n) time, O(n) space\npublic void mergeSort(int[] arr, int left, int right) {\n    if (left < right) {\n        int mid = left + (right - left) / 2;\n        mergeSort(arr, left, mid);\n        mergeSort(arr, mid + 1, right);\n        merge(arr, left, mid, right);\n    }\n}\n\nprivate void merge(int[] arr, int left, int mid, int right) {\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n    int[] L = new int[n1];\n    int[] R = new int[n2];\n    \n    System.arraycopy(arr, left, L, 0, n1);\n    System.arraycopy(arr, mid + 1, R, 0, n2);\n    \n    int i = 0, j = 0, k = left;\n    while (i < n1 && j < n2) {\n        arr[k++] = (L[i] <= R[j]) ? L[i++] : R[j++];\n    }\n    while (i < n1) arr[k++] = L[i++];\n    while (j < n2) arr[k++] = R[j++];\n}\n\n// Quick Sort - O(n log n) average\npublic void quickSort(int[] arr, int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nprivate int partition(int[] arr, int low, int high) {\n    int pivot = arr[high];\n    int i = low - 1;\n    for (int j = low; j < high; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n    int temp = arr[i + 1];\n    arr[i + 1] = arr[high];\n    arr[high] = temp;\n    return i + 1;\n}"
    },
    {
      "id": 12,
      "question": "What is a graph and what are the common ways to represent it?",
      "answer": "A graph is a non-linear data structure consisting of vertices (nodes) and edges (connections between nodes). Graphs model relationships and networks.\n\nGraph Types:\n• Directed (Digraph) - Edges have direction\n• Undirected - Edges are bidirectional\n• Weighted - Edges have associated costs/weights\n• Unweighted - All edges are equal\n• Cyclic - Contains at least one cycle\n• Acyclic - No cycles (DAG - Directed Acyclic Graph)\n\nGraph Representations:\n• Adjacency Matrix - 2D array, O(V²) space\n  - Fast edge lookup O(1)\n  - Space inefficient for sparse graphs\n• Adjacency List - Array of lists, O(V + E) space\n  - Space efficient for sparse graphs\n  - Faster iteration over neighbors\n• Edge List - List of all edges, O(E) space\n  - Simple but slow for most operations\n\nCommon Applications:\n• Social networks\n• Road networks and GPS\n• Web page linking\n• Dependency resolution",
      "explanation": "Graphs consist of vertices and edges representing relationships, commonly represented using adjacency matrices for dense graphs or adjacency lists for sparse graphs.",
      "difficulty": "Medium",
      "code": "// Graph using Adjacency List\nimport java.util.*;\n\nclass Graph {\n    private int vertices;\n    private LinkedList<Integer>[] adjList;\n    \n    @SuppressWarnings(\"unchecked\")\n    public Graph(int vertices) {\n        this.vertices = vertices;\n        adjList = new LinkedList[vertices];\n        for (int i = 0; i < vertices; i++) {\n            adjList[i] = new LinkedList<>();\n        }\n    }\n    \n    // Add edge for undirected graph\n    public void addEdge(int src, int dest) {\n        adjList[src].add(dest);\n        adjList[dest].add(src); // For undirected\n    }\n    \n    // Add edge for directed graph\n    public void addDirectedEdge(int src, int dest) {\n        adjList[src].add(dest);\n    }\n    \n    // Print graph\n    public void printGraph() {\n        for (int i = 0; i < vertices; i++) {\n            System.out.print(\"Vertex \" + i + \":\");\n            for (Integer neighbor : adjList[i]) {\n                System.out.print(\" -> \" + neighbor);\n            }\n            System.out.println();\n        }\n    }\n}\n\n// Graph using Adjacency Matrix\nclass GraphMatrix {\n    private int[][] matrix;\n    private int vertices;\n    \n    public GraphMatrix(int vertices) {\n        this.vertices = vertices;\n        matrix = new int[vertices][vertices];\n    }\n    \n    public void addEdge(int src, int dest) {\n        matrix[src][dest] = 1;\n        matrix[dest][src] = 1; // For undirected\n    }\n    \n    public boolean hasEdge(int src, int dest) {\n        return matrix[src][dest] == 1;\n    }\n}\n\n// Weighted Graph\nclass WeightedGraph {\n    class Edge {\n        int dest, weight;\n        Edge(int dest, int weight) {\n            this.dest = dest;\n            this.weight = weight;\n        }\n    }\n    \n    private LinkedList<Edge>[] adjList;\n    \n    public void addEdge(int src, int dest, int weight) {\n        adjList[src].add(new Edge(dest, weight));\n    }\n}"
    },
    {
      "id": 13,
      "question": "What is Depth-First Search (DFS) and how is it implemented?",
      "answer": "Depth-First Search is a graph traversal algorithm that explores as far as possible along each branch before backtracking.\n\nDFS Characteristics:\n• Uses stack data structure (or recursion)\n• Explores one path completely before trying alternatives\n• Time Complexity - O(V + E) where V = vertices, E = edges\n• Space Complexity - O(V) for recursion stack or visited array\n\nImplementation Approaches:\n• Recursive - Uses call stack implicitly\n• Iterative - Uses explicit stack\n\nApplications:\n• Path finding\n• Cycle detection\n• Topological sorting\n• Connected components\n• Solving puzzles (maze, sudoku)\n• Detecting strongly connected components\n\nDFS vs BFS:\n• DFS uses stack, BFS uses queue\n• DFS may find longer paths first\n• DFS uses less memory for wide graphs\n• BFS better for shortest path in unweighted graphs",
      "explanation": "DFS is a graph traversal algorithm that explores paths deeply using a stack, useful for path finding, cycle detection, and topological sorting.",
      "difficulty": "Medium",
      "code": "class GraphDFS {\n    private LinkedList<Integer>[] adjList;\n    private int vertices;\n    \n    // DFS - Recursive approach\n    public void dfsRecursive(int start) {\n        boolean[] visited = new boolean[vertices];\n        dfsUtil(start, visited);\n    }\n    \n    private void dfsUtil(int vertex, boolean[] visited) {\n        visited[vertex] = true;\n        System.out.print(vertex + \" \");\n        \n        for (Integer neighbor : adjList[vertex]) {\n            if (!visited[neighbor]) {\n                dfsUtil(neighbor, visited);\n            }\n        }\n    }\n    \n    // DFS - Iterative approach using stack\n    public void dfsIterative(int start) {\n        boolean[] visited = new boolean[vertices];\n        Stack<Integer> stack = new Stack<>();\n        \n        stack.push(start);\n        \n        while (!stack.isEmpty()) {\n            int vertex = stack.pop();\n            \n            if (!visited[vertex]) {\n                visited[vertex] = true;\n                System.out.print(vertex + \" \");\n                \n                // Push neighbors in reverse order\n                for (int i = adjList[vertex].size() - 1; i >= 0; i--) {\n                    int neighbor = adjList[vertex].get(i);\n                    if (!visited[neighbor]) {\n                        stack.push(neighbor);\n                    }\n                }\n            }\n        }\n    }\n    \n    // DFS to detect cycle in directed graph\n    public boolean hasCycle() {\n        boolean[] visited = new boolean[vertices];\n        boolean[] recStack = new boolean[vertices];\n        \n        for (int i = 0; i < vertices; i++) {\n            if (hasCycleUtil(i, visited, recStack)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    private boolean hasCycleUtil(int v, boolean[] visited, boolean[] recStack) {\n        if (recStack[v]) return true;\n        if (visited[v]) return false;\n        \n        visited[v] = true;\n        recStack[v] = true;\n        \n        for (Integer neighbor : adjList[v]) {\n            if (hasCycleUtil(neighbor, visited, recStack)) {\n                return true;\n            }\n        }\n        \n        recStack[v] = false;\n        return false;\n    }\n}"
    },
    {
      "id": 14,
      "question": "What is Breadth-First Search (BFS) and how is it implemented?",
      "answer": "Breadth-First Search is a graph traversal algorithm that explores all vertices at the current depth before moving to vertices at the next depth level.\n\nBFS Characteristics:\n• Uses queue data structure\n• Explores neighbors level by level\n• Time Complexity - O(V + E) where V = vertices, E = edges\n• Space Complexity - O(V) for queue and visited array\n• Guarantees shortest path in unweighted graphs\n\nKey Properties:\n• Finds shortest path in unweighted graphs\n• Level-order traversal\n• Complete algorithm (finds solution if exists)\n\nApplications:\n• Shortest path in unweighted graphs\n• Level-order tree traversal\n• Finding connected components\n• Peer-to-peer networks\n• Social networking (finding connections)\n• GPS navigation systems\n• Web crawlers\n\nBFS vs DFS:\n• BFS finds shortest path, DFS may not\n• BFS uses more memory for wide graphs\n• DFS better for deep, narrow graphs",
      "explanation": "BFS explores graphs level by level using a queue, guaranteeing shortest paths in unweighted graphs and useful for level-order traversals.",
      "difficulty": "Medium",
      "code": "import java.util.*;\n\nclass GraphBFS {\n    private LinkedList<Integer>[] adjList;\n    private int vertices;\n    \n    // BFS traversal\n    public void bfs(int start) {\n        boolean[] visited = new boolean[vertices];\n        Queue<Integer> queue = new LinkedList<>();\n        \n        visited[start] = true;\n        queue.offer(start);\n        \n        while (!queue.isEmpty()) {\n            int vertex = queue.poll();\n            System.out.print(vertex + \" \");\n            \n            for (Integer neighbor : adjList[vertex]) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    queue.offer(neighbor);\n                }\n            }\n        }\n    }\n    \n    // BFS to find shortest path\n    public int shortestPath(int start, int end) {\n        if (start == end) return 0;\n        \n        boolean[] visited = new boolean[vertices];\n        Queue<Integer> queue = new LinkedList<>();\n        int[] distance = new int[vertices];\n        \n        visited[start] = true;\n        queue.offer(start);\n        distance[start] = 0;\n        \n        while (!queue.isEmpty()) {\n            int vertex = queue.poll();\n            \n            for (Integer neighbor : adjList[vertex]) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    distance[neighbor] = distance[vertex] + 1;\n                    queue.offer(neighbor);\n                    \n                    if (neighbor == end) {\n                        return distance[neighbor];\n                    }\n                }\n            }\n        }\n        return -1; // No path exists\n    }\n    \n    // BFS with path reconstruction\n    public List<Integer> findPath(int start, int end) {\n        boolean[] visited = new boolean[vertices];\n        Queue<Integer> queue = new LinkedList<>();\n        int[] parent = new int[vertices];\n        Arrays.fill(parent, -1);\n        \n        visited[start] = true;\n        queue.offer(start);\n        \n        while (!queue.isEmpty()) {\n            int vertex = queue.poll();\n            \n            if (vertex == end) {\n                return reconstructPath(parent, start, end);\n            }\n            \n            for (Integer neighbor : adjList[vertex]) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    parent[neighbor] = vertex;\n                    queue.offer(neighbor);\n                }\n            }\n        }\n        return new ArrayList<>();\n    }\n    \n    private List<Integer> reconstructPath(int[] parent, int start, int end) {\n        List<Integer> path = new ArrayList<>();\n        for (int v = end; v != -1; v = parent[v]) {\n            path.add(v);\n        }\n        Collections.reverse(path);\n        return path;\n    }\n}"
    },
    {
      "id": 15,
      "question": "What is dynamic programming and what are its key principles?",
      "answer": "Dynamic Programming (DP) is an optimization technique that solves complex problems by breaking them into simpler overlapping subproblems and storing their solutions to avoid redundant computations.\n\nKey Principles:\n• Optimal Substructure - Optimal solution contains optimal solutions to subproblems\n• Overlapping Subproblems - Same subproblems are solved multiple times\n• Memoization - Store results in cache (top-down)\n• Tabulation - Build solution iteratively (bottom-up)\n\nDP Approaches:\n• Top-Down (Memoization) - Recursive with caching\n• Bottom-Up (Tabulation) - Iterative, builds from base cases\n\nWhen to Use DP:\n• Problem has optimal substructure\n• Overlapping subproblems exist\n• Counting or optimization problems\n• Can define recurrence relation\n\nCommon DP Problems:\n• Fibonacci sequence\n• Longest Common Subsequence\n• Knapsack problems\n• Matrix chain multiplication\n• Edit distance\n• Coin change problem",
      "explanation": "Dynamic programming optimizes recursive solutions by storing subproblem results to avoid redundant calculations, using either memoization or tabulation approaches.",
      "difficulty": "Hard",
      "code": "class DynamicProgramming {\n    \n    // Fibonacci - Recursive (Exponential O(2^n))\n    public int fibRecursive(int n) {\n        if (n <= 1) return n;\n        return fibRecursive(n - 1) + fibRecursive(n - 2);\n    }\n    \n    // Fibonacci - Memoization (Top-Down DP) - O(n)\n    public int fibMemo(int n) {\n        int[] memo = new int[n + 1];\n        return fibMemoHelper(n, memo);\n    }\n    \n    private int fibMemoHelper(int n, int[] memo) {\n        if (n <= 1) return n;\n        if (memo[n] != 0) return memo[n];\n        memo[n] = fibMemoHelper(n - 1, memo) + fibMemoHelper(n - 2, memo);\n        return memo[n];\n    }\n    \n    // Fibonacci - Tabulation (Bottom-Up DP) - O(n)\n    public int fibTabulation(int n) {\n        if (n <= 1) return n;\n        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        dp[1] = 1;\n        for (int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n    \n    // 0/1 Knapsack Problem - O(n * W)\n    public int knapsack(int[] weights, int[] values, int capacity) {\n        int n = weights.length;\n        int[][] dp = new int[n + 1][capacity + 1];\n        \n        for (int i = 1; i <= n; i++) {\n            for (int w = 1; w <= capacity; w++) {\n                if (weights[i - 1] <= w) {\n                    dp[i][w] = Math.max(\n                        values[i - 1] + dp[i - 1][w - weights[i - 1]],\n                        dp[i - 1][w]\n                    );\n                } else {\n                    dp[i][w] = dp[i - 1][w];\n                }\n            }\n        }\n        return dp[n][capacity];\n    }\n    \n    // Longest Common Subsequence - O(m * n)\n    public int lcs(String s1, String s2) {\n        int m = s1.length(), n = s2.length();\n        int[][] dp = new int[m + 1][n + 1];\n        \n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n    \n    // Coin Change - Minimum coins - O(n * amount)\n    public int coinChange(int[] coins, int amount) {\n        int[] dp = new int[amount + 1];\n        Arrays.fill(dp, amount + 1);\n        dp[0] = 0;\n        \n        for (int i = 1; i <= amount; i++) {\n            for (int coin : coins) {\n                if (i >= coin) {\n                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n                }\n            }\n        }\n        return dp[amount] > amount ? -1 : dp[amount];\n    }\n}"
    },
    {
      "id": 16,
      "question": "What is a heap data structure and what are its applications?",
      "answer": "A heap is a specialized tree-based data structure that satisfies the heap property. It is a complete binary tree where parent nodes have specific relationships with their children.\n\nHeap Types:\n• Max Heap - Parent >= children (root has maximum value)\n• Min Heap - Parent <= children (root has minimum value)\n\nHeap Properties:\n• Complete binary tree (all levels filled except possibly last)\n• Heap property maintained throughout\n• Height is always O(log n)\n• Array representation efficient\n\nCore Operations:\n• Insert - O(log n) - Add element and heapify up\n• Extract Min/Max - O(log n) - Remove root and heapify down\n• Peek - O(1) - View root element\n• Build Heap - O(n) - Create heap from array\n\nApplications:\n• Priority queues\n• Heap sort algorithm\n• Graph algorithms (Dijkstra, Prim)\n• Find K largest/smallest elements\n• Median maintenance\n• Job scheduling",
      "explanation": "A heap is a complete binary tree satisfying the heap property where parent nodes are greater (max heap) or smaller (min heap) than children, used for priority queues.",
      "difficulty": "Medium",
      "code": "class MinHeap {\n    private int[] heap;\n    private int size;\n    private int capacity;\n    \n    public MinHeap(int capacity) {\n        this.capacity = capacity;\n        this.size = 0;\n        heap = new int[capacity];\n    }\n    \n    private int parent(int i) { return (i - 1) / 2; }\n    private int leftChild(int i) { return 2 * i + 1; }\n    private int rightChild(int i) { return 2 * i + 2; }\n    \n    // Insert element - O(log n)\n    public void insert(int value) {\n        if (size == capacity) {\n            throw new RuntimeException(\"Heap is full\");\n        }\n        \n        heap[size] = value;\n        int current = size;\n        size++;\n        \n        // Heapify up\n        while (current != 0 && heap[current] < heap[parent(current)]) {\n            swap(current, parent(current));\n            current = parent(current);\n        }\n    }\n    \n    // Extract minimum - O(log n)\n    public int extractMin() {\n        if (size == 0) {\n            throw new RuntimeException(\"Heap is empty\");\n        }\n        if (size == 1) {\n            size--;\n            return heap[0];\n        }\n        \n        int root = heap[0];\n        heap[0] = heap[size - 1];\n        size--;\n        heapifyDown(0);\n        return root;\n    }\n    \n    // Heapify down - O(log n)\n    private void heapifyDown(int i) {\n        int smallest = i;\n        int left = leftChild(i);\n        int right = rightChild(i);\n        \n        if (left < size && heap[left] < heap[smallest]) {\n            smallest = left;\n        }\n        if (right < size && heap[right] < heap[smallest]) {\n            smallest = right;\n        }\n        \n        if (smallest != i) {\n            swap(i, smallest);\n            heapifyDown(smallest);\n        }\n    }\n    \n    // Peek minimum - O(1)\n    public int peek() {\n        if (size == 0) {\n            throw new RuntimeException(\"Heap is empty\");\n        }\n        return heap[0];\n    }\n    \n    // Build heap from array - O(n)\n    public void buildHeap(int[] arr) {\n        size = arr.length;\n        heap = Arrays.copyOf(arr, capacity);\n        for (int i = (size / 2) - 1; i >= 0; i--) {\n            heapifyDown(i);\n        }\n    }\n    \n    private void swap(int i, int j) {\n        int temp = heap[i];\n        heap[i] = heap[j];\n        heap[j] = temp;\n    }\n}\n\n// Using Java's PriorityQueue (Min Heap by default)\nimport java.util.PriorityQueue;\n\nPriorityQueue<Integer> minHeap = new PriorityQueue<>();\nminHeap.offer(5);\nminHeap.offer(3);\nint min = minHeap.poll(); // Returns 3\n\n// Max Heap using comparator\nPriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());"
    },
    {
      "id": 17,
      "question": "What is a trie and what are its use cases?",
      "answer": "A trie (prefix tree) is a tree-like data structure used for efficient storage and retrieval of strings, where each node represents a character and paths represent words.\n\nTrie Characteristics:\n• Each path from root to leaf represents a word\n• Each node contains links to children (typically 26 for lowercase letters)\n• Common prefixes share the same path\n• Space efficient for common prefixes\n\nCore Operations:\n• Insert - O(m) where m is word length\n• Search - O(m) for exact word\n• StartsWith - O(m) for prefix search\n• Delete - O(m) with careful node removal\n\nAdvantages:\n• Faster than hash table for prefix searches\n• No hash collisions\n• Alphabetically sorted traversal\n• Efficient prefix matching\n\nDisadvantages:\n• More memory intensive than hash tables\n• Cache locality can be poor\n\nApplications:\n• Autocomplete features\n• Spell checkers\n• IP routing tables\n• Dictionary implementations\n• Pattern matching",
      "explanation": "A trie is a tree structure for storing strings where nodes represent characters and paths represent words, enabling efficient prefix-based searches and autocomplete.",
      "difficulty": "Medium",
      "code": "class TrieNode {\n    TrieNode[] children;\n    boolean isEndOfWord;\n    \n    public TrieNode() {\n        children = new TrieNode[26]; // For lowercase a-z\n        isEndOfWord = false;\n    }\n}\n\nclass Trie {\n    private TrieNode root;\n    \n    public Trie() {\n        root = new TrieNode();\n    }\n    \n    // Insert word - O(m) where m is word length\n    public void insert(String word) {\n        TrieNode current = root;\n        for (char ch : word.toCharArray()) {\n            int index = ch - 'a';\n            if (current.children[index] == null) {\n                current.children[index] = new TrieNode();\n            }\n            current = current.children[index];\n        }\n        current.isEndOfWord = true;\n    }\n    \n    // Search for exact word - O(m)\n    public boolean search(String word) {\n        TrieNode node = searchNode(word);\n        return node != null && node.isEndOfWord;\n    }\n    \n    // Check if prefix exists - O(m)\n    public boolean startsWith(String prefix) {\n        return searchNode(prefix) != null;\n    }\n    \n    private TrieNode searchNode(String str) {\n        TrieNode current = root;\n        for (char ch : str.toCharArray()) {\n            int index = ch - 'a';\n            if (current.children[index] == null) {\n                return null;\n            }\n            current = current.children[index];\n        }\n        return current;\n    }\n    \n    // Delete word - O(m)\n    public boolean delete(String word) {\n        return deleteHelper(root, word, 0);\n    }\n    \n    private boolean deleteHelper(TrieNode current, String word, int index) {\n        if (index == word.length()) {\n            if (!current.isEndOfWord) {\n                return false;\n            }\n            current.isEndOfWord = false;\n            return hasNoChildren(current);\n        }\n        \n        char ch = word.charAt(index);\n        int childIndex = ch - 'a';\n        TrieNode node = current.children[childIndex];\n        \n        if (node == null) {\n            return false;\n        }\n        \n        boolean shouldDeleteChild = deleteHelper(node, word, index + 1);\n        \n        if (shouldDeleteChild) {\n            current.children[childIndex] = null;\n            return !current.isEndOfWord && hasNoChildren(current);\n        }\n        return false;\n    }\n    \n    private boolean hasNoChildren(TrieNode node) {\n        for (TrieNode child : node.children) {\n            if (child != null) return false;\n        }\n        return true;\n    }\n    \n    // Autocomplete - find all words with given prefix\n    public List<String> autocomplete(String prefix) {\n        List<String> results = new ArrayList<>();\n        TrieNode node = searchNode(prefix);\n        if (node != null) {\n            findAllWords(node, prefix, results);\n        }\n        return results;\n    }\n    \n    private void findAllWords(TrieNode node, String prefix, List<String> results) {\n        if (node.isEndOfWord) {\n            results.add(prefix);\n        }\n        for (int i = 0; i < 26; i++) {\n            if (node.children[i] != null) {\n                findAllWords(node.children[i], prefix + (char)(i + 'a'), results);\n            }\n        }\n    }\n}"
    },
    {
      "id": 18,
      "question": "What is space complexity and how is it analyzed?",
      "answer": "Space complexity measures the total amount of memory an algorithm needs relative to the input size, including both auxiliary space and input storage.\n\nSpace Complexity Components:\n• Input Space - Memory for storing input data\n• Auxiliary Space - Extra memory used during execution\n• Space Complexity = Input Space + Auxiliary Space\n\nCommon Space Complexities:\n• O(1) - Constant: fixed variables, no scaling with input\n• O(log n) - Logarithmic: recursive calls for divide-and-conquer\n• O(n) - Linear: single array/list of size n\n• O(n²) - Quadratic: 2D matrix of size n×n\n\nFactors Affecting Space:\n• Variables and constants\n• Recursion call stack\n• Dynamic data structures\n• Temporary arrays/objects\n\nOptimization Techniques:\n• In-place algorithms\n• Iterative vs recursive\n• Reuse existing space\n• Use primitive types when possible",
      "explanation": "Space complexity measures the total memory an algorithm uses, including input storage and auxiliary space for variables, data structures, and recursion stacks.",
      "difficulty": "Easy",
      "code": "// Space Complexity Examples\n\n// O(1) - Constant space\npublic int sum(int[] arr) {\n    int total = 0; // Only one variable\n    for (int num : arr) {\n        total += num;\n    }\n    return total;\n}\n\n// O(n) - Linear space\npublic int[] doubleArray(int[] arr) {\n    int[] result = new int[arr.length]; // New array of size n\n    for (int i = 0; i < arr.length; i++) {\n        result[i] = arr[i] * 2;\n    }\n    return result;\n}\n\n// O(n) - Recursion stack space\npublic int factorial(int n) {\n    if (n <= 1) return 1;\n    return n * factorial(n - 1); // n recursive calls on stack\n}\n\n// O(n²) - Quadratic space\npublic int[][] createMatrix(int n) {\n    int[][] matrix = new int[n][n]; // n×n matrix\n    return matrix;\n}\n\n// O(log n) - Binary search recursion\npublic int binarySearch(int[] arr, int left, int right, int target) {\n    if (left > right) return -1;\n    int mid = left + (right - left) / 2;\n    if (arr[mid] == target) return mid;\n    if (arr[mid] > target) {\n        return binarySearch(arr, left, mid - 1, target);\n    }\n    return binarySearch(arr, mid + 1, right, target);\n    // log n recursive calls\n}\n\n// In-place algorithm - O(1) auxiliary space\npublic void reverseArray(int[] arr) {\n    int left = 0, right = arr.length - 1;\n    while (left < right) {\n        int temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n        left++;\n        right--;\n    }\n    // Only uses a few variables, modifies input array\n}"
    },
    {
      "id": 19,
      "question": "What is the difference between stable and unstable sorting algorithms?",
      "answer": "Stability in sorting refers to whether a sorting algorithm maintains the relative order of elements with equal keys (values).\n\nStable Sorting:\n• Preserves original order of equal elements\n• If element A appears before B in input and A == B, then A appears before B in output\n• Important when sorting by multiple criteria\n• Examples: Merge Sort, Insertion Sort, Bubble Sort, Counting Sort\n\nUnstable Sorting:\n• May change relative order of equal elements\n• Order of equal elements is unpredictable\n• Often faster or more space-efficient\n• Examples: Quick Sort, Heap Sort, Selection Sort\n\nWhen Stability Matters:\n• Sorting objects by multiple fields\n• Database queries with multiple ORDER BY clauses\n• Maintaining chronological order\n• UI sorting with secondary criteria\n\nExample Scenario:\n• Students sorted by name, then by grade\n• Stable sort preserves name order within same grade",
      "explanation": "Stable sorting algorithms preserve the relative order of equal elements, while unstable algorithms may change it, important for multi-criteria sorting scenarios.",
      "difficulty": "Medium",
      "code": "// Example demonstrating stability\n\nclass Student {\n    String name;\n    int grade;\n    \n    Student(String name, int grade) {\n        this.name = name;\n        this.grade = grade;\n    }\n}\n\n// Input: [(Alice, 85), (Bob, 90), (Charlie, 85), (David, 90)]\n// First sort by grade (ascending)\n\n// Stable sort (Merge Sort) result:\n// [(Alice, 85), (Charlie, 85), (Bob, 90), (David, 90)]\n// Relative order preserved: Alice before Charlie, Bob before David\n\n// Unstable sort (Quick Sort) might produce:\n// [(Charlie, 85), (Alice, 85), (David, 90), (Bob, 90)]\n// Order of equal grades may change\n\n// Merge Sort - Stable\npublic void mergeSort(int[] arr, int[] indices, int left, int right) {\n    if (left < right) {\n        int mid = left + (right - left) / 2;\n        mergeSort(arr, indices, left, mid);\n        mergeSort(arr, indices, mid + 1, right);\n        mergeStable(arr, indices, left, mid, right);\n    }\n}\n\nprivate void mergeStable(int[] arr, int[] indices, int left, int mid, int right) {\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n    int[] L = new int[n1];\n    int[] R = new int[n2];\n    int[] LIdx = new int[n1];\n    int[] RIdx = new int[n2];\n    \n    for (int i = 0; i < n1; i++) {\n        L[i] = arr[left + i];\n        LIdx[i] = indices[left + i];\n    }\n    for (int j = 0; j < n2; j++) {\n        R[j] = arr[mid + 1 + j];\n        RIdx[j] = indices[mid + 1 + j];\n    }\n    \n    int i = 0, j = 0, k = left;\n    while (i < n1 && j < n2) {\n        // Key difference: <= maintains stability\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            indices[k] = LIdx[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            indices[k] = RIdx[j];\n            j++;\n        }\n        k++;\n    }\n    \n    while (i < n1) {\n        arr[k] = L[i];\n        indices[k++] = LIdx[i++];\n    }\n    while (j < n2) {\n        arr[k] = R[j];\n        indices[k++] = RIdx[j++];\n    }\n}\n\n// Java's sorting with stability\nimport java.util.*;\n\n// Stable sort for objects\nList<Student> students = new ArrayList<>();\nCollections.sort(students, (a, b) -> Integer.compare(a.grade, b.grade));\n\n// Arrays.sort() uses:\n// - Merge Sort for objects (stable)\n// - Dual-Pivot Quicksort for primitives (unstable but fast)"
    },
    {
      "id": 20,
      "question": "What are greedy algorithms and when should they be used?",
      "answer": "Greedy algorithms make locally optimal choices at each step with the hope of finding a global optimum solution. They build up a solution piece by piece, always choosing the next piece that offers the most immediate benefit.\n\nGreedy Algorithm Characteristics:\n• Makes best local choice at each step\n• Never reconsiders earlier choices\n• Does not guarantee global optimum for all problems\n• Usually faster than dynamic programming\n• Requires proof of correctness\n\nWhen Greedy Works:\n• Problem has greedy choice property\n• Problem has optimal substructure\n• Local optimum leads to global optimum\n\nGreedy vs Dynamic Programming:\n• Greedy makes one choice and moves forward\n• DP considers all possibilities\n• Greedy is faster but less versatile\n\nCommon Greedy Problems:\n• Activity selection\n• Huffman coding\n• Fractional knapsack\n• Minimum spanning tree (Prim, Kruskal)\n• Dijkstra shortest path\n• Coin change (specific denominations)",
      "explanation": "Greedy algorithms make locally optimal choices at each step without reconsidering, working well for problems with greedy choice property but not guaranteeing global optimum for all problems.",
      "difficulty": "Medium",
      "code": "class GreedyAlgorithms {\n    \n    // Activity Selection Problem\n    // Select maximum number of non-overlapping activities\n    class Activity {\n        int start, end;\n        Activity(int start, int end) {\n            this.start = start;\n            this.end = end;\n        }\n    }\n    \n    public List<Activity> activitySelection(Activity[] activities) {\n        // Sort by end time\n        Arrays.sort(activities, (a, b) -> Integer.compare(a.end, b.end));\n        \n        List<Activity> selected = new ArrayList<>();\n        selected.add(activities[0]);\n        int lastEnd = activities[0].end;\n        \n        for (int i = 1; i < activities.length; i++) {\n            if (activities[i].start >= lastEnd) {\n                selected.add(activities[i]);\n                lastEnd = activities[i].end;\n            }\n        }\n        return selected;\n    }\n    \n    // Fractional Knapsack - O(n log n)\n    class Item {\n        int value, weight;\n        Item(int value, int weight) {\n            this.value = value;\n            this.weight = weight;\n        }\n    }\n    \n    public double fractionalKnapsack(Item[] items, int capacity) {\n        // Sort by value/weight ratio (descending)\n        Arrays.sort(items, (a, b) -> \n            Double.compare((double)b.value/b.weight, (double)a.value/a.weight));\n        \n        double totalValue = 0;\n        int currentWeight = 0;\n        \n        for (Item item : items) {\n            if (currentWeight + item.weight <= capacity) {\n                // Take whole item\n                currentWeight += item.weight;\n                totalValue += item.value;\n            } else {\n                // Take fraction of item\n                int remaining = capacity - currentWeight;\n                totalValue += item.value * ((double)remaining / item.weight);\n                break;\n            }\n        }\n        return totalValue;\n    }\n    \n    // Coin Change - Greedy (works for specific denominations)\n    public int coinChangeGreedy(int[] coins, int amount) {\n        Arrays.sort(coins); // Sort ascending\n        int count = 0;\n        \n        // Start from largest coin\n        for (int i = coins.length - 1; i >= 0; i--) {\n            while (amount >= coins[i]) {\n                amount -= coins[i];\n                count++;\n            }\n        }\n        return amount == 0 ? count : -1;\n    }\n    \n    // Job Sequencing Problem\n    class Job {\n        int id, deadline, profit;\n        Job(int id, int deadline, int profit) {\n            this.id = id;\n            this.deadline = deadline;\n            this.profit = profit;\n        }\n    }\n    \n    public int jobSequencing(Job[] jobs) {\n        // Sort by profit (descending)\n        Arrays.sort(jobs, (a, b) -> Integer.compare(b.profit, a.profit));\n        \n        int maxDeadline = 0;\n        for (Job job : jobs) {\n            maxDeadline = Math.max(maxDeadline, job.deadline);\n        }\n        \n        int[] slots = new int[maxDeadline];\n        Arrays.fill(slots, -1);\n        int totalProfit = 0;\n        \n        for (Job job : jobs) {\n            for (int j = Math.min(maxDeadline, job.deadline) - 1; j >= 0; j--) {\n                if (slots[j] == -1) {\n                    slots[j] = job.id;\n                    totalProfit += job.profit;\n                    break;\n                }\n            }\n        }\n        return totalProfit;\n    }\n}"
    },
    {
      "id": 21,
      "question": "What is the two-pointer technique and when is it useful?",
      "answer": "The two-pointer technique uses two pointers to traverse a data structure simultaneously, often from different positions or directions, to solve problems efficiently.\n\nCommon Patterns:\n• Opposite ends - One pointer at start, one at end, moving toward each other\n• Same direction - Both pointers move forward, at different speeds\n• Sliding window - Two pointers define a window that slides through data\n\nWhen to Use:\n• Array/string problems requiring pair finding\n• Sorted array operations\n• Linked list problems (fast and slow pointers)\n• Removing duplicates\n• Palindrome checking\n• Three sum, four sum problems\n\nAdvantages:\n• Reduces time complexity from O(n²) to O(n) in many cases\n• Space efficient - O(1) extra space\n• Simple to implement\n\nCommon Applications:\n• Finding pairs with given sum\n• Container with most water\n• Removing duplicates from sorted array\n• Detecting cycle in linked list",
      "explanation": "Two-pointer technique uses two pointers traversing data from different positions to efficiently solve array, string, and linked list problems in O(n) time with O(1) space.",
      "difficulty": "Medium",
      "code": "class TwoPointerTechniques {\n    \n    // Two Sum in sorted array - O(n)\n    public int[] twoSumSorted(int[] arr, int target) {\n        int left = 0, right = arr.length - 1;\n        \n        while (left < right) {\n            int sum = arr[left] + arr[right];\n            if (sum == target) {\n                return new int[]{left, right};\n            } else if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return new int[]{-1, -1};\n    }\n    \n    // Remove duplicates from sorted array - O(n)\n    public int removeDuplicates(int[] arr) {\n        if (arr.length == 0) return 0;\n        \n        int slow = 0; // Points to last unique element\n        for (int fast = 1; fast < arr.length; fast++) {\n            if (arr[fast] != arr[slow]) {\n                slow++;\n                arr[slow] = arr[fast];\n            }\n        }\n        return slow + 1; // New length\n    }\n    \n    // Reverse array in place - O(n)\n    public void reverseArray(int[] arr) {\n        int left = 0, right = arr.length - 1;\n        while (left < right) {\n            int temp = arr[left];\n            arr[left] = arr[right];\n            arr[right] = temp;\n            left++;\n            right--;\n        }\n    }\n    \n    // Check if palindrome - O(n)\n    public boolean isPalindrome(String s) {\n        int left = 0, right = s.length() - 1;\n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n    \n    // Container with most water - O(n)\n    public int maxArea(int[] height) {\n        int left = 0, right = height.length - 1;\n        int maxArea = 0;\n        \n        while (left < right) {\n            int width = right - left;\n            int h = Math.min(height[left], height[right]);\n            maxArea = Math.max(maxArea, width * h);\n            \n            // Move pointer with smaller height\n            if (height[left] < height[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return maxArea;\n    }\n    \n    // Three Sum - O(n²)\n    public List<List<Integer>> threeSum(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>> result = new ArrayList<>();\n        \n        for (int i = 0; i < nums.length - 2; i++) {\n            if (i > 0 && nums[i] == nums[i - 1]) continue; // Skip duplicates\n            \n            int left = i + 1, right = nums.length - 1;\n            int target = -nums[i];\n            \n            while (left < right) {\n                int sum = nums[left] + nums[right];\n                if (sum == target) {\n                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));\n                    while (left < right && nums[left] == nums[left + 1]) left++;\n                    while (left < right && nums[right] == nums[right - 1]) right--;\n                    left++;\n                    right--;\n                } else if (sum < target) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n        return result;\n    }\n    \n    // Floyd's Cycle Detection (Fast and Slow pointers)\n    public boolean hasCycle(ListNode head) {\n        if (head == null) return false;\n        \n        ListNode slow = head;\n        ListNode fast = head;\n        \n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) {\n                return true;\n            }\n        }\n        return false;\n    }\n}"
    },
    {
      "id": 22,
      "question": "What is the sliding window technique and what problems does it solve?",
      "answer": "The sliding window technique maintains a window (subarray or substring) that slides through the data structure, adjusting its size dynamically to find optimal solutions.\n\nWindow Types:\n• Fixed Size - Window size remains constant\n• Variable Size - Window expands and contracts based on conditions\n\nCommon Operations:\n• Expand window - Add element from right\n• Shrink window - Remove element from left\n• Calculate window property - Sum, max, unique elements\n\nWhen to Use:\n• Problems involving contiguous subarrays/substrings\n• Finding maximum/minimum in subarrays\n• Longest/shortest subarray with condition\n• Counting problems with contiguous elements\n\nAdvantages:\n• Reduces time from O(n²) or O(n³) to O(n)\n• Avoids redundant calculations\n• Memory efficient\n\nCommon Problems:\n• Maximum sum of k consecutive elements\n• Longest substring without repeating characters\n• Minimum window substring\n• Longest substring with k distinct characters",
      "explanation": "Sliding window maintains a dynamic window over data, expanding and contracting to efficiently solve subarray/substring problems in O(n) time instead of O(n²).",
      "difficulty": "Medium",
      "code": "class SlidingWindowTechniques {\n    \n    // Fixed Size Window - Maximum sum of k consecutive elements\n    public int maxSumKElements(int[] arr, int k) {\n        if (arr.length < k) return -1;\n        \n        // Calculate sum of first window\n        int windowSum = 0;\n        for (int i = 0; i < k; i++) {\n            windowSum += arr[i];\n        }\n        \n        int maxSum = windowSum;\n        \n        // Slide window\n        for (int i = k; i < arr.length; i++) {\n            windowSum = windowSum - arr[i - k] + arr[i];\n            maxSum = Math.max(maxSum, windowSum);\n        }\n        return maxSum;\n    }\n    \n    // Variable Size - Longest substring without repeating characters\n    public int lengthOfLongestSubstring(String s) {\n        Set<Character> set = new HashSet<>();\n        int maxLength = 0;\n        int left = 0;\n        \n        for (int right = 0; right < s.length(); right++) {\n            // Shrink window until no duplicates\n            while (set.contains(s.charAt(right))) {\n                set.remove(s.charAt(left));\n                left++;\n            }\n            set.add(s.charAt(right));\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n        return maxLength;\n    }\n    \n    // Minimum window substring containing all characters\n    public String minWindow(String s, String t) {\n        if (s.length() == 0 || t.length() == 0) return \"\";\n        \n        Map<Character, Integer> dictT = new HashMap<>();\n        for (char c : t.toCharArray()) {\n            dictT.put(c, dictT.getOrDefault(c, 0) + 1);\n        }\n        \n        int required = dictT.size();\n        int formed = 0;\n        Map<Character, Integer> windowCounts = new HashMap<>();\n        \n        int left = 0, right = 0;\n        int minLen = Integer.MAX_VALUE;\n        int minLeft = 0;\n        \n        while (right < s.length()) {\n            char c = s.charAt(right);\n            windowCounts.put(c, windowCounts.getOrDefault(c, 0) + 1);\n            \n            if (dictT.containsKey(c) && \n                windowCounts.get(c).intValue() == dictT.get(c).intValue()) {\n                formed++;\n            }\n            \n            // Try to shrink window\n            while (left <= right && formed == required) {\n                if (right - left + 1 < minLen) {\n                    minLen = right - left + 1;\n                    minLeft = left;\n                }\n                \n                char leftChar = s.charAt(left);\n                windowCounts.put(leftChar, windowCounts.get(leftChar) - 1);\n                if (dictT.containsKey(leftChar) && \n                    windowCounts.get(leftChar) < dictT.get(leftChar)) {\n                    formed--;\n                }\n                left++;\n            }\n            right++;\n        }\n        \n        return minLen == Integer.MAX_VALUE ? \"\" : s.substring(minLeft, minLeft + minLen);\n    }\n    \n    // Longest substring with at most k distinct characters\n    public int lengthOfLongestSubstringKDistinct(String s, int k) {\n        if (s.length() == 0 || k == 0) return 0;\n        \n        Map<Character, Integer> map = new HashMap<>();\n        int left = 0, maxLength = 0;\n        \n        for (int right = 0; right < s.length(); right++) {\n            char c = s.charAt(right);\n            map.put(c, map.getOrDefault(c, 0) + 1);\n            \n            // Shrink window if more than k distinct\n            while (map.size() > k) {\n                char leftChar = s.charAt(left);\n                map.put(leftChar, map.get(leftChar) - 1);\n                if (map.get(leftChar) == 0) {\n                    map.remove(leftChar);\n                }\n                left++;\n            }\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n        return maxLength;\n    }\n    \n    // Count subarrays with sum equals k\n    public int subarraySum(int[] nums, int k) {\n        Map<Integer, Integer> prefixSum = new HashMap<>();\n        prefixSum.put(0, 1);\n        int sum = 0, count = 0;\n        \n        for (int num : nums) {\n            sum += num;\n            if (prefixSum.containsKey(sum - k)) {\n                count += prefixSum.get(sum - k);\n            }\n            prefixSum.put(sum, prefixSum.getOrDefault(sum, 0) + 1);\n        }\n        return count;\n    }\n}"
    },
    {
      "id": 23,
      "question": "What is backtracking and how does it differ from recursion?",
      "answer": "Backtracking is an algorithmic technique for solving problems by trying to build a solution incrementally, abandoning solutions (backtracking) when they fail to satisfy constraints.\n\nBacktracking Characteristics:\n• Explores all possible solutions systematically\n• Abandons partial solutions that cannot lead to valid solution\n• Uses recursion as implementation mechanism\n• Prunes search space to avoid unnecessary exploration\n\nBacktracking vs Recursion:\n• Recursion is a programming technique\n• Backtracking is a problem-solving strategy using recursion\n• Backtracking includes decision making and backtracking steps\n• All backtracking uses recursion, but not all recursion is backtracking\n\nKey Components:\n• Choice - Make a decision\n• Constraint - Check if choice is valid\n• Goal - Check if solution is complete\n• Backtrack - Undo choice if it leads nowhere\n\nCommon Problems:\n• N-Queens problem\n• Sudoku solver\n• Permutations and combinations\n• Subset sum\n• Graph coloring\n• Maze solving",
      "explanation": "Backtracking is a problem-solving technique that uses recursion to explore all possible solutions, abandoning paths that violate constraints and backtracking to try alternatives.",
      "difficulty": "Hard",
      "code": "class BacktrackingProblems {\n    \n    // Generate all permutations - O(n! × n)\n    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        backtrackPermute(nums, new ArrayList<>(), result, new boolean[nums.length]);\n        return result;\n    }\n    \n    private void backtrackPermute(int[] nums, List<Integer> current, \n                                  List<List<Integer>> result, boolean[] used) {\n        // Goal: permutation complete\n        if (current.size() == nums.length) {\n            result.add(new ArrayList<>(current));\n            return;\n        }\n        \n        for (int i = 0; i < nums.length; i++) {\n            // Constraint: skip already used numbers\n            if (used[i]) continue;\n            \n            // Choice: add number\n            current.add(nums[i]);\n            used[i] = true;\n            \n            // Recurse\n            backtrackPermute(nums, current, result, used);\n            \n            // Backtrack: undo choice\n            current.remove(current.size() - 1);\n            used[i] = false;\n        }\n    }\n    \n    // Generate all subsets - O(2^n)\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        backtrackSubsets(nums, 0, new ArrayList<>(), result);\n        return result;\n    }\n    \n    private void backtrackSubsets(int[] nums, int start, \n                                  List<Integer> current, List<List<Integer>> result) {\n        result.add(new ArrayList<>(current));\n        \n        for (int i = start; i < nums.length; i++) {\n            current.add(nums[i]);\n            backtrackSubsets(nums, i + 1, current, result);\n            current.remove(current.size() - 1);\n        }\n    }\n    \n    // N-Queens Problem - O(n!)\n    public List<List<String>> solveNQueens(int n) {\n        List<List<String>> result = new ArrayList<>();\n        char[][] board = new char[n][n];\n        for (char[] row : board) Arrays.fill(row, '.');\n        backtrackNQueens(board, 0, result);\n        return result;\n    }\n    \n    private void backtrackNQueens(char[][] board, int row, List<List<String>> result) {\n        if (row == board.length) {\n            result.add(construct(board));\n            return;\n        }\n        \n        for (int col = 0; col < board.length; col++) {\n            if (isValid(board, row, col)) {\n                board[row][col] = 'Q';\n                backtrackNQueens(board, row + 1, result);\n                board[row][col] = '.';\n            }\n        }\n    }\n    \n    private boolean isValid(char[][] board, int row, int col) {\n        // Check column\n        for (int i = 0; i < row; i++) {\n            if (board[i][col] == 'Q') return false;\n        }\n        // Check diagonal\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n            if (board[i][j] == 'Q') return false;\n        }\n        // Check anti-diagonal\n        for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {\n            if (board[i][j] == 'Q') return false;\n        }\n        return true;\n    }\n    \n    private List<String> construct(char[][] board) {\n        List<String> result = new ArrayList<>();\n        for (char[] row : board) {\n            result.add(new String(row));\n        }\n        return result;\n    }\n    \n    // Combination Sum - O(2^n)\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> result = new ArrayList<>();\n        Arrays.sort(candidates);\n        backtrackCombination(candidates, target, 0, new ArrayList<>(), result);\n        return result;\n    }\n    \n    private void backtrackCombination(int[] candidates, int remaining, int start,\n                                      List<Integer> current, List<List<Integer>> result) {\n        if (remaining == 0) {\n            result.add(new ArrayList<>(current));\n            return;\n        }\n        if (remaining < 0) return;\n        \n        for (int i = start; i < candidates.length; i++) {\n            current.add(candidates[i]);\n            backtrackCombination(candidates, remaining - candidates[i], i, current, result);\n            current.remove(current.size() - 1);\n        }\n    }\n}"
    },
    {
      "id": 24,
      "question": "What is a linked list and what are its types?",
      "answer": "A linked list is a linear data structure where elements (nodes) are connected using pointers, with each node containing data and a reference to the next node.\n\nLinked List Types:\n• Singly Linked List - Each node has reference to next node\n• Doubly Linked List - Each node has references to both next and previous\n• Circular Linked List - Last node points back to first node\n• Doubly Circular - Combination of doubly and circular\n\nAdvantages:\n• Dynamic size\n• Efficient insertion/deletion at beginning - O(1)\n• No memory waste\n• Easy implementation of stacks and queues\n\nDisadvantages:\n• No random access - O(n) to access element\n• Extra memory for pointers\n• Poor cache locality\n• Cannot do binary search\n\nCommon Operations:\n• Insert at beginning - O(1)\n• Insert at end - O(n) for singly, O(1) with tail pointer\n• Delete node - O(n) to find, O(1) to delete\n• Search - O(n)",
      "explanation": "Linked lists are dynamic data structures where nodes are connected via pointers, allowing efficient insertions and deletions but requiring O(n) time for random access.",
      "difficulty": "Easy",
      "code": "// Singly Linked List Node\nclass ListNode {\n    int data;\n    ListNode next;\n    \n    ListNode(int data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\nclass SinglyLinkedList {\n    ListNode head;\n    \n    // Insert at beginning - O(1)\n    public void insertFirst(int data) {\n        ListNode newNode = new ListNode(data);\n        newNode.next = head;\n        head = newNode;\n    }\n    \n    // Insert at end - O(n)\n    public void insertLast(int data) {\n        ListNode newNode = new ListNode(data);\n        if (head == null) {\n            head = newNode;\n            return;\n        }\n        ListNode current = head;\n        while (current.next != null) {\n            current = current.next;\n        }\n        current.next = newNode;\n    }\n    \n    // Delete node with given value - O(n)\n    public void delete(int data) {\n        if (head == null) return;\n        if (head.data == data) {\n            head = head.next;\n            return;\n        }\n        ListNode current = head;\n        while (current.next != null && current.next.data != data) {\n            current = current.next;\n        }\n        if (current.next != null) {\n            current.next = current.next.next;\n        }\n    }\n    \n    // Search - O(n)\n    public boolean search(int data) {\n        ListNode current = head;\n        while (current != null) {\n            if (current.data == data) return true;\n            current = current.next;\n        }\n        return false;\n    }\n    \n    // Reverse linked list - O(n)\n    public void reverse() {\n        ListNode prev = null;\n        ListNode current = head;\n        while (current != null) {\n            ListNode nextNode = current.next;\n            current.next = prev;\n            prev = current;\n            current = nextNode;\n        }\n        head = prev;\n    }\n    \n    // Find middle element - O(n)\n    public int findMiddle() {\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow != null ? slow.data : -1;\n    }\n}\n\n// Doubly Linked List Node\nclass DoublyNode {\n    int data;\n    DoublyNode prev, next;\n    \n    DoublyNode(int data) {\n        this.data = data;\n        this.prev = null;\n        this.next = null;\n    }\n}\n\nclass DoublyLinkedList {\n    DoublyNode head;\n    \n    public void insertFirst(int data) {\n        DoublyNode newNode = new DoublyNode(data);\n        if (head != null) {\n            head.prev = newNode;\n        }\n        newNode.next = head;\n        head = newNode;\n    }\n    \n    public void delete(DoublyNode node) {\n        if (node.prev != null) {\n            node.prev.next = node.next;\n        } else {\n            head = node.next;\n        }\n        if (node.next != null) {\n            node.next.prev = node.prev;\n        }\n    }\n}"
    },
    {
      "id": 25,
      "question": "What are common techniques to detect and remove cycles in a linked list?",
      "answer": "Cycle detection and removal are important linked list operations, with Floyd's Cycle Detection algorithm being the most efficient approach.\n\nFloyd's Cycle Detection (Tortoise and Hare):\n• Uses two pointers: slow (moves 1 step) and fast (moves 2 steps)\n• If cycle exists, pointers will meet inside the cycle\n• Time Complexity - O(n)\n• Space Complexity - O(1)\n\nCycle Detection Methods:\n• Hash Set - Store visited nodes, check for duplicates - O(n) time, O(n) space\n• Floyd's Algorithm - Fast and slow pointers - O(n) time, O(1) space\n• Modify node structure - Mark visited nodes - O(n) time, O(1) space\n\nFinding Cycle Start:\n• After detecting cycle, move one pointer to head\n• Move both pointers one step at a time\n• They meet at cycle start\n\nRemoving Cycle:\n• Find cycle start\n• Traverse to node before cycle start\n• Set its next pointer to null",
      "explanation": "Floyd's cycle detection uses fast and slow pointers to detect cycles in O(n) time with O(1) space, and can find the cycle start for removal.",
      "difficulty": "Medium",
      "code": "class LinkedListCycle {\n    \n    // Detect cycle using Floyd's algorithm - O(n) time, O(1) space\n    public boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null) return false;\n        \n        ListNode slow = head;\n        ListNode fast = head;\n        \n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            \n            if (slow == fast) {\n                return true; // Cycle detected\n            }\n        }\n        return false;\n    }\n    \n    // Find cycle start node\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) return null;\n        \n        ListNode slow = head;\n        ListNode fast = head;\n        boolean hasCycle = false;\n        \n        // Detect cycle\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            \n            if (slow == fast) {\n                hasCycle = true;\n                break;\n            }\n        }\n        \n        if (!hasCycle) return null;\n        \n        // Find cycle start\n        slow = head;\n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow; // This is the cycle start\n    }\n    \n    // Remove cycle from linked list\n    public void removeCycle(ListNode head) {\n        if (head == null || head.next == null) return;\n        \n        ListNode slow = head;\n        ListNode fast = head;\n        \n        // Detect cycle\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            \n            if (slow == fast) {\n                break;\n            }\n        }\n        \n        // No cycle\n        if (slow != fast) return;\n        \n        // Find cycle start\n        slow = head;\n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        \n        // Find node before cycle start\n        while (fast.next != slow) {\n            fast = fast.next;\n        }\n        \n        // Remove cycle\n        fast.next = null;\n    }\n    \n    // Detect cycle using hash set - O(n) time, O(n) space\n    public boolean hasCycleHashSet(ListNode head) {\n        Set<ListNode> visited = new HashSet<>();\n        ListNode current = head;\n        \n        while (current != null) {\n            if (visited.contains(current)) {\n                return true;\n            }\n            visited.add(current);\n            current = current.next;\n        }\n        return false;\n    }\n    \n    // Find cycle length\n    public int cycleLength(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        \n        // Detect cycle\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            \n            if (slow == fast) {\n                // Calculate cycle length\n                int length = 1;\n                fast = fast.next;\n                while (slow != fast) {\n                    fast = fast.next;\n                    length++;\n                }\n                return length;\n            }\n        }\n        return 0; // No cycle\n    }\n    \n    // Check if two lists intersect\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) return null;\n        \n        ListNode pA = headA;\n        ListNode pB = headB;\n        \n        // When pointer reaches end, move to other list's head\n        while (pA != pB) {\n            pA = (pA == null) ? headB : pA.next;\n            pB = (pB == null) ? headA : pB.next;\n        }\n        return pA;\n    }\n}"
    },
    {
      "id": 26,
      "question": "What is the difference between DFS and BFS in terms of implementation and use cases?",
      "answer": "DFS and BFS are fundamental graph traversal algorithms with different characteristics and optimal use cases.\n\nImplementation Differences:\n• DFS uses Stack (or recursion call stack)\n• BFS uses Queue\n• DFS goes deep before wide\n• BFS explores level by level\n\nTime and Space Complexity:\n• Both have O(V + E) time complexity\n• DFS space - O(h) where h is height for recursion, O(V) for visited array\n• BFS space - O(w) where w is maximum width, O(V) worst case\n\nWhen to Use DFS:\n• Finding any path between nodes\n• Detecting cycles\n• Topological sorting\n• Solving puzzles with single solution\n• Memory constrained scenarios\n• Deep, narrow graphs\n\nWhen to Use BFS:\n• Finding shortest path (unweighted)\n• Level order traversal\n• Finding all nodes at distance k\n• Testing bipartiteness\n• Wide, shallow graphs",
      "explanation": "DFS uses a stack to explore deeply first and is better for path finding and cycles, while BFS uses a queue for level-by-level exploration and guarantees shortest paths.",
      "difficulty": "Medium",
      "code": "import java.util.*;\n\nclass GraphTraversal {\n    private LinkedList<Integer>[] adjList;\n    private int vertices;\n    \n    // DFS - Recursive Implementation\n    public void dfs(int start) {\n        boolean[] visited = new boolean[vertices];\n        System.out.println(\"DFS Traversal:\");\n        dfsRecursive(start, visited);\n        System.out.println();\n    }\n    \n    private void dfsRecursive(int v, boolean[] visited) {\n        visited[v] = true;\n        System.out.print(v + \" \");\n        \n        for (int neighbor : adjList[v]) {\n            if (!visited[neighbor]) {\n                dfsRecursive(neighbor, visited);\n            }\n        }\n    }\n    \n    // DFS - Iterative with Stack\n    public void dfsIterative(int start) {\n        boolean[] visited = new boolean[vertices];\n        Stack<Integer> stack = new Stack<>();\n        \n        stack.push(start);\n        System.out.println(\"DFS Iterative:\");\n        \n        while (!stack.isEmpty()) {\n            int v = stack.pop();\n            \n            if (!visited[v]) {\n                visited[v] = true;\n                System.out.print(v + \" \");\n                \n                // Push neighbors in reverse order\n                for (int i = adjList[v].size() - 1; i >= 0; i--) {\n                    int neighbor = adjList[v].get(i);\n                    if (!visited[neighbor]) {\n                        stack.push(neighbor);\n                    }\n                }\n            }\n        }\n        System.out.println();\n    }\n    \n    // BFS - Queue Implementation\n    public void bfs(int start) {\n        boolean[] visited = new boolean[vertices];\n        Queue<Integer> queue = new LinkedList<>();\n        \n        visited[start] = true;\n        queue.offer(start);\n        System.out.println(\"BFS Traversal:\");\n        \n        while (!queue.isEmpty()) {\n            int v = queue.poll();\n            System.out.print(v + \" \");\n            \n            for (int neighbor : adjList[v]) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    queue.offer(neighbor);\n                }\n            }\n        }\n        System.out.println();\n    }\n    \n    // BFS to find shortest path distance\n    public int shortestPathBFS(int start, int end) {\n        if (start == end) return 0;\n        \n        boolean[] visited = new boolean[vertices];\n        Queue<Integer> queue = new LinkedList<>();\n        int[] distance = new int[vertices];\n        \n        visited[start] = true;\n        queue.offer(start);\n        distance[start] = 0;\n        \n        while (!queue.isEmpty()) {\n            int v = queue.poll();\n            \n            for (int neighbor : adjList[v]) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    distance[neighbor] = distance[v] + 1;\n                    queue.offer(neighbor);\n                    \n                    if (neighbor == end) {\n                        return distance[neighbor];\n                    }\n                }\n            }\n        }\n        return -1; // No path found\n    }\n    \n    // DFS to detect cycle in directed graph\n    public boolean hasCycleDFS() {\n        boolean[] visited = new boolean[vertices];\n        boolean[] recStack = new boolean[vertices];\n        \n        for (int i = 0; i < vertices; i++) {\n            if (hasCycleUtil(i, visited, recStack)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    private boolean hasCycleUtil(int v, boolean[] visited, boolean[] recStack) {\n        if (recStack[v]) return true;\n        if (visited[v]) return false;\n        \n        visited[v] = true;\n        recStack[v] = true;\n        \n        for (int neighbor : adjList[v]) {\n            if (hasCycleUtil(neighbor, visited, recStack)) {\n                return true;\n            }\n        }\n        \n        recStack[v] = false;\n        return false;\n    }\n    \n    // BFS to find all nodes at distance k\n    public List<Integer> nodesAtDistanceK(int start, int k) {\n        List<Integer> result = new ArrayList<>();\n        boolean[] visited = new boolean[vertices];\n        Queue<Integer> queue = new LinkedList<>();\n        int[] distance = new int[vertices];\n        \n        visited[start] = true;\n        queue.offer(start);\n        \n        while (!queue.isEmpty()) {\n            int v = queue.poll();\n            \n            if (distance[v] == k) {\n                result.add(v);\n            }\n            \n            for (int neighbor : adjList[v]) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    distance[neighbor] = distance[v] + 1;\n                    queue.offer(neighbor);\n                }\n            }\n        }\n        return result;\n    }\n}"
    },
    {
      "id": 27,
      "question": "What are AVL trees and how do they maintain balance?",
      "answer": "AVL trees are self-balancing Binary Search Trees where the height difference between left and right subtrees (balance factor) of any node is at most 1.\n\nAVL Properties:\n• Balance Factor = Height(Left Subtree) - Height(Right Subtree)\n• Balance Factor must be -1, 0, or 1\n• Automatically rebalances after insertions and deletions\n• More rigidly balanced than Red-Black trees\n• Height is always O(log n)\n\nRotations for Balancing:\n• Left Rotation (LL) - Right subtree too heavy\n• Right Rotation (RR) - Left subtree too heavy\n• Left-Right Rotation (LR) - Left child's right subtree heavy\n• Right-Left Rotation (RL) - Right child's left subtree heavy\n\nTime Complexity:\n• Search - O(log n)\n• Insert - O(log n)\n• Delete - O(log n)\n\nAVL vs Regular BST:\n• AVL guarantees O(log n) operations\n• BST can degrade to O(n) if unbalanced\n• AVL has overhead of rotations",
      "explanation": "AVL trees are self-balancing BSTs that maintain a balance factor of -1, 0, or 1 at each node using rotations, guaranteeing O(log n) operations.",
      "difficulty": "Hard",
      "code": "class AVLNode {\n    int data, height;\n    AVLNode left, right;\n    \n    AVLNode(int data) {\n        this.data = data;\n        this.height = 1;\n    }\n}\n\nclass AVLTree {\n    private AVLNode root;\n    \n    // Get height of node\n    private int height(AVLNode node) {\n        return node == null ? 0 : node.height;\n    }\n    \n    // Get balance factor\n    private int getBalance(AVLNode node) {\n        return node == null ? 0 : height(node.left) - height(node.right);\n    }\n    \n    // Update height\n    private void updateHeight(AVLNode node) {\n        node.height = 1 + Math.max(height(node.left), height(node.right));\n    }\n    \n    // Right rotation\n    private AVLNode rightRotate(AVLNode y) {\n        AVLNode x = y.left;\n        AVLNode T2 = x.right;\n        \n        // Perform rotation\n        x.right = y;\n        y.left = T2;\n        \n        // Update heights\n        updateHeight(y);\n        updateHeight(x);\n        \n        return x; // New root\n    }\n    \n    // Left rotation\n    private AVLNode leftRotate(AVLNode x) {\n        AVLNode y = x.right;\n        AVLNode T2 = y.left;\n        \n        // Perform rotation\n        y.left = x;\n        x.right = T2;\n        \n        // Update heights\n        updateHeight(x);\n        updateHeight(y);\n        \n        return y; // New root\n    }\n    \n    // Insert node\n    public void insert(int data) {\n        root = insertNode(root, data);\n    }\n    \n    private AVLNode insertNode(AVLNode node, int data) {\n        // Standard BST insertion\n        if (node == null) {\n            return new AVLNode(data);\n        }\n        \n        if (data < node.data) {\n            node.left = insertNode(node.left, data);\n        } else if (data > node.data) {\n            node.right = insertNode(node.right, data);\n        } else {\n            return node; // Duplicates not allowed\n        }\n        \n        // Update height\n        updateHeight(node);\n        \n        // Get balance factor\n        int balance = getBalance(node);\n        \n        // Left Left Case\n        if (balance > 1 && data < node.left.data) {\n            return rightRotate(node);\n        }\n        \n        // Right Right Case\n        if (balance < -1 && data > node.right.data) {\n            return leftRotate(node);\n        }\n        \n        // Left Right Case\n        if (balance > 1 && data > node.left.data) {\n            node.left = leftRotate(node.left);\n            return rightRotate(node);\n        }\n        \n        // Right Left Case\n        if (balance < -1 && data < node.right.data) {\n            node.right = rightRotate(node.right);\n            return leftRotate(node);\n        }\n        \n        return node;\n    }\n    \n    // Delete node\n    public void delete(int data) {\n        root = deleteNode(root, data);\n    }\n    \n    private AVLNode deleteNode(AVLNode node, int data) {\n        // Standard BST deletion\n        if (node == null) return node;\n        \n        if (data < node.data) {\n            node.left = deleteNode(node.left, data);\n        } else if (data > node.data) {\n            node.right = deleteNode(node.right, data);\n        } else {\n            // Node with one or no child\n            if (node.left == null || node.right == null) {\n                node = (node.left != null) ? node.left : node.right;\n            } else {\n                // Node with two children\n                AVLNode temp = findMin(node.right);\n                node.data = temp.data;\n                node.right = deleteNode(node.right, temp.data);\n            }\n        }\n        \n        if (node == null) return node;\n        \n        // Update height\n        updateHeight(node);\n        \n        // Balance the node\n        int balance = getBalance(node);\n        \n        // Left Left Case\n        if (balance > 1 && getBalance(node.left) >= 0) {\n            return rightRotate(node);\n        }\n        \n        // Left Right Case\n        if (balance > 1 && getBalance(node.left) < 0) {\n            node.left = leftRotate(node.left);\n            return rightRotate(node);\n        }\n        \n        // Right Right Case\n        if (balance < -1 && getBalance(node.right) <= 0) {\n            return leftRotate(node);\n        }\n        \n        // Right Left Case\n        if (balance < -1 && getBalance(node.right) > 0) {\n            node.right = rightRotate(node.right);\n            return leftRotate(node);\n        }\n        \n        return node;\n    }\n    \n    private AVLNode findMin(AVLNode node) {\n        while (node.left != null) {\n            node = node.left;\n        }\n        return node;\n    }\n}"
    },
    {
      "id": 28,
      "question": "What is topological sorting and how is it implemented?",
      "answer": "Topological sorting is a linear ordering of vertices in a Directed Acyclic Graph (DAG) where for every directed edge from vertex A to B, A comes before B in the ordering.\n\nRequirements:\n• Graph must be directed\n• Graph must be acyclic (DAG)\n• Not unique - multiple valid orderings may exist\n\nImplementation Methods:\n• Kahn's Algorithm (BFS) - Uses in-degree\n• DFS-based approach - Uses recursion and stack\n\nApplications:\n• Task scheduling with dependencies\n• Build systems (makefile execution)\n• Course prerequisite ordering\n• Package dependency resolution\n• Deadlock detection\n• Compilation order determination\n\nTime Complexity:\n• O(V + E) for both methods\n\nDetecting Cycles:\n• If topological sort cannot include all vertices, graph has cycle\n• Useful for detecting circular dependencies",
      "explanation": "Topological sorting orders vertices in a DAG so dependencies come before dependents, implemented using Kahn's algorithm (BFS) or DFS, useful for task scheduling.",
      "difficulty": "Hard",
      "code": "import java.util.*;\n\nclass TopologicalSort {\n    private int vertices;\n    private LinkedList<Integer>[] adjList;\n    \n    // Kahn's Algorithm (BFS-based) - O(V + E)\n    public List<Integer> topologicalSortKahn() {\n        List<Integer> result = new ArrayList<>();\n        int[] inDegree = new int[vertices];\n        \n        // Calculate in-degree for each vertex\n        for (int i = 0; i < vertices; i++) {\n            for (int neighbor : adjList[i]) {\n                inDegree[neighbor]++;\n            }\n        }\n        \n        // Queue for vertices with in-degree 0\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < vertices; i++) {\n            if (inDegree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n        \n        // Process vertices\n        while (!queue.isEmpty()) {\n            int v = queue.poll();\n            result.add(v);\n            \n            // Reduce in-degree of neighbors\n            for (int neighbor : adjList[v]) {\n                inDegree[neighbor]--;\n                if (inDegree[neighbor] == 0) {\n                    queue.offer(neighbor);\n                }\n            }\n        }\n        \n        // Check for cycle\n        if (result.size() != vertices) {\n            System.out.println(\"Graph has a cycle!\");\n            return new ArrayList<>();\n        }\n        \n        return result;\n    }\n    \n    // DFS-based approach - O(V + E)\n    public List<Integer> topologicalSortDFS() {\n        Stack<Integer> stack = new Stack<>();\n        boolean[] visited = new boolean[vertices];\n        \n        // Call DFS for all unvisited vertices\n        for (int i = 0; i < vertices; i++) {\n            if (!visited[i]) {\n                topologicalSortUtil(i, visited, stack);\n            }\n        }\n        \n        // Pop all items from stack\n        List<Integer> result = new ArrayList<>();\n        while (!stack.isEmpty()) {\n            result.add(stack.pop());\n        }\n        return result;\n    }\n    \n    private void topologicalSortUtil(int v, boolean[] visited, Stack<Integer> stack) {\n        visited[v] = true;\n        \n        // Recur for all adjacent vertices\n        for (int neighbor : adjList[v]) {\n            if (!visited[neighbor]) {\n                topologicalSortUtil(neighbor, visited, stack);\n            }\n        }\n        \n        // Push current vertex to stack after visiting all neighbors\n        stack.push(v);\n    }\n    \n    // Detect cycle in directed graph using topological sort\n    public boolean hasCycle() {\n        int[] inDegree = new int[vertices];\n        \n        for (int i = 0; i < vertices; i++) {\n            for (int neighbor : adjList[i]) {\n                inDegree[neighbor]++;\n            }\n        }\n        \n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < vertices; i++) {\n            if (inDegree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n        \n        int processedVertices = 0;\n        while (!queue.isEmpty()) {\n            int v = queue.poll();\n            processedVertices++;\n            \n            for (int neighbor : adjList[v]) {\n                inDegree[neighbor]--;\n                if (inDegree[neighbor] == 0) {\n                    queue.offer(neighbor);\n                }\n            }\n        }\n        \n        return processedVertices != vertices;\n    }\n    \n    // Course Schedule Problem\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        int[] inDegree = new int[numCourses];\n        List<List<Integer>> adj = new ArrayList<>();\n        \n        for (int i = 0; i < numCourses; i++) {\n            adj.add(new ArrayList<>());\n        }\n        \n        for (int[] prereq : prerequisites) {\n            adj.get(prereq[1]).add(prereq[0]);\n            inDegree[prereq[0]]++;\n        }\n        \n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < numCourses; i++) {\n            if (inDegree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n        \n        int completed = 0;\n        while (!queue.isEmpty()) {\n            int course = queue.poll();\n            completed++;\n            \n            for (int next : adj.get(course)) {\n                inDegree[next]--;\n                if (inDegree[next] == 0) {\n                    queue.offer(next);\n                }\n            }\n        }\n        \n        return completed == numCourses;\n    }\n}"
    },
    {
      "id": 29,
      "question": "What is Dijkstra's algorithm and when is it used?",
      "answer": "Dijkstra's algorithm finds the shortest path from a source vertex to all other vertices in a weighted graph with non-negative edge weights.\n\nAlgorithm Characteristics:\n• Greedy algorithm approach\n• Works only with non-negative weights\n• Finds shortest path to all vertices from source\n• Uses priority queue for efficiency\n• Single-source shortest path algorithm\n\nTime Complexity:\n• O((V + E) log V) with binary heap/priority queue\n• O(V²) with simple array implementation\n• O(V + E) with Fibonacci heap\n\nKey Steps:\n• Initialize distances (source = 0, others = infinity)\n• Use min-heap to process vertices by distance\n• Relax edges to update shortest distances\n• Mark vertices as visited\n\nLimitations:\n• Cannot handle negative weights\n• Use Bellman-Ford for negative weights\n\nApplications:\n• GPS navigation systems\n• Network routing protocols\n• Social networking (connections)\n• Flight ticket pricing",
      "explanation": "Dijkstra's algorithm finds shortest paths from a source to all vertices in weighted graphs using a greedy approach with priority queue, working only with non-negative weights.",
      "difficulty": "Hard",
      "code": "import java.util.*;\n\nclass DijkstraAlgorithm {\n    \n    class Edge {\n        int dest, weight;\n        Edge(int dest, int weight) {\n            this.dest = dest;\n            this.weight = weight;\n        }\n    }\n    \n    class Node implements Comparable<Node> {\n        int vertex, distance;\n        Node(int vertex, int distance) {\n            this.vertex = vertex;\n            this.distance = distance;\n        }\n        public int compareTo(Node other) {\n            return Integer.compare(this.distance, other.distance);\n        }\n    }\n    \n    private List<List<Edge>> adjList;\n    private int vertices;\n    \n    // Dijkstra's Algorithm - O((V + E) log V)\n    public int[] dijkstra(int source) {\n        int[] dist = new int[vertices];\n        boolean[] visited = new boolean[vertices];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[source] = 0;\n        \n        PriorityQueue<Node> pq = new PriorityQueue<>();\n        pq.offer(new Node(source, 0));\n        \n        while (!pq.isEmpty()) {\n            Node current = pq.poll();\n            int u = current.vertex;\n            \n            if (visited[u]) continue;\n            visited[u] = true;\n            \n            // Relax edges\n            for (Edge edge : adjList.get(u)) {\n                int v = edge.dest;\n                int weight = edge.weight;\n                \n                if (!visited[v] && dist[u] != Integer.MAX_VALUE && \n                    dist[u] + weight < dist[v]) {\n                    dist[v] = dist[u] + weight;\n                    pq.offer(new Node(v, dist[v]));\n                }\n            }\n        }\n        \n        return dist;\n    }\n    \n    // Dijkstra with path reconstruction\n    public List<Integer> dijkstraWithPath(int source, int destination) {\n        int[] dist = new int[vertices];\n        int[] parent = new int[vertices];\n        boolean[] visited = new boolean[vertices];\n        \n        Arrays.fill(dist, Integer.MAX_VALUE);\n        Arrays.fill(parent, -1);\n        dist[source] = 0;\n        \n        PriorityQueue<Node> pq = new PriorityQueue<>();\n        pq.offer(new Node(source, 0));\n        \n        while (!pq.isEmpty()) {\n            Node current = pq.poll();\n            int u = current.vertex;\n            \n            if (visited[u]) continue;\n            visited[u] = true;\n            \n            if (u == destination) break; // Early termination\n            \n            for (Edge edge : adjList.get(u)) {\n                int v = edge.dest;\n                int weight = edge.weight;\n                \n                if (!visited[v] && dist[u] != Integer.MAX_VALUE && \n                    dist[u] + weight < dist[v]) {\n                    dist[v] = dist[u] + weight;\n                    parent[v] = u;\n                    pq.offer(new Node(v, dist[v]));\n                }\n            }\n        }\n        \n        // Reconstruct path\n        return reconstructPath(parent, source, destination);\n    }\n    \n    private List<Integer> reconstructPath(int[] parent, int source, int dest) {\n        List<Integer> path = new ArrayList<>();\n        if (parent[dest] == -1 && dest != source) {\n            return path; // No path exists\n        }\n        \n        for (int v = dest; v != -1; v = parent[v]) {\n            path.add(v);\n        }\n        Collections.reverse(path);\n        return path;\n    }\n    \n    // Simple array implementation - O(V²)\n    public int[] dijkstraSimple(int source, int[][] graph) {\n        int n = graph.length;\n        int[] dist = new int[n];\n        boolean[] visited = new boolean[n];\n        \n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[source] = 0;\n        \n        for (int count = 0; count < n - 1; count++) {\n            // Find minimum distance vertex\n            int u = minDistance(dist, visited);\n            visited[u] = true;\n            \n            // Update distances\n            for (int v = 0; v < n; v++) {\n                if (!visited[v] && graph[u][v] != 0 && \n                    dist[u] != Integer.MAX_VALUE && \n                    dist[u] + graph[u][v] < dist[v]) {\n                    dist[v] = dist[u] + graph[u][v];\n                }\n            }\n        }\n        \n        return dist;\n    }\n    \n    private int minDistance(int[] dist, boolean[] visited) {\n        int min = Integer.MAX_VALUE;\n        int minIndex = -1;\n        \n        for (int v = 0; v < dist.length; v++) {\n            if (!visited[v] && dist[v] <= min) {\n                min = dist[v];\n                minIndex = v;\n            }\n        }\n        return minIndex;\n    }\n}"
    },
    {
      "id": 30,
      "question": "What is the difference between divide and conquer and dynamic programming?",
      "answer": "Divide and Conquer and Dynamic Programming are both problem-solving paradigms that break problems into subproblems, but differ in how they handle subproblem relationships.\n\nDivide and Conquer:\n• Breaks problem into independent subproblems\n• Solves subproblems recursively\n• Combines solutions to solve original problem\n• No overlapping subproblems\n• Examples: Merge Sort, Quick Sort, Binary Search\n• Top-down approach\n\nDynamic Programming:\n• Breaks problem into overlapping subproblems\n• Stores solutions to avoid recomputation\n• Requires optimal substructure\n• Uses memoization or tabulation\n• Examples: Fibonacci, Knapsack, LCS\n• Can be top-down or bottom-up\n\nKey Difference:\n• D&C solves each subproblem once\n• DP solves overlapping subproblems multiple times without DP\n• DP stores results for reuse\n\nWhen to Use:\n• D&C for independent subproblems\n• DP for overlapping subproblems with optimal substructure",
      "explanation": "Divide and Conquer solves independent subproblems recursively, while Dynamic Programming handles overlapping subproblems by storing solutions to avoid redundant calculations.",
      "difficulty": "Medium",
      "code": "class DivideConquerVsDP {\n    \n    // DIVIDE AND CONQUER EXAMPLES\n    \n    // Merge Sort - O(n log n)\n    public void mergeSort(int[] arr, int left, int right) {\n        if (left < right) {\n            int mid = left + (right - left) / 2;\n            \n            // Divide into independent subproblems\n            mergeSort(arr, left, mid);\n            mergeSort(arr, mid + 1, right);\n            \n            // Conquer - merge solutions\n            merge(arr, left, mid, right);\n        }\n    }\n    \n    private void merge(int[] arr, int left, int mid, int right) {\n        int n1 = mid - left + 1;\n        int n2 = right - mid;\n        int[] L = new int[n1];\n        int[] R = new int[n2];\n        \n        System.arraycopy(arr, left, L, 0, n1);\n        System.arraycopy(arr, mid + 1, R, 0, n2);\n        \n        int i = 0, j = 0, k = left;\n        while (i < n1 && j < n2) {\n            arr[k++] = (L[i] <= R[j]) ? L[i++] : R[j++];\n        }\n        while (i < n1) arr[k++] = L[i++];\n        while (j < n2) arr[k++] = R[j++];\n    }\n    \n    // Binary Search - O(log n)\n    public int binarySearch(int[] arr, int target) {\n        return binarySearchHelper(arr, 0, arr.length - 1, target);\n    }\n    \n    private int binarySearchHelper(int[] arr, int left, int right, int target) {\n        if (left > right) return -1;\n        \n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) return mid;\n        \n        // Independent subproblems\n        if (arr[mid] > target) {\n            return binarySearchHelper(arr, left, mid - 1, target);\n        }\n        return binarySearchHelper(arr, mid + 1, right, target);\n    }\n    \n    // DYNAMIC PROGRAMMING EXAMPLES\n    \n    // Fibonacci without DP - O(2^n) - OVERLAPPING SUBPROBLEMS\n    public int fibRecursive(int n) {\n        if (n <= 1) return n;\n        // f(4) calls f(3) and f(2)\n        // f(3) also calls f(2) - OVERLAP!\n        return fibRecursive(n - 1) + fibRecursive(n - 2);\n    }\n    \n    // Fibonacci with DP (Memoization) - O(n)\n    public int fibMemoization(int n) {\n        int[] memo = new int[n + 1];\n        return fibMemo(n, memo);\n    }\n    \n    private int fibMemo(int n, int[] memo) {\n        if (n <= 1) return n;\n        if (memo[n] != 0) return memo[n]; // Reuse stored result\n        memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo);\n        return memo[n];\n    }\n    \n    // Fibonacci with DP (Tabulation) - O(n)\n    public int fibTabulation(int n) {\n        if (n <= 1) return n;\n        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        dp[1] = 1;\n        \n        // Build solution bottom-up\n        for (int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n    \n    // Longest Common Subsequence - DP with overlapping subproblems\n    public int lcs(String s1, String s2) {\n        int m = s1.length(), n = s2.length();\n        int[][] dp = new int[m + 1][n + 1];\n        \n        // Build solution using previously computed subproblems\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n    \n    // Maximum Subarray - Both approaches possible\n    \n    // Divide and Conquer approach - O(n log n)\n    public int maxSubarrayDC(int[] nums) {\n        return maxSubarrayHelper(nums, 0, nums.length - 1);\n    }\n    \n    private int maxSubarrayHelper(int[] nums, int left, int right) {\n        if (left == right) return nums[left];\n        \n        int mid = left + (right - left) / 2;\n        int leftMax = maxSubarrayHelper(nums, left, mid);\n        int rightMax = maxSubarrayHelper(nums, mid + 1, right);\n        int crossMax = maxCrossingSum(nums, left, mid, right);\n        \n        return Math.max(Math.max(leftMax, rightMax), crossMax);\n    }\n    \n    private int maxCrossingSum(int[] nums, int left, int mid, int right) {\n        int sum = 0, leftSum = Integer.MIN_VALUE;\n        for (int i = mid; i >= left; i--) {\n            sum += nums[i];\n            leftSum = Math.max(leftSum, sum);\n        }\n        \n        sum = 0;\n        int rightSum = Integer.MIN_VALUE;\n        for (int i = mid + 1; i <= right; i++) {\n            sum += nums[i];\n            rightSum = Math.max(rightSum, sum);\n        }\n        \n        return leftSum + rightSum;\n    }\n    \n    // DP approach (Kadane's Algorithm) - O(n)\n    public int maxSubarrayDP(int[] nums) {\n        int maxSoFar = nums[0];\n        int maxEndingHere = nums[0];\n        \n        for (int i = 1; i < nums.length; i++) {\n            maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);\n            maxSoFar = Math.max(maxSoFar, maxEndingHere);\n        }\n        return maxSoFar;\n    }\n}"
    },
    {
      "id": 31,
      "question": "What is memoization and how does it optimize recursive algorithms?",
      "answer": "Memoization is an optimization technique that stores the results of expensive function calls and returns cached results when same inputs occur again.\n\nMemoization Characteristics:\n• Top-down dynamic programming approach\n• Uses recursion with caching\n• Lazy evaluation - computes only needed subproblems\n• Typically uses hash map or array for storage\n• Reduces time complexity at cost of space\n\nHow It Works:\n• Check if result exists in cache\n• If yes, return cached result\n• If no, compute result, store in cache, return\n\nWhen to Use:\n• Recursive functions with overlapping subproblems\n• Expensive computations called repeatedly\n• Pure functions (same input always gives same output)\n\nAdvantages:\n• Dramatically reduces time complexity\n• Easy to implement\n• Natural for recursive problems\n\nDisadvantages:\n• Increases space complexity\n• Overhead of cache lookups\n• Only works for deterministic functions",
      "explanation": "Memoization stores results of function calls in a cache to avoid redundant calculations, transforming exponential recursive algorithms into polynomial time solutions.",
      "difficulty": "Medium",
      "code": "class MemoizationExamples {\n    \n    // Fibonacci without memoization - O(2^n)\n    public int fibSlow(int n) {\n        if (n <= 1) return n;\n        return fibSlow(n - 1) + fibSlow(n - 2);\n        // Recalculates same values many times\n    }\n    \n    // Fibonacci with memoization - O(n)\n    public int fibMemo(int n) {\n        Map<Integer, Integer> memo = new HashMap<>();\n        return fibMemoHelper(n, memo);\n    }\n    \n    private int fibMemoHelper(int n, Map<Integer, Integer> memo) {\n        if (n <= 1) return n;\n        \n        // Check cache\n        if (memo.containsKey(n)) {\n            return memo.get(n);\n        }\n        \n        // Compute and store\n        int result = fibMemoHelper(n - 1, memo) + fibMemoHelper(n - 2, memo);\n        memo.put(n, result);\n        return result;\n    }\n    \n    // Using array for memoization\n    public int fibMemoArray(int n) {\n        int[] memo = new int[n + 1];\n        Arrays.fill(memo, -1);\n        return fibMemoArrayHelper(n, memo);\n    }\n    \n    private int fibMemoArrayHelper(int n, int[] memo) {\n        if (n <= 1) return n;\n        if (memo[n] != -1) return memo[n];\n        \n        memo[n] = fibMemoArrayHelper(n - 1, memo) + \n                  fibMemoArrayHelper(n - 2, memo);\n        return memo[n];\n    }\n    \n    // Climbing Stairs problem - O(n) with memoization\n    public int climbStairs(int n) {\n        Map<Integer, Integer> memo = new HashMap<>();\n        return climbStairsHelper(n, memo);\n    }\n    \n    private int climbStairsHelper(int n, Map<Integer, Integer> memo) {\n        if (n <= 2) return n;\n        if (memo.containsKey(n)) return memo.get(n);\n        \n        int result = climbStairsHelper(n - 1, memo) + \n                     climbStairsHelper(n - 2, memo);\n        memo.put(n, result);\n        return result;\n    }\n    \n    // Grid Traveler - find paths in m×n grid\n    public int gridTraveler(int m, int n) {\n        Map<String, Integer> memo = new HashMap<>();\n        return gridTravelerHelper(m, n, memo);\n    }\n    \n    private int gridTravelerHelper(int m, int n, Map<String, Integer> memo) {\n        if (m == 0 || n == 0) return 0;\n        if (m == 1 && n == 1) return 1;\n        \n        String key = m + \",\" + n;\n        if (memo.containsKey(key)) return memo.get(key);\n        \n        int result = gridTravelerHelper(m - 1, n, memo) + \n                     gridTravelerHelper(m, n - 1, memo);\n        memo.put(key, result);\n        // Optimization: symmetric paths\n        memo.put(n + \",\" + m, result);\n        return result;\n    }\n    \n    // Longest Common Subsequence with memoization\n    public int lcs(String s1, String s2) {\n        int[][] memo = new int[s1.length()][s2.length()];\n        for (int[] row : memo) Arrays.fill(row, -1);\n        return lcsHelper(s1, s2, 0, 0, memo);\n    }\n    \n    private int lcsHelper(String s1, String s2, int i, int j, int[][] memo) {\n        if (i == s1.length() || j == s2.length()) return 0;\n        if (memo[i][j] != -1) return memo[i][j];\n        \n        if (s1.charAt(i) == s2.charAt(j)) {\n            memo[i][j] = 1 + lcsHelper(s1, s2, i + 1, j + 1, memo);\n        } else {\n            memo[i][j] = Math.max(\n                lcsHelper(s1, s2, i + 1, j, memo),\n                lcsHelper(s1, s2, i, j + 1, memo)\n            );\n        }\n        return memo[i][j];\n    }\n    \n    // Word Break problem with memoization\n    public boolean wordBreak(String s, List<String> wordDict) {\n        Set<String> dict = new HashSet<>(wordDict);\n        Map<String, Boolean> memo = new HashMap<>();\n        return wordBreakHelper(s, dict, memo);\n    }\n    \n    private boolean wordBreakHelper(String s, Set<String> dict, \n                                    Map<String, Boolean> memo) {\n        if (s.isEmpty()) return true;\n        if (memo.containsKey(s)) return memo.get(s);\n        \n        for (int i = 1; i <= s.length(); i++) {\n            String prefix = s.substring(0, i);\n            if (dict.contains(prefix) && \n                wordBreakHelper(s.substring(i), dict, memo)) {\n                memo.put(s, true);\n                return true;\n            }\n        }\n        \n        memo.put(s, false);\n        return false;\n    }\n    \n    // Minimum Cost Path with memoization\n    public int minPathSum(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        Integer[][] memo = new Integer[m][n];\n        return minPathSumHelper(grid, 0, 0, memo);\n    }\n    \n    private int minPathSumHelper(int[][] grid, int i, int j, Integer[][] memo) {\n        if (i == grid.length - 1 && j == grid[0].length - 1) {\n            return grid[i][j];\n        }\n        if (i >= grid.length || j >= grid[0].length) {\n            return Integer.MAX_VALUE;\n        }\n        if (memo[i][j] != null) return memo[i][j];\n        \n        int down = minPathSumHelper(grid, i + 1, j, memo);\n        int right = minPathSumHelper(grid, i, j + 1, memo);\n        \n        memo[i][j] = grid[i][j] + Math.min(down, right);\n        return memo[i][j];\n    }\n}"
    },
    {
      "id": 32,
      "question": "What are the different ways to find the kth largest element in an array?",
      "answer": "Finding the kth largest element is a common interview problem with multiple solution approaches, each with different time and space complexities.\n\nApproach 1 - Sorting:\n• Sort array and return arr[n-k]\n• Time: O(n log n), Space: O(1) or O(n)\n• Simple but not optimal\n\nApproach 2 - Min Heap:\n• Maintain heap of size k\n• Time: O(n log k), Space: O(k)\n• Efficient for small k\n\nApproach 3 - Max Heap:\n• Build max heap, extract k times\n• Time: O(n + k log n), Space: O(n)\n• Good when k is small\n\nApproach 4 - Quickselect:\n• Modified quicksort partitioning\n• Average: O(n), Worst: O(n²), Space: O(1)\n• Most efficient on average\n\nApproach 5 - Counting/Bucket Sort:\n• For limited range of values\n• Time: O(n + range), Space: O(range)",
      "explanation": "The kth largest element can be found using sorting O(n log n), min-heap O(n log k), or quickselect O(n) average, with quickselect being most efficient.",
      "difficulty": "Medium",
      "code": "import java.util.*;\n\nclass KthLargestElement {\n    \n    // Approach 1: Sorting - O(n log n)\n    public int findKthLargestSort(int[] nums, int k) {\n        Arrays.sort(nums);\n        return nums[nums.length - k];\n    }\n    \n    // Approach 2: Min Heap - O(n log k)\n    public int findKthLargestMinHeap(int[] nums, int k) {\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n        \n        for (int num : nums) {\n            minHeap.offer(num);\n            if (minHeap.size() > k) {\n                minHeap.poll(); // Remove smallest\n            }\n        }\n        \n        return minHeap.peek();\n    }\n    \n    // Approach 3: Max Heap - O(n + k log n)\n    public int findKthLargestMaxHeap(int[] nums, int k) {\n        PriorityQueue<Integer> maxHeap = \n            new PriorityQueue<>(Collections.reverseOrder());\n        \n        for (int num : nums) {\n            maxHeap.offer(num);\n        }\n        \n        // Extract k-1 times\n        for (int i = 0; i < k - 1; i++) {\n            maxHeap.poll();\n        }\n        \n        return maxHeap.peek();\n    }\n    \n    // Approach 4: Quickselect - O(n) average, O(n²) worst\n    public int findKthLargestQuickselect(int[] nums, int k) {\n        return quickselect(nums, 0, nums.length - 1, nums.length - k);\n    }\n    \n    private int quickselect(int[] nums, int left, int right, int k) {\n        if (left == right) return nums[left];\n        \n        // Random pivot for better average case\n        int pivotIndex = left + new Random().nextInt(right - left + 1);\n        pivotIndex = partition(nums, left, right, pivotIndex);\n        \n        if (k == pivotIndex) {\n            return nums[k];\n        } else if (k < pivotIndex) {\n            return quickselect(nums, left, pivotIndex - 1, k);\n        } else {\n            return quickselect(nums, pivotIndex + 1, right, k);\n        }\n    }\n    \n    private int partition(int[] nums, int left, int right, int pivotIndex) {\n        int pivot = nums[pivotIndex];\n        // Move pivot to end\n        swap(nums, pivotIndex, right);\n        \n        int storeIndex = left;\n        for (int i = left; i < right; i++) {\n            if (nums[i] < pivot) {\n                swap(nums, i, storeIndex);\n                storeIndex++;\n            }\n        }\n        \n        // Move pivot to final position\n        swap(nums, storeIndex, right);\n        return storeIndex;\n    }\n    \n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n    \n    // Find top K frequent elements\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> count = new HashMap<>();\n        for (int num : nums) {\n            count.put(num, count.getOrDefault(num, 0) + 1);\n        }\n        \n        // Min heap based on frequency\n        PriorityQueue<Integer> heap = new PriorityQueue<>(\n            (a, b) -> count.get(a) - count.get(b)\n        );\n        \n        for (int num : count.keySet()) {\n            heap.offer(num);\n            if (heap.size() > k) {\n                heap.poll();\n            }\n        }\n        \n        int[] result = new int[k];\n        for (int i = 0; i < k; i++) {\n            result[i] = heap.poll();\n        }\n        return result;\n    }\n    \n    // Find kth smallest element\n    public int findKthSmallest(int[] nums, int k) {\n        return quickselect(nums, 0, nums.length - 1, k - 1);\n    }\n    \n    // Find median using heaps\n    class MedianFinder {\n        PriorityQueue<Integer> maxHeap; // Lower half\n        PriorityQueue<Integer> minHeap; // Upper half\n        \n        public MedianFinder() {\n            maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n            minHeap = new PriorityQueue<>();\n        }\n        \n        public void addNum(int num) {\n            if (maxHeap.isEmpty() || num <= maxHeap.peek()) {\n                maxHeap.offer(num);\n            } else {\n                minHeap.offer(num);\n            }\n            \n            // Balance heaps\n            if (maxHeap.size() > minHeap.size() + 1) {\n                minHeap.offer(maxHeap.poll());\n            } else if (minHeap.size() > maxHeap.size()) {\n                maxHeap.offer(minHeap.poll());\n            }\n        }\n        \n        public double findMedian() {\n            if (maxHeap.size() == minHeap.size()) {\n                return (maxHeap.peek() + minHeap.peek()) / 2.0;\n            }\n            return maxHeap.peek();\n        }\n    }\n}"
    },
    {
      "id": 33,
      "question": "What is a disjoint set (Union-Find) data structure?",
      "answer": "A Disjoint Set (Union-Find) is a data structure that keeps track of elements partitioned into non-overlapping sets, supporting efficient union and find operations.\n\nCore Operations:\n• Find - Determine which set an element belongs to - O(α(n)) with path compression\n• Union - Merge two sets into one - O(α(n)) with union by rank\n• Connected - Check if two elements are in same set - O(α(n))\n\nNote: α(n) is inverse Ackermann function, practically constant\n\nOptimizations:\n• Path Compression - Flatten tree during find\n• Union by Rank - Attach smaller tree under larger\n• Union by Size - Similar to rank\n\nApplicationations:\n• Kruskal's MST algorithm\n• Detecting cycles in undirected graphs\n• Network connectivity\n• Image processing (connected components)\n• Social network groups\n• Percolation problems\n\nTime Complexity:\n• Without optimizations - O(n) per operation\n• With optimizations - O(α(n)) ≈ O(1) amortized",
      "explanation": "Union-Find efficiently tracks disjoint sets with near-constant time operations using path compression and union by rank, commonly used for connectivity and cycle detection.",
      "difficulty": "Hard",
      "code": "class UnionFind {\n    private int[] parent;\n    private int[] rank;\n    private int count; // Number of disjoint sets\n    \n    // Initialize n disjoint sets\n    public UnionFind(int n) {\n        parent = new int[n];\n        rank = new int[n];\n        count = n;\n        \n        for (int i = 0; i < n; i++) {\n            parent[i] = i; // Each element is its own parent\n            rank[i] = 0;\n        }\n    }\n    \n    // Find with path compression - O(α(n))\n    public int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]); // Path compression\n        }\n        return parent[x];\n    }\n    \n    // Union by rank - O(α(n))\n    public boolean union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        \n        if (rootX == rootY) {\n            return false; // Already in same set\n        }\n        \n        // Union by rank - attach smaller tree under larger\n        if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n        \n        count--;\n        return true;\n    }\n    \n    // Check if connected\n    public boolean connected(int x, int y) {\n        return find(x) == find(y);\n    }\n    \n    // Get number of disjoint sets\n    public int getCount() {\n        return count;\n    }\n}\n\n// Application: Detect cycle in undirected graph\nclass GraphCycleDetection {\n    class Edge {\n        int src, dest;\n        Edge(int src, int dest) {\n            this.src = src;\n            this.dest = dest;\n        }\n    }\n    \n    public boolean hasCycle(int vertices, List<Edge> edges) {\n        UnionFind uf = new UnionFind(vertices);\n        \n        for (Edge edge : edges) {\n            int x = uf.find(edge.src);\n            int y = uf.find(edge.dest);\n            \n            if (x == y) {\n                return true; // Cycle detected\n            }\n            \n            uf.union(x, y);\n        }\n        return false;\n    }\n}\n\n// Application: Number of connected components\nclass ConnectedComponents {\n    public int countComponents(int n, int[][] edges) {\n        UnionFind uf = new UnionFind(n);\n        \n        for (int[] edge : edges) {\n            uf.union(edge[0], edge[1]);\n        }\n        \n        return uf.getCount();\n    }\n}\n\n// Application: Kruskal's MST\nclass KruskalMST {\n    class Edge implements Comparable<Edge> {\n        int src, dest, weight;\n        \n        public int compareTo(Edge other) {\n            return Integer.compare(this.weight, other.weight);\n        }\n    }\n    \n    public List<Edge> kruskalMST(int vertices, List<Edge> edges) {\n        Collections.sort(edges);\n        UnionFind uf = new UnionFind(vertices);\n        List<Edge> mst = new ArrayList<>();\n        \n        for (Edge edge : edges) {\n            if (uf.union(edge.src, edge.dest)) {\n                mst.add(edge);\n                if (mst.size() == vertices - 1) {\n                    break;\n                }\n            }\n        }\n        return mst;\n    }\n}\n\n// Application: Accounts Merge\nclass AccountsMerge {\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\n        UnionFind uf = new UnionFind(accounts.size());\n        Map<String, Integer> emailToId = new HashMap<>();\n        \n        // Union accounts with common emails\n        for (int i = 0; i < accounts.size(); i++) {\n            for (int j = 1; j < accounts.get(i).size(); j++) {\n                String email = accounts.get(i).get(j);\n                if (emailToId.containsKey(email)) {\n                    uf.union(i, emailToId.get(email));\n                } else {\n                    emailToId.put(email, i);\n                }\n            }\n        }\n        \n        // Group emails by root\n        Map<Integer, Set<String>> rootToEmails = new HashMap<>();\n        for (String email : emailToId.keySet()) {\n            int root = uf.find(emailToId.get(email));\n            rootToEmails.computeIfAbsent(root, k -> new TreeSet<>()).add(email);\n        }\n        \n        // Build result\n        List<List<String>> result = new ArrayList<>();\n        for (int root : rootToEmails.keySet()) {\n            List<String> account = new ArrayList<>();\n            account.add(accounts.get(root).get(0)); // Name\n            account.addAll(rootToEmails.get(root));\n            result.add(account);\n        }\n        return result;\n    }\n}"
    },
    {
      "id": 34,
      "question": "What is the knapsack problem and what are its variants?",
      "answer": "The knapsack problem is a classic optimization problem where you select items with given weights and values to maximize total value without exceeding weight capacity.\n\nKnapsack Variants:\n• 0/1 Knapsack - Each item can be taken once or not at all\n• Fractional Knapsack - Can take fractions of items (greedy solution)\n• Unbounded Knapsack - Unlimited quantity of each item\n• Bounded Knapsack - Limited quantity of each item\n• Multiple Knapsack - Multiple knapsacks with different capacities\n\n0/1 Knapsack Solutions:\n• Dynamic Programming - O(n × W) time, O(n × W) space\n• Space optimized DP - O(n × W) time, O(W) space\n• Backtracking - Exponential but can prune\n\nFractional Knapsack:\n• Greedy by value/weight ratio - O(n log n)\n• Always gives optimal solution\n\nUnbounded Knapsack:\n• DP similar to coin change - O(n × W)\n• Can use same item multiple times",
      "explanation": "The knapsack problem maximizes value within weight constraints, with 0/1 variant solved by DP in O(n×W) time and fractional variant by greedy approach in O(n log n).",
      "difficulty": "Hard",
      "code": "class KnapsackProblems {\n    \n    // 0/1 Knapsack - DP - O(n × W) time and space\n    public int knapsack01(int[] weights, int[] values, int capacity) {\n        int n = weights.length;\n        int[][] dp = new int[n + 1][capacity + 1];\n        \n        for (int i = 1; i <= n; i++) {\n            for (int w = 1; w <= capacity; w++) {\n                if (weights[i - 1] <= w) {\n                    // Max of: take item or don't take item\n                    dp[i][w] = Math.max(\n                        values[i - 1] + dp[i - 1][w - weights[i - 1]],\n                        dp[i - 1][w]\n                    );\n                } else {\n                    dp[i][w] = dp[i - 1][w];\n                }\n            }\n        }\n        return dp[n][capacity];\n    }\n    \n    // 0/1 Knapsack - Space optimized - O(n × W) time, O(W) space\n    public int knapsack01Optimized(int[] weights, int[] values, int capacity) {\n        int n = weights.length;\n        int[] dp = new int[capacity + 1];\n        \n        for (int i = 0; i < n; i++) {\n            // Traverse backwards to avoid using updated values\n            for (int w = capacity; w >= weights[i]; w--) {\n                dp[w] = Math.max(dp[w], values[i] + dp[w - weights[i]]);\n            }\n        }\n        return dp[capacity];\n    }\n    \n    // 0/1 Knapsack with items tracking\n    public List<Integer> knapsackWithItems(int[] weights, int[] values, int capacity) {\n        int n = weights.length;\n        int[][] dp = new int[n + 1][capacity + 1];\n        \n        // Fill DP table\n        for (int i = 1; i <= n; i++) {\n            for (int w = 1; w <= capacity; w++) {\n                if (weights[i - 1] <= w) {\n                    dp[i][w] = Math.max(\n                        values[i - 1] + dp[i - 1][w - weights[i - 1]],\n                        dp[i - 1][w]\n                    );\n                } else {\n                    dp[i][w] = dp[i - 1][w];\n                }\n            }\n        }\n        \n        // Backtrack to find items\n        List<Integer> items = new ArrayList<>();\n        int w = capacity;\n        for (int i = n; i > 0 && w > 0; i--) {\n            if (dp[i][w] != dp[i - 1][w]) {\n                items.add(i - 1);\n                w -= weights[i - 1];\n            }\n        }\n        Collections.reverse(items);\n        return items;\n    }\n    \n    // Fractional Knapsack - Greedy - O(n log n)\n    class Item {\n        int value, weight;\n        Item(int value, int weight) {\n            this.value = value;\n            this.weight = weight;\n        }\n    }\n    \n    public double fractionalKnapsack(Item[] items, int capacity) {\n        // Sort by value/weight ratio descending\n        Arrays.sort(items, (a, b) -> \n            Double.compare((double)b.value/b.weight, (double)a.value/a.weight)\n        );\n        \n        double totalValue = 0;\n        int currentWeight = 0;\n        \n        for (Item item : items) {\n            if (currentWeight + item.weight <= capacity) {\n                // Take whole item\n                currentWeight += item.weight;\n                totalValue += item.value;\n            } else {\n                // Take fraction of item\n                int remaining = capacity - currentWeight;\n                totalValue += item.value * ((double)remaining / item.weight);\n                break;\n            }\n        }\n        return totalValue;\n    }\n    \n    // Unbounded Knapsack - O(n × W)\n    public int unboundedKnapsack(int[] weights, int[] values, int capacity) {\n        int n = weights.length;\n        int[] dp = new int[capacity + 1];\n        \n        for (int w = 1; w <= capacity; w++) {\n            for (int i = 0; i < n; i++) {\n                if (weights[i] <= w) {\n                    dp[w] = Math.max(dp[w], \n                                    values[i] + dp[w - weights[i]]);\n                }\n            }\n        }\n        return dp[capacity];\n    }\n    \n    // Subset Sum Problem (special case of 0/1 knapsack)\n    public boolean canPartition(int[] nums) {\n        int sum = 0;\n        for (int num : nums) sum += num;\n        \n        if (sum % 2 != 0) return false;\n        int target = sum / 2;\n        \n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n        \n        for (int num : nums) {\n            for (int j = target; j >= num; j--) {\n                dp[j] = dp[j] || dp[j - num];\n            }\n        }\n        return dp[target];\n    }\n    \n    // Target Sum (count ways to reach target)\n    public int findTargetSumWays(int[] nums, int target) {\n        int sum = 0;\n        for (int num : nums) sum += num;\n        \n        if (Math.abs(target) > sum || (sum + target) % 2 != 0) {\n            return 0;\n        }\n        \n        int subsetSum = (sum + target) / 2;\n        int[] dp = new int[subsetSum + 1];\n        dp[0] = 1;\n        \n        for (int num : nums) {\n            for (int j = subsetSum; j >= num; j--) {\n                dp[j] += dp[j - num];\n            }\n        }\n        return dp[subsetSum];\n    }\n}"
    },
    {
      "id": 35,
      "question": "What are common string manipulation algorithms and techniques?",
      "answer": "String algorithms are essential for text processing, pattern matching, and data manipulation in interviews and real-world applications.\n\nCommon String Operations:\n• Reversal - O(n) time\n• Palindrome checking - O(n) time\n• Anagram detection - O(n) time\n• Pattern matching - various complexities\n• Substring search - O(n × m) naive, O(n) KMP\n\nPattern Matching Algorithms:\n• Naive - O(n × m) time\n• KMP (Knuth-Morris-Pratt) - O(n + m) time\n• Rabin-Karp - O(n + m) average, uses hashing\n• Boyer-Moore - O(n/m) best case\n\nCommon Techniques:\n• Two pointers for palindromes\n• Sliding window for substrings\n• Hash maps for anagrams\n• Character arrays for manipulation\n• StringBuilder for concatenation\n\nString Problems:\n• Longest palindromic substring\n• Longest common substring\n• String compression\n• Word break\n• Regular expression matching",
      "explanation": "String algorithms include reversal, palindrome checking, and pattern matching using techniques like two-pointers, sliding window, and advanced algorithms like KMP for efficient searching.",
      "difficulty": "Medium",
      "code": "class StringAlgorithms {\n    \n    // Reverse string - O(n)\n    public String reverse(String s) {\n        char[] arr = s.toCharArray();\n        int left = 0, right = arr.length - 1;\n        \n        while (left < right) {\n            char temp = arr[left];\n            arr[left] = arr[right];\n            arr[right] = temp;\n            left++;\n            right--;\n        }\n        return new String(arr);\n    }\n    \n    // Check palindrome - O(n)\n    public boolean isPalindrome(String s) {\n        int left = 0, right = s.length() - 1;\n        \n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n    \n    // Valid palindrome (ignore non-alphanumeric) - O(n)\n    public boolean isPalindromeAlphanumeric(String s) {\n        int left = 0, right = s.length() - 1;\n        \n        while (left < right) {\n            while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {\n                left++;\n            }\n            while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {\n                right--;\n            }\n            \n            if (Character.toLowerCase(s.charAt(left)) != \n                Character.toLowerCase(s.charAt(right))) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n    \n    // Check anagrams - O(n)\n    public boolean isAnagram(String s1, String s2) {\n        if (s1.length() != s2.length()) return false;\n        \n        int[] count = new int[26];\n        for (int i = 0; i < s1.length(); i++) {\n            count[s1.charAt(i) - 'a']++;\n            count[s2.charAt(i) - 'a']--;\n        }\n        \n        for (int c : count) {\n            if (c != 0) return false;\n        }\n        return true;\n    }\n    \n    // Longest palindromic substring - O(n²)\n    public String longestPalindrome(String s) {\n        if (s == null || s.length() == 0) return \"\";\n        \n        int start = 0, maxLen = 0;\n        \n        for (int i = 0; i < s.length(); i++) {\n            // Odd length palindromes\n            int len1 = expandAroundCenter(s, i, i);\n            // Even length palindromes\n            int len2 = expandAroundCenter(s, i, i + 1);\n            \n            int len = Math.max(len1, len2);\n            if (len > maxLen) {\n                maxLen = len;\n                start = i - (len - 1) / 2;\n            }\n        }\n        return s.substring(start, start + maxLen);\n    }\n    \n    private int expandAroundCenter(String s, int left, int right) {\n        while (left >= 0 && right < s.length() && \n               s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n        return right - left - 1;\n    }\n    \n    // KMP Pattern Matching - O(n + m)\n    public int kmpSearch(String text, String pattern) {\n        if (pattern.isEmpty()) return 0;\n        \n        int[] lps = computeLPS(pattern);\n        int i = 0, j = 0;\n        \n        while (i < text.length()) {\n            if (text.charAt(i) == pattern.charAt(j)) {\n                i++;\n                j++;\n            }\n            \n            if (j == pattern.length()) {\n                return i - j; // Pattern found\n            } else if (i < text.length() && text.charAt(i) != pattern.charAt(j)) {\n                if (j != 0) {\n                    j = lps[j - 1];\n                } else {\n                    i++;\n                }\n            }\n        }\n        return -1;\n    }\n    \n    private int[] computeLPS(String pattern) {\n        int[] lps = new int[pattern.length()];\n        int len = 0, i = 1;\n        \n        while (i < pattern.length()) {\n            if (pattern.charAt(i) == pattern.charAt(len)) {\n                len++;\n                lps[i] = len;\n                i++;\n            } else {\n                if (len != 0) {\n                    len = lps[len - 1];\n                } else {\n                    lps[i] = 0;\n                    i++;\n                }\n            }\n        }\n        return lps;\n    }\n    \n    // Group anagrams - O(n × k log k) where k is max string length\n    public List<List<String>> groupAnagrams(String[] strs) {\n        Map<String, List<String>> map = new HashMap<>();\n        \n        for (String str : strs) {\n            char[] arr = str.toCharArray();\n            Arrays.sort(arr);\n            String key = new String(arr);\n            \n            map.computeIfAbsent(key, k -> new ArrayList<>()).add(str);\n        }\n        \n        return new ArrayList<>(map.values());\n    }\n    \n    // String compression - O(n)\n    public String compress(String s) {\n        StringBuilder sb = new StringBuilder();\n        int count = 1;\n        \n        for (int i = 1; i <= s.length(); i++) {\n            if (i < s.length() && s.charAt(i) == s.charAt(i - 1)) {\n                count++;\n            } else {\n                sb.append(s.charAt(i - 1));\n                if (count > 1) sb.append(count);\n                count = 1;\n            }\n        }\n        \n        String compressed = sb.toString();\n        return compressed.length() < s.length() ? compressed : s;\n    }\n}"
    },
    {
      "id": 36,
      "question": "What is the Bellman-Ford algorithm and how does it differ from Dijkstra's?",
      "answer": "Bellman-Ford is a single-source shortest path algorithm that can handle negative edge weights, unlike Dijkstra's algorithm.\n\nBellman-Ford Characteristics:\n• Works with negative edge weights\n• Detects negative cycles\n• Time Complexity - O(V × E)\n• Space Complexity - O(V)\n• Uses dynamic programming approach\n• Relaxes all edges V-1 times\n\nDijkstra vs Bellman-Ford:\n• Dijkstra: O((V + E) log V), no negative weights\n• Bellman-Ford: O(V × E), handles negative weights\n• Dijkstra uses greedy approach\n• Bellman-Ford uses DP approach\n• Dijkstra faster for non-negative weights\n\nWhen to Use Bellman-Ford:\n• Graph has negative edge weights\n• Need to detect negative cycles\n• Distributed systems (distance vector routing)\n\nNegative Cycle Detection:\n• If distance can still be reduced after V-1 iterations, negative cycle exists",
      "explanation": "Bellman-Ford finds shortest paths in O(V×E) time and handles negative weights by relaxing all edges V-1 times, unlike Dijkstra's faster but non-negative-only approach.",
      "difficulty": "Hard",
      "code": "class BellmanFord {\n    class Edge {\n        int src, dest, weight;\n        Edge(int src, int dest, int weight) {\n            this.src = src;\n            this.dest = dest;\n            this.weight = weight;\n        }\n    }\n    \n    // Bellman-Ford Algorithm - O(V × E)\n    public int[] bellmanFord(int vertices, List<Edge> edges, int source) {\n        int[] dist = new int[vertices];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[source] = 0;\n        \n        // Relax all edges V-1 times\n        for (int i = 0; i < vertices - 1; i++) {\n            for (Edge edge : edges) {\n                if (dist[edge.src] != Integer.MAX_VALUE && \n                    dist[edge.src] + edge.weight < dist[edge.dest]) {\n                    dist[edge.dest] = dist[edge.src] + edge.weight;\n                }\n            }\n        }\n        \n        // Check for negative cycles\n        for (Edge edge : edges) {\n            if (dist[edge.src] != Integer.MAX_VALUE && \n                dist[edge.src] + edge.weight < dist[edge.dest]) {\n                System.out.println(\"Graph contains negative cycle\");\n                return null;\n            }\n        }\n        \n        return dist;\n    }\n    \n    // Detect negative cycle\n    public boolean hasNegativeCycle(int vertices, List<Edge> edges) {\n        int[] dist = new int[vertices];\n        Arrays.fill(dist, 0); // Start from all vertices\n        \n        for (int i = 0; i < vertices - 1; i++) {\n            for (Edge edge : edges) {\n                if (dist[edge.src] + edge.weight < dist[edge.dest]) {\n                    dist[edge.dest] = dist[edge.src] + edge.weight;\n                }\n            }\n        }\n        \n        for (Edge edge : edges) {\n            if (dist[edge.src] + edge.weight < dist[edge.dest]) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    // Bellman-Ford with path reconstruction\n    public List<Integer> bellmanFordPath(int vertices, List<Edge> edges, \n                                         int source, int dest) {\n        int[] dist = new int[vertices];\n        int[] parent = new int[vertices];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        Arrays.fill(parent, -1);\n        dist[source] = 0;\n        \n        for (int i = 0; i < vertices - 1; i++) {\n            for (Edge edge : edges) {\n                if (dist[edge.src] != Integer.MAX_VALUE && \n                    dist[edge.src] + edge.weight < dist[edge.dest]) {\n                    dist[edge.dest] = dist[edge.src] + edge.weight;\n                    parent[edge.dest] = edge.src;\n                }\n            }\n        }\n        \n        // Reconstruct path\n        List<Integer> path = new ArrayList<>();\n        if (dist[dest] == Integer.MAX_VALUE) return path;\n        \n        for (int v = dest; v != -1; v = parent[v]) {\n            path.add(v);\n        }\n        Collections.reverse(path);\n        return path;\n    }\n}"
    },
    {
      "id": 37,
      "question": "What is bit manipulation and what are common bit operations?",
      "answer": "Bit manipulation involves operating on individual bits of numbers, often used for optimization and solving specific algorithmic problems.\n\nBasic Bit Operations:\n• AND (&) - Both bits 1 returns 1\n• OR (|) - Either bit 1 returns 1\n• XOR (^) - Different bits return 1\n• NOT (~) - Inverts all bits\n• Left Shift (<<) - Multiply by 2^n\n• Right Shift (>>) - Divide by 2^n\n\nCommon Techniques:\n• Check if bit is set: (n & (1 << i)) != 0\n• Set bit: n | (1 << i)\n• Clear bit: n & ~(1 << i)\n• Toggle bit: n ^ (1 << i)\n• Check power of 2: (n & (n-1)) == 0\n• Count set bits: Brian Kernighan's algorithm\n\nApplications:\n• Space optimization (flags, permissions)\n• Fast arithmetic operations\n• Cryptography\n• Graphics programming\n• Network protocols\n\nCommon Problems:\n• Single number\n• Missing number\n• Bit counting\n• Power of two check\n• Subset generation",
      "explanation": "Bit manipulation operates on individual bits using AND, OR, XOR, and shifts for efficient operations, commonly used for flags, optimization, and solving array problems.",
      "difficulty": "Medium",
      "code": "class BitManipulation {\n    \n    // Check if kth bit is set\n    public boolean isKthBitSet(int n, int k) {\n        return (n & (1 << k)) != 0;\n    }\n    \n    // Set kth bit\n    public int setKthBit(int n, int k) {\n        return n | (1 << k);\n    }\n    \n    // Clear kth bit\n    public int clearKthBit(int n, int k) {\n        return n & ~(1 << k);\n    }\n    \n    // Toggle kth bit\n    public int toggleKthBit(int n, int k) {\n        return n ^ (1 << k);\n    }\n    \n    // Check if power of 2\n    public boolean isPowerOfTwo(int n) {\n        return n > 0 && (n & (n - 1)) == 0;\n    }\n    \n    // Count set bits (Brian Kernighan's algorithm)\n    public int countSetBits(int n) {\n        int count = 0;\n        while (n > 0) {\n            n &= (n - 1); // Removes rightmost set bit\n            count++;\n        }\n        return count;\n    }\n    \n    // Alternative: using built-in method\n    public int countSetBitsBuiltin(int n) {\n        return Integer.bitCount(n);\n    }\n    \n    // Single number (XOR approach) - O(n) time, O(1) space\n    public int singleNumber(int[] nums) {\n        int result = 0;\n        for (int num : nums) {\n            result ^= num; // XOR cancels pairs\n        }\n        return result;\n    }\n    \n    // Missing number in 0 to n - O(n) time, O(1) space\n    public int missingNumber(int[] nums) {\n        int n = nums.length;\n        int xor = 0;\n        \n        // XOR all numbers 0 to n\n        for (int i = 0; i <= n; i++) {\n            xor ^= i;\n        }\n        \n        // XOR all numbers in array\n        for (int num : nums) {\n            xor ^= num;\n        }\n        \n        return xor; // Remaining is missing number\n    }\n    \n    // Two numbers appearing once, others twice\n    public int[] singleNumber3(int[] nums) {\n        int xor = 0;\n        for (int num : nums) {\n            xor ^= num;\n        }\n        \n        // Find rightmost set bit\n        int rightmostBit = xor & (-xor);\n        \n        int[] result = new int[2];\n        for (int num : nums) {\n            if ((num & rightmostBit) == 0) {\n                result[0] ^= num;\n            } else {\n                result[1] ^= num;\n            }\n        }\n        return result;\n    }\n    \n    // Generate all subsets using bits\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        int n = nums.length;\n        int totalSubsets = 1 << n; // 2^n\n        \n        for (int i = 0; i < totalSubsets; i++) {\n            List<Integer> subset = new ArrayList<>();\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) != 0) {\n                    subset.add(nums[j]);\n                }\n            }\n            result.add(subset);\n        }\n        return result;\n    }\n    \n    // Reverse bits\n    public int reverseBits(int n) {\n        int result = 0;\n        for (int i = 0; i < 32; i++) {\n            result <<= 1;\n            result |= (n & 1);\n            n >>= 1;\n        }\n        return result;\n    }\n    \n    // Hamming distance\n    public int hammingDistance(int x, int y) {\n        int xor = x ^ y;\n        return countSetBits(xor);\n    }\n    \n    // Maximum XOR of two numbers in array\n    public int findMaximumXOR(int[] nums) {\n        int max = 0;\n        int mask = 0;\n        \n        for (int i = 31; i >= 0; i--) {\n            mask |= (1 << i);\n            Set<Integer> prefixes = new HashSet<>();\n            \n            for (int num : nums) {\n                prefixes.add(num & mask);\n            }\n            \n            int candidate = max | (1 << i);\n            for (int prefix : prefixes) {\n                if (prefixes.contains(candidate ^ prefix)) {\n                    max = candidate;\n                    break;\n                }\n            }\n        }\n        return max;\n    }\n    \n    // Count bits for all numbers 0 to n\n    public int[] countBits(int n) {\n        int[] result = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            result[i] = result[i >> 1] + (i & 1);\n        }\n        return result;\n    }\n}"
    },
    {
      "id": 38,
      "question": "What is matrix manipulation and what are common matrix algorithms?",
      "answer": "Matrix manipulation involves operations on 2D arrays, common in graph problems, dynamic programming, and computational problems.\n\nCommon Matrix Operations:\n• Traversal - row-wise, column-wise, diagonal\n• Rotation - 90°, 180°, 270°\n• Transpose - swap rows and columns\n• Spiral traversal - clockwise/counterclockwise\n• Search in sorted matrix\n• Matrix multiplication - O(n³)\n\nTraversal Patterns:\n• DFS/BFS for connected regions\n• Four directions: up, down, left, right\n• Eight directions: including diagonals\n• Boundary traversal\n\nCommon Problems:\n• Island counting\n• Shortest path in grid\n• Word search\n• Set matrix zeroes\n• Spiral matrix\n• Rotate image\n• Valid Sudoku\n\nOptimization Techniques:\n• In-place modifications\n• Mark visited without extra space\n• Direction arrays for cleaner code",
      "explanation": "Matrix algorithms involve traversal, rotation, and search operations on 2D arrays, commonly using DFS/BFS for connectivity problems and in-place techniques for space optimization.",
      "difficulty": "Medium",
      "code": "class MatrixAlgorithms {\n    \n    // Rotate matrix 90 degrees clockwise - O(n²)\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        \n        // Transpose\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n        \n        // Reverse each row\n        for (int i = 0; i < n; i++) {\n            int left = 0, right = n - 1;\n            while (left < right) {\n                int temp = matrix[i][left];\n                matrix[i][left] = matrix[i][right];\n                matrix[i][right] = temp;\n                left++;\n                right--;\n            }\n        }\n    }\n    \n    // Spiral matrix traversal - O(m × n)\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> result = new ArrayList<>();\n        if (matrix.length == 0) return result;\n        \n        int top = 0, bottom = matrix.length - 1;\n        int left = 0, right = matrix[0].length - 1;\n        \n        while (top <= bottom && left <= right) {\n            // Traverse right\n            for (int i = left; i <= right; i++) {\n                result.add(matrix[top][i]);\n            }\n            top++;\n            \n            // Traverse down\n            for (int i = top; i <= bottom; i++) {\n                result.add(matrix[i][right]);\n            }\n            right--;\n            \n            // Traverse left\n            if (top <= bottom) {\n                for (int i = right; i >= left; i--) {\n                    result.add(matrix[bottom][i]);\n                }\n                bottom--;\n            }\n            \n            // Traverse up\n            if (left <= right) {\n                for (int i = bottom; i >= top; i--) {\n                    result.add(matrix[i][left]);\n                }\n                left++;\n            }\n        }\n        return result;\n    }\n    \n    // Set matrix zeroes - O(m × n) time, O(1) space\n    public void setZeroes(int[][] matrix) {\n        boolean firstRowZero = false;\n        boolean firstColZero = false;\n        \n        // Check if first row/col should be zero\n        for (int j = 0; j < matrix[0].length; j++) {\n            if (matrix[0][j] == 0) firstRowZero = true;\n        }\n        for (int i = 0; i < matrix.length; i++) {\n            if (matrix[i][0] == 0) firstColZero = true;\n        }\n        \n        // Use first row/col as markers\n        for (int i = 1; i < matrix.length; i++) {\n            for (int j = 1; j < matrix[0].length; j++) {\n                if (matrix[i][j] == 0) {\n                    matrix[i][0] = 0;\n                    matrix[0][j] = 0;\n                }\n            }\n        }\n        \n        // Set zeroes based on markers\n        for (int i = 1; i < matrix.length; i++) {\n            for (int j = 1; j < matrix[0].length; j++) {\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n        \n        // Set first row/col\n        if (firstRowZero) {\n            for (int j = 0; j < matrix[0].length; j++) {\n                matrix[0][j] = 0;\n            }\n        }\n        if (firstColZero) {\n            for (int i = 0; i < matrix.length; i++) {\n                matrix[i][0] = 0;\n            }\n        }\n    }\n    \n    // Search in 2D sorted matrix - O(m + n)\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if (matrix.length == 0) return false;\n        \n        int row = 0;\n        int col = matrix[0].length - 1;\n        \n        while (row < matrix.length && col >= 0) {\n            if (matrix[row][col] == target) {\n                return true;\n            } else if (matrix[row][col] > target) {\n                col--;\n            } else {\n                row++;\n            }\n        }\n        return false;\n    }\n    \n    // Count islands - O(m × n)\n    public int numIslands(char[][] grid) {\n        if (grid.length == 0) return 0;\n        \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '1') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n    \n    private void dfs(char[][] grid, int i, int j) {\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || \n            grid[i][j] == '0') {\n            return;\n        }\n        \n        grid[i][j] = '0'; // Mark as visited\n        dfs(grid, i + 1, j);\n        dfs(grid, i - 1, j);\n        dfs(grid, i, j + 1);\n        dfs(grid, i, j - 1);\n    }\n    \n    // Word search - O(m × n × 4^L) where L is word length\n    public boolean exist(char[][] board, String word) {\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                if (dfsWord(board, word, i, j, 0)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    \n    private boolean dfsWord(char[][] board, String word, int i, int j, int index) {\n        if (index == word.length()) return true;\n        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || \n            board[i][j] != word.charAt(index)) {\n            return false;\n        }\n        \n        char temp = board[i][j];\n        board[i][j] = '#'; // Mark as visited\n        \n        boolean found = dfsWord(board, word, i + 1, j, index + 1) ||\n                       dfsWord(board, word, i - 1, j, index + 1) ||\n                       dfsWord(board, word, i, j + 1, index + 1) ||\n                       dfsWord(board, word, i, j - 1, index + 1);\n        \n        board[i][j] = temp; // Backtrack\n        return found;\n    }\n}"
    },
    {
      "id": 39,
      "question": "What are segment trees and when are they used?",
      "answer": "A segment tree is a binary tree data structure used for storing intervals or segments, allowing efficient range queries and updates.\n\nSegment Tree Characteristics:\n• Complete binary tree structure\n• Each node represents an interval/segment\n• Leaf nodes represent individual elements\n• Internal nodes represent union of child segments\n• Height is O(log n)\n• Space complexity - O(4n) = O(n)\n\nOperations:\n• Build tree - O(n)\n• Range query (sum, min, max) - O(log n)\n• Point update - O(log n)\n• Range update - O(log n) with lazy propagation\n\nApplications:\n• Range sum queries\n• Range minimum/maximum queries\n• Finding GCD, LCM over range\n• Counting elements in range\n• Computational geometry\n\nSegment Tree vs:\n• Array - O(1) access, O(n) range query\n• Prefix sum - O(n) build, O(1) query, O(n) update\n• Segment Tree - O(n) build, O(log n) query and update",
      "explanation": "Segment trees enable efficient O(log n) range queries and updates on arrays by organizing data in a tree structure where nodes represent intervals.",
      "difficulty": "Hard",
      "code": "class SegmentTree {\n    private int[] tree;\n    private int n;\n    \n    public SegmentTree(int[] arr) {\n        n = arr.length;\n        tree = new int[4 * n];\n        build(arr, 0, 0, n - 1);\n    }\n    \n    // Build segment tree - O(n)\n    private void build(int[] arr, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = arr[start];\n            return;\n        }\n        \n        int mid = (start + end) / 2;\n        int leftChild = 2 * node + 1;\n        int rightChild = 2 * node + 2;\n        \n        build(arr, leftChild, start, mid);\n        build(arr, rightChild, mid + 1, end);\n        \n        tree[node] = tree[leftChild] + tree[rightChild];\n    }\n    \n    // Range sum query - O(log n)\n    public int query(int left, int right) {\n        return query(0, 0, n - 1, left, right);\n    }\n    \n    private int query(int node, int start, int end, int left, int right) {\n        // No overlap\n        if (right < start || left > end) {\n            return 0;\n        }\n        \n        // Complete overlap\n        if (left <= start && end <= right) {\n            return tree[node];\n        }\n        \n        // Partial overlap\n        int mid = (start + end) / 2;\n        int leftSum = query(2 * node + 1, start, mid, left, right);\n        int rightSum = query(2 * node + 2, mid + 1, end, left, right);\n        return leftSum + rightSum;\n    }\n    \n    // Point update - O(log n)\n    public void update(int index, int value) {\n        update(0, 0, n - 1, index, value);\n    }\n    \n    private void update(int node, int start, int end, int index, int value) {\n        if (start == end) {\n            tree[node] = value;\n            return;\n        }\n        \n        int mid = (start + end) / 2;\n        if (index <= mid) {\n            update(2 * node + 1, start, mid, index, value);\n        } else {\n            update(2 * node + 2, mid + 1, end, index, value);\n        }\n        \n        tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n    }\n}\n\n// Segment Tree for Range Minimum Query\nclass SegmentTreeMin {\n    private int[] tree;\n    private int n;\n    \n    public SegmentTreeMin(int[] arr) {\n        n = arr.length;\n        tree = new int[4 * n];\n        build(arr, 0, 0, n - 1);\n    }\n    \n    private void build(int[] arr, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = arr[start];\n            return;\n        }\n        \n        int mid = (start + end) / 2;\n        build(arr, 2 * node + 1, start, mid);\n        build(arr, 2 * node + 2, mid + 1, end);\n        \n        tree[node] = Math.min(tree[2 * node + 1], tree[2 * node + 2]);\n    }\n    \n    public int queryMin(int left, int right) {\n        return queryMin(0, 0, n - 1, left, right);\n    }\n    \n    private int queryMin(int node, int start, int end, int left, int right) {\n        if (right < start || left > end) {\n            return Integer.MAX_VALUE;\n        }\n        \n        if (left <= start && end <= right) {\n            return tree[node];\n        }\n        \n        int mid = (start + end) / 2;\n        int leftMin = queryMin(2 * node + 1, start, mid, left, right);\n        int rightMin = queryMin(2 * node + 2, mid + 1, end, left, right);\n        return Math.min(leftMin, rightMin);\n    }\n}\n\n// Lazy Propagation for range updates\nclass LazySegmentTree {\n    private int[] tree, lazy;\n    private int n;\n    \n    public LazySegmentTree(int[] arr) {\n        n = arr.length;\n        tree = new int[4 * n];\n        lazy = new int[4 * n];\n        build(arr, 0, 0, n - 1);\n    }\n    \n    private void build(int[] arr, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = arr[start];\n            return;\n        }\n        int mid = (start + end) / 2;\n        build(arr, 2 * node + 1, start, mid);\n        build(arr, 2 * node + 2, mid + 1, end);\n        tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n    }\n    \n    // Range update with lazy propagation\n    public void updateRange(int left, int right, int value) {\n        updateRange(0, 0, n - 1, left, right, value);\n    }\n    \n    private void updateRange(int node, int start, int end, \n                            int left, int right, int value) {\n        if (lazy[node] != 0) {\n            tree[node] += lazy[node] * (end - start + 1);\n            if (start != end) {\n                lazy[2 * node + 1] += lazy[node];\n                lazy[2 * node + 2] += lazy[node];\n            }\n            lazy[node] = 0;\n        }\n        \n        if (start > right || end < left) return;\n        \n        if (start >= left && end <= right) {\n            tree[node] += value * (end - start + 1);\n            if (start != end) {\n                lazy[2 * node + 1] += value;\n                lazy[2 * node + 2] += value;\n            }\n            return;\n        }\n        \n        int mid = (start + end) / 2;\n        updateRange(2 * node + 1, start, mid, left, right, value);\n        updateRange(2 * node + 2, mid + 1, end, left, right, value);\n        tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n    }\n}"
    },
    {
      "id": 40,
      "question": "What is a fenwick tree (binary indexed tree) and how does it work?",
      "answer": "A Fenwick Tree (Binary Indexed Tree or BIT) is a data structure providing efficient methods for cumulative frequency tables, supporting prefix sum queries and updates.\n\nFenwick Tree Characteristics:\n• Array-based implementation\n• 1-indexed for easier bit manipulation\n• Each index stores partial sum\n• Uses binary representation for navigation\n• Space complexity - O(n)\n• Simpler than segment tree for prefix operations\n\nOperations:\n• Build - O(n log n) or O(n)\n• Prefix sum query - O(log n)\n• Point update - O(log n)\n• Range query - Two prefix sums - O(log n)\n\nKey Idea:\n• Index i stores sum of elements from (i - LSB(i) + 1) to i\n• LSB = Least Significant Bit = i & (-i)\n• Update propagates to indices by adding LSB\n• Query accumulates by removing LSB\n\nAdvantages over Segment Tree:\n• Less memory (n instead of 4n)\n• Faster in practice\n• Simpler code\n\nLimitations:\n• Only for prefix operations\n• Not for general range queries",
      "explanation": "Fenwick Tree efficiently handles prefix sums and point updates in O(log n) using bit manipulation, storing partial sums based on binary index representation.",
      "difficulty": "Hard",
      "code": "class FenwickTree {\n    private int[] tree;\n    private int n;\n    \n    public FenwickTree(int size) {\n        n = size;\n        tree = new int[n + 1]; // 1-indexed\n    }\n    \n    // Construct from array - O(n log n)\n    public FenwickTree(int[] arr) {\n        n = arr.length;\n        tree = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            update(i, arr[i]);\n        }\n    }\n    \n    // Update value at index - O(log n)\n    public void update(int index, int delta) {\n        index++; // Convert to 1-indexed\n        while (index <= n) {\n            tree[index] += delta;\n            index += (index & -index); // Add LSB\n        }\n    }\n    \n    // Get prefix sum [0, index] - O(log n)\n    public int prefixSum(int index) {\n        index++; // Convert to 1-indexed\n        int sum = 0;\n        while (index > 0) {\n            sum += tree[index];\n            index -= (index & -index); // Remove LSB\n        }\n        return sum;\n    }\n    \n    // Get range sum [left, right] - O(log n)\n    public int rangeSum(int left, int right) {\n        return prefixSum(right) - (left > 0 ? prefixSum(left - 1) : 0);\n    }\n    \n    // Efficient O(n) construction\n    public static FenwickTree buildEfficient(int[] arr) {\n        FenwickTree ft = new FenwickTree(arr.length);\n        \n        // Copy array to tree\n        for (int i = 0; i < arr.length; i++) {\n            ft.tree[i + 1] = arr[i];\n        }\n        \n        // Build tree in O(n)\n        for (int i = 1; i <= arr.length; i++) {\n            int parent = i + (i & -i);\n            if (parent <= arr.length) {\n                ft.tree[parent] += ft.tree[i];\n            }\n        }\n        return ft;\n    }\n}\n\n// 2D Fenwick Tree for 2D range sum queries\nclass FenwickTree2D {\n    private int[][] tree;\n    private int m, n;\n    \n    public FenwickTree2D(int rows, int cols) {\n        m = rows;\n        n = cols;\n        tree = new int[m + 1][n + 1];\n    }\n    \n    public void update(int row, int col, int delta) {\n        for (int i = row + 1; i <= m; i += (i & -i)) {\n            for (int j = col + 1; j <= n; j += (j & -j)) {\n                tree[i][j] += delta;\n            }\n        }\n    }\n    \n    public int prefixSum(int row, int col) {\n        int sum = 0;\n        for (int i = row + 1; i > 0; i -= (i & -i)) {\n            for (int j = col + 1; j > 0; j -= (j & -j)) {\n                sum += tree[i][j];\n            }\n        }\n        return sum;\n    }\n    \n    public int rangeSum(int row1, int col1, int row2, int col2) {\n        return prefixSum(row2, col2) \n             - prefixSum(row1 - 1, col2)\n             - prefixSum(row2, col1 - 1)\n             + prefixSum(row1 - 1, col1 - 1);\n    }\n}\n\n// Application: Count inversions in array\nclass CountInversions {\n    public int countInversions(int[] arr) {\n        // Coordinate compression\n        int[] sorted = arr.clone();\n        Arrays.sort(sorted);\n        Map<Integer, Integer> compress = new HashMap<>();\n        for (int i = 0; i < sorted.length; i++) {\n            compress.put(sorted[i], i);\n        }\n        \n        FenwickTree ft = new FenwickTree(arr.length);\n        int inversions = 0;\n        \n        for (int i = arr.length - 1; i >= 0; i--) {\n            int compressed = compress.get(arr[i]);\n            inversions += ft.prefixSum(compressed - 1);\n            ft.update(compressed, 1);\n        }\n        return inversions;\n    }\n}"
    },
    {
      "id": 41,
      "question": "What are monotonic stacks and queues and when are they used?",
      "answer": "Monotonic stacks and queues are data structures that maintain elements in monotonic (increasing or decreasing) order, used to solve specific range query problems efficiently.\n\nMonotonic Stack:\n• Maintains monotonic order (increasing or decreasing)\n• Elements pushed/popped to maintain order\n• Used for next greater/smaller element problems\n• O(n) time for n operations (amortized)\n\nMonotonic Queue:\n• Deque maintaining monotonic order\n• Supports sliding window maximum/minimum\n• Elements added at back, removed from front\n• Each element processed at most twice\n\nCommon Applications:\n• Next Greater Element\n• Next Smaller Element\n• Largest Rectangle in Histogram\n• Sliding Window Maximum\n• Stock span problem\n• Daily temperatures\n\nKey Insight:\n• Each element pushed and popped at most once\n• Total time complexity O(n) for n elements",
      "explanation": "Monotonic stacks maintain elements in sorted order to efficiently find next greater/smaller elements in O(n), while monotonic queues solve sliding window min/max problems.",
      "difficulty": "Hard",
      "code": "class MonotonicStructures {\n    \n    // Next Greater Element - O(n)\n    public int[] nextGreaterElement(int[] nums) {\n        int n = nums.length;\n        int[] result = new int[n];\n        Arrays.fill(result, -1);\n        Stack<Integer> stack = new Stack<>(); // Monotonic decreasing\n        \n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && nums[stack.peek()] < nums[i]) {\n                result[stack.pop()] = nums[i];\n            }\n            stack.push(i);\n        }\n        return result;\n    }\n    \n    // Next Smaller Element - O(n)\n    public int[] nextSmallerElement(int[] nums) {\n        int n = nums.length;\n        int[] result = new int[n];\n        Arrays.fill(result, -1);\n        Stack<Integer> stack = new Stack<>(); // Monotonic increasing\n        \n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && nums[stack.peek()] > nums[i]) {\n                result[stack.pop()] = nums[i];\n            }\n            stack.push(i);\n        }\n        return result;\n    }\n    \n    // Largest Rectangle in Histogram - O(n)\n    public int largestRectangleArea(int[] heights) {\n        Stack<Integer> stack = new Stack<>();\n        int maxArea = 0;\n        int n = heights.length;\n        \n        for (int i = 0; i <= n; i++) {\n            int h = (i == n) ? 0 : heights[i];\n            \n            while (!stack.isEmpty() && heights[stack.peek()] > h) {\n                int height = heights[stack.pop()];\n                int width = stack.isEmpty() ? i : i - stack.peek() - 1;\n                maxArea = Math.max(maxArea, height * width);\n            }\n            stack.push(i);\n        }\n        return maxArea;\n    }\n    \n    // Daily Temperatures - O(n)\n    public int[] dailyTemperatures(int[] temperatures) {\n        int n = temperatures.length;\n        int[] result = new int[n];\n        Stack<Integer> stack = new Stack<>();\n        \n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && \n                   temperatures[stack.peek()] < temperatures[i]) {\n                int idx = stack.pop();\n                result[idx] = i - idx;\n            }\n            stack.push(i);\n        }\n        return result;\n    }\n    \n    // Sliding Window Maximum using Monotonic Deque - O(n)\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if (nums.length == 0) return new int[0];\n        \n        int[] result = new int[nums.length - k + 1];\n        Deque<Integer> deque = new LinkedList<>(); // Stores indices\n        \n        for (int i = 0; i < nums.length; i++) {\n            // Remove elements outside window\n            while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {\n                deque.pollFirst();\n            }\n            \n            // Maintain decreasing order\n            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {\n                deque.pollLast();\n            }\n            \n            deque.offerLast(i);\n            \n            // Add to result when window is complete\n            if (i >= k - 1) {\n                result[i - k + 1] = nums[deque.peekFirst()];\n            }\n        }\n        return result;\n    }\n    \n    // Sliding Window Minimum - O(n)\n    public int[] minSlidingWindow(int[] nums, int k) {\n        int[] result = new int[nums.length - k + 1];\n        Deque<Integer> deque = new LinkedList<>();\n        \n        for (int i = 0; i < nums.length; i++) {\n            while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {\n                deque.pollFirst();\n            }\n            \n            // Maintain increasing order for minimum\n            while (!deque.isEmpty() && nums[deque.peekLast()] > nums[i]) {\n                deque.pollLast();\n            }\n            \n            deque.offerLast(i);\n            \n            if (i >= k - 1) {\n                result[i - k + 1] = nums[deque.peekFirst()];\n            }\n        }\n        return result;\n    }\n    \n    // Stock Span Problem - O(n)\n    class StockSpanner {\n        Stack<int[]> stack; // [price, span]\n        \n        public StockSpanner() {\n            stack = new Stack<>();\n        }\n        \n        public int next(int price) {\n            int span = 1;\n            while (!stack.isEmpty() && stack.peek()[0] <= price) {\n                span += stack.pop()[1];\n            }\n            stack.push(new int[]{price, span});\n            return span;\n        }\n    }\n    \n    // Remove K Digits to make smallest number\n    public String removeKdigits(String num, int k) {\n        Stack<Character> stack = new Stack<>();\n        \n        for (char digit : num.toCharArray()) {\n            while (!stack.isEmpty() && k > 0 && stack.peek() > digit) {\n                stack.pop();\n                k--;\n            }\n            stack.push(digit);\n        }\n        \n        // Remove remaining k digits\n        while (k > 0) {\n            stack.pop();\n            k--;\n        }\n        \n        // Build result\n        StringBuilder sb = new StringBuilder();\n        while (!stack.isEmpty()) {\n            sb.append(stack.pop());\n        }\n        sb.reverse();\n        \n        // Remove leading zeros\n        while (sb.length() > 1 && sb.charAt(0) == '0') {\n            sb.deleteCharAt(0);\n        }\n        \n        return sb.length() == 0 ? \"0\" : sb.toString();\n    }\n}"
    },
    {
      "id": 42,
      "question": "What is the Boyer-Moore voting algorithm and what problems does it solve?",
      "answer": "The Boyer-Moore Voting Algorithm efficiently finds the majority element (appears more than n/2 times) in an array with O(n) time and O(1) space.\n\nAlgorithm Concept:\n• Maintains a candidate and count\n• Increment count for candidate match\n• Decrement count for mismatch\n• Change candidate when count becomes 0\n• Requires second pass to verify majority\n\nTime Complexity - O(n):\n• Single pass for candidate finding\n• Second pass for verification\n\nSpace Complexity - O(1):\n• Only stores candidate and count\n\nKey Insight:\n• Majority element appears more than n/2 times\n• Pairing elements cancels out non-majority\n• Last remaining candidate is potential majority\n\nExtensions:\n• Finding elements appearing more than n/3 times\n• Finding top k frequent elements\n\nApplications:\n• Finding majority element in voting\n• Stream processing\n• Data analysis",
      "explanation": "Boyer-Moore voting algorithm finds the majority element (>n/2 occurrences) in O(n) time and O(1) space by maintaining a candidate and count, canceling non-majority pairs.",
      "difficulty": "Medium",
      "code": "class BoyerMoore {\n    \n    // Find majority element (appears > n/2 times) - O(n) time, O(1) space\n    public int majorityElement(int[] nums) {\n        int candidate = nums[0];\n        int count = 1;\n        \n        // Phase 1: Find candidate\n        for (int i = 1; i < nums.length; i++) {\n            if (count == 0) {\n                candidate = nums[i];\n                count = 1;\n            } else if (nums[i] == candidate) {\n                count++;\n            } else {\n                count--;\n            }\n        }\n        \n        // Phase 2: Verify (if not guaranteed to exist)\n        count = 0;\n        for (int num : nums) {\n            if (num == candidate) count++;\n        }\n        \n        return count > nums.length / 2 ? candidate : -1;\n    }\n    \n    // Find elements appearing more than n/3 times - O(n) time, O(1) space\n    public List<Integer> majorityElementII(int[] nums) {\n        List<Integer> result = new ArrayList<>();\n        if (nums.length == 0) return result;\n        \n        // Two candidates (at most 2 elements can appear > n/3 times)\n        int candidate1 = 0, candidate2 = 1;\n        int count1 = 0, count2 = 0;\n        \n        // Phase 1: Find candidates\n        for (int num : nums) {\n            if (num == candidate1) {\n                count1++;\n            } else if (num == candidate2) {\n                count2++;\n            } else if (count1 == 0) {\n                candidate1 = num;\n                count1 = 1;\n            } else if (count2 == 0) {\n                candidate2 = num;\n                count2 = 1;\n            } else {\n                count1--;\n                count2--;\n            }\n        }\n        \n        // Phase 2: Verify candidates\n        count1 = 0;\n        count2 = 0;\n        for (int num : nums) {\n            if (num == candidate1) count1++;\n            else if (num == candidate2) count2++;\n        }\n        \n        if (count1 > nums.length / 3) result.add(candidate1);\n        if (count2 > nums.length / 3) result.add(candidate2);\n        \n        return result;\n    }\n    \n    // Find majority element with guarantee it exists\n    public int majorityElementGuaranteed(int[] nums) {\n        int candidate = 0;\n        int count = 0;\n        \n        for (int num : nums) {\n            if (count == 0) {\n                candidate = num;\n            }\n            count += (num == candidate) ? 1 : -1;\n        }\n        \n        return candidate; // No verification needed\n    }\n    \n    // Check if majority element exists\n    public boolean hasMajority(int[] nums) {\n        int candidate = nums[0];\n        int count = 1;\n        \n        for (int i = 1; i < nums.length; i++) {\n            count += (nums[i] == candidate) ? 1 : -1;\n            if (count == 0) {\n                candidate = nums[i];\n                count = 1;\n            }\n        }\n        \n        // Verify\n        count = 0;\n        for (int num : nums) {\n            if (num == candidate) count++;\n        }\n        \n        return count > nums.length / 2;\n    }\n}"
    },
    {
      "id": 43,
      "question": "What is the Dutch National Flag algorithm and when is it used?",
      "answer": "The Dutch National Flag algorithm solves the three-way partitioning problem, sorting an array with three distinct values in a single pass.\n\nAlgorithm Characteristics:\n• Three-pointer approach\n• Single pass through array\n• In-place sorting\n• Time Complexity - O(n)\n• Space Complexity - O(1)\n\nPointer Roles:\n• Low pointer - boundary of first partition\n• Mid pointer - current element being examined\n• High pointer - boundary of third partition\n\nKey Operations:\n• If arr[mid] == 0: swap with low, increment both\n• If arr[mid] == 1: just increment mid\n• If arr[mid] == 2: swap with high, decrement high\n\nApplications:\n• Sort array of 0s, 1s, and 2s\n• Three-way quicksort partition\n• Color sorting problems\n• Segregation problems\n\nVariants:\n• Two-way partitioning (quicksort)\n• K-way partitioning",
      "explanation": "Dutch National Flag algorithm partitions an array into three sections in O(n) time using three pointers, commonly used to sort arrays with three distinct values.",
      "difficulty": "Medium",
      "code": "class DutchNationalFlag {\n    \n    // Sort array of 0s, 1s, 2s - O(n) time, O(1) space\n    public void sortColors(int[] nums) {\n        int low = 0;        // Boundary of 0s\n        int mid = 0;        // Current element\n        int high = nums.length - 1;  // Boundary of 2s\n        \n        while (mid <= high) {\n            if (nums[mid] == 0) {\n                // Swap with low boundary\n                swap(nums, low, mid);\n                low++;\n                mid++;\n            } else if (nums[mid] == 1) {\n                // Already in correct position\n                mid++;\n            } else { // nums[mid] == 2\n                // Swap with high boundary\n                swap(nums, mid, high);\n                high--;\n                // Don't increment mid (need to examine swapped element)\n            }\n        }\n    }\n    \n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n    \n    // Generalized for any three values\n    public void sortThreeValues(int[] nums, int val1, int val2, int val3) {\n        int low = 0, mid = 0, high = nums.length - 1;\n        \n        while (mid <= high) {\n            if (nums[mid] == val1) {\n                swap(nums, low++, mid++);\n            } else if (nums[mid] == val2) {\n                mid++;\n            } else {\n                swap(nums, mid, high--);\n            }\n        }\n    }\n    \n    // Partition around pivot (three-way quicksort)\n    public void threeWayPartition(int[] nums, int pivot) {\n        int low = 0, mid = 0, high = nums.length - 1;\n        \n        while (mid <= high) {\n            if (nums[mid] < pivot) {\n                swap(nums, low++, mid++);\n            } else if (nums[mid] == pivot) {\n                mid++;\n            } else {\n                swap(nums, mid, high--);\n            }\n        }\n    }\n    \n    // Segregate even and odd with relative order\n    public void segregateEvenOdd(int[] nums) {\n        int[] temp = new int[nums.length];\n        int even = 0, odd = 0;\n        \n        // Count evens\n        for (int num : nums) {\n            if (num % 2 == 0) even++;\n        }\n        \n        // Place elements\n        even = 0;\n        odd = 0;\n        for (int num : nums) {\n            if (num % 2 == 0) {\n                temp[even++] = num;\n            } else {\n                temp[nums.length - 1 - odd++] = num;\n            }\n        }\n        \n        System.arraycopy(temp, 0, nums, 0, nums.length);\n    }\n    \n    // Move all zeros to end while maintaining order\n    public void moveZerosToEnd(int[] nums) {\n        int nonZero = 0;\n        \n        // Move all non-zero elements to front\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] != 0) {\n                nums[nonZero++] = nums[i];\n            }\n        }\n        \n        // Fill remaining with zeros\n        while (nonZero < nums.length) {\n            nums[nonZero++] = 0;\n        }\n    }\n    \n    // Segregate positive and negative\n    public void segregatePositiveNegative(int[] nums) {\n        int left = 0, right = nums.length - 1;\n        \n        while (left < right) {\n            while (left < right && nums[left] < 0) {\n                left++;\n            }\n            while (left < right && nums[right] >= 0) {\n                right--;\n            }\n            if (left < right) {\n                swap(nums, left, right);\n            }\n        }\n    }\n}"
    },
    {
      "id": 44,
      "question": "What is the Kadane's algorithm and what problem does it solve?",
      "answer": "Kadane's algorithm finds the maximum sum of a contiguous subarray in O(n) time and O(1) space using dynamic programming.\n\nAlgorithm Concept:\n• Maintains maximum sum ending at current position\n• At each position, decide to extend subarray or start new\n• Keep track of global maximum\n• Based on optimal substructure principle\n\nKey Insight:\n• maxEndingHere = max(arr[i], maxEndingHere + arr[i])\n• Either start fresh from current element or extend previous subarray\n• maxSoFar tracks overall maximum\n\nTime Complexity - O(n):\n• Single pass through array\n\nSpace Complexity - O(1):\n• Only two variables needed\n\nVariants:\n• Maximum product subarray\n• Circular array maximum sum\n• Maximum sum with at most k negations\n• Maximum sum non-adjacent elements\n\nApplications:\n• Stock market analysis\n• Signal processing\n• Data analysis",
      "explanation": "Kadane's algorithm finds maximum subarray sum in O(n) time by deciding at each position whether to extend the current subarray or start a new one.",
      "difficulty": "Medium",
      "code": "class KadanesAlgorithm {\n    \n    // Maximum subarray sum - O(n) time, O(1) space\n    public int maxSubArray(int[] nums) {\n        int maxSoFar = nums[0];\n        int maxEndingHere = nums[0];\n        \n        for (int i = 1; i < nums.length; i++) {\n            maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);\n            maxSoFar = Math.max(maxSoFar, maxEndingHere);\n        }\n        \n        return maxSoFar;\n    }\n    \n    // Maximum subarray sum with indices\n    public int[] maxSubArrayWithIndices(int[] nums) {\n        int maxSoFar = nums[0];\n        int maxEndingHere = nums[0];\n        int start = 0, end = 0, tempStart = 0;\n        \n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] > maxEndingHere + nums[i]) {\n                maxEndingHere = nums[i];\n                tempStart = i;\n            } else {\n                maxEndingHere += nums[i];\n            }\n            \n            if (maxEndingHere > maxSoFar) {\n                maxSoFar = maxEndingHere;\n                start = tempStart;\n                end = i;\n            }\n        }\n        \n        return new int[]{maxSoFar, start, end};\n    }\n    \n    // Maximum product subarray - O(n)\n    public int maxProduct(int[] nums) {\n        int maxSoFar = nums[0];\n        int maxEndingHere = nums[0];\n        int minEndingHere = nums[0];\n        \n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] < 0) {\n                // Swap max and min\n                int temp = maxEndingHere;\n                maxEndingHere = minEndingHere;\n                minEndingHere = temp;\n            }\n            \n            maxEndingHere = Math.max(nums[i], maxEndingHere * nums[i]);\n            minEndingHere = Math.min(nums[i], minEndingHere * nums[i]);\n            \n            maxSoFar = Math.max(maxSoFar, maxEndingHere);\n        }\n        \n        return maxSoFar;\n    }\n    \n    // Maximum circular subarray sum\n    public int maxCircularSubarray(int[] nums) {\n        int maxKadane = maxSubArray(nums);\n        \n        // Find minimum subarray sum and total sum\n        int totalSum = 0;\n        int minSoFar = nums[0];\n        int minEndingHere = nums[0];\n        \n        for (int i = 0; i < nums.length; i++) {\n            totalSum += nums[i];\n            if (i > 0) {\n                minEndingHere = Math.min(nums[i], minEndingHere + nums[i]);\n                minSoFar = Math.min(minSoFar, minEndingHere);\n            }\n        }\n        \n        // Maximum circular sum is either:\n        // 1. Maximum kadane sum\n        // 2. Total sum - minimum subarray sum\n        int maxCircular = totalSum - minSoFar;\n        \n        // If all numbers are negative, maxCircular will be 0\n        if (maxCircular == 0) {\n            return maxKadane;\n        }\n        \n        return Math.max(maxKadane, maxCircular);\n    }\n    \n    // Maximum sum with no adjacent elements\n    public int maxNonAdjacent(int[] nums) {\n        if (nums.length == 0) return 0;\n        if (nums.length == 1) return nums[0];\n        \n        int include = nums[0];\n        int exclude = 0;\n        \n        for (int i = 1; i < nums.length; i++) {\n            int newExclude = Math.max(include, exclude);\n            include = exclude + nums[i];\n            exclude = newExclude;\n        }\n        \n        return Math.max(include, exclude);\n    }\n    \n    // Maximum sum subarray of size k\n    public int maxSumSubarrayK(int[] nums, int k) {\n        int windowSum = 0;\n        for (int i = 0; i < k; i++) {\n            windowSum += nums[i];\n        }\n        \n        int maxSum = windowSum;\n        for (int i = k; i < nums.length; i++) {\n            windowSum = windowSum - nums[i - k] + nums[i];\n            maxSum = Math.max(maxSum, windowSum);\n        }\n        \n        return maxSum;\n    }\n    \n    // Maximum average subarray\n    public double findMaxAverage(int[] nums, int k) {\n        int sum = 0;\n        for (int i = 0; i < k; i++) {\n            sum += nums[i];\n        }\n        \n        int maxSum = sum;\n        for (int i = k; i < nums.length; i++) {\n            sum = sum - nums[i - k] + nums[i];\n            maxSum = Math.max(maxSum, sum);\n        }\n        \n        return (double) maxSum / k;\n    }\n}"
    },
    {
      "id": 45,
      "question": "What is the Floyd-Warshall algorithm and when is it used?",
      "answer": "Floyd-Warshall is an all-pairs shortest path algorithm that finds shortest paths between all pairs of vertices in a weighted graph, including those with negative weights.\n\nAlgorithm Characteristics:\n• Finds shortest paths between all vertex pairs\n• Uses dynamic programming\n• Works with negative edge weights\n• Detects negative cycles\n• Time Complexity - O(V³)\n• Space Complexity - O(V²)\n\nKey Idea:\n• Consider each vertex as intermediate point\n• For each pair (i,j), check if path through k is shorter\n• dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\nWhen to Use:\n• Need all-pairs shortest paths\n• Dense graphs (many edges)\n• Graph may have negative weights\n• Graph representation as adjacency matrix\n\nFloyd-Warshall vs:\n• Dijkstra: Single-source, faster for sparse graphs\n• Bellman-Ford: Single-source, handles negative\n• Floyd-Warshall: All-pairs, handles negative",
      "explanation": "Floyd-Warshall finds shortest paths between all vertex pairs in O(V³) time using dynamic programming, considering each vertex as potential intermediate point.",
      "difficulty": "Hard",
      "code": "class FloydWarshall {\n    \n    // Floyd-Warshall algorithm - O(V³)\n    public int[][] floydWarshall(int[][] graph) {\n        int n = graph.length;\n        int[][] dist = new int[n][n];\n        \n        // Initialize distances\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dist[i][j] = graph[i][j];\n            }\n        }\n        \n        // Try each vertex as intermediate\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (dist[i][k] != Integer.MAX_VALUE && \n                        dist[k][j] != Integer.MAX_VALUE &&\n                        dist[i][k] + dist[k][j] < dist[i][j]) {\n                        dist[i][j] = dist[i][k] + dist[k][j];\n                    }\n                }\n            }\n        }\n        \n        return dist;\n    }\n    \n    // Floyd-Warshall with path reconstruction\n    public int[][] floydWarshallWithPath(int[][] graph) {\n        int n = graph.length;\n        int[][] dist = new int[n][n];\n        int[][] next = new int[n][n];\n        \n        // Initialize\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dist[i][j] = graph[i][j];\n                if (graph[i][j] != Integer.MAX_VALUE && i != j) {\n                    next[i][j] = j;\n                } else {\n                    next[i][j] = -1;\n                }\n            }\n        }\n        \n        // Floyd-Warshall\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (dist[i][k] != Integer.MAX_VALUE && \n                        dist[k][j] != Integer.MAX_VALUE &&\n                        dist[i][k] + dist[k][j] < dist[i][j]) {\n                        dist[i][j] = dist[i][k] + dist[k][j];\n                        next[i][j] = next[i][k];\n                    }\n                }\n            }\n        }\n        \n        return dist;\n    }\n    \n    // Reconstruct path between two vertices\n    public List<Integer> reconstructPath(int[][] next, int start, int end) {\n        List<Integer> path = new ArrayList<>();\n        if (next[start][end] == -1) return path;\n        \n        path.add(start);\n        while (start != end) {\n            start = next[start][end];\n            path.add(start);\n        }\n        return path;\n    }\n    \n    // Detect negative cycle\n    public boolean hasNegativeCycle(int[][] graph) {\n        int n = graph.length;\n        int[][] dist = floydWarshall(graph);\n        \n        // Check diagonal for negative values\n        for (int i = 0; i < n; i++) {\n            if (dist[i][i] < 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    // Find graph center (vertex with minimum maximum distance)\n    public int findCenter(int[][] graph) {\n        int[][] dist = floydWarshall(graph);\n        int n = dist.length;\n        int center = 0;\n        int minMaxDist = Integer.MAX_VALUE;\n        \n        for (int i = 0; i < n; i++) {\n            int maxDist = 0;\n            for (int j = 0; j < n; j++) {\n                if (i != j && dist[i][j] != Integer.MAX_VALUE) {\n                    maxDist = Math.max(maxDist, dist[i][j]);\n                }\n            }\n            if (maxDist < minMaxDist) {\n                minMaxDist = maxDist;\n                center = i;\n            }\n        }\n        return center;\n    }\n    \n    // Transitive closure (reachability)\n    public boolean[][] transitiveClosure(boolean[][] graph) {\n        int n = graph.length;\n        boolean[][] reach = new boolean[n][n];\n        \n        // Initialize\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                reach[i][j] = graph[i][j] || (i == j);\n            }\n        }\n        \n        // Floyd-Warshall for reachability\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    reach[i][j] = reach[i][j] || \n                                 (reach[i][k] && reach[k][j]);\n                }\n            }\n        }\n        return reach;\n    }\n}"
    },
    {
      "id": 46,
      "question": "What is Prim's algorithm and how does it find minimum spanning trees?",
      "answer": "Prim's algorithm is a greedy algorithm that finds the minimum spanning tree (MST) of a weighted undirected graph by growing the tree one vertex at a time.\n\nPrim's Algorithm Characteristics:\n• Greedy approach\n• Starts from arbitrary vertex\n• Always adds minimum weight edge connecting tree to non-tree vertex\n• Time Complexity - O((V + E) log V) with priority queue, O(V²) with array\n• Space Complexity - O(V)\n\nAlgorithm Steps:\n• Start with arbitrary vertex in MST\n• Maintain priority queue of edges\n• Repeatedly add minimum edge connecting MST to new vertex\n• Continue until all vertices included\n\nPrim's vs Kruskal's:\n• Prim: Grows single tree, better for dense graphs\n• Kruskal: Merges forests, better for sparse graphs\n• Both produce same MST weight\n• Prim uses priority queue, Kruskal uses union-find\n\nApplications:\n• Network design\n• Approximation algorithms\n• Clustering\n• Circuit design",
      "explanation": "Prim's algorithm builds an MST by starting from one vertex and repeatedly adding the minimum weight edge connecting the tree to a new vertex.",
      "difficulty": "Hard",
      "code": "import java.util.*;\n\nclass PrimsAlgorithm {\n    class Edge implements Comparable<Edge> {\n        int dest, weight;\n        Edge(int dest, int weight) {\n            this.dest = dest;\n            this.weight = weight;\n        }\n        public int compareTo(Edge other) {\n            return Integer.compare(this.weight, other.weight);\n        }\n    }\n    \n    // Prim's MST - Priority Queue - O((V + E) log V)\n    public int primMST(List<List<Edge>> graph, int vertices) {\n        boolean[] inMST = new boolean[vertices];\n        PriorityQueue<Edge> pq = new PriorityQueue<>();\n        int mstWeight = 0;\n        int edgesAdded = 0;\n        \n        // Start from vertex 0\n        inMST[0] = true;\n        for (Edge edge : graph.get(0)) {\n            pq.offer(edge);\n        }\n        \n        while (!pq.isEmpty() && edgesAdded < vertices - 1) {\n            Edge edge = pq.poll();\n            \n            if (inMST[edge.dest]) continue;\n            \n            inMST[edge.dest] = true;\n            mstWeight += edge.weight;\n            edgesAdded++;\n            \n            for (Edge nextEdge : graph.get(edge.dest)) {\n                if (!inMST[nextEdge.dest]) {\n                    pq.offer(nextEdge);\n                }\n            }\n        }\n        \n        return mstWeight;\n    }\n    \n    // Prim's with MST edges stored\n    public List<int[]> primMSTWithEdges(List<List<Edge>> graph, int vertices) {\n        boolean[] inMST = new boolean[vertices];\n        int[] parent = new int[vertices];\n        PriorityQueue<Edge> pq = new PriorityQueue<>();\n        List<int[]> mstEdges = new ArrayList<>();\n        \n        Arrays.fill(parent, -1);\n        inMST[0] = true;\n        \n        for (Edge edge : graph.get(0)) {\n            pq.offer(edge);\n        }\n        \n        while (!pq.isEmpty() && mstEdges.size() < vertices - 1) {\n            Edge edge = pq.poll();\n            \n            if (inMST[edge.dest]) continue;\n            \n            inMST[edge.dest] = true;\n            mstEdges.add(new int[]{edge.dest, edge.weight});\n            \n            for (Edge nextEdge : graph.get(edge.dest)) {\n                if (!inMST[nextEdge.dest]) {\n                    pq.offer(nextEdge);\n                }\n            }\n        }\n        \n        return mstEdges;\n    }\n    \n    // Prim's using adjacency matrix - O(V²)\n    public int primMSTMatrix(int[][] graph) {\n        int vertices = graph.length;\n        boolean[] inMST = new boolean[vertices];\n        int[] key = new int[vertices];\n        int[] parent = new int[vertices];\n        \n        Arrays.fill(key, Integer.MAX_VALUE);\n        Arrays.fill(parent, -1);\n        key[0] = 0;\n        \n        for (int count = 0; count < vertices - 1; count++) {\n            int u = minKey(key, inMST, vertices);\n            inMST[u] = true;\n            \n            for (int v = 0; v < vertices; v++) {\n                if (graph[u][v] != 0 && !inMST[v] && graph[u][v] < key[v]) {\n                    parent[v] = u;\n                    key[v] = graph[u][v];\n                }\n            }\n        }\n        \n        int mstWeight = 0;\n        for (int i = 1; i < vertices; i++) {\n            mstWeight += graph[i][parent[i]];\n        }\n        return mstWeight;\n    }\n    \n    private int minKey(int[] key, boolean[] inMST, int vertices) {\n        int min = Integer.MAX_VALUE;\n        int minIndex = -1;\n        \n        for (int v = 0; v < vertices; v++) {\n            if (!inMST[v] && key[v] < min) {\n                min = key[v];\n                minIndex = v;\n            }\n        }\n        return minIndex;\n    }\n}"
    },
    {
      "id": 47,
      "question": "What is Kruskal's algorithm and how does it differ from Prim's?",
      "answer": "Kruskal's algorithm is a greedy algorithm that finds the minimum spanning tree by sorting edges and adding them if they don't create a cycle.\n\nKruskal's Algorithm:\n• Sort all edges by weight\n• Use Union-Find to detect cycles\n• Add edge if it connects different components\n• Time Complexity - O(E log E) or O(E log V)\n• Space Complexity - O(V) for union-find\n\nAlgorithm Steps:\n• Sort edges by increasing weight\n• Initialize union-find structure\n• For each edge, check if endpoints in same set\n• If not, add edge and union the sets\n• Stop when V-1 edges added\n\nKruskal's vs Prim's:\n• Kruskal: Edge-based, better for sparse graphs\n• Prim: Vertex-based, better for dense graphs\n• Kruskal: Requires sorting edges\n• Prim: Uses priority queue for vertices\n• Both O(E log V) with optimal implementation\n\nApplications:\n• Network design\n• Clustering algorithms\n• Image segmentation\n• Approximate TSP",
      "explanation": "Kruskal's algorithm builds MST by sorting edges and adding them if they don't create cycles using Union-Find, optimal for sparse graphs.",
      "difficulty": "Hard",
      "code": "import java.util.*;\n\nclass KruskalsAlgorithm {\n    class Edge implements Comparable<Edge> {\n        int src, dest, weight;\n        \n        Edge(int src, int dest, int weight) {\n            this.src = src;\n            this.dest = dest;\n            this.weight = weight;\n        }\n        \n        public int compareTo(Edge other) {\n            return Integer.compare(this.weight, other.weight);\n        }\n    }\n    \n    class UnionFind {\n        int[] parent, rank;\n        \n        UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n        \n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        boolean union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            \n            if (rootX == rootY) return false;\n            \n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n            return true;\n        }\n    }\n    \n    // Kruskal's MST - O(E log E)\n    public int kruskalMST(int vertices, List<Edge> edges) {\n        Collections.sort(edges);\n        UnionFind uf = new UnionFind(vertices);\n        \n        int mstWeight = 0;\n        int edgesAdded = 0;\n        \n        for (Edge edge : edges) {\n            if (edgesAdded == vertices - 1) break;\n            \n            if (uf.union(edge.src, edge.dest)) {\n                mstWeight += edge.weight;\n                edgesAdded++;\n            }\n        }\n        \n        return mstWeight;\n    }\n    \n    // Kruskal's with MST edges\n    public List<Edge> kruskalMSTWithEdges(int vertices, List<Edge> edges) {\n        Collections.sort(edges);\n        UnionFind uf = new UnionFind(vertices);\n        List<Edge> mstEdges = new ArrayList<>();\n        \n        for (Edge edge : edges) {\n            if (mstEdges.size() == vertices - 1) break;\n            \n            if (uf.union(edge.src, edge.dest)) {\n                mstEdges.add(edge);\n            }\n        }\n        \n        return mstEdges;\n    }\n}"
    },
    {
      "id": 48,
      "question": "What is the A* search algorithm and when is it used?",
      "answer": "A* is an informed search algorithm that finds the shortest path using heuristics to guide the search, commonly used in pathfinding and graph traversal.\n\nA* Characteristics:\n• Uses heuristic function h(n) to estimate cost to goal\n• Maintains cost function f(n) = g(n) + h(n)\n• g(n) = actual cost from start\n• h(n) = estimated cost to goal\n• Guarantees optimal path if heuristic is admissible\n• Time/Space: O(b^d) worst case\n\nHeuristic Requirements:\n• Admissible: Never overestimates actual cost\n• Consistent: h(n) <= cost(n,n') + h(n')\n• Better heuristic = fewer nodes explored\n\nCommon Heuristics:\n• Manhattan distance for grid\n• Euclidean distance for plane\n• Diagonal distance for 8-way movement\n\nA* vs Dijkstra:\n• A* uses heuristic, Dijkstra doesn't\n• A* faster with good heuristic\n• Dijkstra is A* with h(n) = 0\n\nApplications:\n• Game pathfinding\n• GPS navigation\n• Robot motion planning\n• Puzzle solving",
      "explanation": "A* finds optimal paths using cost function f(n)=g(n)+h(n) where g is actual cost and h is heuristic estimate, faster than Dijkstra with good heuristics.",
      "difficulty": "Hard",
      "code": "import java.util.*;\n\nclass AStarSearch {\n    class Node implements Comparable<Node> {\n        int x, y;\n        int g, h, f; // g=cost from start, h=heuristic, f=total\n        Node parent;\n        \n        Node(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n        \n        public int compareTo(Node other) {\n            return Integer.compare(this.f, other.f);\n        }\n        \n        @Override\n        public boolean equals(Object o) {\n            if (!(o instanceof Node)) return false;\n            Node other = (Node) o;\n            return x == other.x && y == other.y;\n        }\n        \n        @Override\n        public int hashCode() {\n            return Objects.hash(x, y);\n        }\n    }\n    \n    // A* pathfinding on grid\n    public List<int[]> aStarGrid(int[][] grid, int[] start, int[] goal) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        \n        PriorityQueue<Node> openSet = new PriorityQueue<>();\n        Set<Node> closedSet = new HashSet<>();\n        \n        Node startNode = new Node(start[0], start[1]);\n        Node goalNode = new Node(goal[0], goal[1]);\n        \n        startNode.g = 0;\n        startNode.h = heuristic(startNode, goalNode);\n        startNode.f = startNode.g + startNode.h;\n        \n        openSet.offer(startNode);\n        \n        int[][] directions = {{0,1}, {1,0}, {0,-1}, {-1,0}};\n        \n        while (!openSet.isEmpty()) {\n            Node current = openSet.poll();\n            \n            if (current.equals(goalNode)) {\n                return reconstructPath(current);\n            }\n            \n            closedSet.add(current);\n            \n            for (int[] dir : directions) {\n                int newX = current.x + dir[0];\n                int newY = current.y + dir[1];\n                \n                if (newX < 0 || newX >= rows || newY < 0 || newY >= cols ||\n                    grid[newX][newY] == 1) {\n                    continue;\n                }\n                \n                Node neighbor = new Node(newX, newY);\n                if (closedSet.contains(neighbor)) continue;\n                \n                int tentativeG = current.g + 1;\n                \n                boolean inOpenSet = openSet.contains(neighbor);\n                if (!inOpenSet || tentativeG < neighbor.g) {\n                    neighbor.parent = current;\n                    neighbor.g = tentativeG;\n                    neighbor.h = heuristic(neighbor, goalNode);\n                    neighbor.f = neighbor.g + neighbor.h;\n                    \n                    if (!inOpenSet) {\n                        openSet.offer(neighbor);\n                    }\n                }\n            }\n        }\n        \n        return new ArrayList<>(); // No path found\n    }\n    \n    // Manhattan distance heuristic\n    private int heuristic(Node a, Node b) {\n        return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n    }\n    \n    // Euclidean distance heuristic\n    private double euclideanHeuristic(Node a, Node b) {\n        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n    }\n    \n    // Diagonal distance heuristic (8-way movement)\n    private int diagonalHeuristic(Node a, Node b) {\n        int dx = Math.abs(a.x - b.x);\n        int dy = Math.abs(a.y - b.y);\n        return Math.max(dx, dy);\n    }\n    \n    private List<int[]> reconstructPath(Node node) {\n        List<int[]> path = new ArrayList<>();\n        while (node != null) {\n            path.add(new int[]{node.x, node.y});\n            node = node.parent;\n        }\n        Collections.reverse(path);\n        return path;\n    }\n}"
    },
    {
      "id": 49,
      "question": "What is the Rabin-Karp algorithm for pattern matching?",
      "answer": "Rabin-Karp is a string searching algorithm that uses hashing to find patterns in text, particularly efficient for multiple pattern searching.\n\nAlgorithm Characteristics:\n• Uses rolling hash for efficiency\n• Compares hash values instead of characters\n• Verifies matches to avoid hash collisions\n• Average Time - O(n + m) where n=text, m=pattern\n• Worst Time - O(n × m) with many collisions\n• Space - O(1)\n\nKey Concept:\n• Compute hash of pattern\n• Compute hash of text windows\n• Use rolling hash for O(1) window updates\n• hash[i+1] = (hash[i] - text[i] × h) × d + text[i+m]\n\nRolling Hash:\n• Remove leftmost character contribution\n• Shift remaining hash\n• Add new rightmost character\n• Enables O(1) hash updates\n\nAdvantages:\n• Efficient for multiple patterns\n• Easy to extend to 2D pattern matching\n• Good average case performance\n\nApplications:\n• Plagiarism detection\n• Multiple pattern search\n• DNA sequence matching",
      "explanation": "Rabin-Karp uses rolling hash to efficiently search patterns by comparing hash values in O(n+m) average time, particularly useful for multiple pattern searches.",
      "difficulty": "Medium",
      "code": "class RabinKarp {\n    private static final int d = 256; // Number of characters\n    private static final int q = 101; // Prime number for modulo\n    \n    // Rabin-Karp pattern matching - O(n + m) average\n    public List<Integer> search(String text, String pattern) {\n        List<Integer> matches = new ArrayList<>();\n        int n = text.length();\n        int m = pattern.length();\n        \n        if (m > n) return matches;\n        \n        int patternHash = 0;\n        int textHash = 0;\n        int h = 1;\n        \n        // Calculate h = d^(m-1) % q\n        for (int i = 0; i < m - 1; i++) {\n            h = (h * d) % q;\n        }\n        \n        // Calculate initial hash values\n        for (int i = 0; i < m; i++) {\n            patternHash = (d * patternHash + pattern.charAt(i)) % q;\n            textHash = (d * textHash + text.charAt(i)) % q;\n        }\n        \n        // Slide pattern over text\n        for (int i = 0; i <= n - m; i++) {\n            // Check hash values\n            if (patternHash == textHash) {\n                // Verify actual match to handle collisions\n                boolean match = true;\n                for (int j = 0; j < m; j++) {\n                    if (text.charAt(i + j) != pattern.charAt(j)) {\n                        match = false;\n                        break;\n                    }\n                }\n                if (match) {\n                    matches.add(i);\n                }\n            }\n            \n            // Calculate hash for next window\n            if (i < n - m) {\n                textHash = (d * (textHash - text.charAt(i) * h) + \n                           text.charAt(i + m)) % q;\n                \n                // Handle negative hash\n                if (textHash < 0) {\n                    textHash += q;\n                }\n            }\n        }\n        \n        return matches;\n    }\n    \n    // Search multiple patterns\n    public Map<String, List<Integer>> searchMultiple(String text, \n                                                      List<String> patterns) {\n        Map<String, List<Integer>> results = new HashMap<>();\n        \n        for (String pattern : patterns) {\n            results.put(pattern, search(text, pattern));\n        }\n        \n        return results;\n    }\n    \n    // 2D pattern matching in matrix\n    public List<int[]> search2D(char[][] text, char[][] pattern) {\n        List<int[]> matches = new ArrayList<>();\n        int textRows = text.length;\n        int textCols = text[0].length;\n        int patternRows = pattern.length;\n        int patternCols = pattern[0].length;\n        \n        if (patternRows > textRows || patternCols > textCols) {\n            return matches;\n        }\n        \n        // Compute hash for pattern\n        long patternHash = hash2D(pattern, 0, 0, patternRows, patternCols);\n        \n        // Search in text\n        for (int i = 0; i <= textRows - patternRows; i++) {\n            for (int j = 0; j <= textCols - patternCols; j++) {\n                long textHash = hash2D(text, i, j, patternRows, patternCols);\n                \n                if (textHash == patternHash && \n                    verify2D(text, pattern, i, j)) {\n                    matches.add(new int[]{i, j});\n                }\n            }\n        }\n        \n        return matches;\n    }\n    \n    private long hash2D(char[][] matrix, int startRow, int startCol, \n                       int rows, int cols) {\n        long hash = 0;\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                hash = hash * d + matrix[startRow + i][startCol + j];\n                hash %= q;\n            }\n        }\n        return hash;\n    }\n    \n    private boolean verify2D(char[][] text, char[][] pattern, \n                            int startRow, int startCol) {\n        for (int i = 0; i < pattern.length; i++) {\n            for (int j = 0; j < pattern[0].length; j++) {\n                if (text[startRow + i][startCol + j] != pattern[i][j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}"
    },
    {
      "id": 50,
      "question": "What is the Manacher's algorithm for finding palindromes?",
      "answer": "Manacher's algorithm finds the longest palindromic substring in linear O(n) time by avoiding redundant comparisons using previously computed information.\n\nAlgorithm Characteristics:\n• Linear time complexity - O(n)\n• Space complexity - O(n)\n• Handles both odd and even length palindromes\n• Uses center expansion with optimization\n• Avoids recomputation using symmetry\n\nKey Concepts:\n• Transform string to handle even/odd lengths uniformly\n• Insert special characters between all characters\n• Maintain rightmost palindrome boundary\n• Use mirror property to skip comparisons\n• Expand only when necessary\n\nTransformation:\n• \"abc\" becomes \"#a#b#c#\"\n• Uniform handling of all palindromes\n• Odd length palindromes in transformed string\n\nOptimization:\n• If position within known palindrome, use mirror info\n• Only expand when beyond rightmost boundary\n• Maintains center and right boundary\n\nAdvantages:\n• Fastest algorithm for longest palindrome\n• Single pass through string\n• No backtracking needed",
      "explanation": "Manacher's algorithm finds the longest palindrome in O(n) time by transforming the string and using symmetry to avoid redundant comparisons.",
      "difficulty": "Hard",
      "code": "class ManachersAlgorithm {\n    \n    // Manacher's algorithm - O(n)\n    public String longestPalindrome(String s) {\n        if (s == null || s.length() == 0) return \"\";\n        \n        // Transform string\n        String transformed = transform(s);\n        int n = transformed.length();\n        int[] p = new int[n]; // Palindrome radii\n        int center = 0, right = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int mirror = 2 * center - i;\n            \n            // Use previously computed values\n            if (i < right) {\n                p[i] = Math.min(right - i, p[mirror]);\n            }\n            \n            // Expand around center i\n            try {\n                while (transformed.charAt(i + p[i] + 1) == \n                       transformed.charAt(i - p[i] - 1)) {\n                    p[i]++;\n                }\n            } catch (Exception e) {\n                // Out of bounds\n            }\n            \n            // Update center and right if palindrome extends past right\n            if (i + p[i] > right) {\n                center = i;\n                right = i + p[i];\n            }\n        }\n        \n        // Find maximum palindrome\n        int maxLen = 0;\n        int maxCenter = 0;\n        for (int i = 0; i < n; i++) {\n            if (p[i] > maxLen) {\n                maxLen = p[i];\n                maxCenter = i;\n            }\n        }\n        \n        // Extract original palindrome\n        int start = (maxCenter - maxLen) / 2;\n        return s.substring(start, start + maxLen);\n    }\n    \n    // Transform string: \"abc\" -> \"#a#b#c#\"\n    private String transform(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            sb.append('#').append(c);\n        }\n        sb.append('#');\n        return sb.toString();\n    }\n    \n    // Find all palindromic substrings count\n    public int countPalindromes(String s) {\n        String transformed = transform(s);\n        int n = transformed.length();\n        int[] p = new int[n];\n        int center = 0, right = 0;\n        int count = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int mirror = 2 * center - i;\n            \n            if (i < right) {\n                p[i] = Math.min(right - i, p[mirror]);\n            }\n            \n            try {\n                while (transformed.charAt(i + p[i] + 1) == \n                       transformed.charAt(i - p[i] - 1)) {\n                    p[i]++;\n                }\n            } catch (Exception e) {}\n            \n            if (i + p[i] > right) {\n                center = i;\n                right = i + p[i];\n            }\n            \n            // Count palindromes\n            count += (p[i] + 1) / 2;\n        }\n        \n        return count;\n    }\n}"
    },
    {
      "id": 51,
      "question": "What are common array manipulation techniques for interview problems?",
      "answer": "Array manipulation involves various techniques to solve problems efficiently, often optimizing from brute force O(n²) to O(n) solutions.\n\nCommon Techniques:\n• Two pointers - opposite or same direction\n• Sliding window - for subarrays/substrings\n• Prefix/suffix arrays - cumulative computations\n• Hash maps - for frequency counting\n• Sorting - enables binary search\n• In-place modifications - O(1) space\n\nPrefix Sum Array:\n• Precompute cumulative sums\n• Range sum query in O(1)\n• sum(i, j) = prefix[j] - prefix[i-1]\n\nIn-Place Techniques:\n• Use array indices as hash keys\n• Mark visited with negative values\n• Swap elements to correct positions\n\nCommon Problems:\n• Remove duplicates\n• Rotate array\n• Find missing/duplicate numbers\n• Merge sorted arrays\n• Maximum subarray sum",
      "explanation": "Array manipulation uses techniques like two-pointers, sliding window, and prefix sums to efficiently solve problems, often reducing complexity from O(n²) to O(n).",
      "difficulty": "Medium",
      "code": "class ArrayTechniques {\n    \n    // Rotate array k positions - O(n), O(1)\n    public void rotate(int[] nums, int k) {\n        k %= nums.length;\n        reverse(nums, 0, nums.length - 1);\n        reverse(nums, 0, k - 1);\n        reverse(nums, k, nums.length - 1);\n    }\n    \n    private void reverse(int[] nums, int start, int end) {\n        while (start < end) {\n            int temp = nums[start];\n            nums[start] = nums[end];\n            nums[end] = temp;\n            start++;\n            end--;\n        }\n    }\n    \n    // Find duplicate using array as hash - O(n), O(1)\n    public int findDuplicate(int[] nums) {\n        for (int i = 0; i < nums.length; i++) {\n            int idx = Math.abs(nums[i]);\n            if (nums[idx] < 0) {\n                return idx;\n            }\n            nums[idx] = -nums[idx];\n        }\n        return -1;\n    }\n    \n    // Product of array except self - O(n), O(1)\n    public int[] productExceptSelf(int[] nums) {\n        int n = nums.length;\n        int[] result = new int[n];\n        \n        result[0] = 1;\n        for (int i = 1; i < n; i++) {\n            result[i] = result[i - 1] * nums[i - 1];\n        }\n        \n        int right = 1;\n        for (int i = n - 1; i >= 0; i--) {\n            result[i] *= right;\n            right *= nums[i];\n        }\n        \n        return result;\n    }\n    \n    // Trapping rain water - O(n), O(1)\n    public int trap(int[] height) {\n        int left = 0, right = height.length - 1;\n        int leftMax = 0, rightMax = 0;\n        int water = 0;\n        \n        while (left < right) {\n            if (height[left] < height[right]) {\n                if (height[left] >= leftMax) {\n                    leftMax = height[left];\n                } else {\n                    water += leftMax - height[left];\n                }\n                left++;\n            } else {\n                if (height[right] >= rightMax) {\n                    rightMax = height[right];\n                } else {\n                    water += rightMax - height[right];\n                }\n                right--;\n            }\n        }\n        return water;\n    }\n}"
    },
    {
      "id": 52,
      "question": "What is memoization in the context of tree problems?",
      "answer": "Memoization in tree problems stores results of subproblems to avoid redundant recursive calls, particularly useful for problems with overlapping subtrees or paths.\n\nTree Memoization Patterns:\n• Path-based memoization\n• Subtree result caching\n• State-based memoization\n• Parent-child relationship caching\n\nCommon Use Cases:\n• Count paths with given sum\n• Longest path with constraints\n• Tree DP problems\n• Distance queries\n\nMemoization Keys:\n• Node + state combination\n• Path characteristics\n• Subtree properties\n\nBenefits:\n• Reduces exponential to polynomial time\n• Enables efficient path queries\n• Optimizes recursive solutions\n\nConsiderations:\n• Choose appropriate key representation\n• Balance memory vs computation\n• Clear cache when tree modifies",
      "explanation": "Tree memoization caches results of recursive calls on subtrees or paths to avoid redundant computations, transforming exponential solutions to polynomial time.",
      "difficulty": "Hard",
      "code": "class TreeMemoization {\n    // Count paths with given sum using memoization\n    public int pathSum(TreeNode root, int targetSum) {\n        Map<Long, Integer> prefixSum = new HashMap<>();\n        prefixSum.put(0L, 1);\n        return pathSumHelper(root, 0, targetSum, prefixSum);\n    }\n    \n    private int pathSumHelper(TreeNode node, long currentSum, \n                             int target, Map<Long, Integer> prefixSum) {\n        if (node == null) return 0;\n        \n        currentSum += node.data;\n        int count = prefixSum.getOrDefault(currentSum - target, 0);\n        \n        prefixSum.put(currentSum, prefixSum.getOrDefault(currentSum, 0) + 1);\n        \n        count += pathSumHelper(node.left, currentSum, target, prefixSum);\n        count += pathSumHelper(node.right, currentSum, target, prefixSum);\n        \n        prefixSum.put(currentSum, prefixSum.get(currentSum) - 1);\n        return count;\n    }\n    \n    // Diameter with memoization\n    private Map<TreeNode, Integer> heightMemo = new HashMap<>();\n    private int maxDiameter = 0;\n    \n    public int diameterOfBinaryTree(TreeNode root) {\n        height(root);\n        return maxDiameter;\n    }\n    \n    private int height(TreeNode node) {\n        if (node == null) return 0;\n        if (heightMemo.containsKey(node)) return heightMemo.get(node);\n        \n        int leftHeight = height(node.left);\n        int rightHeight = height(node.right);\n        \n        maxDiameter = Math.max(maxDiameter, leftHeight + rightHeight);\n        \n        int h = 1 + Math.max(leftHeight, rightHeight);\n        heightMemo.put(node, h);\n        return h;\n    }\n}"
    },
    {
      "id": 53,
      "question": "What are common linked list manipulation patterns?",
      "answer": "Linked list manipulation involves various pointer manipulation techniques to solve problems efficiently without extra space.\n\nCommon Patterns:\n• Dummy head node - simplifies edge cases\n• Fast and slow pointers - cycle detection\n• Multiple pointers - various distances apart\n• Reverse in groups - k-group reversal\n• Runner technique - middle finding\n\nPointer Techniques:\n• prev, curr, next for reversal\n• fast (2x) and slow (1x) for cycles\n• Keep k nodes apart for nth from end\n\nCommon Operations:\n• Reverse - iterative or recursive\n• Detect cycle - Floyd's algorithm\n• Find middle - slow/fast pointers\n• Remove nth from end - two pointers\n• Merge lists - pointer manipulation\n\nBest Practices:\n• Use dummy node for head modifications\n• Check null pointers carefully\n• Draw diagrams for complex operations\n• Test with edge cases (empty, single node)",
      "explanation": "Linked list patterns use pointer manipulation techniques like dummy nodes, fast/slow pointers, and careful traversal to solve problems in-place without extra space.",
      "difficulty": "Medium",
      "code": "class LinkedListPatterns {\n    // Reverse linked list - iterative\n    public ListNode reverse(ListNode head) {\n        ListNode prev = null, curr = head;\n        while (curr != null) {\n            ListNode next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n    \n    // Reverse in k groups\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode prevGroup = dummy;\n        \n        while (true) {\n            ListNode kth = getKth(prevGroup, k);\n            if (kth == null) break;\n            \n            ListNode groupNext = kth.next;\n            ListNode prev = kth.next;\n            ListNode curr = prevGroup.next;\n            \n            while (curr != groupNext) {\n                ListNode next = curr.next;\n                curr.next = prev;\n                prev = curr;\n                curr = next;\n            }\n            \n            ListNode temp = prevGroup.next;\n            prevGroup.next = kth;\n            prevGroup = temp;\n        }\n        return dummy.next;\n    }\n    \n    private ListNode getKth(ListNode node, int k) {\n        while (node != null && k > 0) {\n            node = node.next;\n            k--;\n        }\n        return node;\n    }\n    \n    // Remove nth from end\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode first = dummy, second = dummy;\n        \n        for (int i = 0; i <= n; i++) {\n            first = first.next;\n        }\n        \n        while (first != null) {\n            first = first.next;\n            second = second.next;\n        }\n        \n        second.next = second.next.next;\n        return dummy.next;\n    }\n    \n    // Merge two sorted lists\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        \n        while (l1 != null && l2 != null) {\n            if (l1.data <= l2.data) {\n                curr.next = l1;\n                l1 = l1.next;\n            } else {\n                curr.next = l2;\n                l2 = l2.next;\n            }\n            curr = curr.next;\n        }\n        \n        curr.next = (l1 != null) ? l1 : l2;\n        return dummy.next;\n    }\n}"
    },
    {
      "id": 54,
      "question": "What are interval problems and common approaches to solve them?",
      "answer": "Interval problems involve working with ranges or intervals, common in scheduling, merging, and overlapping scenarios.\n\nCommon Interval Problems:\n• Merge overlapping intervals\n• Insert interval\n• Find non-overlapping intervals\n• Meeting rooms scheduling\n• Interval intersection\n\nKey Techniques:\n• Sort intervals by start time\n• Track end time of last interval\n• Use greedy approach for optimization\n• Sweep line algorithm\n• Priority queue for scheduling\n\nSorting Strategy:\n• Sort by start time - most common\n• Sort by end time - for scheduling\n• Custom comparator - for specific needs\n\nTime Complexity:\n• Usually O(n log n) due to sorting\n• O(n) after sorting for merging\n\nApplications:\n• Calendar scheduling\n• Resource allocation\n• Timeline management\n• Event processing",
      "explanation": "Interval problems typically require sorting intervals and using greedy approaches to merge, find overlaps, or optimize scheduling in O(n log n) time.",
      "difficulty": "Medium",
      "code": "class IntervalProblems {\n    // Merge overlapping intervals\n    public int[][] merge(int[][] intervals) {\n        if (intervals.length == 0) return new int[0][];\n        \n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n        List<int[]> merged = new ArrayList<>();\n        merged.add(intervals[0]);\n        \n        for (int i = 1; i < intervals.length; i++) {\n            int[] last = merged.get(merged.size() - 1);\n            int[] curr = intervals[i];\n            \n            if (curr[0] <= last[1]) {\n                last[1] = Math.max(last[1], curr[1]);\n            } else {\n                merged.add(curr);\n            }\n        }\n        \n        return merged.toArray(new int[merged.size()][]);\n    }\n    \n    // Insert interval\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        List<int[]> result = new ArrayList<>();\n        int i = 0;\n        \n        // Add all intervals before newInterval\n        while (i < intervals.length && intervals[i][1] < newInterval[0]) {\n            result.add(intervals[i++]);\n        }\n        \n        // Merge overlapping intervals\n        while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n            i++;\n        }\n        result.add(newInterval);\n        \n        // Add remaining intervals\n        while (i < intervals.length) {\n            result.add(intervals[i++]);\n        }\n        \n        return result.toArray(new int[result.size()][]);\n    }\n    \n    // Meeting rooms - can attend all?\n    public boolean canAttendMeetings(int[][] intervals) {\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n        \n        for (int i = 1; i < intervals.length; i++) {\n            if (intervals[i][0] < intervals[i-1][1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    // Minimum meeting rooms needed\n    public int minMeetingRooms(int[][] intervals) {\n        int[] starts = new int[intervals.length];\n        int[] ends = new int[intervals.length];\n        \n        for (int i = 0; i < intervals.length; i++) {\n            starts[i] = intervals[i][0];\n            ends[i] = intervals[i][1];\n        }\n        \n        Arrays.sort(starts);\n        Arrays.sort(ends);\n        \n        int rooms = 0, endIdx = 0;\n        for (int start : starts) {\n            if (start < ends[endIdx]) {\n                rooms++;\n            } else {\n                endIdx++;\n            }\n        }\n        return rooms;\n    }\n}"
    },
    {
      "id": 55,
      "question": "What are reservoir sampling and random selection algorithms?",
      "answer": "Reservoir sampling is a family of randomized algorithms for choosing k samples from a stream of unknown size with uniform probability.\n\nReservoir Sampling:\n• Select k items from stream of n items\n• Each item has k/n probability of selection\n• Space complexity O(k)\n• Single pass through stream\n• Works with unknown stream size\n\nAlgorithm Steps:\n• Fill reservoir with first k items\n• For item i > k:\n  - Generate random j in [0, i]\n  - If j < k, replace reservoir[j] with item i\n\nRandom Selection:\n• Select single random element - O(n) time, O(1) space\n• Weighted random selection - O(n) time\n• Random permutation - Fisher-Yates shuffle\n\nApplications:\n• Stream processing\n• Data sampling\n• Load balancing\n• Random testing\n\nVariants:\n• Weighted reservoir sampling\n• Distributed reservoir sampling\n• Online algorithms",
      "explanation": "Reservoir sampling selects k random items from a stream in one pass with O(k) space, ensuring each item has equal probability k/n of selection.",
      "difficulty": "Hard",
      "code": "class ReservoirSampling {\n    // Reservoir sampling for k items\n    public int[] reservoirSample(int[] stream, int k) {\n        int[] reservoir = new int[k];\n        Random rand = new Random();\n        \n        // Fill reservoir\n        for (int i = 0; i < k; i++) {\n            reservoir[i] = stream[i];\n        }\n        \n        // Process remaining items\n        for (int i = k; i < stream.length; i++) {\n            int j = rand.nextInt(i + 1);\n            if (j < k) {\n                reservoir[j] = stream[i];\n            }\n        }\n        \n        return reservoir;\n    }\n    \n    // Random selection from linked list\n    class Solution {\n        ListNode head;\n        Random rand = new Random();\n        \n        public Solution(ListNode head) {\n            this.head = head;\n        }\n        \n        public int getRandom() {\n            ListNode curr = head;\n            int result = curr.data;\n            int count = 1;\n            \n            while (curr != null) {\n                if (rand.nextInt(count) == 0) {\n                    result = curr.data;\n                }\n                count++;\n                curr = curr.next;\n            }\n            return result;\n        }\n    }\n    \n    // Weighted random selection\n    public int weightedRandom(int[] weights) {\n        int totalWeight = 0;\n        for (int w : weights) totalWeight += w;\n        \n        Random rand = new Random();\n        int random = rand.nextInt(totalWeight);\n        int sum = 0;\n        \n        for (int i = 0; i < weights.length; i++) {\n            sum += weights[i];\n            if (random < sum) {\n                return i;\n            }\n        }\n        return weights.length - 1;\n    }\n    \n    // Fisher-Yates shuffle\n    public void shuffle(int[] nums) {\n        Random rand = new Random();\n        for (int i = nums.length - 1; i > 0; i--) {\n            int j = rand.nextInt(i + 1);\n            int temp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = temp;\n        }\n    }\n}"
    },
    {
      "id": 56,
      "question": "What are common tree traversal variations and when to use them?",
      "answer": "Tree traversals visit nodes in specific orders, each suitable for different problem types and requirements.\n\nDepth-First Traversals:\n• Inorder (Left-Root-Right) - BST sorted order\n• Preorder (Root-Left-Right) - tree copying, prefix expression\n• Postorder (Left-Right-Root) - tree deletion, postfix expression\n\nBreadth-First Traversal:\n• Level Order - BFS, shortest path, level-wise processing\n\nSpecial Traversals:\n• Morris Traversal - O(1) space inorder/preorder\n• Zigzag Level Order - alternate left-right\n• Vertical Order - group by vertical columns\n• Boundary Traversal - anticlockwise boundary\n\nIterative Implementations:\n• Use stack for DFS\n• Use queue for BFS\n• Morris uses threading\n\nApplications:\n• Inorder - validate BST, sorted output\n• Preorder - serialize tree\n• Postorder - calculate expressions\n• Level order - min depth, level averages",
      "explanation": "Tree traversals include depth-first (inorder, preorder, postorder) and breadth-first (level order) approaches, each optimized for different tree problems and operations.",
      "difficulty": "Medium",
      "code": "class TreeTraversals {\n    // Morris Inorder - O(n) time, O(1) space\n    public List<Integer> morrisInorder(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        TreeNode curr = root;\n        \n        while (curr != null) {\n            if (curr.left == null) {\n                result.add(curr.data);\n                curr = curr.right;\n            } else {\n                TreeNode pred = curr.left;\n                while (pred.right != null && pred.right != curr) {\n                    pred = pred.right;\n                }\n                \n                if (pred.right == null) {\n                    pred.right = curr;\n                    curr = curr.left;\n                } else {\n                    pred.right = null;\n                    result.add(curr.data);\n                    curr = curr.right;\n                }\n            }\n        }\n        return result;\n    }\n    \n    // Zigzag level order\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (root == null) return result;\n        \n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        boolean leftToRight = true;\n        \n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            List<Integer> level = new ArrayList<>();\n            \n            for (int i = 0; i < size; i++) {\n                TreeNode node = queue.poll();\n                \n                if (leftToRight) {\n                    level.add(node.data);\n                } else {\n                    level.add(0, node.data);\n                }\n                \n                if (node.left != null) queue.offer(node.left);\n                if (node.right != null) queue.offer(node.right);\n            }\n            \n            result.add(level);\n            leftToRight = !leftToRight;\n        }\n        return result;\n    }\n    \n    // Vertical order traversal\n    public List<List<Integer>> verticalOrder(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (root == null) return result;\n        \n        Map<Integer, List<Integer>> map = new TreeMap<>();\n        Queue<Pair<TreeNode, Integer>> queue = new LinkedList<>();\n        queue.offer(new Pair<>(root, 0));\n        \n        while (!queue.isEmpty()) {\n            Pair<TreeNode, Integer> pair = queue.poll();\n            TreeNode node = pair.getKey();\n            int col = pair.getValue();\n            \n            map.computeIfAbsent(col, k -> new ArrayList<>()).add(node.data);\n            \n            if (node.left != null) {\n                queue.offer(new Pair<>(node.left, col - 1));\n            }\n            if (node.right != null) {\n                queue.offer(new Pair<>(node.right, col + 1));\n            }\n        }\n        \n        result.addAll(map.values());\n        return result;\n    }\n    \n    // Boundary traversal\n    public List<Integer> boundaryTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        if (root == null) return result;\n        \n        result.add(root.data);\n        addLeftBoundary(root.left, result);\n        addLeaves(root.left, result);\n        addLeaves(root.right, result);\n        addRightBoundary(root.right, result);\n        \n        return result;\n    }\n    \n    private void addLeftBoundary(TreeNode node, List<Integer> result) {\n        if (node == null || (node.left == null && node.right == null)) return;\n        result.add(node.data);\n        if (node.left != null) addLeftBoundary(node.left, result);\n        else addLeftBoundary(node.right, result);\n    }\n    \n    private void addRightBoundary(TreeNode node, List<Integer> result) {\n        if (node == null || (node.left == null && node.right == null)) return;\n        if (node.right != null) addRightBoundary(node.right, result);\n        else addRightBoundary(node.left, result);\n        result.add(node.data);\n    }\n    \n    private void addLeaves(TreeNode node, List<Integer> result) {\n        if (node == null) return;\n        if (node.left == null && node.right == null) {\n            result.add(node.data);\n            return;\n        }\n        addLeaves(node.left, result);\n        addLeaves(node.right, result);\n    }\n}"
    },
    {
      "id": 57,
      "question": "What is the difference between mutable and immutable data structures?",
      "answer": "Mutable and immutable data structures differ in whether they can be modified after creation, affecting performance, thread-safety, and design patterns.\n\nMutable Data Structures:\n• Can be modified after creation\n• In-place operations possible\n• Better performance for frequent updates\n• Not thread-safe by default\n• Examples: ArrayList, HashMap, StringBuilder\n\nImmutable Data Structures:\n• Cannot be modified after creation\n• Operations create new instances\n• Thread-safe by default\n• Easier reasoning about code\n• Examples: String, Integer, Collections.unmodifiableList\n\nPerformance Considerations:\n• Mutable: Better for heavy modifications\n• Immutable: Extra object creation overhead\n• Structural sharing can optimize immutable structures\n\nUse Cases:\n• Mutable: Algorithm implementations, local computations\n• Immutable: Hash keys, concurrent programming, caching\n\nDesign Impact:\n• Immutable enables pure functions\n• Prevents accidental modifications\n• Simplifies debugging",
      "explanation": "Mutable structures can be modified in-place offering better performance, while immutable structures create new instances providing thread-safety and predictability.",
      "difficulty": "Easy",
      "code": "// Mutable Examples\nList<Integer> mutableList = new ArrayList<>();\nmutableList.add(1); // Modifies existing list\nmutableList.set(0, 2); // Changes element\n\nMap<String, Integer> mutableMap = new HashMap<>();\nmutableMap.put(\"key\", 1); // Modifies map\n\nStringBuilder sb = new StringBuilder(\"hello\");\nsb.append(\" world\"); // Modifies in place\n\n// Immutable Examples\nString immutableStr = \"hello\";\nimmutableStr = immutableStr + \" world\"; // Creates new string\n\nInteger immutableInt = 5;\nimmutableInt = immutableInt + 1; // Creates new Integer\n\nList<Integer> immutableList = List.of(1, 2, 3); // Java 9+\n// immutableList.add(4); // Throws UnsupportedOperationException\n\n// Make mutable structure immutable\nList<Integer> original = new ArrayList<>();\noriginal.add(1);\nList<Integer> unmodifiable = Collections.unmodifiableList(original);\n// unmodifiable.add(2); // Throws exception\n\n// Custom immutable class\nfinal class ImmutablePoint {\n    private final int x;\n    private final int y;\n    \n    public ImmutablePoint(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n    \n    public int getX() { return x; }\n    public int getY() { return y; }\n    \n    // Returns new instance instead of modifying\n    public ImmutablePoint move(int dx, int dy) {\n        return new ImmutablePoint(x + dx, y + dy);\n    }\n}\n\n// Thread-safety comparison\nclass ThreadSafetyExample {\n    // Mutable - needs synchronization\n    private List<Integer> mutableList = new ArrayList<>();\n    \n    public synchronized void addMutable(int value) {\n        mutableList.add(value);\n    }\n    \n    // Immutable - no synchronization needed\n    private volatile List<Integer> immutableList = List.of();\n    \n    public void setImmutable(List<Integer> newList) {\n        immutableList = List.copyOf(newList);\n    }\n}"
    },
    {
      "id": 58,
      "question": "What are common graph coloring algorithms and their applications?",
      "answer": "Graph coloring assigns colors to vertices such that no adjacent vertices have the same color, with various algorithms and applications.\n\nGraph Coloring Problem:\n• Assign minimum colors to vertices\n• No adjacent vertices share color\n• NP-complete for general graphs\n• Polynomial for specific graph types\n\nCommon Algorithms:\n• Greedy Coloring - O(V + E), may not be optimal\n• Backtracking - Exponential, finds optimal\n• Welsh-Powell - Sorts by degree, better greedy\n• DSatur - Dynamic saturation degree\n\nChromatic Number:\n• Minimum colors needed\n• χ(graph) = 1 for empty graph\n• χ(graph) = 2 for bipartite\n• χ(complete graph) = n vertices\n\nSpecial Cases:\n• Bipartite - 2 colors, BFS/DFS check\n• Planar graphs - at most 4 colors (4-color theorem)\n• Trees - 2 colors (bipartite)\n\nApplications:\n• Register allocation in compilers\n• Scheduling problems\n• Map coloring\n• Sudoku solving\n• Frequency assignment",
      "explanation": "Graph coloring assigns colors to vertices ensuring no adjacent vertices share colors, using greedy or backtracking algorithms for scheduling and resource allocation problems.",
      "difficulty": "Hard",
      "code": "class GraphColoring {\n    // Greedy coloring - O(V + E)\n    public int[] greedyColoring(List<List<Integer>> graph) {\n        int vertices = graph.size();\n        int[] colors = new int[vertices];\n        Arrays.fill(colors, -1);\n        \n        colors[0] = 0;\n        boolean[] available = new boolean[vertices];\n        \n        for (int v = 1; v < vertices; v++) {\n            Arrays.fill(available, true);\n            \n            for (int neighbor : graph.get(v)) {\n                if (colors[neighbor] != -1) {\n                    available[colors[neighbor]] = false;\n                }\n            }\n            \n            for (int color = 0; color < vertices; color++) {\n                if (available[color]) {\n                    colors[v] = color;\n                    break;\n                }\n            }\n        }\n        return colors;\n    }\n    \n    // Check if graph is bipartite (2-colorable)\n    public boolean isBipartite(int[][] graph) {\n        int n = graph.length;\n        int[] colors = new int[n];\n        Arrays.fill(colors, -1);\n        \n        for (int start = 0; start < n; start++) {\n            if (colors[start] == -1) {\n                Queue<Integer> queue = new LinkedList<>();\n                queue.offer(start);\n                colors[start] = 0;\n                \n                while (!queue.isEmpty()) {\n                    int node = queue.poll();\n                    \n                    for (int neighbor : graph[node]) {\n                        if (colors[neighbor] == -1) {\n                            colors[neighbor] = 1 - colors[node];\n                            queue.offer(neighbor);\n                        } else if (colors[neighbor] == colors[node]) {\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    \n    // M-coloring using backtracking\n    public boolean mColoring(int[][] graph, int m) {\n        int vertices = graph.length;\n        int[] colors = new int[vertices];\n        return mColoringUtil(graph, m, colors, 0, vertices);\n    }\n    \n    private boolean mColoringUtil(int[][] graph, int m, int[] colors, \n                                  int v, int vertices) {\n        if (v == vertices) return true;\n        \n        for (int color = 1; color <= m; color++) {\n            if (isSafe(graph, colors, v, color, vertices)) {\n                colors[v] = color;\n                if (mColoringUtil(graph, m, colors, v + 1, vertices)) {\n                    return true;\n                }\n                colors[v] = 0;\n            }\n        }\n        return false;\n    }\n    \n    private boolean isSafe(int[][] graph, int[] colors, int v, \n                          int color, int vertices) {\n        for (int i = 0; i < vertices; i++) {\n            if (graph[v][i] == 1 && colors[i] == color) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"
    },
    {
      "id": 59,
      "question": "What are common approaches to solve the longest increasing subsequence problem?",
      "answer": "The Longest Increasing Subsequence (LIS) problem finds the longest subsequence where elements are in strictly increasing order.\n\nApproach 1 - Dynamic Programming:\n• Time: O(n²), Space: O(n)\n• dp[i] = length of LIS ending at i\n• For each i, check all j < i where arr[j] < arr[i]\n• dp[i] = max(dp[j] + 1) for valid j\n\nApproach 2 - Binary Search with Patience Sorting:\n• Time: O(n log n), Space: O(n)\n• Maintain array of smallest tail elements\n• Binary search for insertion position\n• Most efficient approach\n\nApproach 3 - Segment Tree:\n• Time: O(n log n), Space: O(n)\n• Good for online queries\n• Complex implementation\n\nExtensions:\n• Longest Decreasing Subsequence\n• Number of LIS\n• LIS with sum constraints\n• 2D LIS (Russian Doll problem)\n\nApplications:\n• Stock price analysis\n• Version control\n• Patience sorting card game",
      "explanation": "LIS can be solved in O(n²) with DP or O(n log n) with binary search, maintaining smallest tail elements for each subsequence length.",
      "difficulty": "Hard",
      "code": "class LongestIncreasingSubsequence {\n    // DP approach - O(n²)\n    public int lengthOfLIS_DP(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        Arrays.fill(dp, 1);\n        int maxLen = 1;\n        \n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (nums[j] < nums[i]) {\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                }\n            }\n            maxLen = Math.max(maxLen, dp[i]);\n        }\n        return maxLen;\n    }\n    \n    // Binary Search - O(n log n)\n    public int lengthOfLIS(int[] nums) {\n        List<Integer> tails = new ArrayList<>();\n        \n        for (int num : nums) {\n            int pos = binarySearch(tails, num);\n            if (pos == tails.size()) {\n                tails.add(num);\n            } else {\n                tails.set(pos, num);\n            }\n        }\n        return tails.size();\n    }\n    \n    private int binarySearch(List<Integer> tails, int target) {\n        int left = 0, right = tails.size();\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (tails.get(mid) < target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n    \n    // LIS with actual subsequence\n    public List<Integer> findLIS(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        int[] parent = new int[n];\n        Arrays.fill(dp, 1);\n        Arrays.fill(parent, -1);\n        \n        int maxLen = 1;\n        int maxIndex = 0;\n        \n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (nums[j] < nums[i] && dp[j] + 1 > dp[i]) {\n                    dp[i] = dp[j] + 1;\n                    parent[i] = j;\n                }\n            }\n            if (dp[i] > maxLen) {\n                maxLen = dp[i];\n                maxIndex = i;\n            }\n        }\n        \n        List<Integer> lis = new ArrayList<>();\n        for (int i = maxIndex; i != -1; i = parent[i]) {\n            lis.add(nums[i]);\n        }\n        Collections.reverse(lis);\n        return lis;\n    }\n    \n    // Count number of LIS\n    public int findNumberOfLIS(int[] nums) {\n        int n = nums.length;\n        int[] lengths = new int[n];\n        int[] counts = new int[n];\n        Arrays.fill(lengths, 1);\n        Arrays.fill(counts, 1);\n        \n        int maxLen = 1;\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (nums[j] < nums[i]) {\n                    if (lengths[j] + 1 > lengths[i]) {\n                        lengths[i] = lengths[j] + 1;\n                        counts[i] = counts[j];\n                    } else if (lengths[j] + 1 == lengths[i]) {\n                        counts[i] += counts[j];\n                    }\n                }\n            }\n            maxLen = Math.max(maxLen, lengths[i]);\n        }\n        \n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (lengths[i] == maxLen) {\n                result += counts[i];\n            }\n        }\n        return result;\n    }\n}"
    },
    {
      "id": 60,
      "question": "What is the edit distance problem and how is it solved?",
      "answer": "Edit distance (Levenshtein distance) measures the minimum number of operations needed to transform one string into another.\n\nAllowed Operations:\n• Insert a character\n• Delete a character\n• Replace a character\n\nDynamic Programming Solution:\n• Time Complexity - O(m × n)\n• Space Complexity - O(m × n) or O(min(m,n)) optimized\n• Build 2D DP table\n• dp[i][j] = min operations for s1[0..i] to s2[0..j]\n\nRecurrence Relation:\n• If s1[i] == s2[j]: dp[i][j] = dp[i-1][j-1]\n• Else: dp[i][j] = 1 + min(\n  - dp[i-1][j]   (delete)\n  - dp[i][j-1]   (insert)\n  - dp[i-1][j-1] (replace)\n)\n\nApplications:\n• Spell checkers\n• DNA sequence alignment\n• Plagiarism detection\n• Fuzzy string matching\n• Auto-correction\n\nVariants:\n• Longest Common Subsequence\n• One Edit Distance\n• Wildcard matching",
      "explanation": "Edit distance uses DP to find minimum insertions, deletions, and replacements to transform one string to another in O(m×n) time.",
      "difficulty": "Hard",
      "code": "class EditDistance {\n    // Edit distance - O(m × n)\n    public int minDistance(String word1, String word2) {\n        int m = word1.length();\n        int n = word2.length();\n        int[][] dp = new int[m + 1][n + 1];\n        \n        // Base cases\n        for (int i = 0; i <= m; i++) {\n            dp[i][0] = i;\n        }\n        for (int j = 0; j <= n; j++) {\n            dp[0][j] = j;\n        }\n        \n        // Fill DP table\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = 1 + Math.min(Math.min(\n                        dp[i - 1][j],     // Delete\n                        dp[i][j - 1]),    // Insert\n                        dp[i - 1][j - 1]  // Replace\n                    );\n                }\n            }\n        }\n        return dp[m][n];\n    }\n    \n    // Space optimized - O(min(m,n))\n    public int minDistanceOptimized(String word1, String word2) {\n        if (word1.length() < word2.length()) {\n            return minDistanceOptimized(word2, word1);\n        }\n        \n        int n = word2.length();\n        int[] prev = new int[n + 1];\n        int[] curr = new int[n + 1];\n        \n        for (int j = 0; j <= n; j++) {\n            prev[j] = j;\n        }\n        \n        for (int i = 1; i <= word1.length(); i++) {\n            curr[0] = i;\n            for (int j = 1; j <= n; j++) {\n                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                    curr[j] = prev[j - 1];\n                } else {\n                    curr[j] = 1 + Math.min(Math.min(\n                        prev[j], curr[j - 1]), prev[j - 1]\n                    );\n                }\n            }\n            int[] temp = prev;\n            prev = curr;\n            curr = temp;\n        }\n        return prev[n];\n    }\n    \n    // One edit distance\n    public boolean isOneEditDistance(String s, String t) {\n        int m = s.length(), n = t.length();\n        if (Math.abs(m - n) > 1) return false;\n        \n        int i = 0, j = 0;\n        boolean foundDiff = false;\n        \n        while (i < m && j < n) {\n            if (s.charAt(i) != t.charAt(j)) {\n                if (foundDiff) return false;\n                foundDiff = true;\n                \n                if (m > n) {\n                    i++;\n                } else if (m < n) {\n                    j++;\n                } else {\n                    i++;\n                    j++;\n                }\n            } else {\n                i++;\n                j++;\n            }\n        }\n        \n        return foundDiff || Math.abs(m - n) == 1;\n    }\n}"
    },
    {
      "id": 61,
      "question": "What is a binary heap and what are its properties?",
      "answer": "A binary heap is a complete binary tree that satisfies the heap property, commonly used to implement priority queues.\n\nHeap Property:\n• Max Heap - Parent >= Children\n• Min Heap - Parent <= Children\n• Complete binary tree (all levels filled except last)\n• Last level filled left to right\n\nArray Representation:\n• Parent of i at (i-1)/2\n• Left child at 2i + 1\n• Right child at 2i + 2\n• Efficient storage, no pointers needed\n\nOperations:\n• Insert - O(log n) - add at end, heapify up\n• Extract min/max - O(log n) - remove root, heapify down\n• Peek - O(1) - view root\n• Build heap - O(n) - bottom-up heapify\n• Decrease/increase key - O(log n)\n\nHeapify Operations:\n• Heapify Up - bubble element up\n• Heapify Down - percolate element down\n\nApplications:\n• Priority queues\n• Heap sort\n• Graph algorithms (Dijkstra, Prim)\n• K largest/smallest elements\n• Median finding",
      "explanation": "Binary heap is a complete tree satisfying heap property where parent is greater (max heap) or smaller (min heap) than children, enabling O(log n) operations.",
      "difficulty": "Medium",
      "code": "// See DSA-part4.json for complete Min Heap implementation"
    },
    {
      "id": 62,
      "question": "What are common approaches to solve the coin change problem?",
      "answer": "The coin change problem has two variants: finding minimum coins and counting ways to make change.\n\nMinimum Coins Problem:\n• Dynamic Programming - O(amount × n)\n• dp[i] = minimum coins for amount i\n• dp[i] = min(dp[i], dp[i - coin] + 1)\n• Bottom-up approach\n\nCount Ways Problem:\n• Dynamic Programming - O(amount × n)\n• dp[i] = ways to make amount i\n• dp[i] += dp[i - coin]\n• Order matters for combinations\n\nUnbounded Knapsack:\n• Coin change is special case\n• Unlimited quantity of each coin\n• Can use same coin multiple times\n\nOptimization:\n• Space: 1D array instead of 2D\n• Early termination if amount reached\n• Greedy works for some denominations\n\nVariants:\n• Minimum coins with limit\n• Coin change with exact coins\n• Maximum ways with constraints",
      "explanation": "Coin change uses DP to find minimum coins (O(amount×n)) or count ways to make change, treating it as an unbounded knapsack problem.",
      "difficulty": "Medium",
      "code": "class CoinChange {\n    // Minimum coins - O(amount × n)\n    public int coinChange(int[] coins, int amount) {\n        int[] dp = new int[amount + 1];\n        Arrays.fill(dp, amount + 1);\n        dp[0] = 0;\n        \n        for (int i = 1; i <= amount; i++) {\n            for (int coin : coins) {\n                if (i >= coin) {\n                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n                }\n            }\n        }\n        return dp[amount] > amount ? -1 : dp[amount];\n    }\n    \n    // Count ways - O(amount × n)\n    public int change(int amount, int[] coins) {\n        int[] dp = new int[amount + 1];\n        dp[0] = 1;\n        \n        for (int coin : coins) {\n            for (int i = coin; i <= amount; i++) {\n                dp[i] += dp[i - coin];\n            }\n        }\n        return dp[amount];\n    }\n    \n    // With coin count limit\n    public int coinChangeWithLimit(int[] coins, int amount, int maxCoins) {\n        int[][] dp = new int[amount + 1][maxCoins + 1];\n        for (int[] row : dp) Arrays.fill(row, amount + 1);\n        for (int k = 0; k <= maxCoins; k++) dp[0][k] = 0;\n        \n        for (int i = 1; i <= amount; i++) {\n            for (int k = 1; k <= maxCoins; k++) {\n                for (int coin : coins) {\n                    if (i >= coin) {\n                        dp[i][k] = Math.min(dp[i][k], dp[i - coin][k - 1] + 1);\n                    }\n                }\n            }\n        }\n        return dp[amount][maxCoins] > amount ? -1 : dp[amount][maxCoins];\n    }\n}"
    },
    {
      "id": 63,
      "question": "What is a Red-Black tree and what are its properties?",
      "answer": "A Red-Black tree is a self-balancing binary search tree with color properties that guarantee O(log n) operations.\n\nRed-Black Properties:\n• Every node is either red or black\n• Root is always black\n• All leaves (NIL) are black\n• Red node has black children (no two consecutive reds)\n• All paths from node to leaves have same number of black nodes\n\nBalance Guarantee:\n• Height at most 2 × log(n + 1)\n• Less rigid than AVL trees\n• Faster insertion/deletion than AVL\n• Slightly slower search than AVL\n\nOperations:\n• Search - O(log n)\n• Insert - O(log n)\n• Delete - O(log n)\n• All operations guaranteed O(log n)\n\nRebalancing:\n• Color flips\n• Rotations (left, right)\n• Uncle node color determines action\n\nRed-Black vs AVL:\n• RB: Less rigid balance, faster inserts/deletes\n• AVL: Stricter balance, faster searches\n• RB: Max 2 rotations for insert\n• AVL: May need many rotations\n\nApplications:\n• Java TreeMap, TreeSet\n• C++ map, set\n• Linux kernel scheduler",
      "explanation": "Red-Black trees use color properties and rotations to maintain O(log n) height, offering faster insertions/deletions than AVL with slightly slower searches.",
      "difficulty": "Hard",
      "code": "// Red-Black Tree is complex - typically use library implementations\n// Java TreeMap/TreeSet use Red-Black trees\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n// Usage examples\nTreeMap<Integer, String> rbMap = new TreeMap<>();\nrbMap.put(1, \"one\");\nrbMap.put(3, \"three\");\nrbMap.put(2, \"two\");\n// Automatically balanced\n\nTreeSet<Integer> rbSet = new TreeSet<>();\nrbSet.add(5);\nrbSet.add(2);\nrbSet.add(8);\n// Maintains sorted order with O(log n) operations"
    },
    {
      "id": 64,
      "question": "What are common divide and conquer algorithms and their applications?",
      "answer": "Divide and Conquer breaks problems into independent subproblems, solves recursively, then combines solutions.\n\nKey Steps:\n• Divide - Break into smaller subproblems\n• Conquer - Solve subproblems recursively\n• Combine - Merge solutions\n\nCommon Algorithms:\n• Merge Sort - O(n log n) sorting\n• Quick Sort - O(n log n) average sorting\n• Binary Search - O(log n) search\n• Strassen Matrix Multiplication - O(n^2.807)\n• Closest Pair of Points - O(n log n)\n• Karatsuba Multiplication - O(n^1.585)\n\nCharacteristics:\n• Independent subproblems (no overlap)\n• Optimal substructure\n• Usually recursive\n• Often O(n log n) complexity\n\nApplications:\n• Sorting algorithms\n• Searching in sorted data\n• Fast Fourier Transform\n• Matrix operations\n• Computational geometry\n\nRecurrence Relations:\n• T(n) = aT(n/b) + f(n)\n• Master theorem solves many cases",
      "explanation": "Divide and conquer recursively splits problems into independent subproblems, commonly achieving O(n log n) complexity for sorting, searching, and computational problems.",
      "difficulty": "Medium",
      "code": "// See previous examples for Merge Sort, Binary Search\n// Closest Pair of Points - O(n log n)\nclass ClosestPair {\n    class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    public double closestPair(Point[] points) {\n        Arrays.sort(points, (a, b) -> Double.compare(a.x, b.x));\n        return closestPairUtil(points, 0, points.length - 1);\n    }\n    \n    private double closestPairUtil(Point[] points, int left, int right) {\n        if (right - left <= 3) {\n            return bruteForce(points, left, right);\n        }\n        \n        int mid = left + (right - left) / 2;\n        double leftMin = closestPairUtil(points, left, mid);\n        double rightMin = closestPairUtil(points, mid + 1, right);\n        double minDist = Math.min(leftMin, rightMin);\n        \n        return stripClosest(points, left, right, mid, minDist);\n    }\n    \n    private double bruteForce(Point[] points, int left, int right) {\n        double min = Double.MAX_VALUE;\n        for (int i = left; i <= right; i++) {\n            for (int j = i + 1; j <= right; j++) {\n                min = Math.min(min, distance(points[i], points[j]));\n            }\n        }\n        return min;\n    }\n    \n    private double stripClosest(Point[] points, int left, int right, \n                                int mid, double minDist) {\n        double midX = points[mid].x;\n        List<Point> strip = new ArrayList<>();\n        \n        for (int i = left; i <= right; i++) {\n            if (Math.abs(points[i].x - midX) < minDist) {\n                strip.add(points[i]);\n            }\n        }\n        \n        strip.sort((a, b) -> Double.compare(a.y, b.y));\n        \n        for (int i = 0; i < strip.size(); i++) {\n            for (int j = i + 1; j < strip.size() && \n                 (strip.get(j).y - strip.get(i).y) < minDist; j++) {\n                minDist = Math.min(minDist, \n                                  distance(strip.get(i), strip.get(j)));\n            }\n        }\n        return minDist;\n    }\n    \n    private double distance(Point p1, Point p2) {\n        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n    }\n}"
    },
    {
      "id": 65,
      "question": "What is the Master Theorem and how is it used for analyzing recursive algorithms?",
      "answer": "The Master Theorem provides a cookbook method for solving recurrence relations of the form T(n) = aT(n/b) + f(n).\n\nMaster Theorem Formula:\nT(n) = aT(n/b) + f(n) where:\n• a >= 1 (number of subproblems)\n• b > 1 (factor by which size reduces)\n• f(n) is asymptotically positive\n\nThree Cases:\n1. If f(n) = O(n^(log_b(a) - ε)) for ε > 0:\n   T(n) = Θ(n^log_b(a))\n\n2. If f(n) = Θ(n^log_b(a)):\n   T(n) = Θ(n^log_b(a) × log n)\n\n3. If f(n) = Ω(n^(log_b(a) + ε)) and af(n/b) <= cf(n):\n   T(n) = Θ(f(n))\n\nCommon Examples:\n• Merge Sort: T(n) = 2T(n/2) + O(n) → Case 2 → O(n log n)\n• Binary Search: T(n) = T(n/2) + O(1) → Case 2 → O(log n)\n• Strassen: T(n) = 7T(n/2) + O(n²) → Case 1 → O(n^2.807)\n\nLimitations:\n• Only works for specific recurrence form\n• f(n) must be polynomial\n• Doesn't cover all cases",
      "explanation": "Master Theorem solves recurrences T(n)=aT(n/b)+f(n) by comparing f(n) with n^(log_b a), determining complexity based on which dominates.",
      "difficulty": "Hard",
      "code": "// Master Theorem Examples\n\n// Example 1: Merge Sort\n// T(n) = 2T(n/2) + n\n// a=2, b=2, f(n)=n\n// log_b(a) = log_2(2) = 1\n// f(n) = n = Θ(n^1)\n// Case 2: T(n) = Θ(n log n)\n\n// Example 2: Binary Search\n// T(n) = T(n/2) + 1\n// a=1, b=2, f(n)=1\n// log_b(a) = log_2(1) = 0\n// f(n) = 1 = Θ(n^0)\n// Case 2: T(n) = Θ(log n)\n\n// Example 3: Recursive Tree Traversal\n// T(n) = 2T(n/2) + 1\n// a=2, b=2, f(n)=1\n// log_b(a) = 1\n// f(n) = 1 = O(n^(1-ε))\n// Case 1: T(n) = Θ(n)\n\n// Example 4: Strassen Matrix Multiplication\n// T(n) = 7T(n/2) + n²\n// a=7, b=2, f(n)=n²\n// log_b(a) = log_2(7) ≈ 2.807\n// f(n) = n² = O(n^(2.807-ε))\n// Case 1: T(n) = Θ(n^2.807)\n\n// Example 5: Invalid for Master Theorem\n// T(n) = 2T(n/2) + n log n\n// f(n) is not polynomial different from n^log_b(a)\n// Master Theorem doesn't directly apply"
    },
    {
      "id": 66,
      "question": "What are B-trees and B+ trees and where are they used?",
      "answer": "B-trees and B+ trees are self-balancing tree structures optimized for systems that read/write large blocks of data, commonly used in databases and file systems.\n\nB-Tree Properties:\n• All leaves at same level\n• Node can have multiple keys (not just 2)\n• Order m: node has at most m children\n• Internal nodes store keys and data\n• Minimizes disk I/O operations\n• Height is O(log n)\n\nB+ Tree Properties:\n• All data in leaf nodes\n• Internal nodes only store keys\n• Leaves form linked list\n• Better range queries\n• More efficient sequential access\n\nB-Tree vs B+ Tree:\n• B-tree: Data in all nodes\n• B+ tree: Data only in leaves\n• B+ tree: Better for scans\n• B+ tree: More cache-friendly\n\nOperations:\n• Search - O(log n)\n• Insert - O(log n)\n• Delete - O(log n)\n• Range query - O(log n + k)\n\nApplications:\n• Database indexing\n• File systems (NTFS, ext4)\n• MongoDB, PostgreSQL indexes",
      "explanation": "B-trees and B+ trees are multi-way trees optimized for disk operations, with B+ trees storing data only in leaves for better range queries and sequential access.",
      "difficulty": "Hard",
      "code": "// B-tree and B+ tree implementations are complex\n// Used internally by databases\n// Java example of database index usage:\n\n// SQL with B-tree index\n// CREATE INDEX idx_user_id ON users(user_id);\n// B-tree index enables fast lookups\n\n// Range queries benefit from B+ tree\n// SELECT * FROM users WHERE age BETWEEN 20 AND 30;\n// B+ tree linked leaves enable efficient range scan\n\n// Conceptual B-tree node\nclass BTreeNode {\n    int t; // Minimum degree\n    int[] keys;\n    BTreeNode[] children;\n    int n; // Current number of keys\n    boolean leaf;\n    \n    BTreeNode(int t, boolean leaf) {\n        this.t = t;\n        this.leaf = leaf;\n        this.keys = new int[2 * t - 1];\n        this.children = new BTreeNode[2 * t];\n        this.n = 0;\n    }\n    \n    // Search in B-tree node\n    BTreeNode search(int key) {\n        int i = 0;\n        while (i < n && key > keys[i]) {\n            i++;\n        }\n        \n        if (i < n && keys[i] == key) {\n            return this;\n        }\n        \n        if (leaf) {\n            return null;\n        }\n        \n        return children[i].search(key);\n    }\n}"
    },
    {
      "id": 67,
      "question": "What is amortized analysis and what are common examples?",
      "answer": "Amortized analysis determines the average time per operation over a sequence of operations, providing tighter bounds than worst-case analysis.\n\nAnalysis Methods:\n• Aggregate Method - Total cost / number of operations\n• Accounting Method - Assign different charges to operations\n• Potential Method - Define potential function\n\nKey Concept:\n• Some operations expensive\n• Others cheap\n• Average over sequence is low\n• Not same as average-case\n\nCommon Examples:\n• Dynamic Array - O(1) amortized append\n• Stack with multipop - O(1) amortized\n• Binary counter - O(1) amortized increment\n• Disjoint set union - O(α(n)) amortized\n• Splay trees - O(log n) amortized\n\nDynamic Array Analysis:\n• Double size when full\n• Individual insert can be O(n)\n• Amortized over n inserts: O(1)\n• Doubling happens O(log n) times\n\nWhen to Use:\n• Occasional expensive operations\n• Overall performance matters\n• Data structure design",
      "explanation": "Amortized analysis calculates average operation time over a sequence, showing that occasional expensive operations are offset by many cheap ones for O(1) average.",
      "difficulty": "Hard",
      "code": "// Dynamic Array with amortized O(1) append\nclass DynamicArray {\n    private int[] arr;\n    private int size;\n    private int capacity;\n    \n    public DynamicArray() {\n        capacity = 1;\n        arr = new int[capacity];\n        size = 0;\n    }\n    \n    // Amortized O(1)\n    public void append(int value) {\n        if (size == capacity) {\n            resize();\n        }\n        arr[size++] = value;\n    }\n    \n    private void resize() {\n        capacity *= 2;\n        int[] newArr = new int[capacity];\n        System.arraycopy(arr, 0, newArr, 0, size);\n        arr = newArr;\n    }\n    \n    // Analysis:\n    // Insert 1: cost = 1\n    // Insert 2: cost = 2 (copy 1 + insert 1)\n    // Insert 3: cost = 3 (copy 2 + insert 1)\n    // Insert 5: cost = 5 (copy 4 + insert 1)\n    // Total for n inserts ≈ 2n\n    // Amortized: 2n/n = O(1)\n}\n\n// Binary Counter - O(1) amortized increment\nclass BinaryCounter {\n    private boolean[] bits;\n    \n    public BinaryCounter(int n) {\n        bits = new boolean[n];\n    }\n    \n    // Amortized O(1)\n    public void increment() {\n        int i = 0;\n        while (i < bits.length && bits[i]) {\n            bits[i] = false;\n            i++;\n        }\n        if (i < bits.length) {\n            bits[i] = true;\n        }\n    }\n    \n    // Analysis:\n    // Bit 0 flips every increment\n    // Bit 1 flips every 2 increments\n    // Bit i flips every 2^i increments\n    // Total flips in n increments < 2n\n    // Amortized: O(1)\n}"
    },
    {
      "id": 68,
      "question": "What are probabilistic data structures and what are common examples?",
      "answer": "Probabilistic data structures use randomization to trade accuracy for space/time efficiency, allowing small error probability.\n\nCharacteristics:\n• Space efficient\n• Fast operations\n• Small error probability\n• No false negatives (for some)\n• Deterministic bounds on error\n\nCommon Structures:\n• Bloom Filter - Set membership testing\n• Count-Min Sketch - Frequency estimation\n• HyperLogLog - Cardinality estimation\n• Skip List - Probabilistic balanced tree\n• Cuckoo Filter - Improved Bloom filter\n\nBloom Filter:\n• Test if element in set\n• Can have false positives\n• Never false negatives\n• Space: O(m) for m bits\n• Operations: O(k) for k hash functions\n\nApplications:\n• Cache systems\n• Databases (BigTable, Cassandra)\n• Network routers\n• Spell checkers\n• Distributed systems\n\nTrade-offs:\n• Space vs accuracy\n• Speed vs precision\n• Cannot remove elements (some structures)",
      "explanation": "Probabilistic structures like Bloom filters use randomization and hash functions for space-efficient operations with controlled error rates, accepting false positives for better performance.",
      "difficulty": "Hard",
      "code": "import java.util.*;\n\nclass BloomFilter {\n    private BitSet bitSet;\n    private int size;\n    private int numHashes;\n    \n    public BloomFilter(int size, int numHashes) {\n        this.size = size;\n        this.numHashes = numHashes;\n        this.bitSet = new BitSet(size);\n    }\n    \n    // Add element - O(k)\n    public void add(String element) {\n        for (int i = 0; i < numHashes; i++) {\n            int hash = hash(element, i);\n            bitSet.set(hash);\n        }\n    }\n    \n    // Check membership - O(k)\n    public boolean mightContain(String element) {\n        for (int i = 0; i < numHashes; i++) {\n            int hash = hash(element, i);\n            if (!bitSet.get(hash)) {\n                return false; // Definitely not present\n            }\n        }\n        return true; // Might be present (could be false positive)\n    }\n    \n    private int hash(String element, int seed) {\n        int hash = element.hashCode();\n        hash ^= (hash >>> 16);\n        hash *= 0x85ebca6b;\n        hash ^= (hash >>> 13);\n        hash *= 0xc2b2ae35 + seed;\n        hash ^= (hash >>> 16);\n        return Math.abs(hash % size);\n    }\n}\n\n// Skip List - O(log n) average operations\nclass SkipListNode {\n    int value;\n    SkipListNode[] forward;\n    \n    SkipListNode(int value, int level) {\n        this.value = value;\n        this.forward = new SkipListNode[level + 1];\n    }\n}\n\nclass SkipList {\n    private static final int MAX_LEVEL = 16;\n    private SkipListNode head;\n    private int level;\n    private Random rand;\n    \n    public SkipList() {\n        head = new SkipListNode(Integer.MIN_VALUE, MAX_LEVEL);\n        level = 0;\n        rand = new Random();\n    }\n    \n    private int randomLevel() {\n        int lvl = 0;\n        while (rand.nextDouble() < 0.5 && lvl < MAX_LEVEL) {\n            lvl++;\n        }\n        return lvl;\n    }\n    \n    public boolean search(int target) {\n        SkipListNode curr = head;\n        for (int i = level; i >= 0; i--) {\n            while (curr.forward[i] != null && \n                   curr.forward[i].value < target) {\n                curr = curr.forward[i];\n            }\n        }\n        curr = curr.forward[0];\n        return curr != null && curr.value == target;\n    }\n    \n    public void insert(int value) {\n        SkipListNode[] update = new SkipListNode[MAX_LEVEL + 1];\n        SkipListNode curr = head;\n        \n        for (int i = level; i >= 0; i--) {\n            while (curr.forward[i] != null && \n                   curr.forward[i].value < value) {\n                curr = curr.forward[i];\n            }\n            update[i] = curr;\n        }\n        \n        int newLevel = randomLevel();\n        if (newLevel > level) {\n            for (int i = level + 1; i <= newLevel; i++) {\n                update[i] = head;\n            }\n            level = newLevel;\n        }\n        \n        SkipListNode newNode = new SkipListNode(value, newLevel);\n        for (int i = 0; i <= newLevel; i++) {\n            newNode.forward[i] = update[i].forward[i];\n            update[i].forward[i] = newNode;\n        }\n    }\n}"
    },
    {
      "id": 69,
      "question": "What is the Traveling Salesman Problem and what approaches exist to solve it?",
      "answer": "The Traveling Salesman Problem (TSP) finds the shortest route visiting all cities exactly once and returning to start.\n\nProblem Characteristics:\n• NP-hard problem\n• No known polynomial solution\n• n! possible tours for n cities\n• Optimization problem\n\nExact Algorithms:\n• Brute Force - O(n!) - Try all permutations\n• Dynamic Programming - O(n² × 2^n) - Held-Karp\n• Branch and Bound - Prunes search space\n\nApproximate Algorithms:\n• Nearest Neighbor - O(n²) - Greedy heuristic\n• 2-Opt - O(n²) - Local search improvement\n• Genetic Algorithms - Evolutionary approach\n• Ant Colony Optimization - Swarm intelligence\n• Simulated Annealing - Probabilistic technique\n\nHeld-Karp DP:\n• dp[mask][i] = min cost visiting cities in mask, ending at i\n• Use bitmask for visited cities\n• Best exact algorithm for small n\n\nApplications:\n• Route optimization\n• Circuit board drilling\n• DNA sequencing\n• Logistics planning",
      "explanation": "TSP is NP-hard with no efficient exact solution; solved exactly with DP in O(n²×2^n) or approximately with heuristics like nearest neighbor and 2-opt.",
      "difficulty": "Hard",
      "code": "class TSP {\n    // Held-Karp DP - O(n² × 2^n)\n    public int tsp(int[][] graph) {\n        int n = graph.length;\n        int[][] dp = new int[1 << n][n];\n        \n        for (int[] row : dp) {\n            Arrays.fill(row, Integer.MAX_VALUE / 2);\n        }\n        dp[1][0] = 0;\n        \n        for (int mask = 1; mask < (1 << n); mask++) {\n            for (int last = 0; last < n; last++) {\n                if ((mask & (1 << last)) == 0) continue;\n                \n                for (int curr = 0; curr < n; curr++) {\n                    if ((mask & (1 << curr)) != 0) continue;\n                    \n                    int nextMask = mask | (1 << curr);\n                    dp[nextMask][curr] = Math.min(\n                        dp[nextMask][curr],\n                        dp[mask][last] + graph[last][curr]\n                    );\n                }\n            }\n        }\n        \n        int fullMask = (1 << n) - 1;\n        int result = Integer.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            result = Math.min(result, dp[fullMask][i] + graph[i][0]);\n        }\n        return result;\n    }\n    \n    // Nearest Neighbor - O(n²) - Approximation\n    public List<Integer> nearestNeighbor(int[][] graph) {\n        int n = graph.length;\n        boolean[] visited = new boolean[n];\n        List<Integer> tour = new ArrayList<>();\n        \n        int current = 0;\n        tour.add(current);\n        visited[current] = true;\n        \n        for (int i = 1; i < n; i++) {\n            int nearest = -1;\n            int minDist = Integer.MAX_VALUE;\n            \n            for (int j = 0; j < n; j++) {\n                if (!visited[j] && graph[current][j] < minDist) {\n                    minDist = graph[current][j];\n                    nearest = j;\n                }\n            }\n            \n            tour.add(nearest);\n            visited[nearest] = true;\n            current = nearest;\n        }\n        \n        tour.add(0); // Return to start\n        return tour;\n    }\n    \n    // 2-Opt improvement - O(n²) per iteration\n    public void twoOpt(List<Integer> tour, int[][] graph) {\n        boolean improved = true;\n        \n        while (improved) {\n            improved = false;\n            \n            for (int i = 1; i < tour.size() - 2; i++) {\n                for (int j = i + 1; j < tour.size() - 1; j++) {\n                    if (shouldSwap(tour, i, j, graph)) {\n                        reverse(tour, i, j);\n                        improved = true;\n                    }\n                }\n            }\n        }\n    }\n    \n    private boolean shouldSwap(List<Integer> tour, int i, int j, \n                              int[][] graph) {\n        int a = tour.get(i - 1);\n        int b = tour.get(i);\n        int c = tour.get(j);\n        int d = tour.get(j + 1);\n        \n        int currentDist = graph[a][b] + graph[c][d];\n        int newDist = graph[a][c] + graph[b][d];\n        \n        return newDist < currentDist;\n    }\n    \n    private void reverse(List<Integer> tour, int i, int j) {\n        while (i < j) {\n            Collections.swap(tour, i++, j--);\n        }\n    }\n}"
    },
    {
      "id": 70,
      "question": "What are common string matching algorithms beyond KMP?",
      "answer": "String matching algorithms find occurrences of a pattern in text, with various approaches optimized for different scenarios.\n\nBeyond KMP:\n• Boyer-Moore - O(n/m) best case, preprocesses pattern\n• Rabin-Karp - O(n+m) average, uses hashing\n• Aho-Corasick - O(n+m+z) for multiple patterns\n• Suffix Array/Tree - O(n+m) with O(n) preprocessing\n• Z-Algorithm - O(n+m) linear time\n\nBoyer-Moore:\n• Scans pattern right to left\n• Uses bad character and good suffix rules\n• Skip large portions of text\n• Best for long patterns\n• O(n/m) best case\n\nAho-Corasick:\n• Finds all occurrences of multiple patterns\n• Builds trie + failure links\n• Single pass through text\n• Used in intrusion detection\n\nSuffix Trees/Arrays:\n• Preprocess text once\n• Answer many pattern queries\n• Space: O(n) for suffix array\n• Build: O(n log n) or O(n)\n\nApplications:\n• Text editors\n• DNA sequence analysis\n• Spam detection\n• Plagiarism detection",
      "explanation": "String matching includes Boyer-Moore for long patterns, Rabin-Karp for hashing-based search, and Aho-Corasick for multiple patterns, each optimized for specific use cases.",
      "difficulty": "Hard",
      "code": "// Boyer-Moore - See Rabin-Karp in DSA-part10\n\nclass AhoCorasick {\n    class TrieNode {\n        Map<Character, TrieNode> children = new HashMap<>();\n        TrieNode failure;\n        List<String> output = new ArrayList<>();\n    }\n    \n    private TrieNode root;\n    \n    public AhoCorasick() {\n        root = new TrieNode();\n    }\n    \n    // Build trie with patterns\n    public void buildTrie(List<String> patterns) {\n        for (String pattern : patterns) {\n            TrieNode curr = root;\n            for (char c : pattern.toCharArray()) {\n                curr = curr.children.computeIfAbsent(c, k -> new TrieNode());\n            }\n            curr.output.add(pattern);\n        }\n        buildFailureLinks();\n    }\n    \n    private void buildFailureLinks() {\n        Queue<TrieNode> queue = new LinkedList<>();\n        \n        for (TrieNode child : root.children.values()) {\n            child.failure = root;\n            queue.offer(child);\n        }\n        \n        while (!queue.isEmpty()) {\n            TrieNode curr = queue.poll();\n            \n            for (Map.Entry<Character, TrieNode> entry : \n                 curr.children.entrySet()) {\n                char c = entry.getKey();\n                TrieNode child = entry.getValue();\n                queue.offer(child);\n                \n                TrieNode failure = curr.failure;\n                while (failure != null && !failure.children.containsKey(c)) {\n                    failure = failure.failure;\n                }\n                \n                child.failure = (failure == null) ? root : \n                               failure.children.get(c);\n                child.output.addAll(child.failure.output);\n            }\n        }\n    }\n    \n    // Search all patterns in text\n    public Map<String, List<Integer>> search(String text) {\n        Map<String, List<Integer>> matches = new HashMap<>();\n        TrieNode curr = root;\n        \n        for (int i = 0; i < text.length(); i++) {\n            char c = text.charAt(i);\n            \n            while (curr != null && !curr.children.containsKey(c)) {\n                curr = curr.failure;\n            }\n            \n            curr = (curr == null) ? root : curr.children.get(c);\n            \n            for (String pattern : curr.output) {\n                matches.computeIfAbsent(pattern, k -> new ArrayList<>())\n                      .add(i - pattern.length() + 1);\n            }\n        }\n        return matches;\n    }\n}"
    },
    {
      "id": 71,
      "question": "What is space-time tradeoff in algorithm design?",
      "answer": "Space-time tradeoff involves using additional memory to reduce time complexity or vice versa, a fundamental principle in algorithm optimization.\n\nKey Concepts:\n• Spend more space to save time\n• Spend more time to save space\n• Precomputation vs on-the-fly calculation\n• Caching and memoization\n\nCommon Examples:\n• Hash tables - O(n) space for O(1) lookup\n• Memoization - Cache results to avoid recomputation\n• Lookup tables - Precompute values\n• Index structures - Space for faster queries\n• Suffix arrays - O(n) space for O(log n) search\n\nWhen to Trade Space for Time:\n• Repeated computations\n• Frequently accessed data\n• Real-time requirements\n• Memory is abundant\n\nWhen to Trade Time for Space:\n• Memory constrained\n• One-time computations\n• Data too large to store\n• Embedded systems\n\nExamples:\n• Fibonacci: O(2^n) time, O(1) space vs O(n) time, O(n) space\n• String search: O(nm) no space vs O(n+m) with preprocessing\n• Graph algorithms: Adjacency matrix vs list",
      "explanation": "Space-time tradeoff balances memory usage against execution time, using techniques like caching and precomputation to optimize for specific constraints and requirements.",
      "difficulty": "Medium",
      "code": "// Example: Space-time tradeoffs\n\n// Time-optimized: O(1) lookup, O(n) space\nclass FastLookup {\n    private Map<Integer, String> cache = new HashMap<>();\n    \n    public String get(int key) {\n        if (!cache.containsKey(key)) {\n            cache.put(key, computeExpensive(key));\n        }\n        return cache.get(key);\n    }\n    \n    private String computeExpensive(int key) {\n        // Expensive computation\n        return String.valueOf(key);\n    }\n}\n\n// Space-optimized: O(n) time, O(1) space\nclass SlowLookup {\n    public String get(int key) {\n        return computeExpensive(key); // Recompute each time\n    }\n    \n    private String computeExpensive(int key) {\n        return String.valueOf(key);\n    }\n}\n\n// Precomputation tradeoff\nclass FactorialTable {\n    private long[] factorials;\n    \n    // O(n) time, O(n) space to build\n    public FactorialTable(int n) {\n        factorials = new long[n + 1];\n        factorials[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            factorials[i] = factorials[i - 1] * i;\n        }\n    }\n    \n    // O(1) lookup\n    public long getFactorial(int n) {\n        return factorials[n];\n    }\n}\n\n// Without precomputation: O(n) per query, O(1) space\nclass FactorialOnDemand {\n    public long getFactorial(int n) {\n        long result = 1;\n        for (int i = 2; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n}"
    },
    {
      "id": 72,
      "question": "What are online vs offline algorithms?",
      "answer": "Online and offline algorithms differ in how they process input and make decisions based on available information.\n\nOnline Algorithms:\n• Process input piece by piece\n• Make decisions without seeing future\n• Cannot revise past decisions\n• Must work with partial information\n• Evaluated by competitive ratio\n\nOffline Algorithms:\n• Have access to all input upfront\n• Can plan optimal strategy\n• Can preprocess data\n• Generally more efficient\n• Optimal solutions possible\n\nCommon Online Problems:\n• Paging and caching\n• Load balancing\n• Online bipartite matching\n• Ski rental problem\n• Stock trading\n\nCompetitive Analysis:\n• Compare online to optimal offline\n• Competitive ratio = max(online cost / offline cost)\n• k-competitive if ratio <= k\n\nExamples:\n• LRU cache - online eviction policy\n• Greedy algorithms - often online\n• Streaming algorithms - process data once\n• Dynamic programming - typically offline\n\nApplications:\n• Real-time systems\n• Operating systems\n• Network routing\n• Resource allocation",
      "explanation": "Online algorithms process input incrementally without future knowledge, while offline algorithms have complete input, with online performance measured by competitive ratio against optimal offline.",
      "difficulty": "Medium",
      "code": "// Online vs Offline examples\n\n// Online: LRU Cache - decides without future access pattern\nclass LRUCache {\n    private LinkedHashMap<Integer, Integer> cache;\n    private int capacity;\n    \n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        this.cache = new LinkedHashMap<>(capacity, 0.75f, true) {\n            protected boolean removeEldestEntry(Map.Entry eldest) {\n                return size() > capacity;\n            }\n        };\n    }\n    \n    public int get(int key) {\n        return cache.getOrDefault(key, -1);\n    }\n    \n    public void put(int key, int value) {\n        cache.put(key, value);\n    }\n}\n\n// Offline: If we knew future access pattern\nclass OptimalCache {\n    public int optimalEviction(List<Integer> futureAccesses, \n                               Set<Integer> currentCache, int newPage) {\n        // Evict page accessed farthest in future\n        int farthest = -1;\n        int evictPage = -1;\n        \n        for (int page : currentCache) {\n            int nextUse = futureAccesses.indexOf(page);\n            if (nextUse == -1) {\n                return page; // Never used again\n            }\n            if (nextUse > farthest) {\n                farthest = nextUse;\n                evictPage = page;\n            }\n        }\n        return evictPage;\n    }\n}\n\n// Online: Stock trading - decide without future prices\npublic int maxProfitOnline(int[] prices) {\n    int minPrice = Integer.MAX_VALUE;\n    int maxProfit = 0;\n    \n    for (int price : prices) {\n        minPrice = Math.min(minPrice, price);\n        maxProfit = Math.max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n}\n\n// Offline: With all prices known, can find optimal buy/sell\npublic int maxProfitOffline(int[] prices) {\n    // Can plan optimal strategy with complete information\n    int profit = 0;\n    for (int i = 1; i < prices.length; i++) {\n        if (prices[i] > prices[i - 1]) {\n            profit += prices[i] - prices[i - 1];\n        }\n    }\n    return profit;\n}"
    },
    {
      "id": 73,
      "question": "What are cache-oblivious algorithms?",
      "answer": "Cache-oblivious algorithms are designed to be efficient across all levels of memory hierarchy without knowing cache parameters.\n\nKey Characteristics:\n• No knowledge of cache size\n• No knowledge of block size\n• Automatic adaptation to hardware\n• Optimal for all cache levels\n• Divide-and-conquer often used\n\nCache-Aware vs Cache-Oblivious:\n• Cache-aware: Tuned to specific cache\n• Cache-oblivious: Works for all caches\n• Cache-oblivious more portable\n• Both minimize cache misses\n\nCommon Techniques:\n• Recursive division\n• van Emde Boas layout\n• Lazy funnelsort\n• Cache-oblivious B-trees\n\nMemory Hierarchy:\n• L1, L2, L3 caches\n• Main memory\n• Disk storage\n• Algorithm efficient at all levels\n\nExamples:\n• Matrix multiplication - recursive\n• Matrix transpose - recursive\n• Sorting - funnelsort\n• Binary search tree - van Emde Boas layout\n\nBenefits:\n• Portable across machines\n• Future-proof\n• Simpler than cache-tuning\n• Automatic optimization",
      "explanation": "Cache-oblivious algorithms achieve optimal cache performance without knowing cache parameters by using recursive divide-and-conquer approaches that naturally adapt to memory hierarchy.",
      "difficulty": "Hard",
      "code": "// Cache-oblivious matrix multiplication\nclass CacheObliviousMatrix {\n    // Recursive matrix multiplication - O(n³)\n    // Cache-oblivious: works optimally for any cache size\n    public void multiply(double[][] A, double[][] B, double[][] C,\n                        int rowA, int colA, int rowB, int colB,\n                        int rowC, int colC, int size) {\n        if (size == 1) {\n            C[rowC][colC] += A[rowA][colA] * B[rowB][colB];\n            return;\n        }\n        \n        int newSize = size / 2;\n        \n        // Divide matrices into quadrants and multiply recursively\n        multiply(A, B, C, rowA, colA, rowB, colB, rowC, colC, newSize);\n        multiply(A, B, C, rowA, colA + newSize, rowB + newSize, colB, rowC, colC, newSize);\n        \n        multiply(A, B, C, rowA, colA, rowB, colB + newSize, rowC, colC + newSize, newSize);\n        multiply(A, B, C, rowA, colA + newSize, rowB + newSize, colB + newSize, rowC, colC + newSize, newSize);\n        \n        multiply(A, B, C, rowA + newSize, colA, rowB, colB, rowC + newSize, colC, newSize);\n        multiply(A, B, C, rowA + newSize, colA + newSize, rowB + newSize, colB, rowC + newSize, colC, newSize);\n        \n        multiply(A, B, C, rowA + newSize, colA, rowB, colB + newSize, rowC + newSize, colC + newSize, newSize);\n        multiply(A, B, C, rowA + newSize, colA + newSize, rowB + newSize, colB + newSize, rowC + newSize, colC + newSize, newSize);\n    }\n    \n    // Cache-oblivious matrix transpose\n    public void transpose(int[][] A, int[][] B, \n                         int rowA, int colA, int rowB, int colB, int size) {\n        if (size == 1) {\n            B[rowB][colB] = A[rowA][colA];\n            return;\n        }\n        \n        int newSize = size / 2;\n        \n        transpose(A, B, rowA, colA, rowB, colB, newSize);\n        transpose(A, B, rowA, colA + newSize, rowB + newSize, colB, newSize);\n        transpose(A, B, rowA + newSize, colA, rowB, colB + newSize, newSize);\n        transpose(A, B, rowA + newSize, colA + newSize, rowB + newSize, colB + newSize, newSize);\n    }\n}"
    },
    {
      "id": 74,
      "question": "What is the difference between comparison-based and non-comparison sorting?",
      "answer": "Sorting algorithms are categorized by whether they compare elements or use other properties like digit values.\n\nComparison-Based Sorting:\n• Compare elements pairwise\n• Lower bound: Ω(n log n)\n• Examples: Quick, Merge, Heap sort\n• Work on any comparable type\n• Decision tree has n! leaves\n\nNon-Comparison Sorting:\n• Use element properties (digits, values)\n• Can beat O(n log n) bound\n• Limited to specific data types\n• Linear time possible\n• Examples: Counting, Radix, Bucket sort\n\nCounting Sort:\n• O(n + k) where k = range\n• Stable sort\n• Works for small integer ranges\n• Uses frequency array\n\nRadix Sort:\n• O(d × (n + k)) where d = digits\n• Sorts by digit positions\n• Uses stable sort (counting) as subroutine\n• Good for fixed-length keys\n\nBucket Sort:\n• O(n + k) average\n• Divides into buckets\n• Works for uniformly distributed data\n• Each bucket sorted individually\n\nWhen to Use:\n• Comparison: General purpose\n• Non-comparison: Specific data, need linear time",
      "explanation": "Comparison sorts are limited to O(n log n) by comparing elements, while non-comparison sorts like counting and radix can achieve O(n) for specific data types using properties.",
      "difficulty": "Medium",
      "code": "// Non-comparison sorting algorithms\n\n// Counting Sort - O(n + k)\npublic void countingSort(int[] arr, int max) {\n    int[] count = new int[max + 1];\n    int[] output = new int[arr.length];\n    \n    // Count frequencies\n    for (int num : arr) {\n        count[num]++;\n    }\n    \n    // Cumulative count\n    for (int i = 1; i <= max; i++) {\n        count[i] += count[i - 1];\n    }\n    \n    // Build output\n    for (int i = arr.length - 1; i >= 0; i--) {\n        output[count[arr[i]] - 1] = arr[i];\n        count[arr[i]]--;\n    }\n    \n    System.arraycopy(output, 0, arr, 0, arr.length);\n}\n\n// Radix Sort - O(d × (n + k))\npublic void radixSort(int[] arr) {\n    int max = Arrays.stream(arr).max().getAsInt();\n    \n    for (int exp = 1; max / exp > 0; exp *= 10) {\n        countingSortByDigit(arr, exp);\n    }\n}\n\nprivate void countingSortByDigit(int[] arr, int exp) {\n    int[] output = new int[arr.length];\n    int[] count = new int[10];\n    \n    for (int num : arr) {\n        count[(num / exp) % 10]++;\n    }\n    \n    for (int i = 1; i < 10; i++) {\n        count[i] += count[i - 1];\n    }\n    \n    for (int i = arr.length - 1; i >= 0; i--) {\n        int digit = (arr[i] / exp) % 10;\n        output[count[digit] - 1] = arr[i];\n        count[digit]--;\n    }\n    \n    System.arraycopy(output, 0, arr, 0, arr.length);\n}\n\n// Bucket Sort - O(n + k) average\npublic void bucketSort(float[] arr) {\n    int n = arr.length;\n    List<List<Float>> buckets = new ArrayList<>();\n    \n    for (int i = 0; i < n; i++) {\n        buckets.add(new ArrayList<>());\n    }\n    \n    // Distribute into buckets\n    for (float num : arr) {\n        int bucketIndex = (int)(num * n);\n        buckets.get(bucketIndex).add(num);\n    }\n    \n    // Sort each bucket and concatenate\n    int index = 0;\n    for (List<Float> bucket : buckets) {\n        Collections.sort(bucket);\n        for (float num : bucket) {\n            arr[index++] = num;\n        }\n    }\n}"
    },
    {
      "id": 75,
      "question": "What are persistent data structures and their applications?",
      "answer": "Persistent data structures preserve previous versions after modifications, enabling time-travel and undo operations.\n\nPersistence Types:\n• Fully Persistent - All versions can be accessed and modified\n• Partially Persistent - All versions accessed, only latest modified\n• Confluent Persistent - Merge operations on versions\n• Ephemeral - Standard structures, no version history\n\nImplementation Techniques:\n• Path copying - Copy nodes on path to change\n• Fat nodes - Store multiple values per node\n• Node copying - Copy modified nodes\n• Lazy copying - Copy on write\n\nCharacteristics:\n• Immutable by nature\n• Thread-safe automatically\n• Enable functional programming\n• Extra space overhead\n• Structural sharing reduces cost\n\nCommon Examples:\n• Persistent arrays - O(log n) access/update\n• Persistent trees - O(log n) operations\n• Git version control - DAG of versions\n• Clojure persistent collections\n\nApplications:\n• Version control systems\n• Undo/redo functionality\n• Functional programming\n• Concurrent algorithms\n• Database snapshots\n• Time-travel debugging",
      "explanation": "Persistent structures maintain all versions after changes using techniques like path copying and structural sharing, enabling version history and safe concurrency.",
      "difficulty": "Hard",
      "code": "// Persistent Binary Tree with path copying\nclass PersistentTreeNode {\n    int value;\n    PersistentTreeNode left, right;\n    \n    PersistentTreeNode(int value, PersistentTreeNode left, PersistentTreeNode right) {\n        this.value = value;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass PersistentBST {\n    // Insert returns new root, doesn't modify original\n    public PersistentTreeNode insert(PersistentTreeNode root, int value) {\n        if (root == null) {\n            return new PersistentTreeNode(value, null, null);\n        }\n        \n        if (value < root.value) {\n            // Create new node with updated left child\n            return new PersistentTreeNode(root.value, \n                                         insert(root.left, value), \n                                         root.right);\n        } else {\n            return new PersistentTreeNode(root.value, \n                                         root.left, \n                                         insert(root.right, value));\n        }\n    }\n    \n    // Search doesn't need copying\n    public boolean search(PersistentTreeNode root, int value) {\n        if (root == null) return false;\n        if (root.value == value) return true;\n        return value < root.value ? \n               search(root.left, value) : search(root.right, value);\n    }\n}\n\n// Version history management\nclass VersionedStructure {\n    private List<PersistentTreeNode> versions = new ArrayList<>();\n    \n    public VersionedStructure() {\n        versions.add(null); // Version 0: empty tree\n    }\n    \n    public int insert(int versionId, int value) {\n        PersistentBST bst = new PersistentBST();\n        PersistentTreeNode oldRoot = versions.get(versionId);\n        PersistentTreeNode newRoot = bst.insert(oldRoot, value);\n        versions.add(newRoot);\n        return versions.size() - 1; // Return new version ID\n    }\n    \n    public boolean search(int versionId, int value) {\n        PersistentBST bst = new PersistentBST();\n        return bst.search(versions.get(versionId), value);\n    }\n}\n\n// Usage example\nVersionedStructure vs = new VersionedStructure();\nint v1 = vs.insert(0, 10); // Insert 10 in version 0\nint v2 = vs.insert(v1, 20); // Insert 20 in version 1\nint v3 = vs.insert(v1, 15); // Insert 15 in version 1 (branching!)\n\nvs.search(v2, 20); // true\nvs.search(v3, 20); // false (different branch)"
    },
    {
      "id": 76,
      "question": "How do you solve the Longest Common Subsequence problem?",
      "answer": "LCS finds the longest subsequence common to two sequences, a classic DP problem with many applications.\n\nDynamic Programming Approach:\n• Create 2D table dp[i][j]\n• dp[i][j] = LCS length of s1[0...i-1] and s2[0...j-1]\n• If chars match: dp[i][j] = 1 + dp[i-1][j-1]\n• If don't match: dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n• Time: O(mn), Space: O(mn)\n\nRecurrence Relation:\n• LCS(i, j) = 1 + LCS(i-1, j-1) if s1[i] == s2[j]\n• LCS(i, j) = max(LCS(i-1, j), LCS(i, j-1)) otherwise\n• Base: LCS(i, 0) = LCS(0, j) = 0\n\nOptimizations:\n• Space: O(min(m,n)) using two rows\n• Backtracking to find actual sequence\n• Memoization for recursive\n\nApplications:\n• Diff utilities\n• Bioinformatics - DNA sequence alignment\n• Version control systems\n• Plagiarism detection\n• File comparison\n\nVariations:\n• Longest Common Substring - contiguous\n• Edit distance - related problem\n• Multiple sequence alignment",
      "explanation": "LCS uses dynamic programming with O(mn) time to build a table where each cell represents the longest common subsequence length of prefixes.",
      "difficulty": "Hard",
      "code": "// Longest Common Subsequence\nclass LCS {\n    // DP solution - O(mn) time, O(mn) space\n    public int longestCommonSubsequence(String text1, String text2) {\n        int m = text1.length(), n = text2.length();\n        int[][] dp = new int[m + 1][n + 1];\n        \n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n    \n    // Space-optimized: O(min(m,n)) space\n    public int lcsSpaceOptimized(String text1, String text2) {\n        if (text1.length() < text2.length()) {\n            String temp = text1;\n            text1 = text2;\n            text2 = temp;\n        }\n        \n        int m = text1.length(), n = text2.length();\n        int[] prev = new int[n + 1];\n        int[] curr = new int[n + 1];\n        \n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                    curr[j] = 1 + prev[j - 1];\n                } else {\n                    curr[j] = Math.max(prev[j], curr[j - 1]);\n                }\n            }\n            int[] temp = prev;\n            prev = curr;\n            curr = temp;\n        }\n        return prev[n];\n    }\n    \n    // Get actual LCS string\n    public String getLCS(String text1, String text2) {\n        int m = text1.length(), n = text2.length();\n        int[][] dp = new int[m + 1][n + 1];\n        \n        // Build DP table\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        \n        // Backtrack to find LCS\n        StringBuilder lcs = new StringBuilder();\n        int i = m, j = n;\n        while (i > 0 && j > 0) {\n            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                lcs.append(text1.charAt(i - 1));\n                i--;\n                j--;\n            } else if (dp[i - 1][j] > dp[i][j - 1]) {\n                i--;\n            } else {\n                j--;\n            }\n        }\n        return lcs.reverse().toString();\n    }\n}"
    },
    {
      "id": 77,
      "question": "What is a Trie and when should you use it?",
      "answer": "A Trie (prefix tree) is a tree structure for efficiently storing and retrieving strings with common prefixes.\n\nStructure:\n• Each node represents a character\n• Root is empty\n• Path from root to node = string prefix\n• Nodes marked if end of word\n• Children stored in array or map\n\nOperations:\n• Insert: O(L) where L = word length\n• Search: O(L)\n• Delete: O(L)\n• Prefix search: O(L + K) for K results\n• Space: O(ALPHABET_SIZE × N × L)\n\nAdvantages:\n• Fast prefix search\n• Autocomplete functionality\n• Dictionary operations\n• Lexicographic sorting\n• Common prefix identification\n\nDisadvantages:\n• High memory usage\n• Slower than hash tables for exact match\n• Implementation complexity\n\nUse Cases:\n• Autocomplete systems\n• Spell checkers\n• IP routing tables\n• T9 predictive text\n• DNA sequence analysis\n• Contact search\n\nOptimizations:\n• Compressed Trie - merge single-child chains\n• Radix Tree - store strings on edges\n• Ternary Search Tree - space efficient",
      "explanation": "A Trie stores strings efficiently using tree nodes for each character, enabling O(L) operations and fast prefix searches for autocomplete and dictionary applications.",
      "difficulty": "Hard",
      "code": "// Trie implementation\nclass TrieNode {\n    Map<Character, TrieNode> children;\n    boolean isEndOfWord;\n    \n    TrieNode() {\n        children = new HashMap<>();\n        isEndOfWord = false;\n    }\n}\n\nclass Trie {\n    private TrieNode root;\n    \n    public Trie() {\n        root = new TrieNode();\n    }\n    \n    // Insert word - O(L)\n    public void insert(String word) {\n        TrieNode node = root;\n        for (char ch : word.toCharArray()) {\n            node.children.putIfAbsent(ch, new TrieNode());\n            node = node.children.get(ch);\n        }\n        node.isEndOfWord = true;\n    }\n    \n    // Search exact word - O(L)\n    public boolean search(String word) {\n        TrieNode node = findNode(word);\n        return node != null && node.isEndOfWord;\n    }\n    \n    // Check if prefix exists - O(L)\n    public boolean startsWith(String prefix) {\n        return findNode(prefix) != null;\n    }\n    \n    private TrieNode findNode(String str) {\n        TrieNode node = root;\n        for (char ch : str.toCharArray()) {\n            node = node.children.get(ch);\n            if (node == null) {\n                return null;\n            }\n        }\n        return node;\n    }\n    \n    // Delete word\n    public boolean delete(String word) {\n        return delete(root, word, 0);\n    }\n    \n    private boolean delete(TrieNode node, String word, int index) {\n        if (index == word.length()) {\n            if (!node.isEndOfWord) return false;\n            node.isEndOfWord = false;\n            return node.children.isEmpty();\n        }\n        \n        char ch = word.charAt(index);\n        TrieNode child = node.children.get(ch);\n        if (child == null) return false;\n        \n        boolean shouldDeleteChild = delete(child, word, index + 1);\n        \n        if (shouldDeleteChild) {\n            node.children.remove(ch);\n            return node.children.isEmpty() && !node.isEndOfWord;\n        }\n        return false;\n    }\n    \n    // Get all words with prefix\n    public List<String> wordsWithPrefix(String prefix) {\n        List<String> result = new ArrayList<>();\n        TrieNode node = findNode(prefix);\n        if (node != null) {\n            dfs(node, prefix, result);\n        }\n        return result;\n    }\n    \n    private void dfs(TrieNode node, String current, List<String> result) {\n        if (node.isEndOfWord) {\n            result.add(current);\n        }\n        for (Map.Entry<Character, TrieNode> entry : node.children.entrySet()) {\n            dfs(entry.getValue(), current + entry.getKey(), result);\n        }\n    }\n}"
    },
    {
      "id": 78,
      "question": "How do you detect and remove a cycle in a linked list?",
      "answer": "Cycle detection and removal in linked lists uses Floyd's algorithm (tortoise and hare) efficiently.\n\nFloyd's Cycle Detection:\n• Use two pointers: slow and fast\n• Slow moves 1 step, fast moves 2 steps\n• If they meet, cycle exists\n• Time: O(n), Space: O(1)\n• Guaranteed to meet in cycle if exists\n\nWhy It Works:\n• Fast catches up to slow in cycle\n• Relative speed difference is 1\n• Will meet within one cycle traversal\n• Distance relationship guarantees detection\n\nFinding Cycle Start:\n• After detection, reset slow to head\n• Move both pointers 1 step at a time\n• They meet at cycle start\n• Mathematical proof based on distances\n\nRemoving Cycle:\n• Find cycle start\n• Traverse to find node before start\n• Set its next to null\n\nAlternatives:\n• Hash set - O(n) space\n• Marking nodes - modifies structure\n• Brent's algorithm - fewer operations\n\nApplications:\n• Linked list validation\n• Graph cycle detection\n• Duplicate detection",
      "explanation": "Floyd's algorithm detects cycles using two pointers moving at different speeds; they meet if a cycle exists, then finding and removing the cycle requires O(n) time with O(1) space.",
      "difficulty": "Hard",
      "code": "// Cycle detection and removal in linked list\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(int val) { this.val = val; }\n}\n\nclass LinkedListCycle {\n    // Detect cycle - O(n) time, O(1) space\n    public boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null) return false;\n        \n        ListNode slow = head;\n        ListNode fast = head;\n        \n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            \n            if (slow == fast) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    // Find cycle start node\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) return null;\n        \n        ListNode slow = head;\n        ListNode fast = head;\n        \n        // Detect cycle\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            \n            if (slow == fast) {\n                // Cycle found, find start\n                slow = head;\n                while (slow != fast) {\n                    slow = slow.next;\n                    fast = fast.next;\n                }\n                return slow; // Cycle start\n            }\n        }\n        return null;\n    }\n    \n    // Remove cycle\n    public void removeCycle(ListNode head) {\n        if (head == null || head.next == null) return;\n        \n        ListNode slow = head;\n        ListNode fast = head;\n        \n        // Detect cycle\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            \n            if (slow == fast) {\n                break;\n            }\n        }\n        \n        // No cycle\n        if (fast == null || fast.next == null) return;\n        \n        // Find cycle start\n        slow = head;\n        if (slow == fast) {\n            // Cycle starts at head\n            while (fast.next != slow) {\n                fast = fast.next;\n            }\n        } else {\n            while (slow.next != fast.next) {\n                slow = slow.next;\n                fast = fast.next;\n            }\n        }\n        \n        // Remove cycle\n        fast.next = null;\n    }\n    \n    // Get cycle length\n    public int getCycleLength(ListNode head) {\n        if (head == null) return 0;\n        \n        ListNode slow = head;\n        ListNode fast = head;\n        \n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            \n            if (slow == fast) {\n                // Count nodes in cycle\n                int length = 1;\n                ListNode temp = slow.next;\n                while (temp != slow) {\n                    length++;\n                    temp = temp.next;\n                }\n                return length;\n            }\n        }\n        return 0;\n    }\n}"
    },
    {
      "id": 79,
      "question": "What are external sorting algorithms and when are they used?",
      "answer": "External sorting handles data too large to fit in memory by using disk storage efficiently.\n\nKey Characteristics:\n• Data doesn't fit in RAM\n• Minimize disk I/O operations\n• Read/write in large blocks\n• Multi-pass algorithms\n• Tape or disk based\n\nExternal Merge Sort:\n• Most common external sort\n• Phase 1: Create sorted runs\n• Phase 2: Merge runs iteratively\n• K-way merge for efficiency\n• Time: O(n log n), I/O: O(n log_M n)\n\nAlgorithm Steps:\n• Read chunks that fit in memory\n• Sort each chunk (internal sort)\n• Write sorted runs to disk\n• Merge runs using priority queue\n• Repeat until single sorted file\n\nOptimizations:\n• Replacement selection for longer runs\n• Multi-way merge (k-way)\n• Buffering strategies\n• Parallel I/O\n• Compression\n\nI/O Complexity:\n• Passes: ceiling(log_k(N/M))\n• k = number of runs merged\n• N = file size\n• M = memory size\n\nApplications:\n• Database sorting\n• Log file processing\n• MapReduce shuffle\n• Large-scale data processing",
      "explanation": "External sorting uses disk-based merge sort with phases for creating sorted runs and k-way merging, minimizing I/O operations for data larger than RAM.",
      "difficulty": "Hard",
      "code": "// External merge sort simulation\nimport java.io.*;\nimport java.util.*;\n\nclass ExternalSort {\n    private static final int MEMORY_SIZE = 1000; // Simulated memory limit\n    \n    // External merge sort\n    public void externalMergeSort(String inputFile, String outputFile) throws IOException {\n        // Phase 1: Create sorted runs\n        List<String> runFiles = createSortedRuns(inputFile);\n        \n        // Phase 2: Merge runs\n        mergeRuns(runFiles, outputFile);\n        \n        // Cleanup\n        for (String file : runFiles) {\n            new File(file).delete();\n        }\n    }\n    \n    // Phase 1: Create sorted runs that fit in memory\n    private List<String> createSortedRuns(String inputFile) throws IOException {\n        List<String> runFiles = new ArrayList<>();\n        BufferedReader reader = new BufferedReader(new FileReader(inputFile));\n        \n        List<Integer> buffer = new ArrayList<>();\n        String line;\n        int runNumber = 0;\n        \n        while ((line = reader.readLine()) != null) {\n            buffer.add(Integer.parseInt(line));\n            \n            // When buffer full, sort and write\n            if (buffer.size() >= MEMORY_SIZE) {\n                String runFile = writeRun(buffer, runNumber++);\n                runFiles.add(runFile);\n                buffer.clear();\n            }\n        }\n        \n        // Write remaining data\n        if (!buffer.isEmpty()) {\n            String runFile = writeRun(buffer, runNumber);\n            runFiles.add(runFile);\n        }\n        \n        reader.close();\n        return runFiles;\n    }\n    \n    private String writeRun(List<Integer> buffer, int runNumber) throws IOException {\n        Collections.sort(buffer);\n        String fileName = \"run_\" + runNumber + \".txt\";\n        PrintWriter writer = new PrintWriter(fileName);\n        \n        for (int num : buffer) {\n            writer.println(num);\n        }\n        writer.close();\n        return fileName;\n    }\n    \n    // Phase 2: K-way merge of runs\n    private void mergeRuns(List<String> runFiles, String outputFile) throws IOException {\n        PriorityQueue<RunIterator> pq = new PriorityQueue<>();\n        \n        // Open all run files\n        for (String file : runFiles) {\n            RunIterator iterator = new RunIterator(file);\n            if (iterator.hasNext()) {\n                pq.offer(iterator);\n            }\n        }\n        \n        // Merge\n        PrintWriter writer = new PrintWriter(outputFile);\n        while (!pq.isEmpty()) {\n            RunIterator iterator = pq.poll();\n            writer.println(iterator.current);\n            \n            if (iterator.next()) {\n                pq.offer(iterator);\n            } else {\n                iterator.close();\n            }\n        }\n        writer.close();\n    }\n    \n    // Iterator for reading sorted runs\n    class RunIterator implements Comparable<RunIterator> {\n        BufferedReader reader;\n        Integer current;\n        \n        RunIterator(String fileName) throws IOException {\n            reader = new BufferedReader(new FileReader(fileName));\n            next();\n        }\n        \n        boolean hasNext() {\n            return current != null;\n        }\n        \n        boolean next() throws IOException {\n            String line = reader.readLine();\n            if (line != null) {\n                current = Integer.parseInt(line);\n                return true;\n            }\n            current = null;\n            return false;\n        }\n        \n        void close() throws IOException {\n            reader.close();\n        }\n        \n        @Override\n        public int compareTo(RunIterator other) {\n            return Integer.compare(this.current, other.current);\n        }\n    }\n}"
    },
    {
      "id": 80,
      "question": "What is the difference between BFS and DFS for tree/graph traversal?",
      "answer": "BFS and DFS are fundamental graph traversal strategies with different characteristics and use cases.\n\nBreadth-First Search (BFS):\n• Explores level by level\n• Uses queue data structure\n• Finds shortest path (unweighted)\n• More memory for wide graphs\n• Time: O(V + E), Space: O(V)\n\nDepth-First Search (DFS):\n• Explores as far as possible first\n• Uses stack (or recursion)\n• Doesn't guarantee shortest path\n• Less memory for deep graphs\n• Time: O(V + E), Space: O(h) where h = height\n\nWhen to Use BFS:\n• Shortest path needed\n• Level-order traversal\n• Finding nearest neighbors\n• Web crawlers\n• Network broadcasting\n\nWhen to Use DFS:\n• Topological sorting\n• Cycle detection\n• Path finding (any path)\n• Maze solving\n• Connected components\n\nImplementation Differences:\n• BFS: Iterative with queue\n• DFS: Recursive or stack\n• BFS: Guaranteed optimal (unweighted)\n• DFS: May find non-optimal paths\n\nComplexity Comparison:\n• Both O(V + E) time\n• BFS: O(V) space worst case\n• DFS: O(h) space, better for trees",
      "explanation": "BFS explores level-by-level using a queue and finds shortest paths, while DFS goes deep using a stack/recursion and is better for topological sorting and cycle detection.",
      "difficulty": "Medium",
      "code": "// BFS vs DFS comparison\nimport java.util.*;\n\nclass GraphTraversal {\n    static class Graph {\n        Map<Integer, List<Integer>> adj = new HashMap<>();\n        \n        void addEdge(int u, int v) {\n            adj.putIfAbsent(u, new ArrayList<>());\n            adj.get(u).add(v);\n        }\n    }\n    \n    // BFS - Level by level, uses queue\n    public void bfs(Graph graph, int start) {\n        Set<Integer> visited = new HashSet<>();\n        Queue<Integer> queue = new LinkedList<>();\n        \n        queue.offer(start);\n        visited.add(start);\n        \n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n            System.out.print(node + \" \");\n            \n            for (int neighbor : graph.adj.getOrDefault(node, new ArrayList<>())) {\n                if (!visited.contains(neighbor)) {\n                    visited.add(neighbor);\n                    queue.offer(neighbor);\n                }\n            }\n        }\n    }\n    \n    // BFS shortest path\n    public int shortestPath(Graph graph, int start, int target) {\n        Set<Integer> visited = new HashSet<>();\n        Queue<int[]> queue = new LinkedList<>(); // [node, distance]\n        \n        queue.offer(new int[]{start, 0});\n        visited.add(start);\n        \n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int node = current[0];\n            int dist = current[1];\n            \n            if (node == target) return dist;\n            \n            for (int neighbor : graph.adj.getOrDefault(node, new ArrayList<>())) {\n                if (!visited.contains(neighbor)) {\n                    visited.add(neighbor);\n                    queue.offer(new int[]{neighbor, dist + 1});\n                }\n            }\n        }\n        return -1;\n    }\n    \n    // DFS - Recursive, explores deep\n    public void dfsRecursive(Graph graph, int node, Set<Integer> visited) {\n        visited.add(node);\n        System.out.print(node + \" \");\n        \n        for (int neighbor : graph.adj.getOrDefault(node, new ArrayList<>())) {\n            if (!visited.contains(neighbor)) {\n                dfsRecursive(graph, neighbor, visited);\n            }\n        }\n    }\n    \n    // DFS - Iterative with stack\n    public void dfsIterative(Graph graph, int start) {\n        Set<Integer> visited = new HashSet<>();\n        Stack<Integer> stack = new Stack<>();\n        \n        stack.push(start);\n        \n        while (!stack.isEmpty()) {\n            int node = stack.pop();\n            \n            if (!visited.contains(node)) {\n                visited.add(node);\n                System.out.print(node + \" \");\n                \n                // Add neighbors to stack\n                List<Integer> neighbors = graph.adj.getOrDefault(node, new ArrayList<>());\n                for (int i = neighbors.size() - 1; i >= 0; i--) {\n                    if (!visited.contains(neighbors.get(i))) {\n                        stack.push(neighbors.get(i));\n                    }\n                }\n            }\n        }\n    }\n    \n    // DFS for path finding\n    public boolean hasPath(Graph graph, int start, int target, Set<Integer> visited) {\n        if (start == target) return true;\n        visited.add(start);\n        \n        for (int neighbor : graph.adj.getOrDefault(start, new ArrayList<>())) {\n            if (!visited.contains(neighbor)) {\n                if (hasPath(graph, neighbor, target, visited)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}"
    },
    {
      "id": 81,
      "question": "How do you implement an LRU cache efficiently?",
      "answer": "LRU (Least Recently Used) cache evicts the least recently used item when capacity is reached, using doubly linked list and hash map.\n\nData Structures:\n• HashMap - O(1) key lookup\n• Doubly Linked List - O(1) add/remove\n• Head = most recent\n• Tail = least recent\n• Capacity limit\n\nOperations:\n• Get(key): O(1) - Move to front if exists\n• Put(key, value): O(1) - Add/update and move to front\n• Remove LRU: O(1) - Remove from tail\n• All operations constant time\n\nImplementation Details:\n• Hash map stores key -> node reference\n• Doubly linked list maintains order\n• Dummy head/tail nodes simplify logic\n• Update both structures on access\n\nWhy Doubly Linked:\n• Need to remove from middle\n• O(1) removal with node reference\n• O(1) add to front\n• Single linked requires O(n) for removal\n\nApplications:\n• CPU cache\n• Web browser cache\n• Database buffer pool\n• Operating system page replacement\n• CDN caching\n\nVariations:\n• LFU - Least Frequently Used\n• MRU - Most Recently Used\n• TTL cache - Time-based expiration",
      "explanation": "LRU cache combines HashMap for O(1) lookup and doubly linked list for O(1) insertion/deletion, maintaining access order and evicting least recently used items.",
      "difficulty": "Hard",
      "code": "// LRU Cache implementation\nclass LRUCache {\n    class Node {\n        int key, value;\n        Node prev, next;\n        \n        Node(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n    \n    private Map<Integer, Node> cache;\n    private int capacity;\n    private Node head, tail; // Dummy nodes\n    \n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        this.cache = new HashMap<>();\n        \n        // Initialize dummy head and tail\n        head = new Node(0, 0);\n        tail = new Node(0, 0);\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    // Get value - O(1)\n    public int get(int key) {\n        if (!cache.containsKey(key)) {\n            return -1;\n        }\n        \n        Node node = cache.get(key);\n        // Move to front (most recent)\n        remove(node);\n        addToFront(node);\n        return node.value;\n    }\n    \n    // Put key-value - O(1)\n    public void put(int key, int value) {\n        if (cache.containsKey(key)) {\n            // Update existing\n            Node node = cache.get(key);\n            node.value = value;\n            remove(node);\n            addToFront(node);\n        } else {\n            // Add new\n            if (cache.size() >= capacity) {\n                // Remove LRU (tail.prev)\n                Node lru = tail.prev;\n                remove(lru);\n                cache.remove(lru.key);\n            }\n            \n            Node newNode = new Node(key, value);\n            cache.put(key, newNode);\n            addToFront(newNode);\n        }\n    }\n    \n    // Add node to front (after head)\n    private void addToFront(Node node) {\n        node.next = head.next;\n        node.prev = head;\n        head.next.prev = node;\n        head.next = node;\n    }\n    \n    // Remove node from list\n    private void remove(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n}\n\n// Alternative: Using LinkedHashMap\nclass LRUCacheSimple extends LinkedHashMap<Integer, Integer> {\n    private int capacity;\n    \n    public LRUCacheSimple(int capacity) {\n        super(capacity, 0.75f, true); // access-order\n        this.capacity = capacity;\n    }\n    \n    public int get(int key) {\n        return super.getOrDefault(key, -1);\n    }\n    \n    public void put(int key, int value) {\n        super.put(key, value);\n    }\n    \n    @Override\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\n        return size() > capacity;\n    }\n}\n\n// Usage\nLRUCache cache = new LRUCache(2);\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // returns 1\ncache.put(3, 3);    // evicts key 2\ncache.get(2);       // returns -1 (not found)"
    },
    {
      "id": 82,
      "question": "What are the key differences between Array and ArrayList in Java?",
      "answer": "Arrays and ArrayLists both store sequential data but differ in flexibility, performance, and functionality.\n\nArrays:\n• Fixed size at creation\n• Can store primitives or objects\n• Access: O(1), native performance\n• Memory efficient\n• No built-in methods\n• Type-safe at compile time\n\nArrayList:\n• Dynamic size (resizable)\n• Only stores objects (uses boxing)\n• Access: O(1), slight overhead\n• Automatic resizing\n• Rich API (add, remove, contains, etc.)\n• Generics for type safety\n\nPerformance:\n• Array: Faster for primitives\n• ArrayList: Overhead from object wrapper\n• ArrayList resize: O(n) when capacity exceeded\n• Array: No resize cost\n\nMemory:\n• Array: Exact size allocation\n• ArrayList: Extra capacity for growth\n• ArrayList: Additional object overhead\n\nOperations:\n• Array: Manual implementation needed\n• ArrayList: Built-in add, remove, search\n• ArrayList: Dynamic operations easier\n\nWhen to Use Array:\n• Fixed size known\n• Performance critical\n• Primitive types\n• Multi-dimensional structures\n\nWhen to Use ArrayList:\n• Dynamic sizing needed\n• Frequent insertions/deletions\n• Need utility methods\n• Collection framework integration",
      "explanation": "Arrays have fixed size and better performance for primitives, while ArrayList provides dynamic resizing and rich methods but only stores objects with slight overhead.",
      "difficulty": "Easy",
      "code": "// Array vs ArrayList comparison\nimport java.util.*;\n\nclass ArrayVsArrayList {\n    public static void main(String[] args) {\n        // ARRAY\n        // Fixed size, can store primitives\n        int[] array = new int[5];\n        array[0] = 1;\n        array[1] = 2;\n        // array[5] = 3; // ArrayIndexOutOfBoundsException\n        \n        // Multi-dimensional\n        int[][] matrix = new int[3][3];\n        \n        // Length is fixed\n        System.out.println(\"Array length: \" + array.length);\n        \n        // Iterate\n        for (int i = 0; i < array.length; i++) {\n            System.out.println(array[i]);\n        }\n        \n        // ARRAYLIST\n        // Dynamic size, stores objects only\n        ArrayList<Integer> list = new ArrayList<>();\n        list.add(1);  // Auto-boxing: int -> Integer\n        list.add(2);\n        list.add(3);\n        list.add(4);\n        list.add(5);\n        list.add(6);  // Automatically resizes\n        \n        // Rich methods\n        list.remove(0);           // Remove by index\n        list.remove(Integer.valueOf(3)); // Remove by value\n        list.contains(4);         // Check existence\n        list.size();              // Get size\n        list.indexOf(5);          // Find index\n        \n        // Iterate\n        for (int num : list) {\n            System.out.println(num); // Auto-unboxing\n        }\n        \n        // Convert ArrayList to Array\n        Integer[] arr = list.toArray(new Integer[0]);\n        \n        // Convert Array to ArrayList\n        Integer[] nums = {1, 2, 3};\n        ArrayList<Integer> list2 = new ArrayList<>(Arrays.asList(nums));\n        \n        // PERFORMANCE COMPARISON\n        // Array: Fast primitive access\n        int[] primitives = new int[1000000];\n        long start = System.nanoTime();\n        for (int i = 0; i < primitives.length; i++) {\n            primitives[i] = i;\n        }\n        long arrayTime = System.nanoTime() - start;\n        \n        // ArrayList: Boxing overhead\n        ArrayList<Integer> objects = new ArrayList<>(1000000);\n        start = System.nanoTime();\n        for (int i = 0; i < 1000000; i++) {\n            objects.add(i); // Boxing overhead\n        }\n        long listTime = System.nanoTime() - start;\n        \n        System.out.println(\"Array time: \" + arrayTime);\n        System.out.println(\"ArrayList time: \" + listTime);\n        \n        // MEMORY\n        // Array: int[1000] = 4000 bytes\n        // ArrayList<Integer>: ~16000 bytes (Integer objects + overhead)\n    }\n    \n    // Example: When to use each\n    \n    // Use Array: Fixed size, performance critical\n    public int[] sortArray(int[] nums) {\n        Arrays.sort(nums);\n        return nums;\n    }\n    \n    // Use ArrayList: Dynamic size, convenience methods\n    public List<Integer> findDuplicates(int[] nums) {\n        List<Integer> duplicates = new ArrayList<>();\n        Set<Integer> seen = new HashSet<>();\n        \n        for (int num : nums) {\n            if (!seen.add(num)) {\n                duplicates.add(num);\n            }\n        }\n        return duplicates;\n    }\n}"
    },
    {
      "id": 83,
      "question": "How does a Min-Heap differ from a Max-Heap, and how do you implement them?",
      "answer": "Heaps are complete binary trees with ordering properties, implemented using arrays for efficiency.\n\nMin-Heap:\n• Parent smaller than children\n• Root is minimum element\n• Used for ascending priority\n• Heapify-up/down maintains property\n\nMax-Heap:\n• Parent larger than children\n• Root is maximum element\n• Used for descending priority\n• Similar operations, opposite comparison\n\nArray Representation:\n• Parent at i, children at 2i+1 and 2i+2\n• Child at i, parent at (i-1)/2\n• No pointers needed\n• Cache-friendly layout\n\nOperations - O(log n):\n• Insert: Add to end, heapify-up\n• Extract: Remove root, heapify-down\n• Peek: O(1) - return root\n• Build heap: O(n) from array\n\nHeapify-Up:\n• Compare with parent\n• Swap if violates property\n• Repeat until valid\n\nHeapify-Down:\n• Compare with children\n• Swap with appropriate child\n• Repeat until valid\n\nApplications:\n• Priority Queue implementation\n• Heap Sort\n• Dijkstra's algorithm\n• Median maintenance\n• Top K elements",
      "explanation": "Min-heap keeps minimum at root while max-heap keeps maximum, both using array-based complete binary trees with O(log n) insertion and extraction operations.",
      "difficulty": "Medium",
      "code": "// Min-Heap and Max-Heap implementations\nclass MinHeap {\n    private List<Integer> heap;\n    \n    public MinHeap() {\n        heap = new ArrayList<>();\n    }\n    \n    // Insert - O(log n)\n    public void insert(int val) {\n        heap.add(val);\n        heapifyUp(heap.size() - 1);\n    }\n    \n    // Extract minimum - O(log n)\n    public int extractMin() {\n        if (heap.isEmpty()) throw new NoSuchElementException();\n        \n        int min = heap.get(0);\n        int last = heap.remove(heap.size() - 1);\n        \n        if (!heap.isEmpty()) {\n            heap.set(0, last);\n            heapifyDown(0);\n        }\n        return min;\n    }\n    \n    // Peek minimum - O(1)\n    public int peek() {\n        if (heap.isEmpty()) throw new NoSuchElementException();\n        return heap.get(0);\n    }\n    \n    private void heapifyUp(int index) {\n        while (index > 0) {\n            int parent = (index - 1) / 2;\n            if (heap.get(index) >= heap.get(parent)) break;\n            \n            swap(index, parent);\n            index = parent;\n        }\n    }\n    \n    private void heapifyDown(int index) {\n        int size = heap.size();\n        \n        while (true) {\n            int smallest = index;\n            int left = 2 * index + 1;\n            int right = 2 * index + 2;\n            \n            if (left < size && heap.get(left) < heap.get(smallest)) {\n                smallest = left;\n            }\n            if (right < size && heap.get(right) < heap.get(smallest)) {\n                smallest = right;\n            }\n            \n            if (smallest == index) break;\n            \n            swap(index, smallest);\n            index = smallest;\n        }\n    }\n    \n    private void swap(int i, int j) {\n        int temp = heap.get(i);\n        heap.set(i, heap.get(j));\n        heap.set(j, temp);\n    }\n    \n    // Build heap from array - O(n)\n    public static MinHeap buildHeap(int[] arr) {\n        MinHeap heap = new MinHeap();\n        heap.heap = new ArrayList<>();\n        for (int num : arr) {\n            heap.heap.add(num);\n        }\n        \n        // Heapify from last non-leaf to root\n        for (int i = arr.length / 2 - 1; i >= 0; i--) {\n            heap.heapifyDown(i);\n        }\n        return heap;\n    }\n}\n\nclass MaxHeap {\n    private List<Integer> heap;\n    \n    public MaxHeap() {\n        heap = new ArrayList<>();\n    }\n    \n    public void insert(int val) {\n        heap.add(val);\n        heapifyUp(heap.size() - 1);\n    }\n    \n    public int extractMax() {\n        if (heap.isEmpty()) throw new NoSuchElementException();\n        \n        int max = heap.get(0);\n        int last = heap.remove(heap.size() - 1);\n        \n        if (!heap.isEmpty()) {\n            heap.set(0, last);\n            heapifyDown(0);\n        }\n        return max;\n    }\n    \n    private void heapifyUp(int index) {\n        while (index > 0) {\n            int parent = (index - 1) / 2;\n            if (heap.get(index) <= heap.get(parent)) break;\n            \n            swap(index, parent);\n            index = parent;\n        }\n    }\n    \n    private void heapifyDown(int index) {\n        int size = heap.size();\n        \n        while (true) {\n            int largest = index;\n            int left = 2 * index + 1;\n            int right = 2 * index + 2;\n            \n            if (left < size && heap.get(left) > heap.get(largest)) {\n                largest = left;\n            }\n            if (right < size && heap.get(right) > heap.get(largest)) {\n                largest = right;\n            }\n            \n            if (largest == index) break;\n            \n            swap(index, largest);\n            index = largest;\n        }\n    }\n    \n    private void swap(int i, int j) {\n        int temp = heap.get(i);\n        heap.set(i, heap.get(j));\n        heap.set(j, temp);\n    }\n}\n\n// Using Java's PriorityQueue\nPriorityQueue<Integer> minHeap = new PriorityQueue<>();\nPriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());"
    },
    {
      "id": 84,
      "question": "What is memoization and how is it different from tabulation in dynamic programming?",
      "answer": "Memoization and tabulation are two approaches to implementing dynamic programming solutions.\n\nMemoization (Top-Down):\n• Recursive approach\n• Cache results as needed\n• Solves subproblems on demand\n• Uses recursion stack\n• Easier to implement from recursive solution\n\nTabulation (Bottom-Up):\n• Iterative approach\n• Build table systematically\n• Solves all subproblems\n• No recursion overhead\n• Better space optimization possible\n\nKey Differences:\n• Direction: Top-down vs bottom-up\n• Storage: Cache vs table\n• Implementation: Recursion vs iteration\n• Subproblems: On-demand vs all\n• Stack: Uses vs avoids\n\nMemoization Advantages:\n• Intuitive from recursion\n• Only solves needed subproblems\n• Natural problem decomposition\n• Good for sparse problems\n\nTabulation Advantages:\n• No recursion overhead\n• Better cache locality\n• Easier to optimize space\n• Predictable memory usage\n• No stack overflow risk\n\nWhen to Use:\n• Memoization: Sparse subproblem space\n• Tabulation: All subproblems needed\n• Memoization: Easier to start\n• Tabulation: Production optimization",
      "explanation": "Memoization caches recursive calls top-down solving subproblems on demand, while tabulation builds solutions bottom-up iteratively solving all subproblems without recursion.",
      "difficulty": "Medium",
      "code": "// Memoization vs Tabulation\n\nclass DPComparison {\n    // FIBONACCI - Classic example\n    \n    // Memoization (Top-Down) - O(n) time, O(n) space\n    public int fibMemo(int n) {\n        return fibMemoHelper(n, new HashMap<>());\n    }\n    \n    private int fibMemoHelper(int n, Map<Integer, Integer> memo) {\n        if (n <= 1) return n;\n        \n        if (memo.containsKey(n)) {\n            return memo.get(n); // Return cached result\n        }\n        \n        int result = fibMemoHelper(n - 1, memo) + fibMemoHelper(n - 2, memo);\n        memo.put(n, result); // Cache result\n        return result;\n    }\n    \n    // Tabulation (Bottom-Up) - O(n) time, O(n) space\n    public int fibTab(int n) {\n        if (n <= 1) return n;\n        \n        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        dp[1] = 1;\n        \n        for (int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n    \n    // Tabulation Space-Optimized - O(n) time, O(1) space\n    public int fibTabOptimized(int n) {\n        if (n <= 1) return n;\n        \n        int prev2 = 0, prev1 = 1;\n        for (int i = 2; i <= n; i++) {\n            int curr = prev1 + prev2;\n            prev2 = prev1;\n            prev1 = curr;\n        }\n        return prev1;\n    }\n    \n    // LONGEST COMMON SUBSEQUENCE\n    \n    // Memoization approach\n    public int lcsMemo(String s1, String s2) {\n        return lcsMemoHelper(s1, s2, s1.length(), s2.length(), new HashMap<>());\n    }\n    \n    private int lcsMemoHelper(String s1, String s2, int i, int j, \n                             Map<String, Integer> memo) {\n        if (i == 0 || j == 0) return 0;\n        \n        String key = i + \",\" + j;\n        if (memo.containsKey(key)) return memo.get(key);\n        \n        int result;\n        if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\n            result = 1 + lcsMemoHelper(s1, s2, i - 1, j - 1, memo);\n        } else {\n            result = Math.max(\n                lcsMemoHelper(s1, s2, i - 1, j, memo),\n                lcsMemoHelper(s1, s2, i, j - 1, memo)\n            );\n        }\n        \n        memo.put(key, result);\n        return result;\n    }\n    \n    // Tabulation approach\n    public int lcsTab(String s1, String s2) {\n        int m = s1.length(), n = s2.length();\n        int[][] dp = new int[m + 1][n + 1];\n        \n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n    \n    // COMPARISON\n    public void compare() {\n        // Memoization benefits:\n        // - Only computes needed subproblems\n        // - Example: fib(100) with memo only computed once per value\n        \n        // Tabulation benefits:\n        // - No recursion stack overhead\n        // - Can optimize space easily\n        // - Better for dense subproblem graphs\n    }\n}"
    },
    {
      "id": 85,
      "question": "What are the different ways to represent graphs and their trade-offs?",
      "answer": "Graphs can be represented in multiple ways, each with different space and time trade-offs.\n\nAdjacency Matrix:\n• 2D array: matrix[i][j] = edge weight\n• Space: O(V²)\n• Edge check: O(1)\n• Get neighbors: O(V)\n• Good for dense graphs\n• Wasted space for sparse graphs\n\nAdjacency List:\n• Array/map of lists\n• Space: O(V + E)\n• Edge check: O(degree)\n• Get neighbors: O(degree)\n• Good for sparse graphs\n• Most common representation\n\nEdge List:\n• List of (u, v, weight) tuples\n• Space: O(E)\n• Simple to construct\n• Iterate edges: O(E)\n• Poor for neighbor queries\n• Good for Kruskal's algorithm\n\nIncidence Matrix:\n• matrix[v][e] = 1 if v in edge e\n• Space: O(V × E)\n• Rarely used\n• Good for hypergraphs\n\nComparison:\n• Matrix: Fast queries, high space\n• List: Balanced, most versatile\n• Edge list: Minimal space, slow queries\n\nWhen to Use:\n• Matrix: Dense graphs, frequent edge checks\n• List: General purpose, sparse graphs\n• Edge list: Minimal memory, edge iteration",
      "explanation": "Adjacency matrix offers O(1) edge lookup with O(V²) space, while adjacency list uses O(V+E) space with O(degree) lookups, best for sparse graphs.",
      "difficulty": "Medium",
      "code": "// Graph representations comparison\n\n// 1. ADJACENCY MATRIX\nclass GraphMatrix {\n    private int[][] matrix;\n    private int vertices;\n    \n    public GraphMatrix(int vertices) {\n        this.vertices = vertices;\n        matrix = new int[vertices][vertices];\n    }\n    \n    // Add edge - O(1)\n    public void addEdge(int u, int v, int weight) {\n        matrix[u][v] = weight;\n        // matrix[v][u] = weight; // For undirected\n    }\n    \n    // Check edge - O(1)\n    public boolean hasEdge(int u, int v) {\n        return matrix[u][v] != 0;\n    }\n    \n    // Get weight - O(1)\n    public int getWeight(int u, int v) {\n        return matrix[u][v];\n    }\n    \n    // Get neighbors - O(V)\n    public List<Integer> getNeighbors(int u) {\n        List<Integer> neighbors = new ArrayList<>();\n        for (int v = 0; v < vertices; v++) {\n            if (matrix[u][v] != 0) {\n                neighbors.add(v);\n            }\n        }\n        return neighbors;\n    }\n}\n\n// 2. ADJACENCY LIST\nclass GraphList {\n    private Map<Integer, List<Edge>> adjList;\n    \n    static class Edge {\n        int dest, weight;\n        Edge(int dest, int weight) {\n            this.dest = dest;\n            this.weight = weight;\n        }\n    }\n    \n    public GraphList() {\n        adjList = new HashMap<>();\n    }\n    \n    // Add edge - O(1)\n    public void addEdge(int u, int v, int weight) {\n        adjList.putIfAbsent(u, new ArrayList<>());\n        adjList.get(u).add(new Edge(v, weight));\n        // For undirected:\n        // adjList.putIfAbsent(v, new ArrayList<>());\n        // adjList.get(v).add(new Edge(u, weight));\n    }\n    \n    // Check edge - O(degree of u)\n    public boolean hasEdge(int u, int v) {\n        if (!adjList.containsKey(u)) return false;\n        for (Edge e : adjList.get(u)) {\n            if (e.dest == v) return true;\n        }\n        return false;\n    }\n    \n    // Get neighbors - O(1) to get list\n    public List<Edge> getNeighbors(int u) {\n        return adjList.getOrDefault(u, new ArrayList<>());\n    }\n    \n    // BFS - Easy with adjacency list\n    public void bfs(int start) {\n        Set<Integer> visited = new HashSet<>();\n        Queue<Integer> queue = new LinkedList<>();\n        \n        queue.offer(start);\n        visited.add(start);\n        \n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n            System.out.print(node + \" \");\n            \n            for (Edge e : getNeighbors(node)) {\n                if (!visited.contains(e.dest)) {\n                    visited.add(e.dest);\n                    queue.offer(e.dest);\n                }\n            }\n        }\n    }\n}\n\n// 3. EDGE LIST\nclass GraphEdgeList {\n    static class Edge {\n        int src, dest, weight;\n        Edge(int src, int dest, int weight) {\n            this.src = src;\n            this.dest = dest;\n            this.weight = weight;\n        }\n    }\n    \n    private List<Edge> edges;\n    private int vertices;\n    \n    public GraphEdgeList(int vertices) {\n        this.vertices = vertices;\n        edges = new ArrayList<>();\n    }\n    \n    // Add edge - O(1)\n    public void addEdge(int u, int v, int weight) {\n        edges.add(new Edge(u, v, weight));\n    }\n    \n    // Get all edges - O(1)\n    public List<Edge> getEdges() {\n        return edges;\n    }\n    \n    // Good for Kruskal's MST\n    public List<Edge> kruskalMST() {\n        List<Edge> mst = new ArrayList<>();\n        edges.sort(Comparator.comparingInt(e -> e.weight));\n        // ... Union-Find implementation\n        return mst;\n    }\n}\n\n// SPACE COMPARISON\n// Dense graph (many edges): V² edges\n//   Matrix: O(V²) - optimal\n//   List: O(V²) - similar\n// Sparse graph (few edges): E << V²\n//   Matrix: O(V²) - wasteful\n//   List: O(V + E) - optimal"
    },
    {
      "id": 86,
      "question": "How do you find the median of a stream of integers?",
      "answer": "Finding median from a data stream requires efficient insertion and median retrieval using two heaps.\n\nTwo-Heap Approach:\n• Max-heap for smaller half\n• Min-heap for larger half\n• Balance heap sizes\n• Median at heap tops\n• O(log n) insertion, O(1) median retrieval\n\nAlgorithm:\n• Maintain: maxHeap.size() >= minHeap.size()\n• Difference at most 1\n• If odd count: median = maxHeap.top()\n• If even count: median = (maxHeap.top() + minHeap.top()) / 2\n\nInsertion Strategy:\n• Add to maxHeap first\n• If maxHeap.top() > minHeap.top(), swap tops\n• Balance if size difference > 1\n• Ensures proper partitioning\n\nWhy This Works:\n• Max-heap keeps max of lower half\n• Min-heap keeps min of upper half\n• Median always between these values\n• O(log n) for heap operations\n\nAlternatives:\n• Sorted array - O(n) insertion\n• BST with size tracking - O(log n) average\n• Skip list - O(log n) expected\n\nApplications:\n• Running statistics\n• Data stream analysis\n• Real-time monitoring\n• Percentile calculations",
      "explanation": "Use max-heap for smaller half and min-heap for larger half, maintaining balanced sizes to get median from heap tops in O(1) with O(log n) insertions.",
      "difficulty": "Hard",
      "code": "// Median from data stream\nclass MedianFinder {\n    private PriorityQueue<Integer> maxHeap; // Lower half\n    private PriorityQueue<Integer> minHeap; // Upper half\n    \n    public MedianFinder() {\n        maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n        minHeap = new PriorityQueue<>();\n    }\n    \n    // Add number - O(log n)\n    public void addNum(int num) {\n        // Add to max heap first\n        maxHeap.offer(num);\n        \n        // Balance: ensure all in maxHeap <= all in minHeap\n        if (!minHeap.isEmpty() && maxHeap.peek() > minHeap.peek()) {\n            minHeap.offer(maxHeap.poll());\n        }\n        \n        // Balance sizes: maxHeap.size >= minHeap.size\n        // and difference at most 1\n        if (maxHeap.size() < minHeap.size()) {\n            maxHeap.offer(minHeap.poll());\n        }\n        if (maxHeap.size() > minHeap.size() + 1) {\n            minHeap.offer(maxHeap.poll());\n        }\n    }\n    \n    // Get median - O(1)\n    public double findMedian() {\n        if (maxHeap.size() > minHeap.size()) {\n            return maxHeap.peek();\n        }\n        return (maxHeap.peek() + minHeap.peek()) / 2.0;\n    }\n}\n\n// Alternative: Simplified version\nclass MedianFinderSimple {\n    private PriorityQueue<Integer> small; // Max heap\n    private PriorityQueue<Integer> large; // Min heap\n    \n    public MedianFinderSimple() {\n        small = new PriorityQueue<>(Collections.reverseOrder());\n        large = new PriorityQueue<>();\n    }\n    \n    public void addNum(int num) {\n        // Add to appropriate heap\n        if (small.isEmpty() || num <= small.peek()) {\n            small.offer(num);\n        } else {\n            large.offer(num);\n        }\n        \n        // Balance\n        if (small.size() > large.size() + 1) {\n            large.offer(small.poll());\n        } else if (large.size() > small.size()) {\n            small.offer(large.poll());\n        }\n    }\n    \n    public double findMedian() {\n        if (small.size() > large.size()) {\n            return small.peek();\n        }\n        return (small.peek() + large.peek()) / 2.0;\n    }\n}\n\n// Usage example\nMedianFinder mf = new MedianFinder();\nmf.addNum(1);    // [1]\nmf.findMedian(); // 1.0\nmf.addNum(2);    // [1, 2]\nmf.findMedian(); // 1.5\nmf.addNum(3);    // [1, 2, 3]\nmf.findMedian(); // 2.0\n\n// Extended: Find kth percentile\nclass PercentileFinder {\n    private PriorityQueue<Integer> smaller;\n    private PriorityQueue<Integer> larger;\n    private double percentile; // 0.0 to 1.0\n    \n    public PercentileFinder(double percentile) {\n        this.percentile = percentile;\n        smaller = new PriorityQueue<>(Collections.reverseOrder());\n        larger = new PriorityQueue<>();\n    }\n    \n    public void addNum(int num) {\n        if (smaller.isEmpty() || num <= smaller.peek()) {\n            smaller.offer(num);\n        } else {\n            larger.offer(num);\n        }\n        \n        // Balance to maintain percentile\n        int total = smaller.size() + larger.size();\n        int targetSmaller = (int)(total * percentile);\n        \n        while (smaller.size() > targetSmaller) {\n            larger.offer(smaller.poll());\n        }\n        while (smaller.size() < targetSmaller && !larger.isEmpty()) {\n            smaller.offer(larger.poll());\n        }\n    }\n    \n    public double findPercentile() {\n        if (smaller.isEmpty()) return larger.peek();\n        if (larger.isEmpty()) return smaller.peek();\n        return smaller.peek();\n    }\n}"
    },
    {
      "id": 87,
      "question": "What is the difference between Depth and Height of a tree?",
      "answer": "Depth and height are fundamental tree metrics measured from different reference points.\n\nDepth of Node:\n• Distance from root to node\n• Number of edges from root\n• Measured downward from root\n• Root has depth 0\n• Also called level\n\nHeight of Node:\n• Distance from node to deepest leaf\n• Number of edges to farthest descendant\n• Measured upward to leaves\n• Leaf has height 0\n• Represents subtree height\n\nHeight of Tree:\n• Height of root node\n• Maximum depth of any node\n• Number of edges in longest path\n• Empty tree: -1 or 0 (convention)\n• Single node: 0\n\nKey Differences:\n• Depth: From root downward\n• Height: From node upward\n• Depth increases going down\n• Height increases going up\n• Node depth is unique\n• Node height depends on subtree\n\nRelationship:\n• height(node) + depth(node) <= height(tree)\n• Balanced tree: All paths similar length\n• Skewed tree: Height = n-1\n\nApplications:\n• Depth: Level-order operations\n• Height: Balance checking\n• Both: Complexity analysis",
      "explanation": "Depth measures distance from root downward (root has depth 0), while height measures distance to deepest leaf upward (leaf has height 0).",
      "difficulty": "Easy",
      "code": "// Tree depth and height\nclass TreeNode {\n    int val;\n    TreeNode left, right;\n    TreeNode(int val) { this.val = val; }\n}\n\nclass TreeMetrics {\n    // Calculate depth of a node - O(h)\n    public int depth(TreeNode root, TreeNode target) {\n        return depthHelper(root, target, 0);\n    }\n    \n    private int depthHelper(TreeNode node, TreeNode target, int currentDepth) {\n        if (node == null) return -1;\n        if (node == target) return currentDepth;\n        \n        int leftDepth = depthHelper(node.left, target, currentDepth + 1);\n        if (leftDepth != -1) return leftDepth;\n        \n        return depthHelper(node.right, target, currentDepth + 1);\n    }\n    \n    // Calculate height of tree - O(n)\n    public int height(TreeNode root) {\n        if (root == null) return -1; // Convention: empty tree = -1\n        // Alternative: return 0 for null\n        \n        int leftHeight = height(root.left);\n        int rightHeight = height(root.right);\n        \n        return 1 + Math.max(leftHeight, rightHeight);\n    }\n    \n    // Calculate height of specific node\n    public int heightOfNode(TreeNode node) {\n        if (node == null) return -1;\n        return 1 + Math.max(heightOfNode(node.left), heightOfNode(node.right));\n    }\n    \n    // Get max depth (same as height)\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n    }\n    \n    // Get all nodes at a given depth\n    public List<TreeNode> nodesAtDepth(TreeNode root, int targetDepth) {\n        List<TreeNode> result = new ArrayList<>();\n        nodesAtDepthHelper(root, 0, targetDepth, result);\n        return result;\n    }\n    \n    private void nodesAtDepthHelper(TreeNode node, int currentDepth, \n                                    int targetDepth, List<TreeNode> result) {\n        if (node == null) return;\n        \n        if (currentDepth == targetDepth) {\n            result.add(node);\n            return;\n        }\n        \n        nodesAtDepthHelper(node.left, currentDepth + 1, targetDepth, result);\n        nodesAtDepthHelper(node.right, currentDepth + 1, targetDepth, result);\n    }\n    \n    // Check if tree is balanced (height difference <= 1)\n    public boolean isBalanced(TreeNode root) {\n        return checkBalance(root) != -1;\n    }\n    \n    private int checkBalance(TreeNode node) {\n        if (node == null) return 0;\n        \n        int leftHeight = checkBalance(node.left);\n        if (leftHeight == -1) return -1;\n        \n        int rightHeight = checkBalance(node.right);\n        if (rightHeight == -1) return -1;\n        \n        if (Math.abs(leftHeight - rightHeight) > 1) {\n            return -1; // Unbalanced\n        }\n        \n        return 1 + Math.max(leftHeight, rightHeight);\n    }\n    \n    // Example visualization\n    public void printMetrics(TreeNode root) {\n        System.out.println(\"Tree height: \" + height(root));\n        System.out.println(\"Tree max depth: \" + maxDepth(root));\n        printNodeMetrics(root, 0);\n    }\n    \n    private void printNodeMetrics(TreeNode node, int depth) {\n        if (node == null) return;\n        \n        System.out.println(\"Node \" + node.val + \n                          \": depth=\" + depth + \n                          \", height=\" + heightOfNode(node));\n        \n        printNodeMetrics(node.left, depth + 1);\n        printNodeMetrics(node.right, depth + 1);\n    }\n}\n\n/*\nExample tree:\n       1           depth=0, height=2\n      / \\\n     2   3         depth=1, height=1\n    / \\\n   4   5           depth=2, height=0\n   \nheight(tree) = 2\nmaxDepth(tree) = 3 (counting nodes) or 2 (counting edges)\nNode 4: depth=2, height=0\nNode 2: depth=1, height=1\n*/"
    },
    {
      "id": 88,
      "question": "What is the Two-Pointer technique and when should you use it?",
      "answer": "Two-pointer technique uses two pointers to solve array/string problems efficiently, often reducing O(n²) to O(n).\n\nTypes of Two Pointers:\n• Opposite ends - Start and end converging\n• Same direction - Fast and slow pointers\n• Sliding window - Both move forward\n• Parallel arrays - One pointer per array\n\nOpposite Direction Pattern:\n• Start at both ends\n• Move toward each other\n• Used for: Two sum, palindrome check, container with most water\n• Condition-based pointer movement\n\nSame Direction Pattern:\n• Both start at beginning\n• Fast moves ahead of slow\n• Used for: Remove duplicates, cycle detection\n• Fast explores, slow processes\n\nWhen to Use:\n• Sorted array problems\n• Palindrome checking\n• Finding pairs/triplets\n• Removing duplicates\n• Merging arrays\n• Cycle detection\n\nAdvantages:\n• Reduces time complexity\n• O(1) extra space\n• Clean, intuitive code\n• No need for hash maps\n\nCommon Problems:\n• Two sum (sorted)\n• Three sum\n• Container with most water\n• Valid palindrome\n• Remove nth node from end",
      "explanation": "Two-pointer technique uses two indices moving through data structures to solve problems in O(n) time with O(1) space, effective for sorted arrays and list problems.",
      "difficulty": "Medium",
      "code": "// Two-pointer technique examples\n\nclass TwoPointerProblems {\n    // 1. Two Sum (sorted array) - O(n)\n    public int[] twoSum(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n        \n        while (left < right) {\n            int sum = nums[left] + nums[right];\n            if (sum == target) {\n                return new int[]{left, right};\n            } else if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return new int[]{-1, -1};\n    }\n    \n    // 2. Valid Palindrome - O(n)\n    public boolean isPalindrome(String s) {\n        int left = 0, right = s.length() - 1;\n        \n        while (left < right) {\n            // Skip non-alphanumeric\n            while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {\n                left++;\n            }\n            while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {\n                right--;\n            }\n            \n            if (Character.toLowerCase(s.charAt(left)) != \n                Character.toLowerCase(s.charAt(right))) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n    \n    // 3. Remove Duplicates (sorted array) - O(n)\n    public int removeDuplicates(int[] nums) {\n        if (nums.length == 0) return 0;\n        \n        int slow = 0; // Position for next unique element\n        \n        for (int fast = 1; fast < nums.length; fast++) {\n            if (nums[fast] != nums[slow]) {\n                slow++;\n                nums[slow] = nums[fast];\n            }\n        }\n        return slow + 1;\n    }\n    \n    // 4. Container With Most Water - O(n)\n    public int maxArea(int[] height) {\n        int left = 0, right = height.length - 1;\n        int maxArea = 0;\n        \n        while (left < right) {\n            int width = right - left;\n            int h = Math.min(height[left], height[right]);\n            maxArea = Math.max(maxArea, width * h);\n            \n            // Move pointer with smaller height\n            if (height[left] < height[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return maxArea;\n    }\n    \n    // 5. Three Sum - O(n²)\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        Arrays.sort(nums);\n        \n        for (int i = 0; i < nums.length - 2; i++) {\n            if (i > 0 && nums[i] == nums[i - 1]) continue; // Skip duplicates\n            \n            int left = i + 1, right = nums.length - 1;\n            int target = -nums[i];\n            \n            while (left < right) {\n                int sum = nums[left] + nums[right];\n                if (sum == target) {\n                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));\n                    \n                    // Skip duplicates\n                    while (left < right && nums[left] == nums[left + 1]) left++;\n                    while (left < right && nums[right] == nums[right - 1]) right--;\n                    \n                    left++;\n                    right--;\n                } else if (sum < target) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n        return result;\n    }\n    \n    // 6. Merge Sorted Arrays - O(m + n)\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int p1 = m - 1, p2 = n - 1;\n        int p = m + n - 1;\n        \n        // Fill from end to avoid overwriting\n        while (p1 >= 0 && p2 >= 0) {\n            if (nums1[p1] > nums2[p2]) {\n                nums1[p] = nums1[p1];\n                p1--;\n            } else {\n                nums1[p] = nums2[p2];\n                p2--;\n            }\n            p--;\n        }\n        \n        // Copy remaining from nums2\n        while (p2 >= 0) {\n            nums1[p] = nums2[p2];\n            p2--;\n            p--;\n        }\n    }\n    \n    // 7. Linked List Cycle Detection (Fast-Slow pointers)\n    public boolean hasCycle(ListNode head) {\n        if (head == null) return false;\n        \n        ListNode slow = head, fast = head;\n        \n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            \n            if (slow == fast) return true;\n        }\n        return false;\n    }\n}"
    },
    {
      "id": 89,
      "question": "What is backtracking and how does it differ from recursion?",
      "answer": "Backtracking is a algorithmic technique that builds solutions incrementally and abandons paths that don't lead to valid solutions.\n\nBacktracking:\n• Systematic trial and error\n• Builds solution incrementally\n• Abandons invalid paths early\n• Explores all possibilities\n• Undoes choices (backtracks)\n\nRecursion:\n• Function calls itself\n• Problem decomposition technique\n• Divides into subproblems\n• No choice undoing\n• General programming technique\n\nKey Differences:\n• Backtracking uses recursion\n• Recursion is broader concept\n• Backtracking explores state space\n• Recursion solves subproblems\n• Backtracking has choice/unchoice\n\nBacktracking Template:\n• Choose - Make a choice\n• Explore - Recurse with choice\n• Unchoose - Undo choice (backtrack)\n• Base case - Check if solution valid\n\nWhen to Use:\n• Constraint satisfaction problems\n• Finding all solutions\n• Combinatorial problems\n• Puzzles (Sudoku, N-Queens)\n• Path finding\n\nCommon Problems:\n• N-Queens\n• Sudoku solver\n• Permutations\n• Combinations\n• Word search\n• Subset sum",
      "explanation": "Backtracking uses recursion with choice exploration and undoing, systematically trying possibilities and abandoning invalid paths, while recursion is just a function calling itself.",
      "difficulty": "Medium",
      "code": "// Backtracking examples\n\nclass BacktrackingProblems {\n    // 1. Generate all permutations - O(n!)\n    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        backtrackPermute(nums, new ArrayList<>(), new boolean[nums.length], result);\n        return result;\n    }\n    \n    private void backtrackPermute(int[] nums, List<Integer> current, \n                                 boolean[] used, List<List<Integer>> result) {\n        // Base case: complete permutation\n        if (current.size() == nums.length) {\n            result.add(new ArrayList<>(current));\n            return;\n        }\n        \n        for (int i = 0; i < nums.length; i++) {\n            if (used[i]) continue;\n            \n            // Choose\n            current.add(nums[i]);\n            used[i] = true;\n            \n            // Explore\n            backtrackPermute(nums, current, used, result);\n            \n            // Unchoose (backtrack)\n            current.remove(current.size() - 1);\n            used[i] = false;\n        }\n    }\n    \n    // 2. Generate all subsets - O(2^n)\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        backtrackSubsets(nums, 0, new ArrayList<>(), result);\n        return result;\n    }\n    \n    private void backtrackSubsets(int[] nums, int start, \n                                 List<Integer> current, List<List<Integer>> result) {\n        // Every state is a valid subset\n        result.add(new ArrayList<>(current));\n        \n        for (int i = start; i < nums.length; i++) {\n            // Choose\n            current.add(nums[i]);\n            \n            // Explore\n            backtrackSubsets(nums, i + 1, current, result);\n            \n            // Unchoose\n            current.remove(current.size() - 1);\n        }\n    }\n    \n    // 3. N-Queens problem\n    public List<List<String>> solveNQueens(int n) {\n        List<List<String>> result = new ArrayList<>();\n        char[][] board = new char[n][n];\n        for (char[] row : board) Arrays.fill(row, '.');\n        \n        backtrackQueens(board, 0, result);\n        return result;\n    }\n    \n    private void backtrackQueens(char[][] board, int row, \n                                List<List<String>> result) {\n        if (row == board.length) {\n            result.add(construct(board));\n            return;\n        }\n        \n        for (int col = 0; col < board.length; col++) {\n            if (!isValid(board, row, col)) continue;\n            \n            // Choose\n            board[row][col] = 'Q';\n            \n            // Explore\n            backtrackQueens(board, row + 1, result);\n            \n            // Unchoose\n            board[row][col] = '.';\n        }\n    }\n    \n    private boolean isValid(char[][] board, int row, int col) {\n        // Check column\n        for (int i = 0; i < row; i++) {\n            if (board[i][col] == 'Q') return false;\n        }\n        \n        // Check diagonal\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n            if (board[i][j] == 'Q') return false;\n        }\n        \n        // Check anti-diagonal\n        for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {\n            if (board[i][j] == 'Q') return false;\n        }\n        \n        return true;\n    }\n    \n    private List<String> construct(char[][] board) {\n        List<String> result = new ArrayList<>();\n        for (char[] row : board) {\n            result.add(new String(row));\n        }\n        return result;\n    }\n    \n    // 4. Word Search - O(m*n*4^L) where L = word length\n    public boolean exist(char[][] board, String word) {\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                if (backtrackWord(board, word, i, j, 0)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    \n    private boolean backtrackWord(char[][] board, String word, \n                                 int row, int col, int index) {\n        if (index == word.length()) return true;\n        \n        if (row < 0 || row >= board.length || \n            col < 0 || col >= board[0].length || \n            board[row][col] != word.charAt(index)) {\n            return false;\n        }\n        \n        // Choose\n        char temp = board[row][col];\n        board[row][col] = '#'; // Mark visited\n        \n        // Explore all 4 directions\n        boolean found = backtrackWord(board, word, row + 1, col, index + 1) ||\n                       backtrackWord(board, word, row - 1, col, index + 1) ||\n                       backtrackWord(board, word, row, col + 1, index + 1) ||\n                       backtrackWord(board, word, row, col - 1, index + 1);\n        \n        // Unchoose\n        board[row][col] = temp;\n        \n        return found;\n    }\n}"
    },
    {
      "id": 90,
      "question": "What is the Sliding Window technique and its common patterns?",
      "answer": "Sliding window optimizes problems involving subarrays/substrings by maintaining a window that slides through the array.\n\nCore Concept:\n• Maintain window boundaries\n• Expand or shrink window\n• Track window state\n• Avoid redundant computation\n• O(n) time typically\n\nFixed-Size Window:\n• Window size constant\n• Slide one position at a time\n• Add new element, remove old\n• Example: Max sum of k elements\n\nVariable-Size Window:\n• Window size changes\n• Expand when valid\n• Shrink when invalid\n• Two pointers track boundaries\n• Example: Longest substring without repeating chars\n\nCommon Patterns:\n• Maximum/minimum subarray\n• Longest/shortest substring\n• Count of subarrays\n• Distinct elements\n• Frequency constraints\n\nWindow State Tracking:\n• Hash map for frequencies\n• Counter for conditions\n• Variables for metrics\n• Update on add/remove\n\nWhen to Use:\n• Contiguous sequence problems\n• Optimization over subarrays\n• String pattern matching\n• Fixed or variable window size\n\nAdvantages:\n• Reduces O(n²) to O(n)\n• Simple to implement\n• Space efficient",
      "explanation": "Sliding window maintains a dynamic window through arrays/strings with two pointers, expanding or shrinking based on constraints to solve subarray problems in O(n) time.",
      "difficulty": "Medium",
      "code": "// Sliding window technique examples\n\nclass SlidingWindowProblems {\n    // 1. Fixed-size: Max sum of k consecutive elements\n    public int maxSumFixedWindow(int[] arr, int k) {\n        if (arr.length < k) return -1;\n        \n        // Initial window sum\n        int windowSum = 0;\n        for (int i = 0; i < k; i++) {\n            windowSum += arr[i];\n        }\n        \n        int maxSum = windowSum;\n        \n        // Slide window\n        for (int i = k; i < arr.length; i++) {\n            windowSum += arr[i] - arr[i - k]; // Add new, remove old\n            maxSum = Math.max(maxSum, windowSum);\n        }\n        \n        return maxSum;\n    }\n    \n    // 2. Variable-size: Longest substring without repeating chars\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> charIndex = new HashMap<>();\n        int maxLen = 0;\n        int left = 0;\n        \n        for (int right = 0; right < s.length(); right++) {\n            char c = s.charAt(right);\n            \n            // If char seen and in current window, shrink window\n            if (charIndex.containsKey(c) && charIndex.get(c) >= left) {\n                left = charIndex.get(c) + 1;\n            }\n            \n            charIndex.put(c, right);\n            maxLen = Math.max(maxLen, right - left + 1);\n        }\n        \n        return maxLen;\n    }\n    \n    // 3. Min window substring\n    public String minWindow(String s, String t) {\n        if (s.length() < t.length()) return \"\";\n        \n        Map<Character, Integer> required = new HashMap<>();\n        for (char c : t.toCharArray()) {\n            required.put(c, required.getOrDefault(c, 0) + 1);\n        }\n        \n        int left = 0, right = 0;\n        int formed = 0; // Number of unique chars matched\n        int required_size = required.size();\n        Map<Character, Integer> windowCounts = new HashMap<>();\n        \n        int[] result = {-1, 0, 0}; // {length, left, right}\n        \n        while (right < s.length()) {\n            // Expand window\n            char c = s.charAt(right);\n            windowCounts.put(c, windowCounts.getOrDefault(c, 0) + 1);\n            \n            if (required.containsKey(c) && \n                windowCounts.get(c).intValue() == required.get(c).intValue()) {\n                formed++;\n            }\n            \n            // Shrink window while valid\n            while (left <= right && formed == required_size) {\n                c = s.charAt(left);\n                \n                // Update result if smaller\n                if (result[0] == -1 || right - left + 1 < result[0]) {\n                    result[0] = right - left + 1;\n                    result[1] = left;\n                    result[2] = right;\n                }\n                \n                windowCounts.put(c, windowCounts.get(c) - 1);\n                if (required.containsKey(c) && \n                    windowCounts.get(c) < required.get(c)) {\n                    formed--;\n                }\n                \n                left++;\n            }\n            \n            right++;\n        }\n        \n        return result[0] == -1 ? \"\" : s.substring(result[1], result[2] + 1);\n    }\n    \n    // 4. Max consecutive ones with k flips\n    public int longestOnes(int[] nums, int k) {\n        int left = 0, right = 0;\n        int maxLen = 0;\n        int zerosCount = 0;\n        \n        while (right < nums.length) {\n            // Expand window\n            if (nums[right] == 0) {\n                zerosCount++;\n            }\n            \n            // Shrink if too many zeros\n            while (zerosCount > k) {\n                if (nums[left] == 0) {\n                    zerosCount--;\n                }\n                left++;\n            }\n            \n            maxLen = Math.max(maxLen, right - left + 1);\n            right++;\n        }\n        \n        return maxLen;\n    }\n    \n    // 5. Subarrays with k different integers\n    public int subarraysWithKDistinct(int[] nums, int k) {\n        return atMostK(nums, k) - atMostK(nums, k - 1);\n    }\n    \n    private int atMostK(int[] nums, int k) {\n        Map<Integer, Integer> count = new HashMap<>();\n        int left = 0, result = 0;\n        \n        for (int right = 0; right < nums.length; right++) {\n            count.put(nums[right], count.getOrDefault(nums[right], 0) + 1);\n            \n            while (count.size() > k) {\n                count.put(nums[left], count.get(nums[left]) - 1);\n                if (count.get(nums[left]) == 0) {\n                    count.remove(nums[left]);\n                }\n                left++;\n            }\n            \n            result += right - left + 1;\n        }\n        \n        return result;\n    }\n}"
    },
    {
      "id": 91,
      "question": "How do you implement a Graph using adjacency list in Java?",
      "answer": "Adjacency list represents graphs efficiently using a map of vertex to list of neighbors, ideal for sparse graphs.\n\nImplementation Approaches:\n• Map with ArrayList\n• Array of ArrayLists\n• HashMap for non-integer vertices\n• LinkedList vs ArrayList\n• Weighted vs unweighted edges\n\nKey Components:\n• Vertex representation\n• Edge storage\n• Add/remove operations\n• Traversal methods\n• Space: O(V + E)\n\nDirected vs Undirected:\n• Directed: Add edge u -> v only\n• Undirected: Add both u -> v and v -> u\n• Bidirectional storage\n\nWeighted Graphs:\n• Store edge objects with weight\n• Or use Map<Vertex, List<Pair>>\n• Include weight in traversals\n\nCommon Operations:\n• Add vertex: O(1)\n• Add edge: O(1)\n• Remove vertex: O(V + E)\n• Remove edge: O(E)\n• Get neighbors: O(1)\n• Check edge: O(degree)\n\nAdvantages:\n• Space efficient for sparse\n• Easy neighbor iteration\n• Dynamic size\n• Natural representation",
      "explanation": "Graph adjacency list uses a map from vertices to neighbor lists, providing O(V+E) space and efficient neighbor access, ideal for sparse graphs.",
      "difficulty": "Medium",
      "code": "// Graph implementation using adjacency list\nimport java.util.*;\n\n// Generic Graph class\nclass Graph<T> {\n    private Map<T, List<Edge<T>>> adjacencyList;\n    private boolean isDirected;\n    \n    static class Edge<T> {\n        T dest;\n        int weight;\n        \n        Edge(T dest, int weight) {\n            this.dest = dest;\n            this.weight = weight;\n        }\n        \n        Edge(T dest) {\n            this(dest, 1); // Default weight 1\n        }\n    }\n    \n    public Graph(boolean isDirected) {\n        this.adjacencyList = new HashMap<>();\n        this.isDirected = isDirected;\n    }\n    \n    // Add vertex - O(1)\n    public void addVertex(T vertex) {\n        adjacencyList.putIfAbsent(vertex, new ArrayList<>());\n    }\n    \n    // Add edge - O(1)\n    public void addEdge(T src, T dest, int weight) {\n        addVertex(src);\n        addVertex(dest);\n        \n        adjacencyList.get(src).add(new Edge<>(dest, weight));\n        \n        if (!isDirected) {\n            adjacencyList.get(dest).add(new Edge<>(src, weight));\n        }\n    }\n    \n    public void addEdge(T src, T dest) {\n        addEdge(src, dest, 1);\n    }\n    \n    // Remove vertex - O(V + E)\n    public void removeVertex(T vertex) {\n        if (!adjacencyList.containsKey(vertex)) return;\n        \n        // Remove all edges to this vertex\n        for (List<Edge<T>> edges : adjacencyList.values()) {\n            edges.removeIf(edge -> edge.dest.equals(vertex));\n        }\n        \n        // Remove vertex\n        adjacencyList.remove(vertex);\n    }\n    \n    // Remove edge - O(degree)\n    public void removeEdge(T src, T dest) {\n        List<Edge<T>> srcEdges = adjacencyList.get(src);\n        if (srcEdges != null) {\n            srcEdges.removeIf(edge -> edge.dest.equals(dest));\n        }\n        \n        if (!isDirected) {\n            List<Edge<T>> destEdges = adjacencyList.get(dest);\n            if (destEdges != null) {\n                destEdges.removeIf(edge -> edge.dest.equals(src));\n            }\n        }\n    }\n    \n    // Get neighbors - O(1)\n    public List<Edge<T>> getNeighbors(T vertex) {\n        return adjacencyList.getOrDefault(vertex, new ArrayList<>());\n    }\n    \n    // Check if edge exists - O(degree)\n    public boolean hasEdge(T src, T dest) {\n        List<Edge<T>> edges = adjacencyList.get(src);\n        if (edges == null) return false;\n        \n        for (Edge<T> edge : edges) {\n            if (edge.dest.equals(dest)) return true;\n        }\n        return false;\n    }\n    \n    // Get all vertices\n    public Set<T> getVertices() {\n        return adjacencyList.keySet();\n    }\n    \n    // BFS traversal\n    public void bfs(T start) {\n        Set<T> visited = new HashSet<>();\n        Queue<T> queue = new LinkedList<>();\n        \n        queue.offer(start);\n        visited.add(start);\n        \n        while (!queue.isEmpty()) {\n            T vertex = queue.poll();\n            System.out.print(vertex + \" \");\n            \n            for (Edge<T> edge : getNeighbors(vertex)) {\n                if (!visited.contains(edge.dest)) {\n                    visited.add(edge.dest);\n                    queue.offer(edge.dest);\n                }\n            }\n        }\n    }\n    \n    // DFS traversal\n    public void dfs(T start) {\n        Set<T> visited = new HashSet<>();\n        dfsHelper(start, visited);\n    }\n    \n    private void dfsHelper(T vertex, Set<T> visited) {\n        visited.add(vertex);\n        System.out.print(vertex + \" \");\n        \n        for (Edge<T> edge : getNeighbors(vertex)) {\n            if (!visited.contains(edge.dest)) {\n                dfsHelper(edge.dest, visited);\n            }\n        }\n    }\n    \n    // Check if path exists\n    public boolean hasPath(T src, T dest) {\n        Set<T> visited = new HashSet<>();\n        return hasPathHelper(src, dest, visited);\n    }\n    \n    private boolean hasPathHelper(T current, T dest, Set<T> visited) {\n        if (current.equals(dest)) return true;\n        if (visited.contains(current)) return false;\n        \n        visited.add(current);\n        \n        for (Edge<T> edge : getNeighbors(current)) {\n            if (hasPathHelper(edge.dest, dest, visited)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    // Print graph\n    public void printGraph() {\n        for (Map.Entry<T, List<Edge<T>>> entry : adjacencyList.entrySet()) {\n            System.out.print(entry.getKey() + \" -> \");\n            for (Edge<T> edge : entry.getValue()) {\n                System.out.print(edge.dest + \"(\" + edge.weight + \") \");\n            }\n            System.out.println();\n        }\n    }\n}\n\n// Usage example\nclass GraphExample {\n    public static void main(String[] args) {\n        // Undirected graph\n        Graph<Integer> graph = new Graph<>(false);\n        graph.addEdge(0, 1);\n        graph.addEdge(0, 2);\n        graph.addEdge(1, 2);\n        graph.addEdge(2, 3);\n        \n        System.out.println(\"Graph structure:\");\n        graph.printGraph();\n        \n        System.out.println(\"\\nBFS from 0:\");\n        graph.bfs(0);\n        \n        System.out.println(\"\\n\\nDFS from 0:\");\n        graph.dfs(0);\n        \n        // Weighted directed graph\n        Graph<String> cityGraph = new Graph<>(true);\n        cityGraph.addEdge(\"NYC\", \"LA\", 2800);\n        cityGraph.addEdge(\"NYC\", \"Chicago\", 800);\n        cityGraph.addEdge(\"LA\", \"Chicago\", 2000);\n        \n        System.out.println(\"\\n\\nCity graph:\");\n        cityGraph.printGraph();\n    }\n}"
    },
    {
      "id": 92,
      "question": "What are the different tree traversal methods and their applications?",
      "answer": "Tree traversals visit all nodes in a specific order, each with distinct characteristics and use cases.\n\nInorder (Left-Root-Right):\n• Visits left, then root, then right\n• BST: Produces sorted order\n• Time: O(n), Space: O(h)\n• Applications: Get sorted data, expression evaluation\n\nPreorder (Root-Left-Right):\n• Visits root first\n• Then left subtree\n• Then right subtree\n• Applications: Tree copying, prefix expressions, tree serialization\n\nPostorder (Left-Right-Root):\n• Visits children before parent\n• Root visited last\n• Applications: Tree deletion, postfix expressions, directory size\n\nLevel-Order (BFS):\n• Level by level traversal\n• Uses queue\n• Applications: Level-wise processing, shortest path in tree\n\nImplementation Methods:\n• Recursive - Simple, uses call stack\n• Iterative - Uses explicit stack/queue\n• Morris - O(1) space, modifies tree temporarily\n\nSpace Complexity:\n• Recursive: O(h) for call stack\n• Iterative: O(h) for explicit stack\n• Level-order: O(w) where w = max width\n• Morris: O(1)",
      "explanation": "Tree traversals include inorder (sorted for BST), preorder (root first), postorder (children first), and level-order (BFS), each with O(n) time and specific applications.",
      "difficulty": "Medium",
      "code": "// Tree traversal implementations\nclass TreeNode {\n    int val;\n    TreeNode left, right;\n    TreeNode(int val) { this.val = val; }\n}\n\nclass TreeTraversal {\n    // INORDER: Left -> Root -> Right\n    // Recursive - O(n) time, O(h) space\n    public void inorderRecursive(TreeNode root) {\n        if (root == null) return;\n        inorderRecursive(root.left);\n        System.out.print(root.val + \" \");\n        inorderRecursive(root.right);\n    }\n    \n    // Iterative using stack\n    public List<Integer> inorderIterative(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode current = root;\n        \n        while (current != null || !stack.isEmpty()) {\n            // Go to leftmost node\n            while (current != null) {\n                stack.push(current);\n                current = current.left;\n            }\n            \n            // Process node\n            current = stack.pop();\n            result.add(current.val);\n            \n            // Go to right\n            current = current.right;\n        }\n        return result;\n    }\n    \n    // PREORDER: Root -> Left -> Right\n    // Recursive\n    public void preorderRecursive(TreeNode root) {\n        if (root == null) return;\n        System.out.print(root.val + \" \");\n        preorderRecursive(root.left);\n        preorderRecursive(root.right);\n    }\n    \n    // Iterative\n    public List<Integer> preorderIterative(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        if (root == null) return result;\n        \n        Stack<TreeNode> stack = new Stack<>();\n        stack.push(root);\n        \n        while (!stack.isEmpty()) {\n            TreeNode node = stack.pop();\n            result.add(node.val);\n            \n            // Push right first so left is processed first\n            if (node.right != null) stack.push(node.right);\n            if (node.left != null) stack.push(node.left);\n        }\n        return result;\n    }\n    \n    // POSTORDER: Left -> Right -> Root\n    // Recursive\n    public void postorderRecursive(TreeNode root) {\n        if (root == null) return;\n        postorderRecursive(root.left);\n        postorderRecursive(root.right);\n        System.out.print(root.val + \" \");\n    }\n    \n    // Iterative using two stacks\n    public List<Integer> postorderIterative(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        if (root == null) return result;\n        \n        Stack<TreeNode> stack1 = new Stack<>();\n        Stack<TreeNode> stack2 = new Stack<>();\n        \n        stack1.push(root);\n        \n        while (!stack1.isEmpty()) {\n            TreeNode node = stack1.pop();\n            stack2.push(node);\n            \n            if (node.left != null) stack1.push(node.left);\n            if (node.right != null) stack1.push(node.right);\n        }\n        \n        while (!stack2.isEmpty()) {\n            result.add(stack2.pop().val);\n        }\n        return result;\n    }\n    \n    // LEVEL-ORDER: BFS\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (root == null) return result;\n        \n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        while (!queue.isEmpty()) {\n            int levelSize = queue.size();\n            List<Integer> currentLevel = new ArrayList<>();\n            \n            for (int i = 0; i < levelSize; i++) {\n                TreeNode node = queue.poll();\n                currentLevel.add(node.val);\n                \n                if (node.left != null) queue.offer(node.left);\n                if (node.right != null) queue.offer(node.right);\n            }\n            \n            result.add(currentLevel);\n        }\n        return result;\n    }\n    \n    // MORRIS INORDER: O(1) space\n    public List<Integer> morrisInorder(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        TreeNode current = root;\n        \n        while (current != null) {\n            if (current.left == null) {\n                result.add(current.val);\n                current = current.right;\n            } else {\n                // Find inorder predecessor\n                TreeNode predecessor = current.left;\n                while (predecessor.right != null && predecessor.right != current) {\n                    predecessor = predecessor.right;\n                }\n                \n                if (predecessor.right == null) {\n                    // Create thread\n                    predecessor.right = current;\n                    current = current.left;\n                } else {\n                    // Remove thread\n                    predecessor.right = null;\n                    result.add(current.val);\n                    current = current.right;\n                }\n            }\n        }\n        return result;\n    }\n    \n    // APPLICATIONS\n    \n    // Get BST values in sorted order (inorder)\n    public List<Integer> getSortedValues(TreeNode root) {\n        List<Integer> sorted = new ArrayList<>();\n        inorderHelper(root, sorted);\n        return sorted;\n    }\n    \n    private void inorderHelper(TreeNode node, List<Integer> list) {\n        if (node == null) return;\n        inorderHelper(node.left, list);\n        list.add(node.val);\n        inorderHelper(node.right, list);\n    }\n    \n    // Serialize tree (preorder)\n    public String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        serializeHelper(root, sb);\n        return sb.toString();\n    }\n    \n    private void serializeHelper(TreeNode node, StringBuilder sb) {\n        if (node == null) {\n            sb.append(\"null,\");\n            return;\n        }\n        sb.append(node.val).append(\",\");\n        serializeHelper(node.left, sb);\n        serializeHelper(node.right, sb);\n    }\n}"
    },
    {
      "id": 93,
      "question": "What is the difference between StringBuilder and StringBuffer in Java?",
      "answer": "StringBuilder and StringBuffer both provide mutable string operations but differ in thread safety and performance.\n\nStringBuilder:\n• Not thread-safe\n• Faster performance\n• No synchronization overhead\n• Introduced in Java 5\n• Recommended for single-threaded\n\nStringBuffer:\n• Thread-safe (synchronized)\n• Slower due to locking\n• Multiple threads can use safely\n• Legacy class (Java 1.0)\n• Overhead of synchronization\n\nCommon Features:\n• Mutable sequences\n• Methods: append, insert, delete, reverse\n• Same API interface\n• Better than String concatenation\n• O(1) amortized append\n\nPerformance:\n• StringBuilder: ~10-20% faster\n• StringBuffer: Synchronization cost\n• Single thread: Use StringBuilder\n• Multi-thread: Use StringBuffer or external sync\n\nWhen to Use:\n• StringBuilder: Default choice for single thread\n• StringBuffer: Legacy code or guaranteed thread-safety\n• String: Immutable, small concatenations\n\nString vs StringBuilder:\n• String creates new objects\n• StringBuilder modifies in place\n• StringBuilder for loops\n• String for constants",
      "explanation": "StringBuilder is faster but not thread-safe, while StringBuffer is synchronized and thread-safe; both provide mutable strings, prefer StringBuilder for single-threaded code.",
      "difficulty": "Easy",
      "code": "// StringBuilder vs StringBuffer\n\nclass StringComparison {\n    public static void main(String[] args) {\n        // STRING - Immutable, creates many objects\n        String str = \"Hello\";\n        str += \" World\"; // Creates new String object\n        // str = str + \"!\"; // Creates another new object\n        // Inefficient for loops\n        \n        // STRINGBUILDER - Mutable, not thread-safe, fast\n        StringBuilder sb = new StringBuilder(\"Hello\");\n        sb.append(\" World\");  // Modifies same object\n        sb.append(\"!\");\n        sb.insert(5, \",\");    // \"Hello, World!\"\n        sb.delete(5, 6);      // \"Hello World!\"\n        sb.reverse();         // \"!dlroW olleH\"\n        sb.reverse();         // Back to \"Hello World!\"\n        String result = sb.toString();\n        \n        // STRINGBUFFER - Mutable, thread-safe, slower\n        StringBuffer sbf = new StringBuffer(\"Hello\");\n        sbf.append(\" World\"); // Synchronized method\n        sbf.append(\"!\");\n        \n        // PERFORMANCE COMPARISON\n        int iterations = 100000;\n        \n        // String concatenation - SLOW\n        long start = System.currentTimeMillis();\n        String s = \"\";\n        for (int i = 0; i < iterations; i++) {\n            s += \"a\"; // Creates new String each time\n        }\n        long stringTime = System.currentTimeMillis() - start;\n        \n        // StringBuilder - FAST\n        start = System.currentTimeMillis();\n        StringBuilder builder = new StringBuilder();\n        for (int i = 0; i < iterations; i++) {\n            builder.append(\"a\");\n        }\n        String sbResult = builder.toString();\n        long builderTime = System.currentTimeMillis() - start;\n        \n        // StringBuffer - SLOWER (synchronized)\n        start = System.currentTimeMillis();\n        StringBuffer buffer = new StringBuffer();\n        for (int i = 0; i < iterations; i++) {\n            buffer.append(\"a\");\n        }\n        String bufferResult = buffer.toString();\n        long bufferTime = System.currentTimeMillis() - start;\n        \n        System.out.println(\"String concatenation: \" + stringTime + \"ms\");\n        System.out.println(\"StringBuilder: \" + builderTime + \"ms\");\n        System.out.println(\"StringBuffer: \" + bufferTime + \"ms\");\n        \n        // WHEN TO USE EACH\n        \n        // 1. StringBuilder - Single-threaded string building\n        public String buildQuery(List<String> conditions) {\n            StringBuilder query = new StringBuilder(\"SELECT * FROM users WHERE \");\n            for (int i = 0; i < conditions.size(); i++) {\n                if (i > 0) query.append(\" AND \");\n                query.append(conditions.get(i));\n            }\n            return query.toString();\n        }\n        \n        // 2. StringBuffer - Thread-safe shared string building\n        class Logger {\n            private StringBuffer log = new StringBuffer();\n            \n            public synchronized void addLog(String message) {\n                log.append(message).append(\"\\n\");\n            }\n            \n            public String getLogs() {\n                return log.toString();\n            }\n        }\n        \n        // 3. String - Simple, immutable\n        String greeting = \"Hello\" + \" \" + \"World\"; // Compiler optimizes\n        final String constant = \"API_KEY_123\"; // Immutable is good\n    }\n    \n    // COMMON OPERATIONS\n    public void commonOperations() {\n        StringBuilder sb = new StringBuilder();\n        \n        // Append various types\n        sb.append(\"String\");\n        sb.append(123);\n        sb.append(true);\n        sb.append('c');\n        \n        // Insert at position\n        sb.insert(0, \"Start: \");\n        \n        // Delete range\n        sb.delete(0, 7); // Remove \"Start: \"\n        \n        // Replace range\n        sb.replace(0, 6, \"Text\");\n        \n        // Reverse\n        sb.reverse();\n        \n        // Get length and capacity\n        int length = sb.length();\n        int capacity = sb.capacity();\n        \n        // Set length (truncate or extend)\n        sb.setLength(10);\n        \n        // Get substring\n        String sub = sb.substring(0, 5);\n        \n        // Convert to String\n        String result = sb.toString();\n    }\n}"
    },
    {
      "id": 94,
      "question": "How do you detect if a binary tree is balanced?",
      "answer": "A balanced binary tree has left and right subtree heights differing by at most 1 for every node, checkable in O(n) time.\n\nDefinition:\n• Height difference <= 1 for all nodes\n• Not just root, but every node\n• Recursively balanced subtrees\n• Empty tree is balanced\n\nNaive Approach:\n• Check height difference at each node\n• Recursively check left and right\n• Time: O(n²) - height computed repeatedly\n• Space: O(h) for recursion\n\nOptimized Approach:\n• Compute height while checking balance\n• Return -1 if unbalanced\n• Single traversal\n• Time: O(n), Space: O(h)\n\nAlgorithm:\n• Post-order traversal\n• Check children before parent\n• Propagate imbalance upward\n• Height = 1 + max(left, right)\n\nBalance Types:\n• Height-balanced (AVL) - |left - right| <= 1\n• Weight-balanced - Node counts\n• Perfect - All levels full\n• Complete - All levels full except possibly last\n\nApplications:\n• AVL tree validation\n• Tree optimization decisions\n• Data structure health check",
      "explanation": "Check if binary tree is balanced by computing heights post-order and verifying each node's subtree height difference is at most 1, achievable in O(n) time.",
      "difficulty": "Medium",
      "code": "// Check if binary tree is balanced\nclass TreeNode {\n    int val;\n    TreeNode left, right;\n    TreeNode(int val) { this.val = val; }\n}\n\nclass BalancedTree {\n    // OPTIMIZED: O(n) time, O(h) space\n    public boolean isBalanced(TreeNode root) {\n        return checkHeight(root) != -1;\n    }\n    \n    // Returns height if balanced, -1 if unbalanced\n    private int checkHeight(TreeNode node) {\n        if (node == null) return 0;\n        \n        // Check left subtree\n        int leftHeight = checkHeight(node.left);\n        if (leftHeight == -1) return -1; // Left unbalanced\n        \n        // Check right subtree\n        int rightHeight = checkHeight(node.right);\n        if (rightHeight == -1) return -1; // Right unbalanced\n        \n        // Check current node balance\n        if (Math.abs(leftHeight - rightHeight) > 1) {\n            return -1; // Current node unbalanced\n        }\n        \n        // Return height\n        return 1 + Math.max(leftHeight, rightHeight);\n    }\n    \n    // NAIVE: O(n²) time - height computed multiple times\n    public boolean isBalancedNaive(TreeNode root) {\n        if (root == null) return true;\n        \n        int leftHeight = height(root.left);\n        int rightHeight = height(root.right);\n        \n        return Math.abs(leftHeight - rightHeight) <= 1 &&\n               isBalancedNaive(root.left) &&\n               isBalancedNaive(root.right);\n    }\n    \n    private int height(TreeNode node) {\n        if (node == null) return 0;\n        return 1 + Math.max(height(node.left), height(node.right));\n    }\n    \n    // Alternative: Using wrapper class\n    class HeightBalance {\n        boolean isBalanced;\n        int height;\n        \n        HeightBalance(boolean isBalanced, int height) {\n            this.isBalanced = isBalanced;\n            this.height = height;\n        }\n    }\n    \n    public boolean isBalancedWrapper(TreeNode root) {\n        return checkBalance(root).isBalanced;\n    }\n    \n    private HeightBalance checkBalance(TreeNode node) {\n        if (node == null) {\n            return new HeightBalance(true, 0);\n        }\n        \n        HeightBalance left = checkBalance(node.left);\n        if (!left.isBalanced) {\n            return new HeightBalance(false, 0);\n        }\n        \n        HeightBalance right = checkBalance(node.right);\n        if (!right.isBalanced) {\n            return new HeightBalance(false, 0);\n        }\n        \n        boolean balanced = Math.abs(left.height - right.height) <= 1;\n        int height = 1 + Math.max(left.height, right.height);\n        \n        return new HeightBalance(balanced, height);\n    }\n    \n    // Check if tree is perfectly balanced (complete binary tree)\n    public boolean isPerfect(TreeNode root) {\n        int height = height(root);\n        return isPerfectHelper(root, height, 0);\n    }\n    \n    private boolean isPerfectHelper(TreeNode node, int totalHeight, int level) {\n        if (node == null) return true;\n        \n        // Leaf check\n        if (node.left == null && node.right == null) {\n            return level == totalHeight - 1;\n        }\n        \n        // Internal node must have both children\n        if (node.left == null || node.right == null) {\n            return false;\n        }\n        \n        return isPerfectHelper(node.left, totalHeight, level + 1) &&\n               isPerfectHelper(node.right, totalHeight, level + 1);\n    }\n    \n    // Get balance factor for a node\n    public int getBalanceFactor(TreeNode node) {\n        if (node == null) return 0;\n        return height(node.left) - height(node.right);\n    }\n    \n    // Find first unbalanced node\n    public TreeNode findUnbalancedNode(TreeNode root) {\n        if (root == null) return null;\n        \n        int leftHeight = height(root.left);\n        int rightHeight = height(root.right);\n        \n        if (Math.abs(leftHeight - rightHeight) > 1) {\n            return root;\n        }\n        \n        TreeNode leftUnbalanced = findUnbalancedNode(root.left);\n        if (leftUnbalanced != null) return leftUnbalanced;\n        \n        return findUnbalancedNode(root.right);\n    }\n}\n\n/*\nExamples:\n\nBalanced:       Unbalanced:\n    1               1\n   / \\               \\\n  2   3               2\n / \\                   \\\n4   5                   3\n                         \\\n                          4\n*/\n\n// Test\nTreeNode balanced = new TreeNode(1);\nbalanced.left = new TreeNode(2);\nbalanced.right = new TreeNode(3);\nbalanced.left.left = new TreeNode(4);\nbalanced.left.right = new TreeNode(5);\n\nBalancedTree bt = new BalancedTree();\nSystem.out.println(bt.isBalanced(balanced)); // true"
    },
    {
      "id": 95,
      "question": "What are the key differences between Array, ArrayList, and LinkedList in Java?",
      "answer": "Arrays, ArrayList, and LinkedList are sequential data structures with different performance characteristics and use cases.\n\nArray:\n• Fixed size\n• Primitives or objects\n• Contiguous memory\n• O(1) access by index\n• No built-in methods\n• Memory efficient\n\nArrayList:\n• Dynamic resizing\n• Objects only (boxing for primitives)\n• Backed by array\n• O(1) access, O(n) insert/delete\n• Rich API\n• Amortized O(1) append\n\nLinkedList:\n• Node-based structure\n• Doubly-linked\n• O(n) access by index\n• O(1) insert/delete at ends\n• More memory per element\n• Implements Queue and Deque\n\nPerformance Comparison:\n• Access: Array = ArrayList > LinkedList\n• Insert at end: ArrayList ≈ LinkedList\n• Insert at middle: LinkedList > ArrayList\n• Memory: Array < ArrayList < LinkedList\n\nWhen to Use:\n• Array: Fixed size, primitives, performance critical\n• ArrayList: General purpose, random access\n• LinkedList: Frequent insertions/deletions, queue/deque operations\n\nMemory Overhead:\n• Array: Just data\n• ArrayList: Data + capacity overhead\n• LinkedList: Data + 2 pointers per node",
      "explanation": "Array has fixed size with best performance, ArrayList is resizable array-backed with O(1) access, LinkedList is node-based with O(1) insertion/deletion but O(n) access.",
      "difficulty": "Medium",
      "code": "// Array vs ArrayList vs LinkedList comparison\nimport java.util.*;\n\nclass SequentialStructures {\n    public static void main(String[] args) {\n        // ARRAY - Fixed size, primitives allowed\n        int[] array = new int[5];\n        array[0] = 1;\n        array[1] = 2;\n        // array[5] = 3; // ArrayIndexOutOfBoundsException\n        int length = array.length;\n        \n        // ARRAYLIST - Dynamic, objects only\n        ArrayList<Integer> arrayList = new ArrayList<>();\n        arrayList.add(1);      // O(1) amortized\n        arrayList.add(2);\n        arrayList.add(0, 0);   // O(n) - shift elements\n        arrayList.get(1);      // O(1) access\n        arrayList.remove(0);   // O(n) - shift elements\n        arrayList.size();\n        \n        // LINKEDLIST - Node-based, implements Deque\n        LinkedList<Integer> linkedList = new LinkedList<>();\n        linkedList.add(1);         // O(1)\n        linkedList.addFirst(0);    // O(1)\n        linkedList.addLast(2);     // O(1)\n        linkedList.get(1);         // O(n) - traverse\n        linkedList.removeFirst();  // O(1)\n        linkedList.removeLast();   // O(1)\n        \n        // PERFORMANCE COMPARISON\n        int n = 100000;\n        \n        // 1. Random Access\n        System.out.println(\"Random Access:\");\n        \n        ArrayList<Integer> al = new ArrayList<>();\n        LinkedList<Integer> ll = new LinkedList<>();\n        for (int i = 0; i < n; i++) {\n            al.add(i);\n            ll.add(i);\n        }\n        \n        long start = System.nanoTime();\n        for (int i = 0; i < 1000; i++) {\n            al.get(n / 2);\n        }\n        System.out.println(\"ArrayList: \" + (System.nanoTime() - start) + \"ns\");\n        \n        start = System.nanoTime();\n        for (int i = 0; i < 1000; i++) {\n            ll.get(n / 2);\n        }\n        System.out.println(\"LinkedList: \" + (System.nanoTime() - start) + \"ns\");\n        \n        // 2. Insert at Beginning\n        System.out.println(\"\\nInsert at Beginning:\");\n        \n        al = new ArrayList<>();\n        ll = new LinkedList<>();\n        \n        start = System.nanoTime();\n        for (int i = 0; i < 10000; i++) {\n            al.add(0, i); // O(n) each time\n        }\n        System.out.println(\"ArrayList: \" + (System.nanoTime() - start) + \"ns\");\n        \n        start = System.nanoTime();\n        for (int i = 0; i < 10000; i++) {\n            ll.addFirst(i); // O(1) each time\n        }\n        System.out.println(\"LinkedList: \" + (System.nanoTime() - start) + \"ns\");\n        \n        // 3. Append at End\n        System.out.println(\"\\nAppend at End:\");\n        \n        al = new ArrayList<>();\n        ll = new LinkedList<>();\n        \n        start = System.nanoTime();\n        for (int i = 0; i < n; i++) {\n            al.add(i); // O(1) amortized\n        }\n        System.out.println(\"ArrayList: \" + (System.nanoTime() - start) + \"ns\");\n        \n        start = System.nanoTime();\n        for (int i = 0; i < n; i++) {\n            ll.add(i); // O(1)\n        }\n        System.out.println(\"LinkedList: \" + (System.nanoTime() - start) + \"ns\");\n    }\n    \n    // WHEN TO USE EACH\n    \n    // Use Array: Fixed size, performance critical\n    public int findMax(int[] numbers) {\n        int max = numbers[0];\n        for (int num : numbers) {\n            max = Math.max(max, num);\n        }\n        return max;\n    }\n    \n    // Use ArrayList: General purpose, random access\n    public List<String> filterNames(List<String> names, String prefix) {\n        List<String> filtered = new ArrayList<>();\n        for (String name : names) {\n            if (name.startsWith(prefix)) {\n                filtered.add(name);\n            }\n        }\n        return filtered;\n    }\n    \n    // Use LinkedList: Queue/Deque operations\n    class TaskQueue {\n        private LinkedList<Task> queue = new LinkedList<>();\n        \n        public void enqueue(Task task) {\n            queue.addLast(task); // O(1)\n        }\n        \n        public Task dequeue() {\n            return queue.removeFirst(); // O(1)\n        }\n        \n        public void addPriority(Task task) {\n            queue.addFirst(task); // O(1)\n        }\n    }\n    \n    // MEMORY COMPARISON\n    // Array: 4 bytes per int\n    // ArrayList: 4 bytes per int + object overhead + capacity buffer\n    // LinkedList: 4 bytes + 16 bytes (2 pointers) + object overhead per node\n}\n\nclass Task {\n    String name;\n}"
    },
    {
      "id": 96,
      "question": "How do you implement a Min Stack that supports getMin in O(1)?",
      "answer": "Min Stack maintains minimum element at each state, enabling O(1) retrieval using auxiliary storage or encoding.\n\nTwo-Stack Approach:\n• Main stack for all elements\n• Min stack tracks minimums\n• Push: Add to both if new min\n• Pop: Remove from both if current min\n• GetMin: Return minStack.top()\n• Space: O(n) worst case\n\nSingle Stack with Pairs:\n• Store (value, currentMin) pairs\n• Each element knows min at its level\n• Space: O(n) always\n• Simpler implementation\n\nEncoding Approach:\n• Store encoded values\n• When push < min, encode both\n• Decode on pop\n• Space: O(1) extra\n• More complex logic\n\nAll Operations:\n• Push: O(1)\n• Pop: O(1)\n• Top: O(1)\n• GetMin: O(1)\n\nKey Insight:\n• Track historical minimums\n• Minimum at each state matters\n• Must handle duplicates\n• Restore previous min on pop",
      "explanation": "Min Stack uses auxiliary stack or value pairs to track minimum at each level, enabling O(1) getMin, push, and pop operations.",
      "difficulty": "Hard",
      "code": "// Min Stack implementations\n\n// Approach 1: Two Stacks\nclass MinStack {\n    private Stack<Integer> stack;\n    private Stack<Integer> minStack;\n    \n    public MinStack() {\n        stack = new Stack<>();\n        minStack = new Stack<>();\n    }\n    \n    // Push - O(1)\n    public void push(int val) {\n        stack.push(val);\n        \n        if (minStack.isEmpty() || val <= minStack.peek()) {\n            minStack.push(val);\n        }\n    }\n    \n    // Pop - O(1)\n    public void pop() {\n        int val = stack.pop();\n        \n        if (val == minStack.peek()) {\n            minStack.pop();\n        }\n    }\n    \n    // Top - O(1)\n    public int top() {\n        return stack.peek();\n    }\n    \n    // Get minimum - O(1)\n    public int getMin() {\n        return minStack.peek();\n    }\n}\n\n// Approach 2: Stack of Pairs\nclass MinStackPairs {\n    private Stack<int[]> stack; // [value, currentMin]\n    \n    public MinStackPairs() {\n        stack = new Stack<>();\n    }\n    \n    public void push(int val) {\n        if (stack.isEmpty()) {\n            stack.push(new int[]{val, val});\n        } else {\n            int currentMin = Math.min(val, stack.peek()[1]);\n            stack.push(new int[]{val, currentMin});\n        }\n    }\n    \n    public void pop() {\n        stack.pop();\n    }\n    \n    public int top() {\n        return stack.peek()[0];\n    }\n    \n    public int getMin() {\n        return stack.peek()[1];\n    }\n}\n\n// Approach 3: Single Stack with Node\nclass MinStackNode {\n    class Node {\n        int value;\n        int min;\n        Node next;\n        \n        Node(int value, int min, Node next) {\n            this.value = value;\n            this.min = min;\n            this.next = next;\n        }\n    }\n    \n    private Node head;\n    \n    public MinStackNode() {\n        head = null;\n    }\n    \n    public void push(int val) {\n        if (head == null) {\n            head = new Node(val, val, null);\n        } else {\n            int currentMin = Math.min(val, head.min);\n            head = new Node(val, currentMin, head);\n        }\n    }\n    \n    public void pop() {\n        head = head.next;\n    }\n    \n    public int top() {\n        return head.value;\n    }\n    \n    public int getMin() {\n        return head.min;\n    }\n}\n\n// Approach 4: Encoding (Space-optimized)\nclass MinStackEncoded {\n    private Stack<Long> stack;\n    private long min;\n    \n    public MinStackEncoded() {\n        stack = new Stack<>();\n    }\n    \n    public void push(int val) {\n        if (stack.isEmpty()) {\n            stack.push(0L);\n            min = val;\n        } else {\n            // Encode: push difference from min\n            stack.push(val - min);\n            if (val < min) {\n                min = val; // Update min\n            }\n        }\n    }\n    \n    public void pop() {\n        if (stack.isEmpty()) return;\n        \n        long pop = stack.pop();\n        \n        if (pop < 0) {\n            // Previous min was stored, restore it\n            min = min - pop;\n        }\n    }\n    \n    public int top() {\n        long top = stack.peek();\n        if (top < 0) {\n            return (int) min;\n        }\n        return (int) (top + min);\n    }\n    \n    public int getMin() {\n        return (int) min;\n    }\n}\n\n// Usage and Testing\nclass MinStackTest {\n    public static void main(String[] args) {\n        MinStack minStack = new MinStack();\n        \n        minStack.push(-2);\n        minStack.push(0);\n        minStack.push(-3);\n        System.out.println(minStack.getMin()); // -3\n        \n        minStack.pop();\n        System.out.println(minStack.top());    // 0\n        System.out.println(minStack.getMin()); // -2\n        \n        // Test with duplicates\n        minStack.push(-2);\n        System.out.println(minStack.getMin()); // -2\n        minStack.pop();\n        System.out.println(minStack.getMin()); // -2\n    }\n}\n\n// Extended: Max Stack (similar concept)\nclass MaxStack {\n    private Stack<Integer> stack;\n    private Stack<Integer> maxStack;\n    \n    public MaxStack() {\n        stack = new Stack<>();\n        maxStack = new Stack<>();\n    }\n    \n    public void push(int val) {\n        stack.push(val);\n        \n        if (maxStack.isEmpty() || val >= maxStack.peek()) {\n            maxStack.push(val);\n        }\n    }\n    \n    public void pop() {\n        int val = stack.pop();\n        \n        if (val == maxStack.peek()) {\n            maxStack.pop();\n        }\n    }\n    \n    public int top() {\n        return stack.peek();\n    }\n    \n    public int getMax() {\n        return maxStack.peek();\n    }\n}"
    },
    {
      "id": 97,
      "question": "What is the difference between Comparable and Comparator in Java?",
      "answer": "Comparable and Comparator both enable sorting but differ in implementation location and flexibility.\n\nComparable:\n• Interface with compareTo method\n• Defined in the class itself\n• Natural ordering\n• Single sorting sequence\n• Modifies original class\n• Method: compareTo(T other)\n\nComparator:\n• Separate class or lambda\n• External to compared class\n• Custom ordering\n• Multiple sorting sequences possible\n• Doesn't modify original class\n• Method: compare(T o1, T o2)\n\nWhen to Use:\n• Comparable: Natural/default ordering\n• Comparator: Multiple orderings, can't modify class\n• Comparator: Sorting by different criteria\n\nReturn Values:\n• Negative: this < other (or o1 < o2)\n• Zero: equal\n• Positive: this > other (or o1 > o2)\n\nCommon Usage:\n• Collections.sort() uses Comparable\n• Collections.sort(list, comparator) uses Comparator\n• Arrays.sort() supports both\n• TreeSet/TreeMap use both\n\nJava 8 Enhancements:\n• Comparator.comparing()\n• Comparator.thenComparing()\n• Lambda expressions\n• Method references",
      "explanation": "Comparable defines natural ordering within a class via compareTo, while Comparator provides external custom ordering via compare, allowing multiple sort criteria.",
      "difficulty": "Medium",
      "code": "// Comparable vs Comparator\nimport java.util.*;\n\n// Using COMPARABLE - Natural ordering\nclass Student implements Comparable<Student> {\n    String name;\n    int id;\n    double gpa;\n    \n    Student(String name, int id, double gpa) {\n        this.name = name;\n        this.id = id;\n        this.gpa = gpa;\n    }\n    \n    // Natural ordering by ID\n    @Override\n    public int compareTo(Student other) {\n        return Integer.compare(this.id, other.id);\n        // Or: return this.id - other.id;\n    }\n    \n    @Override\n    public String toString() {\n        return name + \"(\" + id + \", \" + gpa + \")\";\n    }\n}\n\n// Using COMPARATOR - Custom orderings\nclass ComparatorExamples {\n    // Comparator by name\n    static class NameComparator implements Comparator<Student> {\n        @Override\n        public int compare(Student s1, Student s2) {\n            return s1.name.compareTo(s2.name);\n        }\n    }\n    \n    // Comparator by GPA (descending)\n    static class GPAComparator implements Comparator<Student> {\n        @Override\n        public int compare(Student s1, Student s2) {\n            return Double.compare(s2.gpa, s1.gpa); // Descending\n        }\n    }\n    \n    public static void main(String[] args) {\n        List<Student> students = Arrays.asList(\n            new Student(\"Alice\", 103, 3.8),\n            new Student(\"Bob\", 101, 3.5),\n            new Student(\"Charlie\", 102, 3.9)\n        );\n        \n        // 1. Sort using Comparable (natural ordering by ID)\n        Collections.sort(students);\n        System.out.println(\"By ID: \" + students);\n        \n        // 2. Sort using Comparator by name\n        Collections.sort(students, new NameComparator());\n        System.out.println(\"By Name: \" + students);\n        \n        // 3. Sort using Comparator by GPA\n        Collections.sort(students, new GPAComparator());\n        System.out.println(\"By GPA: \" + students);\n        \n        // JAVA 8+ LAMBDA EXPRESSIONS\n        \n        // Sort by name (ascending)\n        students.sort((s1, s2) -> s1.name.compareTo(s2.name));\n        \n        // Sort by GPA (descending)\n        students.sort((s1, s2) -> Double.compare(s2.gpa, s1.gpa));\n        \n        // JAVA 8+ METHOD REFERENCES\n        \n        // Using Comparator.comparing\n        students.sort(Comparator.comparing(s -> s.name));\n        students.sort(Comparator.comparing(Student::getName));\n        \n        // Reverse order\n        students.sort(Comparator.comparing(Student::getGpa).reversed());\n        \n        // Multiple criteria (chaining)\n        students.sort(Comparator.comparing(Student::getGpa)\n                               .reversed()\n                               .thenComparing(Student::getName));\n        \n        // Natural order (for Comparable classes)\n        students.sort(Comparator.naturalOrder());\n        students.sort(Comparator.reverseOrder());\n        \n        // NULLS HANDLING\n        students.sort(Comparator.nullsFirst(\n            Comparator.comparing(Student::getName)\n        ));\n        \n        students.sort(Comparator.nullsLast(\n            Comparator.comparing(Student::getName)\n        ));\n    }\n}\n\n// Complete example with getters\nclass Employee implements Comparable<Employee> {\n    private String name;\n    private int age;\n    private double salary;\n    \n    public Employee(String name, int age, double salary) {\n        this.name = name;\n        this.age = age;\n        this.salary = salary;\n    }\n    \n    // Natural ordering by salary\n    @Override\n    public int compareTo(Employee other) {\n        return Double.compare(this.salary, other.salary);\n    }\n    \n    // Getters\n    public String getName() { return name; }\n    public int getAge() { return age; }\n    public double getSalary() { return salary; }\n    \n    @Override\n    public String toString() {\n        return name + \"(\" + age + \", $\" + salary + \")\";\n    }\n}\n\nclass EmployeeComparators {\n    public static void main(String[] args) {\n        List<Employee> employees = Arrays.asList(\n            new Employee(\"Alice\", 30, 75000),\n            new Employee(\"Bob\", 25, 60000),\n            new Employee(\"Charlie\", 35, 80000),\n            new Employee(\"David\", 25, 70000)\n        );\n        \n        // Natural order (by salary)\n        Collections.sort(employees);\n        System.out.println(\"By Salary: \" + employees);\n        \n        // By age, then by name\n        employees.sort(Comparator.comparingInt(Employee::getAge)\n                                .thenComparing(Employee::getName));\n        System.out.println(\"By Age, then Name: \" + employees);\n        \n        // By name length, then alphabetically\n        employees.sort(Comparator.comparingInt((Employee e) -> e.getName().length())\n                                .thenComparing(Employee::getName));\n        System.out.println(\"By Name Length: \" + employees);\n    }\n}\n\n// TREESET AND TREEMAP\nclass TreeExample {\n    public static void main(String[] args) {\n        // TreeSet uses Comparable\n        Set<Student> studentSet = new TreeSet<>(); // Uses compareTo\n        \n        // TreeSet with Comparator\n        Set<Student> byName = new TreeSet<>(new NameComparator());\n        \n        // TreeMap\n        Map<Student, String> grades = new TreeMap<>(); // Uses compareTo\n        Map<Student, String> gradesByName = new TreeMap<>(new NameComparator());\n    }\n}"
    },
    {
      "id": 98,
      "question": "How do you reverse a linked list iteratively and recursively?",
      "answer": "Reversing a linked list involves changing next pointers to point backward, achievable both iteratively and recursively.\n\nIterative Approach:\n• Three pointers: prev, current, next\n• Traverse and reverse pointers\n• Time: O(n), Space: O(1)\n• More space efficient\n• Single pass through list\n\nRecursive Approach:\n• Base case: Single node\n• Reverse rest recursively\n• Fix current node's next\n• Time: O(n), Space: O(n) for call stack\n• More elegant code\n• Stack space overhead\n\nKey Steps (Iterative):\n• Initialize prev = null\n• While current not null\n• Save next node\n• Reverse current.next to prev\n• Move prev and current forward\n• Return prev (new head)\n\nKey Steps (Recursive):\n• If null or single node, return\n• Recursively reverse rest\n• Set next node's next to current\n• Set current's next to null\n• Return new head\n\nEdge Cases:\n• Empty list\n• Single node\n• Two nodes\n• Circular detection",
      "explanation": "Linked list reversal uses three pointers iteratively in O(1) space or recursive calls in O(n) space, both achieving O(n) time to reverse pointer directions.",
      "difficulty": "Medium",
      "code": "// Reverse linked list implementations\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(int val) { this.val = val; }\n}\n\nclass ReverseLinkedList {\n    // ITERATIVE - O(n) time, O(1) space\n    public ListNode reverseIterative(ListNode head) {\n        ListNode prev = null;\n        ListNode current = head;\n        \n        while (current != null) {\n            ListNode next = current.next; // Save next\n            current.next = prev;          // Reverse pointer\n            prev = current;               // Move prev forward\n            current = next;               // Move current forward\n        }\n        \n        return prev; // New head\n    }\n    \n    // RECURSIVE - O(n) time, O(n) space\n    public ListNode reverseRecursive(ListNode head) {\n        // Base cases\n        if (head == null || head.next == null) {\n            return head;\n        }\n        \n        // Reverse rest of list\n        ListNode newHead = reverseRecursive(head.next);\n        \n        // Fix current node\n        head.next.next = head; // Next node points back to current\n        head.next = null;      // Current points to null\n        \n        return newHead;\n    }\n    \n    // Alternative recursive with helper\n    public ListNode reverseRecursiveHelper(ListNode head) {\n        return reverseHelper(head, null);\n    }\n    \n    private ListNode reverseHelper(ListNode current, ListNode prev) {\n        if (current == null) {\n            return prev;\n        }\n        \n        ListNode next = current.next;\n        current.next = prev;\n        return reverseHelper(next, current);\n    }\n    \n    // Reverse between positions [left, right]\n    public ListNode reverseBetween(ListNode head, int left, int right) {\n        if (head == null || left == right) return head;\n        \n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode prev = dummy;\n        \n        // Move to node before left\n        for (int i = 1; i < left; i++) {\n            prev = prev.next;\n        }\n        \n        // Reverse between left and right\n        ListNode current = prev.next;\n        for (int i = 0; i < right - left; i++) {\n            ListNode temp = current.next;\n            current.next = temp.next;\n            temp.next = prev.next;\n            prev.next = temp;\n        }\n        \n        return dummy.next;\n    }\n    \n    // Reverse in k-group\n    public ListNode reverseKGroup(ListNode head, int k) {\n        if (head == null || k == 1) return head;\n        \n        // Check if k nodes available\n        ListNode current = head;\n        int count = 0;\n        while (current != null && count < k) {\n            current = current.next;\n            count++;\n        }\n        \n        if (count < k) return head; // Not enough nodes\n        \n        // Reverse k nodes\n        ListNode prev = null;\n        current = head;\n        for (int i = 0; i < k; i++) {\n            ListNode next = current.next;\n            current.next = prev;\n            prev = current;\n            current = next;\n        }\n        \n        // Recursively reverse remaining\n        head.next = reverseKGroup(current, k);\n        \n        return prev;\n    }\n    \n    // Reverse alternate k nodes\n    public ListNode reverseAlternateKGroup(ListNode head, int k) {\n        if (head == null) return null;\n        \n        ListNode current = head;\n        ListNode prev = null;\n        int count = 0;\n        \n        // Reverse k nodes\n        while (current != null && count < k) {\n            ListNode next = current.next;\n            current.next = prev;\n            prev = current;\n            current = next;\n            count++;\n        }\n        \n        // Skip next k nodes\n        if (head != null) {\n            head.next = current;\n            count = 0;\n            while (count < k - 1 && current != null) {\n                current = current.next;\n                count++;\n            }\n            \n            // Recursively process remaining\n            if (current != null) {\n                current.next = reverseAlternateKGroup(current.next, k);\n            }\n        }\n        \n        return prev;\n    }\n    \n    // Print list\n    public void printList(ListNode head) {\n        ListNode current = head;\n        while (current != null) {\n            System.out.print(current.val);\n            if (current.next != null) System.out.print(\" -> \");\n            current = current.next;\n        }\n        System.out.println();\n    }\n}\n\n// Test\nclass TestReverse {\n    public static void main(String[] args) {\n        ReverseLinkedList rll = new ReverseLinkedList();\n        \n        // Create list: 1 -> 2 -> 3 -> 4 -> 5\n        ListNode head = new ListNode(1);\n        head.next = new ListNode(2);\n        head.next.next = new ListNode(3);\n        head.next.next.next = new ListNode(4);\n        head.next.next.next.next = new ListNode(5);\n        \n        System.out.println(\"Original:\");\n        rll.printList(head);\n        \n        // Reverse iteratively\n        head = rll.reverseIterative(head);\n        System.out.println(\"Reversed (Iterative):\");\n        rll.printList(head); // 5 -> 4 -> 3 -> 2 -> 1\n        \n        // Reverse back recursively\n        head = rll.reverseRecursive(head);\n        System.out.println(\"Reversed back (Recursive):\");\n        rll.printList(head); // 1 -> 2 -> 3 -> 4 -> 5\n        \n        // Reverse between positions\n        head = rll.reverseBetween(head, 2, 4);\n        System.out.println(\"Reversed between 2-4:\");\n        rll.printList(head); // 1 -> 4 -> 3 -> 2 -> 5\n    }\n}\n\n/*\nVisualization:\n\nOriginal: 1 -> 2 -> 3 -> 4 -> 5 -> null\n\nIterative steps:\nprev   curr  next\nnull   1     2      : 1.next = null\n1      2     3      : 2.next = 1\n2      3     4      : 3.next = 2\n3      4     5      : 4.next = 3\n4      5     null   : 5.next = 4\n5      null  -      : return 5\n\nReversed: 5 -> 4 -> 3 -> 2 -> 1 -> null\n*/"
    },
    {
      "id": 99,
      "question": "What is the time and space complexity of common sorting algorithms?",
      "answer": "Sorting algorithms have different complexity characteristics affecting their suitability for various scenarios.\n\nComparison-Based Sorts:\n\nQuick Sort:\n• Average: O(n log n) time, O(log n) space\n• Worst: O(n²) time, O(n) space\n• In-place, not stable\n• Best for general purpose\n\nMerge Sort:\n• All cases: O(n log n) time, O(n) space\n• Stable, not in-place\n• Good for linked lists\n• Predictable performance\n\nHeap Sort:\n• All cases: O(n log n) time, O(1) space\n• In-place, not stable\n• No worst case quadratic\n\nInsertion Sort:\n• Best: O(n), Average/Worst: O(n²)\n• O(1) space, stable\n• Good for small or nearly sorted\n\nNon-Comparison Sorts:\n\nCounting Sort:\n• O(n + k) time, O(n + k) space\n• k = range of values\n• Stable, linear time\n\nRadix Sort:\n• O(d × (n + k)) time\n• d = digits, k = base\n• Stable, good for integers\n\nSpace Types:\n• In-place: O(1) or O(log n)\n• Out-place: O(n)\n• Stable: Preserves relative order",
      "explanation": "Sorting algorithms range from O(n log n) comparison sorts like merge and quick sort to O(n) non-comparison sorts like counting and radix for specific data.",
      "difficulty": "Medium",
      "code": "// Sorting algorithms with complexity analysis\n\nclass SortingAlgorithms {\n    \n    // QUICK SORT - O(n log n) average, O(n²) worst\n    // Space: O(log n) average due to recursion\n    public void quickSort(int[] arr, int low, int high) {\n        if (low < high) {\n            int pivotIndex = partition(arr, low, high);\n            quickSort(arr, low, pivotIndex - 1);\n            quickSort(arr, pivotIndex + 1, high);\n        }\n    }\n    \n    private int partition(int[] arr, int low, int high) {\n        int pivot = arr[high];\n        int i = low - 1;\n        \n        for (int j = low; j < high; j++) {\n            if (arr[j] <= pivot) {\n                i++;\n                swap(arr, i, j);\n            }\n        }\n        swap(arr, i + 1, high);\n        return i + 1;\n    }\n    \n    // MERGE SORT - O(n log n) all cases\n    // Space: O(n)\n    public void mergeSort(int[] arr, int left, int right) {\n        if (left < right) {\n            int mid = left + (right - left) / 2;\n            mergeSort(arr, left, mid);\n            mergeSort(arr, mid + 1, right);\n            merge(arr, left, mid, right);\n        }\n    }\n    \n    private void merge(int[] arr, int left, int mid, int right) {\n        int n1 = mid - left + 1;\n        int n2 = right - mid;\n        \n        int[] L = new int[n1];\n        int[] R = new int[n2];\n        \n        System.arraycopy(arr, left, L, 0, n1);\n        System.arraycopy(arr, mid + 1, R, 0, n2);\n        \n        int i = 0, j = 0, k = left;\n        \n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k++] = L[i++];\n            } else {\n                arr[k++] = R[j++];\n            }\n        }\n        \n        while (i < n1) arr[k++] = L[i++];\n        while (j < n2) arr[k++] = R[j++];\n    }\n    \n    // HEAP SORT - O(n log n) all cases\n    // Space: O(1)\n    public void heapSort(int[] arr) {\n        int n = arr.length;\n        \n        // Build max heap\n        for (int i = n / 2 - 1; i >= 0; i--) {\n            heapify(arr, n, i);\n        }\n        \n        // Extract elements from heap\n        for (int i = n - 1; i > 0; i--) {\n            swap(arr, 0, i);\n            heapify(arr, i, 0);\n        }\n    }\n    \n    private void heapify(int[] arr, int n, int i) {\n        int largest = i;\n        int left = 2 * i + 1;\n        int right = 2 * i + 2;\n        \n        if (left < n && arr[left] > arr[largest]) largest = left;\n        if (right < n && arr[right] > arr[largest]) largest = right;\n        \n        if (largest != i) {\n            swap(arr, i, largest);\n            heapify(arr, n, largest);\n        }\n    }\n    \n    // INSERTION SORT - O(n²) average/worst, O(n) best\n    // Space: O(1), Stable\n    public void insertionSort(int[] arr) {\n        for (int i = 1; i < arr.length; i++) {\n            int key = arr[i];\n            int j = i - 1;\n            \n            while (j >= 0 && arr[j] > key) {\n                arr[j + 1] = arr[j];\n                j--;\n            }\n            arr[j + 1] = key;\n        }\n    }\n    \n    // BUBBLE SORT - O(n²) average/worst, O(n) best\n    // Space: O(1), Stable\n    public void bubbleSort(int[] arr) {\n        int n = arr.length;\n        for (int i = 0; i < n - 1; i++) {\n            boolean swapped = false;\n            for (int j = 0; j < n - i - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    swap(arr, j, j + 1);\n                    swapped = true;\n                }\n            }\n            if (!swapped) break; // Already sorted\n        }\n    }\n    \n    // SELECTION SORT - O(n²) all cases\n    // Space: O(1), Not stable\n    public void selectionSort(int[] arr) {\n        for (int i = 0; i < arr.length - 1; i++) {\n            int minIndex = i;\n            for (int j = i + 1; j < arr.length; j++) {\n                if (arr[j] < arr[minIndex]) {\n                    minIndex = j;\n                }\n            }\n            swap(arr, i, minIndex);\n        }\n    }\n    \n    // COUNTING SORT - O(n + k)\n    // Space: O(n + k), Stable\n    public void countingSort(int[] arr) {\n        int max = Arrays.stream(arr).max().getAsInt();\n        int min = Arrays.stream(arr).min().getAsInt();\n        int range = max - min + 1;\n        \n        int[] count = new int[range];\n        int[] output = new int[arr.length];\n        \n        // Count frequencies\n        for (int num : arr) {\n            count[num - min]++;\n        }\n        \n        // Cumulative count\n        for (int i = 1; i < range; i++) {\n            count[i] += count[i - 1];\n        }\n        \n        // Build output\n        for (int i = arr.length - 1; i >= 0; i--) {\n            output[count[arr[i] - min] - 1] = arr[i];\n            count[arr[i] - min]--;\n        }\n        \n        System.arraycopy(output, 0, arr, 0, arr.length);\n    }\n    \n    private void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}\n\n// Complexity Summary Table\n/*\nAlgorithm       Best         Average      Worst        Space    Stable\n---------------------------------------------------------------------------\nQuick Sort      O(n log n)   O(n log n)   O(n²)       O(log n)  No\nMerge Sort      O(n log n)   O(n log n)   O(n log n)  O(n)      Yes\nHeap Sort       O(n log n)   O(n log n)   O(n log n)  O(1)      No\nInsertion Sort  O(n)         O(n²)        O(n²)       O(1)      Yes\nBubble Sort     O(n)         O(n²)        O(n²)       O(1)      Yes\nSelection Sort  O(n²)        O(n²)        O(n²)       O(1)      No\nCounting Sort   O(n+k)       O(n+k)       O(n+k)      O(n+k)    Yes\nRadix Sort      O(d(n+k))    O(d(n+k))    O(d(n+k))   O(n+k)    Yes\n\nWhen to use:\n- Quick Sort: General purpose, average case important\n- Merge Sort: Stable sort needed, linked lists\n- Heap Sort: O(1) space needed, no worst O(n²)\n- Insertion: Small or nearly sorted data\n- Counting: Small integer range\n- Radix: Fixed-length integers\n*/"
    },
    {
      "id": 100,
      "question": "What are the key strategies for solving dynamic programming problems?",
      "answer": "Dynamic programming solves optimization problems by breaking them into overlapping subproblems and using optimal substructure.\n\nIdentifying DP Problems:\n• Optimal substructure - Optimal solution contains optimal subsolutions\n• Overlapping subproblems - Same subproblems solved multiple times\n• Make choices that affect future states\n• Count ways or find min/max\n• Keywords: maximize, minimize, count, longest, shortest\n\nKey Strategies:\n\n1. Define State:\n• What information needed at each step\n• Usually 1D or 2D array\n• Index represents subproblem\n\n2. Find Recurrence:\n• How to build solution from smaller ones\n• Transition between states\n• Consider all choices\n\n3. Base Cases:\n• Smallest solvable subproblems\n• Usually trivial solutions\n• Initialize DP array\n\n4. Order of Computation:\n• Bottom-up: Smaller to larger\n• Top-down: Memoize recursive\n• Ensure dependencies met\n\n5. Space Optimization:\n• Often can reduce dimensions\n• Keep only needed previous states\n• Rolling array technique\n\nCommon Patterns:\n• Linear DP - House Robber, Climbing Stairs\n• 2D Grid - Unique Paths, Min Path Sum\n• Strings - LCS, Edit Distance\n• Knapsack - Subset Sum, Coin Change\n• Trees - Binary tree max path\n\nProblem-Solving Steps:\n• Identify if DP applicable\n• Define state and subproblems\n• Write recurrence relation\n• Implement with memoization or tabulation\n• Optimize space if possible",
      "explanation": "DP problems require identifying optimal substructure and overlapping subproblems, then defining states, deriving recurrence relations, and implementing via memoization or tabulation.",
      "difficulty": "Hard",
      "code": "// Dynamic Programming strategies and patterns\n\nclass DPStrategies {\n    \n    // PATTERN 1: Linear DP - Fibonacci\n    // State: dp[i] = ith Fibonacci number\n    // Recurrence: dp[i] = dp[i-1] + dp[i-2]\n    public int fibonacci(int n) {\n        if (n <= 1) return n;\n        \n        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        dp[1] = 1;\n        \n        for (int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n    \n    // Space-optimized: O(1)\n    public int fibonacciOptimized(int n) {\n        if (n <= 1) return n;\n        int prev2 = 0, prev1 = 1;\n        for (int i = 2; i <= n; i++) {\n            int curr = prev1 + prev2;\n            prev2 = prev1;\n            prev1 = curr;\n        }\n        return prev1;\n    }\n    \n    // PATTERN 2: Decision Making - House Robber\n    // State: dp[i] = max money robbing up to house i\n    // Recurrence: dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    public int rob(int[] nums) {\n        if (nums.length == 0) return 0;\n        if (nums.length == 1) return nums[0];\n        \n        int[] dp = new int[nums.length];\n        dp[0] = nums[0];\n        dp[1] = Math.max(nums[0], nums[1]);\n        \n        for (int i = 2; i < nums.length; i++) {\n            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);\n        }\n        return dp[nums.length - 1];\n    }\n    \n    // PATTERN 3: 2D Grid - Unique Paths\n    // State: dp[i][j] = paths to reach (i,j)\n    // Recurrence: dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    public int uniquePaths(int m, int n) {\n        int[][] dp = new int[m][n];\n        \n        // Base case: first row and column\n        for (int i = 0; i < m; i++) dp[i][0] = 1;\n        for (int j = 0; j < n; j++) dp[0][j] = 1;\n        \n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n    \n    // Space-optimized: O(n)\n    public int uniquePathsOptimized(int m, int n) {\n        int[] dp = new int[n];\n        Arrays.fill(dp, 1);\n        \n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[j] += dp[j - 1];\n            }\n        }\n        return dp[n - 1];\n    }\n    \n    // PATTERN 4: String DP - Longest Common Subsequence\n    // State: dp[i][j] = LCS length of s1[0..i-1] and s2[0..j-1]\n    public int longestCommonSubsequence(String text1, String text2) {\n        int m = text1.length(), n = text2.length();\n        int[][] dp = new int[m + 1][n + 1];\n        \n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n    \n    // PATTERN 5: Knapsack - Coin Change\n    // State: dp[i] = min coins to make amount i\n    // Recurrence: dp[i] = min(dp[i-coin] + 1) for all coins\n    public int coinChange(int[] coins, int amount) {\n        int[] dp = new int[amount + 1];\n        Arrays.fill(dp, amount + 1);\n        dp[0] = 0;\n        \n        for (int i = 1; i <= amount; i++) {\n            for (int coin : coins) {\n                if (i >= coin) {\n                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n                }\n            }\n        }\n        return dp[amount] > amount ? -1 : dp[amount];\n    }\n    \n    // PATTERN 6: Partition - Partition Equal Subset Sum\n    // State: dp[i][j] = can make sum j using first i elements\n    public boolean canPartition(int[] nums) {\n        int sum = Arrays.stream(nums).sum();\n        if (sum % 2 != 0) return false;\n        \n        int target = sum / 2;\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n        \n        for (int num : nums) {\n            for (int j = target; j >= num; j--) {\n                dp[j] = dp[j] || dp[j - num];\n            }\n        }\n        return dp[target];\n    }\n    \n    // GENERAL DP TEMPLATE\n    public int dpTemplate(int[] input) {\n        // 1. Define state\n        int n = input.length;\n        int[] dp = new int[n];\n        \n        // 2. Initialize base cases\n        dp[0] = input[0];\n        \n        // 3. Fill table using recurrence\n        for (int i = 1; i < n; i++) {\n            // Consider all choices/transitions\n            dp[i] = Math.max(dp[i - 1], input[i]);\n        }\n        \n        // 4. Return answer\n        return dp[n - 1];\n    }\n    \n    // DP Problem Checklist:\n    // 1. Can problem be broken into subproblems?\n    // 2. Do subproblems overlap?\n    // 3. Is there optimal substructure?\n    // 4. What are the states?\n    // 5. What is the recurrence relation?\n    // 6. What are base cases?\n    // 7. What order to compute?\n    // 8. Can space be optimized?\n}\n\n/*\nCommon DP Patterns Summary:\n\n1. Linear DP: dp[i] depends on dp[i-1], dp[i-2], etc.\n   Examples: Fibonacci, Climbing Stairs, House Robber\n\n2. 2D DP: dp[i][j] depends on dp[i-1][j], dp[i][j-1], etc.\n   Examples: Unique Paths, Edit Distance, LCS\n\n3. Knapsack: Choose to include or exclude items\n   Examples: 0/1 Knapsack, Coin Change, Subset Sum\n\n4. Interval DP: dp[i][j] for range [i,j]\n   Examples: Longest Palindromic Substring, Burst Balloons\n\n5. Tree DP: States on tree nodes\n   Examples: Binary Tree Max Path Sum, House Robber III\n\n6. State Machine DP: States represent different conditions\n   Examples: Stock Trading, Paint House\n*/"
    }
  ]
}
