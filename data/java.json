{
  "topic": "Java",
  "questions": [
    {
      "id": 1,
      "question": "What is the difference between JDK, JRE, and JVM?",
      "answer": "JVM (Java Virtual Machine): Executes Java bytecode and provides platform independence.\n\nJRE (Java Runtime Environment): Contains JVM + libraries needed to run Java applications.\n\nJDK (Java Development Kit): Contains JRE + development tools (compiler, debugger) to develop Java applications.",
      "explanation": "Think of it as layers: JVM is the core engine, JRE wraps it with libraries for running apps, and JDK adds development tools on top. You need JDK to develop, JRE to run, and JVM is always running underneath.",
      "difficulty": "Easy",
      "code": "// Check Java version\njava -version  // Shows JRE version\njavac -version // Shows JDK version (compiler)"
    },
    {
      "id": 2,
      "question": "What are the main principles of OOP in Java?",
      "answer": "The four main principles are:\n\n1. Encapsulation: Bundling data and methods together, hiding internal state using access modifiers.\n\n2. Inheritance: A class can inherit properties and methods from another class using 'extends'.\n\n3. Polymorphism: Objects can take multiple forms - method overloading (compile-time) and overriding (runtime).\n\n4. Abstraction: Hiding complex implementation details, showing only necessary features using abstract classes and interfaces.",
      "explanation": "These principles help create modular, reusable, and maintainable code. Encapsulation protects data, inheritance promotes code reuse, polymorphism enables flexibility, and abstraction simplifies complexity.",
      "difficulty": "Easy"
    },
    {
      "id": 3,
      "question": "What is the difference between == and .equals() in Java?",
      "answer": "== compares references (memory addresses) - checks if two variables point to the same object.\n\n.equals() compares values/content - checks if two objects are logically equal.\n\nFor primitives, == compares values directly. For objects, always use .equals() for content comparison.",
      "explanation": "This is a common source of bugs. String s1 = new String(\"hello\"); String s2 = new String(\"hello\"); s1 == s2 is false (different objects), but s1.equals(s2) is true (same content).",
      "difficulty": "Easy",
      "code": "String s1 = new String(\"hello\");\nString s2 = new String(\"hello\");\n\nSystem.out.println(s1 == s2);      // false (different objects)\nSystem.out.println(s1.equals(s2)); // true (same content)\n\n// String pool exception\nString s3 = \"hello\";\nString s4 = \"hello\";\nSystem.out.println(s3 == s4);      // true (same pool reference)"
    },
    {
      "id": 4,
      "question": "What is the difference between Abstract Class and Interface?",
      "answer": "Abstract Class:\n• Can have abstract and concrete methods\n• Can have instance variables\n• Single inheritance only\n• Can have constructors\n• Use 'extends' keyword\n\nInterface:\n• All methods are abstract (before Java 8)\n• Can have default and static methods (Java 8+)\n• Only constants (public static final)\n• Multiple inheritance supported\n• Use 'implements' keyword",
      "explanation": "Use abstract class when classes share common behavior with some implementation. Use interface to define a contract that multiple unrelated classes can implement. Since Java 8, interfaces can have default methods, blurring the line.",
      "difficulty": "Medium",
      "code": "// Abstract Class\nabstract class Animal {\n    String name;\n    abstract void sound();\n    void sleep() { System.out.println(\"Sleeping...\"); }\n}\n\n// Interface\ninterface Flyable {\n    void fly();\n    default void land() { System.out.println(\"Landing...\"); }\n}\n\nclass Bird extends Animal implements Flyable {\n    void sound() { System.out.println(\"Chirp\"); }\n    public void fly() { System.out.println(\"Flying\"); }\n}"
    },
    {
      "id": 5,
      "question": "What is the String Pool in Java?",
      "answer": "String Pool is a special memory area in the heap where Java stores String literals. When you create a String literal, Java first checks if it exists in the pool. If yes, it returns the reference; if no, it creates a new String in the pool.\n\nThis saves memory by reusing immutable String objects.",
      "explanation": "String pool is why s1 == s2 returns true for literals but false for new String(). The intern() method can add strings to the pool manually.",
      "difficulty": "Medium",
      "code": "String s1 = \"hello\";  // Goes to String Pool\nString s2 = \"hello\";  // Returns same reference from pool\nString s3 = new String(\"hello\"); // Creates new object in heap\n\nSystem.out.println(s1 == s2);  // true\nSystem.out.println(s1 == s3);  // false\nSystem.out.println(s1 == s3.intern()); // true (intern adds to pool)"
    },
    {
      "id": 6,
      "question": "What are the differences between ArrayList and LinkedList?",
      "answer": "ArrayList:\n• Backed by dynamic array\n• Fast random access O(1)\n• Slow insertion/deletion O(n) - needs shifting\n• Less memory overhead\n• Better for read-heavy operations\n\nLinkedList:\n• Doubly linked list structure\n• Slow random access O(n)\n• Fast insertion/deletion O(1) at known position\n• More memory (stores prev/next pointers)\n• Better for frequent add/remove operations",
      "explanation": "Choose ArrayList for most cases due to cache locality and random access. Use LinkedList only when you need frequent insertions/deletions at the beginning or middle of the list.",
      "difficulty": "Medium",
      "code": "List<String> arrayList = new ArrayList<>();\narrayList.add(\"A\");     // O(1) amortized\narrayList.get(0);       // O(1) - fast\narrayList.remove(0);    // O(n) - slow, needs shifting\n\nList<String> linkedList = new LinkedList<>();\nlinkedList.add(\"A\");    // O(1)\nlinkedList.get(0);      // O(n) - slow, traversal\nlinkedList.removeFirst(); // O(1) - fast"
    },
    {
      "id": 7,
      "question": "What is the difference between HashMap and HashTable?",
      "answer": "HashMap:\n• Not synchronized (not thread-safe)\n• Allows one null key and multiple null values\n• Faster performance\n• Part of Collections framework\n• Use ConcurrentHashMap for thread-safety\n\nHashTable:\n• Synchronized (thread-safe)\n• Does not allow null keys or values\n• Slower due to synchronization\n• Legacy class\n• Considered obsolete",
      "explanation": "Always prefer HashMap over HashTable. For thread-safety, use ConcurrentHashMap which provides better performance than HashTable through segment-level locking.",
      "difficulty": "Medium",
      "code": "// HashMap - preferred\nMap<String, Integer> hashMap = new HashMap<>();\nhashMap.put(null, 1);  // OK\nhashMap.put(\"key\", null); // OK\n\n// HashTable - legacy, avoid\nMap<String, Integer> hashTable = new Hashtable<>();\n// hashTable.put(null, 1);  // NullPointerException\n\n// For thread-safety, use:\nMap<String, Integer> concurrentMap = new ConcurrentHashMap<>();"
    },
    {
      "id": 8,
      "question": "What is the difference between final, finally, and finalize?",
      "answer": "final:\n• Keyword to declare constants, prevent inheritance, or prevent method overriding\n• final variable = constant\n• final method = cannot override\n• final class = cannot extend\n\nfinally:\n• Block that always executes after try-catch\n• Used for cleanup (closing resources)\n\nfinalize:\n• Method called by garbage collector before destroying object\n• Deprecated in Java 9+, avoid using",
      "explanation": "These three have completely different purposes despite similar names. 'final' is for immutability, 'finally' for cleanup, and 'finalize' was for pre-destruction cleanup (now deprecated).",
      "difficulty": "Easy",
      "code": "// final\nfinal int MAX = 100;  // constant\nfinal class Utility {} // cannot extend\n\n// finally\ntry {\n    // code\n} catch (Exception e) {\n    // handle\n} finally {\n    // always runs - cleanup\n}\n\n// finalize (deprecated)\n@Override\nprotected void finalize() throws Throwable {\n    // cleanup before GC\n}"
    },
    {
      "id": 9,
      "question": "What is Java Garbage Collection and how does it work?",
      "answer": "Garbage Collection (GC) is automatic memory management that identifies and removes objects no longer in use.\n\nHow it works:\n1. Mark: Identifies reachable objects from GC roots\n2. Sweep: Removes unmarked (unreachable) objects\n3. Compact: Defragments memory (optional)\n\nGenerations:\n• Young Generation: New objects, frequent GC (Minor GC)\n• Old Generation: Long-lived objects, less frequent GC (Major GC)\n• Metaspace: Class metadata (replaced PermGen in Java 8)",
      "explanation": "GC eliminates memory leaks and manual memory management. However, you cannot force GC - System.gc() is only a suggestion. Understanding GC helps optimize application performance.",
      "difficulty": "Medium"
    },
    {
      "id": 10,
      "question": "What are Java Streams and how do they work?",
      "answer": "Streams are a sequence of elements supporting sequential and parallel aggregate operations. Introduced in Java 8.\n\nKey characteristics:\n• Not a data structure - processes data from sources\n• Lazy evaluation - intermediate operations not executed until terminal operation\n• Can be parallelized easily\n• Cannot be reused after terminal operation\n\nOperations:\n• Intermediate: filter, map, sorted (return Stream)\n• Terminal: collect, forEach, reduce (produce result)",
      "explanation": "Streams enable functional-style operations on collections. They make code more readable and can be parallelized for better performance on multi-core processors.",
      "difficulty": "Medium",
      "code": "List<String> names = Arrays.asList(\"John\", \"Jane\", \"Bob\", \"Alice\");\n\n// Filter, transform, collect\nList<String> result = names.stream()\n    .filter(n -> n.startsWith(\"J\"))  // intermediate\n    .map(String::toUpperCase)         // intermediate\n    .sorted()                          // intermediate\n    .collect(Collectors.toList());    // terminal\n\n// Result: [\"JANE\", \"JOHN\"]\n\n// Parallel processing\nnames.parallelStream()\n    .forEach(System.out::println);"
    },
    {
      "id": 11,
      "question": "What is the difference between Checked and Unchecked Exceptions?",
      "answer": "Checked Exceptions:\n• Checked at compile-time\n• Must be handled (try-catch) or declared (throws)\n• Extend Exception class\n• Examples: IOException, SQLException\n\nUnchecked Exceptions:\n• Not checked at compile-time\n• No mandatory handling required\n• Extend RuntimeException\n• Examples: NullPointerException, ArrayIndexOutOfBoundsException",
      "explanation": "Checked exceptions force you to handle predictable errors (file not found, network issues). Unchecked exceptions are programming errors that should be fixed in code rather than caught.",
      "difficulty": "Easy",
      "code": "// Checked - must handle\npublic void readFile() throws IOException {\n    FileReader fr = new FileReader(\"file.txt\");\n}\n\n// Or use try-catch\npublic void readFile() {\n    try {\n        FileReader fr = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n\n// Unchecked - no mandatory handling\npublic void process() {\n    String s = null;\n    s.length(); // NullPointerException - runtime error\n}"
    },
    {
      "id": 12,
      "question": "What is the difference between method overloading and overriding?",
      "answer": "Method Overloading:\n• Same method name, different parameters\n• Compile-time polymorphism\n• Within the same class\n• Return type can be different\n• Access modifier can be different\n\nMethod Overriding:\n• Same method signature in parent and child class\n• Runtime polymorphism\n• Between parent and child class\n• Return type must be same or covariant\n• Access modifier cannot be more restrictive",
      "explanation": "Overloading provides multiple ways to call a method with different arguments. Overriding allows child class to provide specific implementation of a method already defined in parent class.",
      "difficulty": "Easy",
      "code": "// Overloading - same class, different params\nclass Calculator {\n    int add(int a, int b) { return a + b; }\n    double add(double a, double b) { return a + b; }\n    int add(int a, int b, int c) { return a + b + c; }\n}\n\n// Overriding - child class changes behavior\nclass Animal {\n    void sound() { System.out.println(\"Some sound\"); }\n}\n\nclass Dog extends Animal {\n    @Override\n    void sound() { System.out.println(\"Bark\"); }\n}"
    },
    {
      "id": 13,
      "question": "What is the volatile keyword in Java?",
      "answer": "volatile is a keyword used in multi-threading to ensure that a variable's value is always read from main memory, not from thread's local cache.\n\nEffects:\n• Guarantees visibility across threads\n• Prevents caching of variable in CPU registers\n• Ensures happens-before relationship\n• Does NOT provide atomicity\n\nUse when:\n• Variable is accessed by multiple threads\n• No compound operations (i++ is not atomic)",
      "explanation": "Without volatile, threads may see stale values due to CPU caching. volatile solves visibility but not atomicity - for atomic operations use AtomicInteger or synchronized.",
      "difficulty": "Hard",
      "code": "class SharedResource {\n    // Without volatile - threads may not see updates\n    private boolean running = true;\n    \n    // With volatile - guaranteed visibility\n    private volatile boolean flag = true;\n    \n    public void stop() {\n        flag = false; // Other threads will see this immediately\n    }\n    \n    public void run() {\n        while (flag) {\n            // work\n        }\n    }\n}"
    },
    {
      "id": 14,
      "question": "What is the difference between synchronized block and method?",
      "answer": "Synchronized Method:\n• Locks the entire method\n• Lock on 'this' object (instance method) or Class object (static method)\n• Simple syntax\n• Less granular control\n\nSynchronized Block:\n• Locks only specific code section\n• Can lock on any object\n• More granular control\n• Better performance (less locking time)\n• Can have different locks for different blocks",
      "explanation": "Prefer synchronized blocks for finer control and better performance. Synchronized methods lock the entire method which may be overkill and can cause unnecessary thread contention.",
      "difficulty": "Medium",
      "code": "// Synchronized method - locks 'this'\npublic synchronized void method1() {\n    // entire method is synchronized\n}\n\n// Synchronized block - more control\npublic void method2() {\n    // non-synchronized code\n    synchronized(this) {\n        // only this block is synchronized\n    }\n    // more non-synchronized code\n}\n\n// Different locks for different resources\nprivate final Object lock1 = new Object();\nprivate final Object lock2 = new Object();\n\npublic void method3() {\n    synchronized(lock1) { /* access resource1 */ }\n    synchronized(lock2) { /* access resource2 */ }\n}"
    },
    {
      "id": 15,
      "question": "What is the Java Memory Model?",
      "answer": "Java Memory Model (JMM) defines how threads interact through memory and what behaviors are allowed in concurrent execution.\n\nKey areas:\n• Heap: Shared memory for objects (all threads access)\n• Stack: Thread-local memory for method calls and local variables\n• Metaspace: Class metadata\n\nKey concepts:\n• Happens-before relationship\n• Visibility guarantees\n• Atomicity rules\n• Ordering guarantees",
      "explanation": "JMM ensures predictable behavior in multi-threaded programs. It defines when changes made by one thread become visible to others and prevents certain compiler/hardware optimizations that could break thread safety.",
      "difficulty": "Hard"
    },
    {
      "id": 16,
      "question": "What are Functional Interfaces in Java?",
      "answer": "A Functional Interface is an interface with exactly one abstract method. It can have multiple default or static methods.\n\nUsed as target types for lambda expressions and method references.\n\nBuilt-in examples:\n• Runnable: void run()\n• Callable<V>: V call()\n• Comparator<T>: int compare(T, T)\n• Function<T,R>: R apply(T)\n• Predicate<T>: boolean test(T)\n• Consumer<T>: void accept(T)\n• Supplier<T>: T get()",
      "explanation": "Functional interfaces enable functional programming in Java. The @FunctionalInterface annotation is optional but helps catch errors if you accidentally add more abstract methods.",
      "difficulty": "Medium",
      "code": "@FunctionalInterface\ninterface Calculator {\n    int calculate(int a, int b);\n    \n    // default methods are allowed\n    default void print() { }\n}\n\n// Using with lambda\nCalculator add = (a, b) -> a + b;\nCalculator multiply = (a, b) -> a * b;\n\nSystem.out.println(add.calculate(5, 3));      // 8\nSystem.out.println(multiply.calculate(5, 3)); // 15\n\n// Built-in functional interfaces\nPredicate<String> isEmpty = s -> s.isEmpty();\nFunction<String, Integer> length = String::length;\nConsumer<String> printer = System.out::println;"
    },
    {
      "id": 17,
      "question": "What is Optional in Java and why use it?",
      "answer": "Optional<T> is a container object that may or may not contain a non-null value. Introduced in Java 8 to avoid NullPointerException.\n\nKey methods:\n• Optional.of(value) - creates Optional, throws if null\n• Optional.ofNullable(value) - creates Optional, allows null\n• Optional.empty() - creates empty Optional\n• isPresent() - checks if value exists\n• orElse(default) - returns value or default\n• orElseThrow() - returns value or throws exception\n• map(), flatMap() - transform value",
      "explanation": "Optional forces developers to explicitly handle the absence of a value, making code more expressive and reducing null checks. It's particularly useful as return type for methods that might not return a value.",
      "difficulty": "Medium",
      "code": "// Without Optional - null checks everywhere\nString name = user.getName();\nif (name != null) {\n    System.out.println(name.toUpperCase());\n}\n\n// With Optional - cleaner\nOptional<String> optName = Optional.ofNullable(user.getName());\noptName.ifPresent(n -> System.out.println(n.toUpperCase()));\n\n// Chain operations\nString result = Optional.ofNullable(user)\n    .map(User::getName)\n    .map(String::toUpperCase)\n    .orElse(\"UNKNOWN\");\n\n// Method returning Optional\npublic Optional<User> findById(Long id) {\n    User user = repository.find(id);\n    return Optional.ofNullable(user);\n}"
    },
    {
      "id": 18,
      "question": "What is the difference between Comparable and Comparator?",
      "answer": "Comparable:\n• Interface implemented by the class itself\n• Single sorting sequence (natural ordering)\n• compareTo(Object o) method\n• Modifies the original class\n• java.lang package\n\nComparator:\n• Separate class for comparison logic\n• Multiple sorting sequences possible\n• compare(Object o1, Object o2) method\n• Does not modify original class\n• java.util package",
      "explanation": "Use Comparable for natural/default ordering (like String, Integer). Use Comparator when you need multiple sort orders or can't modify the class being sorted.",
      "difficulty": "Medium",
      "code": "// Comparable - natural ordering\nclass Employee implements Comparable<Employee> {\n    String name;\n    int salary;\n    \n    @Override\n    public int compareTo(Employee e) {\n        return this.salary - e.salary; // sort by salary\n    }\n}\n\n// Comparator - custom ordering\nComparator<Employee> byName = (e1, e2) -> e1.name.compareTo(e2.name);\nComparator<Employee> bySalaryDesc = (e1, e2) -> e2.salary - e1.salary;\n\n// Using\nCollections.sort(employees);           // uses Comparable\nCollections.sort(employees, byName);   // uses Comparator\nemployees.sort(bySalaryDesc);          // Java 8+ List.sort"
    },
    {
      "id": 19,
      "question": "What is the difference between fail-fast and fail-safe iterators?",
      "answer": "Fail-Fast Iterators:\n• Throw ConcurrentModificationException if collection modified during iteration\n• Work on original collection\n• Examples: ArrayList, HashMap iterators\n• Faster, less memory\n\nFail-Safe Iterators:\n• Do not throw exception on modification\n• Work on a copy of the collection\n• Examples: CopyOnWriteArrayList, ConcurrentHashMap\n• Slower, more memory (due to copying)",
      "explanation": "Fail-fast helps detect bugs early in single-threaded scenarios. Fail-safe is designed for concurrent access but may not reflect latest changes during iteration.",
      "difficulty": "Hard",
      "code": "// Fail-Fast - ArrayList\nList<String> list = new ArrayList<>();\nlist.add(\"A\"); list.add(\"B\");\n\nfor (String s : list) {\n    list.remove(s); // ConcurrentModificationException!\n}\n\n// Fail-Safe - CopyOnWriteArrayList\nList<String> safeList = new CopyOnWriteArrayList<>();\nsafeList.add(\"A\"); safeList.add(\"B\");\n\nfor (String s : safeList) {\n    safeList.remove(s); // OK - works on copy\n}\n\n// Safe removal with iterator\nIterator<String> it = list.iterator();\nwhile (it.hasNext()) {\n    it.next();\n    it.remove(); // Safe way to remove\n}"
    },
    {
      "id": 20,
      "question": "What is the difference between wait() and sleep()?",
      "answer": "wait():\n• Defined in Object class\n• Releases the lock/monitor\n• Must be called from synchronized context\n• Wakes up by notify()/notifyAll() or timeout\n• Used for inter-thread communication\n\nsleep():\n• Defined in Thread class\n• Does NOT release the lock\n• Can be called from anywhere\n• Wakes up after specified time\n• Used to pause execution for a duration",
      "explanation": "wait() is for thread coordination - a thread waits for a condition and releases the lock for others. sleep() just pauses the current thread without affecting locks.",
      "difficulty": "Medium",
      "code": "// wait() - releases lock, needs synchronized\nsynchronized(lock) {\n    while (!condition) {\n        lock.wait(); // releases lock, waits\n    }\n    // proceed when notified\n}\n\n// notify from another thread\nsynchronized(lock) {\n    condition = true;\n    lock.notify(); // wakes up waiting thread\n}\n\n// sleep() - does NOT release lock\nsynchronized(lock) {\n    Thread.sleep(1000); // still holds lock!\n}"
    },
    {
      "id": 21,
      "question": "What is the static keyword in Java?",
      "answer": "static is a keyword that belongs to the class rather than instance.\n\nCan be applied to:\n• Variables: Shared by all instances, one copy per class\n• Methods: Can be called without creating instance\n• Blocks: Executed once when class is loaded\n• Nested classes: Can be instantiated without outer class instance\n\nCharacteristics:\n• Cannot access non-static members directly\n• Loaded at class loading time\n• Memory efficient (single copy)",
      "explanation": "static members are useful for constants, utility methods, and counters that should be shared across all instances. Main method is static so JVM can call it without creating object.",
      "difficulty": "Easy",
      "code": "class Counter {\n    static int count = 0;  // Shared by all instances\n    int id;\n    \n    Counter() {\n        count++;  // Increment shared counter\n        id = count;\n    }\n    \n    static void displayCount() {  // Static method\n        System.out.println(\"Total: \" + count);\n        // System.out.println(id);  // Error: can't access non-static\n    }\n    \n    static {  // Static block\n        System.out.println(\"Class loaded\");\n    }\n}\n\n// Usage\nCounter.displayCount();  // Call without instance\nCounter c1 = new Counter();\nCounter c2 = new Counter();\nCounter.count;  // 2"
    },
    {
      "id": 22,
      "question": "What is the difference between this and super keywords?",
      "answer": "this:\n• Refers to current instance of the class\n• Access current class members\n• Call current class constructor (this())\n• Used to differentiate between instance and local variables\n\nsuper:\n• Refers to parent class instance\n• Access parent class members\n• Call parent class constructor (super())\n• Used to invoke overridden methods from parent",
      "explanation": "this is for the current object, super is for the parent object. Both must be the first statement when calling constructors.",
      "difficulty": "Easy",
      "code": "class Parent {\n    String name = \"Parent\";\n    \n    Parent() {\n        System.out.println(\"Parent constructor\");\n    }\n    \n    void display() {\n        System.out.println(\"Parent display\");\n    }\n}\n\nclass Child extends Parent {\n    String name = \"Child\";\n    \n    Child() {\n        super();  // Call parent constructor (must be first)\n        System.out.println(\"Child constructor\");\n    }\n    \n    void show() {\n        System.out.println(this.name);   // Child\n        System.out.println(super.name);  // Parent\n        super.display();  // Call parent method\n    }\n}"
    },
    {
      "id": 23,
      "question": "What are the different types of constructors in Java?",
      "answer": "Types of constructors:\n\n1. Default Constructor: No parameters, provided by compiler if no constructor defined\n\n2. No-arg Constructor: Explicitly defined with no parameters\n\n3. Parameterized Constructor: Accepts parameters to initialize object\n\n4. Copy Constructor: Creates object by copying another object (not built-in in Java)\n\nRules:\n• Constructor name must match class name\n• No return type (not even void)\n• Can be overloaded\n• First line is super() or this() call (implicit if not specified)",
      "explanation": "If you define any constructor, the compiler won't provide default constructor. Use constructor overloading to provide multiple ways to initialize objects.",
      "difficulty": "Easy",
      "code": "class Person {\n    String name;\n    int age;\n    \n    // Default constructor (only if no other constructor)\n    // Person() { }\n    \n    // No-arg constructor\n    Person() {\n        name = \"Unknown\";\n        age = 0;\n    }\n    \n    // Parameterized constructor\n    Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    // Copy constructor (manual implementation)\n    Person(Person other) {\n        this.name = other.name;\n        this.age = other.age;\n    }\n}\n\n// Usage\nPerson p1 = new Person();\nPerson p2 = new Person(\"John\", 25);\nPerson p3 = new Person(p2);  // Copy"
    },
    {
      "id": 24,
      "question": "What are access modifiers in Java?",
      "answer": "Access modifiers control visibility of classes, methods, and variables:\n\npublic:\n• Accessible from anywhere\n• Classes, methods, variables\n\nprotected:\n• Accessible within package and by subclasses\n• Methods, variables (not top-level classes)\n\ndefault (no modifier):\n• Package-private, accessible within same package only\n• Classes, methods, variables\n\nprivate:\n• Accessible only within the same class\n• Methods, variables (not top-level classes)",
      "explanation": "Choose the most restrictive access level that makes sense. This is encapsulation - hiding internal details and exposing only what's necessary.",
      "difficulty": "Easy",
      "code": "// File: Person.java\npublic class Person {\n    public String name;        // Accessible everywhere\n    protected int age;         // Package + subclasses\n    String address;            // Default - package only\n    private String ssn;        // Only within Person\n    \n    public void publicMethod() { }\n    protected void protectedMethod() { }\n    void defaultMethod() { }\n    private void privateMethod() { }\n    \n    // Getter for private field\n    public String getSsn() {\n        return ssn;\n    }\n}"
    },
    {
      "id": 25,
      "question": "What is autoboxing and unboxing in Java?",
      "answer": "Autoboxing: Automatic conversion of primitive types to their corresponding wrapper objects\n\nUnboxing: Automatic conversion of wrapper objects to primitive types\n\nWrapper Classes:\n• byte → Byte\n• short → Short\n• int → Integer\n• long → Long\n• float → Float\n• double → Double\n• char → Character\n• boolean → Boolean\n\nIntroduced in Java 5 for convenience.",
      "explanation": "Autoboxing/unboxing makes code cleaner but can cause performance overhead and NullPointerException if wrapper is null. Be cautious in performance-critical loops.",
      "difficulty": "Easy",
      "code": "// Autoboxing - primitive to wrapper\nint primitive = 5;\nInteger wrapper = primitive;  // Automatic conversion\n// Equivalent to: Integer wrapper = Integer.valueOf(primitive);\n\n// Unboxing - wrapper to primitive\nInteger obj = 10;\nint value = obj;  // Automatic conversion\n// Equivalent to: int value = obj.intValue();\n\n// In collections (only objects allowed)\nList<Integer> list = new ArrayList<>();\nlist.add(5);  // Autoboxing: 5 → Integer(5)\nint num = list.get(0);  // Unboxing: Integer(5) → 5\n\n// Potential NullPointerException\nInteger nullValue = null;\n// int x = nullValue;  // NullPointerException on unboxing!"
    },
    {
      "id": 26,
      "question": "What is the equals() and hashCode() contract?",
      "answer": "The contract states:\n\n1. If two objects are equal (equals() returns true), they must have the same hashCode()\n\n2. If two objects have the same hashCode(), they may or may not be equal\n\n3. If equals() is overridden, hashCode() must also be overridden\n\n4. equals() must be reflexive, symmetric, transitive, and consistent\n\nWhy important:\n• HashMap, HashSet rely on this contract\n• Violating it causes incorrect behavior in hash-based collections",
      "explanation": "Breaking this contract leads to objects not being found in HashMaps even though they're equal, or duplicate entries in HashSets. Always override both methods together.",
      "difficulty": "Medium",
      "code": "class Person {\n    String name;\n    int age;\n    \n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;\n        if (obj == null || getClass() != obj.getClass()) return false;\n        Person person = (Person) obj;\n        return age == person.age && \n               Objects.equals(name, person.name);\n    }\n    \n    @Override\n    public int hashCode() {\n        return Objects.hash(name, age);  // Same fields as equals\n    }\n}\n\n// Usage\nPerson p1 = new Person(\"John\", 25);\nPerson p2 = new Person(\"John\", 25);\np1.equals(p2);  // true\np1.hashCode() == p2.hashCode();  // true (contract satisfied)\n\nSet<Person> set = new HashSet<>();\nset.add(p1);\nset.contains(p2);  // true (works correctly)"
    },
    {
      "id": 27,
      "question": "What is the difference between shallow copy and deep copy?",
      "answer": "Shallow Copy:\n• Copies object and its primitive fields\n• References to other objects are copied (not the objects themselves)\n• Changes to referenced objects affect both copies\n• Object.clone() performs shallow copy by default\n\nDeep Copy:\n• Copies object and all objects it references recursively\n• Complete independence between copies\n• Changes to one don't affect the other\n• Must be implemented manually",
      "explanation": "Shallow copy is faster but shared references can cause unexpected side effects. Deep copy is safer for objects with mutable referenced objects but requires more memory and processing.",
      "difficulty": "Medium",
      "code": "class Address {\n    String city;\n    Address(String city) { this.city = city; }\n}\n\nclass Person implements Cloneable {\n    String name;\n    Address address;\n    \n    // Shallow copy\n    @Override\n    public Person clone() throws CloneNotSupportedException {\n        return (Person) super.clone();  // Shallow copy\n    }\n    \n    // Deep copy\n    public Person deepClone() {\n        Person copy = new Person();\n        copy.name = this.name;\n        copy.address = new Address(this.address.city);  // New object\n        return copy;\n    }\n}\n\n// Shallow copy issue\nPerson p1 = new Person();\np1.address = new Address(\"NYC\");\nPerson p2 = p1.clone();  // Shallow copy\np2.address.city = \"LA\";\nSystem.out.println(p1.address.city);  // \"LA\" - affected!\n\n// Deep copy - independent\nPerson p3 = p1.deepClone();\np3.address.city = \"Boston\";\nSystem.out.println(p1.address.city);  // \"LA\" - not affected"
    },
    {
      "id": 28,
      "question": "What is Serialization in Java?",
      "answer": "Serialization is the process of converting an object into a byte stream for storage or transmission.\n\nDeserialization is the reverse - reconstructing object from byte stream.\n\nKey points:\n• Implement Serializable interface (marker interface)\n• serialVersionUID for version control\n• transient keyword excludes fields from serialization\n• static fields are not serialized\n• Used for: Object persistence, network transmission, caching",
      "explanation": "Serialization enables object persistence and distributed computing. Always define serialVersionUID to avoid InvalidClassException when class definition changes.",
      "difficulty": "Medium",
      "code": "class User implements Serializable {\n    private static final long serialVersionUID = 1L;\n    \n    private String username;\n    private transient String password;  // Not serialized\n    private static int count = 0;       // Not serialized\n    \n    // Constructors, methods...\n}\n\n// Serialization\nUser user = new User(\"john\", \"secret123\");\ntry (ObjectOutputStream out = new ObjectOutputStream(\n        new FileOutputStream(\"user.ser\"))) {\n    out.writeObject(user);\n}\n\n// Deserialization\ntry (ObjectInputStream in = new ObjectInputStream(\n        new FileInputStream(\"user.ser\"))) {\n    User loadedUser = (User) in.readObject();\n    System.out.println(loadedUser.username);  // \"john\"\n    System.out.println(loadedUser.password);  // null (transient)\n}"
    },
    {
      "id": 29,
      "question": "What is the Reflection API in Java?",
      "answer": "Reflection API allows inspection and manipulation of classes, methods, fields, and constructors at runtime.\n\nCapabilities:\n• Inspect class structure\n• Create objects dynamically\n• Invoke methods dynamically\n• Access/modify private fields\n• Discover annotations\n\nKey classes:\n• Class<T>: Represents classes\n• Method, Field, Constructor: Represent members\n• Modifier: Check access modifiers",
      "explanation": "Reflection is powerful but breaks encapsulation and has performance overhead. Used in frameworks (Spring, Hibernate), testing tools, and serialization. Prefer direct access when possible.",
      "difficulty": "Hard",
      "code": "class Person {\n    private String name;\n    \n    public Person(String name) { this.name = name; }\n    \n    private void secret() {\n        System.out.println(\"Secret method\");\n    }\n}\n\n// Get Class object\nClass<?> clazz = Person.class;\n// or: Class.forName(\"com.example.Person\");\n\n// Create instance\nConstructor<?> constructor = clazz.getConstructor(String.class);\nObject person = constructor.newInstance(\"John\");\n\n// Access private field\nField field = clazz.getDeclaredField(\"name\");\nfield.setAccessible(true);  // Bypass private\nSystem.out.println(field.get(person));  // \"John\"\n\n// Invoke private method\nMethod method = clazz.getDeclaredMethod(\"secret\");\nmethod.setAccessible(true);\nmethod.invoke(person);  // Calls secret()\n\n// List all methods\nfor (Method m : clazz.getDeclaredMethods()) {\n    System.out.println(m.getName());\n}"
    },
    {
      "id": 30,
      "question": "What are Annotations in Java?",
      "answer": "Annotations are metadata that provide information about code to compiler, runtime, or tools.\n\nBuilt-in annotations:\n• @Override: Ensures method overrides parent method\n• @Deprecated: Marks code as outdated\n• @SuppressWarnings: Suppresses compiler warnings\n• @FunctionalInterface: Marks functional interface\n• @SafeVarargs: Suppresses varargs warnings\n\nRetention policies:\n• SOURCE: Discarded after compilation\n• CLASS: In bytecode, not at runtime\n• RUNTIME: Available at runtime via reflection",
      "explanation": "Annotations enable declarative programming. Frameworks use them extensively - @Entity, @Autowired, @Test. You can create custom annotations for cross-cutting concerns.",
      "difficulty": "Medium",
      "code": "// Using built-in annotations\nclass Parent {\n    void display() { }\n}\n\nclass Child extends Parent {\n    @Override  // Compile error if not actually overriding\n    void display() { }\n    \n    @Deprecated\n    void oldMethod() { }  // Warns when used\n    \n    @SuppressWarnings(\"unchecked\")\n    void problematic() { }\n}\n\n// Custom annotation\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@interface Test {\n    String value() default \"\";\n    int timeout() default 0;\n}\n\n// Usage\nclass MyTest {\n    @Test(value = \"testAdd\", timeout = 1000)\n    void testMethod() { }\n}\n\n// Reading at runtime\nMethod method = MyTest.class.getMethod(\"testMethod\");\nif (method.isAnnotationPresent(Test.class)) {\n    Test test = method.getAnnotation(Test.class);\n    System.out.println(test.value());  // \"testAdd\"\n}"
    },
    {
      "id": 31,
      "question": "What are Generics in Java and why use them?",
      "answer": "Generics enable type parameters in classes, interfaces, and methods, providing compile-time type safety.\n\nBenefits:\n• Type safety: Compile-time type checking\n• No casting required\n• Code reusability\n• Catch errors at compile time, not runtime\n\nKey concepts:\n• Type parameters: <T>, <E>, <K,V>\n• Bounded type parameters: <T extends Number>\n• Wildcards: <? extends T>, <? super T>\n• Type erasure: Generic types removed at runtime",
      "explanation": "Generics are fundamental to Collections framework. They prevent ClassCastException and make code more maintainable. Type erasure means List<String> and List<Integer> become List at runtime.",
      "difficulty": "Medium",
      "code": "// Without generics - unsafe\nList list = new ArrayList();\nlist.add(\"String\");\nlist.add(123);  // No compile error!\nString s = (String) list.get(1);  // ClassCastException!\n\n// With generics - type safe\nList<String> safeList = new ArrayList<>();\nsafeList.add(\"String\");\n// safeList.add(123);  // Compile error!\nString str = safeList.get(0);  // No casting needed\n\n// Generic class\nclass Box<T> {\n    private T value;\n    \n    void set(T value) { this.value = value; }\n    T get() { return value; }\n}\n\nBox<Integer> intBox = new Box<>();\nintBox.set(123);\n// intBox.set(\"String\");  // Compile error!\n\n// Generic method\npublic <T> void printArray(T[] array) {\n    for (T element : array) {\n        System.out.println(element);\n    }\n}\n\n// Bounded type parameter\nclass NumberBox<T extends Number> {\n    T value;\n    double doubleValue() { return value.doubleValue(); }\n}"
    },
    {
      "id": 32,
      "question": "What are wildcards in Java Generics?",
      "answer": "Wildcards represent unknown types in generics:\n\nUnbounded wildcard (?):\n• Represents any type\n• Use when type doesn't matter\n• Example: List<?>\n\nUpper bounded wildcard (? extends T):\n• Any type that is T or subclass of T\n• Read-only scenario\n• Example: List<? extends Number>\n\nLower bounded wildcard (? super T):\n• Any type that is T or superclass of T\n• Write scenario\n• Example: List<? super Integer>\n\nPECS principle: Producer Extends, Consumer Super",
      "explanation": "Wildcards provide flexibility. Use extends for reading, super for writing. Unbounded wildcard for operations that don't depend on type parameter.",
      "difficulty": "Hard",
      "code": "// Unbounded wildcard\nvoid printList(List<?> list) {\n    for (Object obj : list) {  // Can only read as Object\n        System.out.println(obj);\n    }\n    // list.add(\"something\");  // Compile error!\n}\n\n// Upper bounded - read from producer\nvoid sumNumbers(List<? extends Number> numbers) {\n    double sum = 0;\n    for (Number n : numbers) {  // Read as Number\n        sum += n.doubleValue();\n    }\n    // numbers.add(5);  // Compile error! (unknown exact type)\n}\nsumNumbers(new ArrayList<Integer>());  // OK\nsumNumbers(new ArrayList<Double>());   // OK\n\n// Lower bounded - write to consumer\nvoid addIntegers(List<? super Integer> list) {\n    list.add(5);      // OK - can add Integer\n    list.add(10);     // OK\n    // Integer n = list.get(0);  // Compile error!\n    Object obj = list.get(0);    // Can only read as Object\n}\naddIntegers(new ArrayList<Integer>());  // OK\naddIntegers(new ArrayList<Number>());   // OK\naddIntegers(new ArrayList<Object>());   // OK"
    },
    {
      "id": 33,
      "question": "What is an Enum in Java?",
      "answer": "Enum is a special class that represents a group of constants (fixed set of instances).\n\nFeatures:\n• Type-safe constants\n• Can have fields, methods, constructors\n• Implicitly public static final\n• Cannot be instantiated directly\n• Can implement interfaces\n• Automatically provides values() and valueOf() methods\n• Can be used in switch statements",
      "explanation": "Enums are better than int constants - they provide type safety, namespace, and can contain behavior. Use enums for fixed sets of constants like days, directions, status codes.",
      "difficulty": "Easy",
      "code": "// Simple enum\nenum Day {\n    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n}\n\n// Enum with fields and methods\nenum Planet {\n    EARTH(5.976e+24, 6.37814e6),\n    MARS(6.421e+23, 3.3972e6);\n    \n    private final double mass;\n    private final double radius;\n    \n    Planet(double mass, double radius) {\n        this.mass = mass;\n        this.radius = radius;\n    }\n    \n    double surfaceGravity() {\n        return mass / (radius * radius);\n    }\n}\n\n// Usage\nDay today = Day.MONDAY;\nswitch (today) {\n    case MONDAY: System.out.println(\"Start of week\"); break;\n    case FRIDAY: System.out.println(\"Weekend soon!\"); break;\n    default: break;\n}\n\n// Iterate all values\nfor (Day d : Day.values()) {\n    System.out.println(d);\n}\n\n// String to enum\nDay day = Day.valueOf(\"TUESDAY\");\n\n// Enum methods\nSystem.out.println(Planet.EARTH.surfaceGravity());"
    },
    {
      "id": 34,
      "question": "What are the different types of inner classes in Java?",
      "answer": "Four types of inner classes:\n\n1. Member Inner Class: Non-static nested class, has access to outer class members\n\n2. Static Nested Class: Static nested class, can only access static members of outer class\n\n3. Local Inner Class: Defined inside a method, can access final/effectively final local variables\n\n4. Anonymous Inner Class: Class without name, used for one-time implementation",
      "explanation": "Inner classes provide logical grouping and encapsulation. They can access private members of outer class. Use anonymous classes for simple one-off implementations (though lambdas are often better).",
      "difficulty": "Medium",
      "code": "class Outer {\n    private int outerField = 10;\n    private static int staticField = 20;\n    \n    // 1. Member Inner Class\n    class MemberInner {\n        void display() {\n            System.out.println(outerField);  // Access outer\n        }\n    }\n    \n    // 2. Static Nested Class\n    static class StaticNested {\n        void display() {\n            System.out.println(staticField);  // Only static\n            // System.out.println(outerField);  // Error!\n        }\n    }\n    \n    void method() {\n        final int localVar = 30;\n        \n        // 3. Local Inner Class\n        class LocalInner {\n            void display() {\n                System.out.println(localVar);  // Final/effectively final\n            }\n        }\n        LocalInner local = new LocalInner();\n        local.display();\n    }\n}\n\n// 4. Anonymous Inner Class\nRunnable runnable = new Runnable() {\n    @Override\n    public void run() {\n        System.out.println(\"Anonymous\");\n    }\n};\n\n// Usage\nOuter outer = new Outer();\nOuter.MemberInner inner = outer.new MemberInner();\nOuter.StaticNested nested = new Outer.StaticNested();"
    },
    {
      "id": 35,
      "question": "What are Lambda expressions in Java?",
      "answer": "Lambda expressions are anonymous functions that provide implementation of functional interfaces in a concise way.\n\nSyntax: (parameters) -> expression or block\n\nBenefits:\n• Concise code\n• Enable functional programming\n• Improved readability\n• Support for method references\n• Easy parallelization with streams\n\nRequirements:\n• Target type must be a functional interface\n• Can access final or effectively final variables",
      "explanation": "Lambdas make code more expressive and concise, especially with collections and streams. They replace anonymous inner classes for functional interfaces.",
      "difficulty": "Medium",
      "code": "// Without lambda - anonymous inner class\nRunnable r1 = new Runnable() {\n    @Override\n    public void run() {\n        System.out.println(\"Hello\");\n    }\n};\n\n// With lambda - concise\nRunnable r2 = () -> System.out.println(\"Hello\");\n\n// Lambda with parameters\nComparator<String> comparator = (s1, s2) -> s1.length() - s2.length();\n\n// Lambda with block\nComparator<String> comp2 = (s1, s2) -> {\n    System.out.println(\"Comparing\");\n    return s1.compareTo(s2);\n};\n\n// With streams\nList<String> names = Arrays.asList(\"John\", \"Jane\", \"Bob\");\nnames.stream()\n     .filter(name -> name.startsWith(\"J\"))\n     .map(name -> name.toUpperCase())\n     .forEach(name -> System.out.println(name));\n\n// Accessing variables (must be final/effectively final)\nint factor = 2;\nFunction<Integer, Integer> multiplier = n -> n * factor;\n// factor = 3;  // Error: must be effectively final"
    },
    {
      "id": 36,
      "question": "What are Method References in Java?",
      "answer": "Method references are shorthand for lambda expressions that only call an existing method.\n\nFour types:\n\n1. Static method reference: ClassName::staticMethod\n\n2. Instance method reference: instance::instanceMethod\n\n3. Instance method of arbitrary object: ClassName::instanceMethod\n\n4. Constructor reference: ClassName::new\n\nBenefits:\n• More concise than lambda\n• Improved readability\n• Reuse existing methods",
      "explanation": "Method references make code even cleaner than lambdas when you're just calling an existing method. They're syntactic sugar for simple lambda expressions.",
      "difficulty": "Medium",
      "code": "List<String> names = Arrays.asList(\"John\", \"Jane\", \"Bob\");\n\n// Lambda vs Method Reference\n\n// 1. Static method reference\n// Lambda: s -> Integer.parseInt(s)\nFunction<String, Integer> parser = Integer::parseInt;\n\n// 2. Instance method of particular object\nSystem.out::println;  // Instead of: s -> System.out.println(s)\nnames.forEach(System.out::println);\n\n// 3. Instance method of arbitrary object\n// Lambda: (s1, s2) -> s1.compareToIgnoreCase(s2)\nComparator<String> comp = String::compareToIgnoreCase;\nnames.sort(String::compareToIgnoreCase);\n\n// 4. Constructor reference\n// Lambda: () -> new ArrayList<>()\nSupplier<List<String>> listSupplier = ArrayList::new;\nList<String> list = listSupplier.get();\n\n// With streams\nList<Integer> lengths = names.stream()\n    .map(String::length)  // Instead of: s -> s.length()\n    .collect(Collectors.toList());\n\n// Array constructor reference\nString[] array = names.stream()\n    .toArray(String[]::new);  // Instead of: size -> new String[size]"
    },
    {
      "id": 37,
      "question": "What is the Java Collection Framework hierarchy?",
      "answer": "Collection Framework hierarchy:\n\nIterable\n└── Collection\n    ├── List (ordered, allows duplicates)\n    │   ├── ArrayList\n    │   ├── LinkedList\n    │   └── Vector (legacy)\n    ├── Set (no duplicates)\n    │   ├── HashSet\n    │   ├── LinkedHashSet\n    │   └── SortedSet\n    │       └── TreeSet\n    └── Queue\n        ├── PriorityQueue\n        └── Deque\n            └── ArrayDeque\n\nMap (separate hierarchy)\n├── HashMap\n├── LinkedHashMap\n├── Hashtable (legacy)\n└── SortedMap\n    └── TreeMap",
      "explanation": "Understanding the hierarchy helps choose the right collection. List for ordered access, Set for uniqueness, Queue for FIFO, Map for key-value pairs.",
      "difficulty": "Medium",
      "code": "// List - ordered, duplicates allowed\nList<String> list = new ArrayList<>();\nlist.add(\"A\"); list.add(\"B\"); list.add(\"A\");\nlist.get(0);  // Access by index\n\n// Set - no duplicates\nSet<String> set = new HashSet<>();\nset.add(\"A\"); set.add(\"B\"); set.add(\"A\");\nSystem.out.println(set.size());  // 2 (no duplicates)\n\n// Queue - FIFO\nQueue<String> queue = new LinkedList<>();\nqueue.offer(\"First\");\nqueue.offer(\"Second\");\nqueue.poll();  // Returns \"First\"\n\n// Map - key-value pairs\nMap<String, Integer> map = new HashMap<>();\nmap.put(\"John\", 25);\nmap.put(\"Jane\", 30);\nmap.get(\"John\");  // 25\n\n// TreeSet - sorted\nSet<Integer> sortedSet = new TreeSet<>();\nsortedSet.add(5); sortedSet.add(1); sortedSet.add(3);\n// Order: [1, 3, 5]"
    },
    {
      "id": 38,
      "question": "What is the difference between HashSet, LinkedHashSet, and TreeSet?",
      "answer": "HashSet:\n• Backed by HashMap\n• No ordering guarantees\n• Fast: O(1) for add, remove, contains\n• Allows one null element\n• Best for: Fast lookups, no ordering needed\n\nLinkedHashSet:\n• Backed by LinkedHashMap\n• Maintains insertion order\n• Slightly slower: O(1) but with overhead\n• Allows one null element\n• Best for: When insertion order matters\n\nTreeSet:\n• Backed by TreeMap (Red-Black tree)\n• Sorted order (natural or comparator)\n• Slower: O(log n) operations\n• No null elements\n• Best for: Sorted data, range queries",
      "explanation": "Choose HashSet for performance, LinkedHashSet for predictable iteration, TreeSet for sorted data. All guarantee no duplicates.",
      "difficulty": "Medium",
      "code": "// HashSet - no order\nSet<String> hashSet = new HashSet<>();\nhashSet.add(\"C\"); hashSet.add(\"A\"); hashSet.add(\"B\");\nSystem.out.println(hashSet);  // [A, B, C] or any order\n\n// LinkedHashSet - insertion order\nSet<String> linkedSet = new LinkedHashSet<>();\nlinkedSet.add(\"C\"); linkedSet.add(\"A\"); linkedSet.add(\"B\");\nSystem.out.println(linkedSet);  // [C, A, B] (insertion order)\n\n// TreeSet - sorted order\nSet<String> treeSet = new TreeSet<>();\ntreeSet.add(\"C\"); treeSet.add(\"A\"); treeSet.add(\"B\");\nSystem.out.println(treeSet);  // [A, B, C] (sorted)\n\n// TreeSet with custom comparator\nSet<String> reverseSet = new TreeSet<>(Comparator.reverseOrder());\nreverseSet.add(\"C\"); reverseSet.add(\"A\"); reverseSet.add(\"B\");\nSystem.out.println(reverseSet);  // [C, B, A]\n\n// TreeSet range operations\nTreeSet<Integer> numbers = new TreeSet<>();\nnumbers.addAll(Arrays.asList(1, 3, 5, 7, 9));\nnumbers.subSet(3, 8);   // [3, 5, 7]\nnumbers.headSet(5);     // [1, 3]\nnumbers.tailSet(5);     // [5, 7, 9]"
    },
    {
      "id": 39,
      "question": "What is the difference between HashMap, LinkedHashMap, and TreeMap?",
      "answer": "HashMap:\n• Hash table based\n• No ordering guarantees\n• Fast: O(1) average for operations\n• Allows one null key, multiple null values\n• Best for: Fast key-value lookups\n\nLinkedHashMap:\n• HashMap + doubly-linked list\n• Maintains insertion order (or access order)\n• Slightly slower than HashMap\n• Allows one null key\n• Best for: LRU cache, when order matters\n\nTreeMap:\n• Red-Black tree based\n• Sorted by keys (natural or comparator)\n• Slower: O(log n) operations\n• No null keys\n• Best for: Sorted maps, range queries",
      "explanation": "HashMap is the default choice for performance. LinkedHashMap for predictable iteration. TreeMap when you need sorted keys or range operations.",
      "difficulty": "Medium",
      "code": "// HashMap - no order\nMap<String, Integer> hashMap = new HashMap<>();\nhashMap.put(\"C\", 3); hashMap.put(\"A\", 1); hashMap.put(\"B\", 2);\n// Iteration order: unpredictable\n\n// LinkedHashMap - insertion order\nMap<String, Integer> linkedMap = new LinkedHashMap<>();\nlinkedMap.put(\"C\", 3); linkedMap.put(\"A\", 1); linkedMap.put(\"B\", 2);\n// Iteration order: C, A, B\n\n// LinkedHashMap - access order (for LRU cache)\nMap<String, Integer> lruMap = new LinkedHashMap<>(16, 0.75f, true);\nlruMap.put(\"A\", 1); lruMap.put(\"B\", 2);\nlruMap.get(\"A\");  // A becomes most recently used\n// Iteration order: B, A\n\n// TreeMap - sorted order\nMap<String, Integer> treeMap = new TreeMap<>();\ntreeMap.put(\"C\", 3); treeMap.put(\"A\", 1); treeMap.put(\"B\", 2);\n// Iteration order: A, B, C (sorted by key)\n\n// TreeMap range operations\ntreeMap.subMap(\"A\", \"C\");    // Entries from A to B\ntreeMap.headMap(\"C\");        // Entries before C\ntreeMap.tailMap(\"B\");        // Entries from B onwards"
    },
    {
      "id": 40,
      "question": "What is the difference between Queue and Deque?",
      "answer": "Queue:\n• FIFO (First-In-First-Out) data structure\n• Add at rear, remove from front\n• Methods: offer(), poll(), peek()\n• Single-ended\n• Implementations: LinkedList, PriorityQueue, ArrayDeque\n\nDeque (Double-Ended Queue):\n• Add/remove from both ends\n• Can be used as Stack (LIFO) or Queue (FIFO)\n• Methods: offerFirst/Last, pollFirst/Last, peekFirst/Last\n• More flexible than Queue and Stack\n• Implementation: ArrayDeque (preferred over Stack)",
      "explanation": "Use Queue for standard FIFO operations. Use Deque when you need flexibility to add/remove from both ends. ArrayDeque is preferred over Stack class for stack operations.",
      "difficulty": "Easy",
      "code": "// Queue - FIFO\nQueue<String> queue = new LinkedList<>();\nqueue.offer(\"First\");   // Add to rear\nqueue.offer(\"Second\");\nqueue.offer(\"Third\");\nqueue.poll();           // Remove \"First\"\nqueue.peek();           // View \"Second\" without removing\n\n// Deque - as Queue (FIFO)\nDeque<String> deque = new ArrayDeque<>();\ndeque.offerLast(\"First\");\ndeque.offerLast(\"Second\");\ndeque.pollFirst();      // FIFO behavior\n\n// Deque - as Stack (LIFO)\nDeque<String> stack = new ArrayDeque<>();\nstack.push(\"First\");    // or offerFirst\nstack.push(\"Second\");\nstack.pop();            // Returns \"Second\" (LIFO)\nstack.peek();           // View \"First\"\n\n// Deque - both ends\ndeque.offerFirst(\"Front\");\ndeque.offerLast(\"Back\");\ndeque.pollFirst();      // Remove from front\ndeque.pollLast();       // Remove from back"
    },
    {
      "id": 41,
      "question": "What is ConcurrentHashMap and how does it work?",
      "answer": "ConcurrentHashMap is a thread-safe HashMap implementation without locking the entire map.\n\nKey features:\n• Segment-level locking (Java 7) / Node-level locking (Java 8+)\n• Multiple threads can read/write concurrently\n• No ConcurrentModificationException\n• Doesn't allow null keys or values\n• Better performance than Hashtable\n\nJava 8+ improvements:\n• Uses CAS (Compare-And-Swap) operations\n• Tree bins for better collision handling\n• Parallel search operations",
      "explanation": "ConcurrentHashMap allows concurrent reads and writes by locking only affected segments/nodes, not the entire map. Much better than synchronized HashMap or Hashtable for concurrent access.",
      "difficulty": "Hard",
      "code": "// ConcurrentHashMap - thread-safe\nMap<String, Integer> concurrentMap = new ConcurrentHashMap<>();\n\n// Multiple threads can access safely\nconcurrentMap.put(\"key1\", 1);\nconcurrentMap.put(\"key2\", 2);\n\n// Atomic operations\nconcurrentMap.putIfAbsent(\"key3\", 3);  // Atomic\nconcurrentMap.computeIfAbsent(\"key4\", k -> 4);  // Atomic compute\nconcurrentMap.merge(\"key1\", 10, Integer::sum);  // Atomic merge\n\n// Bulk operations (parallel in Java 8+)\nconcurrentMap.forEach((k, v) -> System.out.println(k + \":\" + v));\nconcurrentMap.search(1, (k, v) -> v > 2 ? k : null);\n\n// Won't throw ConcurrentModificationException\nfor (String key : concurrentMap.keySet()) {\n    concurrentMap.put(\"new\" + key, 0);  // Safe during iteration\n}\n\n// Compare with synchronized Map\nMap<String, Integer> syncMap = \n    Collections.synchronizedMap(new HashMap<>());\n// syncMap locks entire map on each operation"
    },
    {
      "id": 42,
      "question": "What is ThreadLocal in Java?",
      "answer": "ThreadLocal provides thread-local variables where each thread has its own independent copy of the variable.\n\nUse cases:\n• User context in web applications\n• Database connections per thread\n• Date formatters (SimpleDateFormat is not thread-safe)\n• Transaction context\n\nMethods:\n• get(): Returns thread's copy\n• set(value): Sets thread's copy\n• remove(): Clears thread's copy (important to avoid memory leaks)\n• initialValue(): Override to provide initial value",
      "explanation": "ThreadLocal isolates data per thread, preventing concurrent access issues. Always call remove() in finally block to prevent memory leaks, especially in thread pools.",
      "difficulty": "Hard",
      "code": "// ThreadLocal variable\nprivate static ThreadLocal<Integer> threadId = \n    ThreadLocal.withInitial(() -> 0);\n\n// Or override initialValue\nprivate static ThreadLocal<SimpleDateFormat> dateFormat = \n    new ThreadLocal<SimpleDateFormat>() {\n        @Override\n        protected SimpleDateFormat initialValue() {\n            return new SimpleDateFormat(\"yyyy-MM-dd\");\n        }\n    };\n\n// Usage\nclass UserContext {\n    private static ThreadLocal<String> currentUser = new ThreadLocal<>();\n    \n    public static void setUser(String user) {\n        currentUser.set(user);\n    }\n    \n    public static String getUser() {\n        return currentUser.get();\n    }\n    \n    public static void clear() {\n        currentUser.remove();  // Prevent memory leak\n    }\n}\n\n// In a web request\ntry {\n    UserContext.setUser(\"John\");\n    // Each thread sees its own user\n    System.out.println(UserContext.getUser());\n} finally {\n    UserContext.clear();  // Always clean up!\n}"
    },
    {
      "id": 43,
      "question": "What is the Executor Framework in Java?",
      "answer": "Executor Framework provides a higher-level API for managing threads, separating task submission from execution mechanics.\n\nKey interfaces:\n• Executor: Basic interface with execute() method\n• ExecutorService: Manages lifecycle, returns Future\n• ScheduledExecutorService: Schedule tasks with delays\n\nCommon implementations:\n• newFixedThreadPool: Fixed number of threads\n• newCachedThreadPool: Creates threads as needed\n• newSingleThreadExecutor: Single worker thread\n• newScheduledThreadPool: Schedule tasks",
      "explanation": "Executor framework manages thread pooling, reduces thread creation overhead, and provides better control over concurrent execution. Always shutdownGracefully when done.",
      "difficulty": "Medium",
      "code": "// Fixed thread pool\nExecutorService executor = Executors.newFixedThreadPool(5);\n\n// Submit Runnable\nexecutor.execute(() -> System.out.println(\"Task 1\"));\n\n// Submit Callable (returns result)\nFuture<Integer> future = executor.submit(() -> {\n    Thread.sleep(1000);\n    return 42;\n});\n\ntry {\n    Integer result = future.get();  // Blocks until complete\n    System.out.println(result);      // 42\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n// Submit multiple tasks\nList<Callable<String>> tasks = Arrays.asList(\n    () -> \"Task 1\",\n    () -> \"Task 2\",\n    () -> \"Task 3\"\n);\nList<Future<String>> results = executor.invokeAll(tasks);\n\n// Scheduled executor\nScheduledExecutorService scheduler = \n    Executors.newScheduledThreadPool(2);\nscheduler.schedule(() -> System.out.println(\"Delayed\"), \n                   5, TimeUnit.SECONDS);\nscheduler.scheduleAtFixedRate(() -> System.out.println(\"Periodic\"),\n                              0, 1, TimeUnit.SECONDS);\n\n// Shutdown\nexecutor.shutdown();\n// executor.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);"
    },
    {
      "id": 44,
      "question": "What is CompletableFuture in Java?",
      "answer": "CompletableFuture is a composable, asynchronous computation framework introduced in Java 8.\n\nKey features:\n• Explicit completion control\n• Compose multiple async operations\n• Exception handling\n• Combine multiple futures\n• Non-blocking callbacks\n\nCommon methods:\n• supplyAsync: Run async with return value\n• thenApply: Transform result\n• thenCompose: Chain dependent operations\n• thenCombine: Combine two futures\n• exceptionally: Handle errors",
      "explanation": "CompletableFuture provides functional-style async programming. It's more powerful than Future - you can chain operations, handle errors, and compose multiple async tasks.",
      "difficulty": "Hard",
      "code": "// Simple async operation\nCompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\n    // Runs in ForkJoinPool\n    return \"Hello\";\n});\n\n// Transform result\nCompletableFuture<String> result = future.thenApply(s -> s + \" World\");\nSystem.out.println(result.get());  // \"Hello World\"\n\n// Chain dependent operations\nCompletableFuture.supplyAsync(() -> \"User123\")\n    .thenCompose(userId -> fetchUserDetails(userId))  // Returns CF\n    .thenApply(user -> user.getName())\n    .thenAccept(name -> System.out.println(name));\n\n// Combine multiple futures\nCompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> \"Hello\");\nCompletableFuture<String> f2 = CompletableFuture.supplyAsync(() -> \"World\");\nCompletableFuture<String> combined = f1.thenCombine(f2, (s1, s2) -> s1 + \" \" + s2);\n\n// Wait for all\nCompletableFuture<Void> all = CompletableFuture.allOf(f1, f2);\nall.thenRun(() -> System.out.println(\"All complete\"));\n\n// Exception handling\nCompletableFuture.supplyAsync(() -> {\n    if (true) throw new RuntimeException(\"Error\");\n    return \"Success\";\n}).exceptionally(ex -> {\n    System.out.println(\"Handled: \" + ex.getMessage());\n    return \"Default\";\n}).thenAccept(System.out::println);"
    },
    {
      "id": 45,
      "question": "What is CountDownLatch in Java?",
      "answer": "CountDownLatch is a synchronization aid that allows threads to wait until a set of operations complete.\n\nKey concepts:\n• Initialized with a count\n• Threads call await() to wait\n• Other threads call countDown() to decrement\n• When count reaches zero, waiting threads proceed\n• Cannot be reused (count doesn't reset)\n\nUse cases:\n• Wait for multiple threads to start/complete\n• Parallel initialization\n• Wait for service dependencies",
      "explanation": "CountDownLatch is like a gate that opens when count reaches zero. Use it when you need to wait for N operations to complete before proceeding. For reusable barriers, use CyclicBarrier.",
      "difficulty": "Medium",
      "code": "// Main thread waits for 3 worker threads\nCountDownLatch latch = new CountDownLatch(3);\n\nfor (int i = 0; i < 3; i++) {\n    new Thread(() -> {\n        try {\n            System.out.println(\"Working...\");\n            Thread.sleep(1000);\n            System.out.println(\"Done\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            latch.countDown();  // Decrement count\n        }\n    }).start();\n}\n\n// Main thread waits\nSystem.out.println(\"Waiting for workers...\");\nlatch.await();  // Blocks until count = 0\nSystem.out.println(\"All workers done!\");\n\n// With timeout\nboolean completed = latch.await(5, TimeUnit.SECONDS);\nif (completed) {\n    System.out.println(\"Completed in time\");\n} else {\n    System.out.println(\"Timeout!\");\n}"
    },
    {
      "id": 46,
      "question": "What is CyclicBarrier in Java?",
      "answer": "CyclicBarrier is a synchronization aid where threads wait for each other at a barrier point.\n\nKey features:\n• Threads call await() at barrier\n• When all threads arrive, barrier breaks and all proceed\n• Can be reused (cyclic)\n• Optional barrier action runs when barrier breaks\n\nDifference from CountDownLatch:\n• Reusable (cyclic)\n• Threads wait for each other\n• Can trigger action when barrier breaks",
      "explanation": "CyclicBarrier is for coordinating threads that need to wait for each other at a common point. Unlike CountDownLatch, it can be reused for multiple rounds of synchronization.",
      "difficulty": "Medium",
      "code": "// 3 threads wait for each other\nCyclicBarrier barrier = new CyclicBarrier(3, () -> {\n    System.out.println(\"All threads arrived!\");\n});\n\nfor (int i = 0; i < 3; i++) {\n    new Thread(() -> {\n        try {\n            System.out.println(\"Thread \" + Thread.currentThread().getId() + \" working\");\n            Thread.sleep(1000);\n            \n            System.out.println(\"Thread \" + Thread.currentThread().getId() + \" waiting at barrier\");\n            barrier.await();  // Wait for others\n            \n            System.out.println(\"Thread \" + Thread.currentThread().getId() + \" proceeding\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }).start();\n}\n\n// Reusable for multiple rounds\nfor (int round = 0; round < 2; round++) {\n    // All threads call await() - barrier can be reused\n    barrier.await();\n}"
    },
    {
      "id": 47,
      "question": "What is Semaphore in Java?",
      "answer": "Semaphore maintains a set of permits to control access to a resource.\n\nKey methods:\n• acquire(): Get a permit (blocks if none available)\n• release(): Release a permit\n• tryAcquire(): Try to get permit without blocking\n• availablePermits(): Number of available permits\n\nTypes:\n• Binary Semaphore: 1 permit (like mutex)\n• Counting Semaphore: N permits\n\nUse cases:\n• Limit concurrent access\n• Connection pooling\n• Rate limiting",
      "explanation": "Semaphore controls how many threads can access a resource simultaneously. Perfect for connection pools where you want to limit concurrent connections.",
      "difficulty": "Medium",
      "code": "// Semaphore with 3 permits (max 3 concurrent threads)\nSemaphore semaphore = new Semaphore(3);\n\n// Simulate connection pool\nclass ConnectionPool {\n    private Semaphore semaphore = new Semaphore(10);  // 10 connections\n    \n    public void useConnection() {\n        try {\n            semaphore.acquire();  // Get connection\n            System.out.println(\"Using connection\");\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            semaphore.release();  // Return connection\n        }\n    }\n}\n\n// Multiple threads competing for permits\nfor (int i = 0; i < 10; i++) {\n    new Thread(() -> {\n        try {\n            semaphore.acquire();  // Wait for permit\n            System.out.println(Thread.currentThread().getId() + \" acquired\");\n            Thread.sleep(2000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            semaphore.release();\n            System.out.println(Thread.currentThread().getId() + \" released\");\n        }\n    }).start();\n}"
    },
    {
      "id": 48,
      "question": "What is ReentrantLock in Java?",
      "answer": "ReentrantLock is an explicit lock implementation that provides more flexibility than synchronized.\n\nFeatures:\n• Explicit lock/unlock\n• Try lock with timeout\n• Interruptible locking\n• Fair/unfair lock acquisition\n• Multiple condition variables\n• Lock status queries\n\nAdvantages over synchronized:\n• Can try to acquire lock without blocking\n• Can give up trying to acquire lock\n• Better for complex synchronization scenarios",
      "explanation": "ReentrantLock gives more control than synchronized keyword. Use it when you need advanced features like timeouts, interruptibility, or fairness. Always use try-finally to ensure unlock.",
      "difficulty": "Hard",
      "code": "// ReentrantLock\nprivate ReentrantLock lock = new ReentrantLock();\n\n// Basic usage - must unlock in finally\npublic void method() {\n    lock.lock();\n    try {\n        // Critical section\n        System.out.println(\"Lock acquired\");\n    } finally {\n        lock.unlock();  // Always unlock!\n    }\n}\n\n// Try lock with timeout\npublic void tryMethod() {\n    try {\n        if (lock.tryLock(1, TimeUnit.SECONDS)) {\n            try {\n                // Got lock\n            } finally {\n                lock.unlock();\n            }\n        } else {\n            System.out.println(\"Could not acquire lock\");\n        }\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n\n// Fair lock (prevents starvation)\nprivate ReentrantLock fairLock = new ReentrantLock(true);\n\n// Condition variables\nprivate Lock lock = new ReentrantLock();\nprivate Condition condition = lock.newCondition();\n\npublic void waitForCondition() throws InterruptedException {\n    lock.lock();\n    try {\n        while (!ready) {\n            condition.await();\n        }\n    } finally {\n        lock.unlock();\n    }\n}\n\npublic void signalCondition() {\n    lock.lock();\n    try {\n        ready = true;\n        condition.signalAll();\n    } finally {\n        lock.unlock();\n    }\n}"
    },
    {
      "id": 49,
      "question": "What are Atomic classes in Java?",
      "answer": "Atomic classes provide lock-free thread-safe operations using compare-and-swap (CAS) hardware instructions.\n\nCommon classes:\n• AtomicInteger, AtomicLong: Atomic numeric operations\n• AtomicBoolean: Atomic boolean operations\n• AtomicReference: Atomic object reference\n• AtomicIntegerArray: Atomic array operations\n\nKey operations:\n• get(), set(): Read/write\n• compareAndSet(): CAS operation\n• getAndIncrement(): Atomic increment\n• incrementAndGet(): Increment then get\n• updateAndGet(): Apply function atomically",
      "explanation": "Atomic classes are faster than synchronized for simple operations. They use CPU-level atomic instructions instead of locks. Perfect for counters and flags in concurrent scenarios.",
      "difficulty": "Medium",
      "code": "// AtomicInteger - thread-safe counter\nprivate AtomicInteger counter = new AtomicInteger(0);\n\n// Atomic operations\ncounter.incrementAndGet();  // Atomic ++\ncounter.decrementAndGet();  // Atomic --\ncounter.addAndGet(5);       // Atomic += 5\ncounter.get();              // Read current value\n\n// Compare and set (CAS)\nint expected = 10;\nint newValue = 20;\nboolean updated = counter.compareAndSet(expected, newValue);\nif (updated) {\n    System.out.println(\"Updated from 10 to 20\");\n}\n\n// AtomicReference\nAtomicReference<String> atomicRef = new AtomicReference<>(\"Initial\");\natomicRef.set(\"Updated\");\natomicRef.compareAndSet(\"Updated\", \"Final\");\n\n// updateAndGet with lambda\nAtomicInteger value = new AtomicInteger(5);\nint result = value.updateAndGet(v -> v * 2);  // Atomic: value = value * 2\nSystem.out.println(result);  // 10\n\n// vs synchronized (atomic is faster)\nsynchronized (this) {\n    counter++;  // Slower due to lock\n}"
    },
    {
      "id": 50,
      "question": "What are the thread states in Java?",
      "answer": "Thread lifecycle has 6 states (Thread.State enum):\n\n1. NEW: Thread created but not started\n\n2. RUNNABLE: Running or ready to run (including OS running)\n\n3. BLOCKED: Waiting for monitor lock to enter synchronized block\n\n4. WAITING: Waiting indefinitely (wait(), join(), park())\n\n5. TIMED_WAITING: Waiting for specified time (sleep(), wait(timeout))\n\n6. TERMINATED: Thread completed execution",
      "explanation": "Understanding states helps debug threading issues. Use thread dumps to see state of all threads. BLOCKED vs WAITING: BLOCKED is for locks, WAITING is for explicit wait calls.",
      "difficulty": "Easy",
      "code": "Thread thread = new Thread(() -> {\n    synchronized(lock) {\n        try {\n            Thread.sleep(1000);\n            lock.wait();\n        } catch (InterruptedException e) {}\n    }\n});\n\n// Check states\nSystem.out.println(thread.getState());  // NEW\n\nthread.start();\nSystem.out.println(thread.getState());  // RUNNABLE\n\n// Thread states during execution:\n// NEW → start() → RUNNABLE\n// RUNNABLE → sleep()/wait(timeout) → TIMED_WAITING\n// RUNNABLE → wait()/join() → WAITING\n// RUNNABLE → synchronized block → BLOCKED (if lock held)\n// Any state → complete → TERMINATED\n\n// Get all thread states\nMap<Thread, StackTraceElement[]> threads = Thread.getAllStackTraces();\nfor (Thread t : threads.keySet()) {\n    System.out.println(t.getName() + \": \" + t.getState());\n}"
    },
    {
      "id": 51,
      "question": "What is deadlock and how to prevent it?",
      "answer": "Deadlock occurs when two or more threads wait for each other's locks indefinitely.\n\nFour conditions for deadlock:\n1. Mutual exclusion: Resources can't be shared\n2. Hold and wait: Holding while waiting for more\n3. No preemption: Can't force release\n4. Circular wait: Circular chain of waiting\n\nPrevention strategies:\n• Lock ordering: Always acquire locks in same order\n• Lock timeout: Use tryLock with timeout\n• Avoid nested locks: Minimize lock holding\n• Use concurrent utilities: Higher-level abstractions\n• Detect and break: Monitor and interrupt",
      "explanation": "Deadlock is a critical issue in concurrent programming. Prevention is key - consistent lock ordering is the most common solution. Use tools like jstack for detection.",
      "difficulty": "Hard",
      "code": "// Deadlock example\nObject lock1 = new Object();\nObject lock2 = new Object();\n\nThread t1 = new Thread(() -> {\n    synchronized(lock1) {\n        System.out.println(\"T1: Holding lock1\");\n        try { Thread.sleep(50); } catch (InterruptedException e) {}\n        synchronized(lock2) {  // Waiting for lock2\n            System.out.println(\"T1: Holding lock1 & lock2\");\n        }\n    }\n});\n\nThread t2 = new Thread(() -> {\n    synchronized(lock2) {\n        System.out.println(\"T2: Holding lock2\");\n        synchronized(lock1) {  // Waiting for lock1 - DEADLOCK!\n            System.out.println(\"T2: Holding lock1 & lock2\");\n        }\n    }\n});\n\n// Solution 1: Lock ordering\nsynchronized(lock1) {  // Both threads acquire in same order\n    synchronized(lock2) {\n        // Safe\n    }\n}\n\n// Solution 2: Try lock with timeout\nReentrantLock lockA = new ReentrantLock();\nReentrantLock lockB = new ReentrantLock();\n\nif (lockA.tryLock(1000, TimeUnit.MILLISECONDS)) {\n    try {\n        if (lockB.tryLock(1000, TimeUnit.MILLISECONDS)) {\n            try {\n                // Got both locks\n            } finally {\n                lockB.unlock();\n            }\n        }\n    } finally {\n        lockA.unlock();\n    }\n}"
    },
    {
      "id": 52,
      "question": "What is the Java 8 Date and Time API?",
      "answer": "Java 8 introduced java.time package, replacing java.util.Date and Calendar.\n\nKey classes:\n• LocalDate: Date without time\n• LocalTime: Time without date\n• LocalDateTime: Date and time\n• ZonedDateTime: Date and time with timezone\n• Instant: Timestamp (epoch seconds)\n• Duration: Time-based amount\n• Period: Date-based amount\n• DateTimeFormatter: Format/parse dates\n\nBenefits:\n• Immutable and thread-safe\n• Clear API\n• Better timezone handling",
      "explanation": "Old Date/Calendar APIs were mutable, confusing, and not thread-safe. New API is immutable, fluent, and comprehensive. Always use java.time for new code.",
      "difficulty": "Medium",
      "code": "// LocalDate - date without time\nLocalDate today = LocalDate.now();\nLocalDate birthday = LocalDate.of(1990, Month.JANUARY, 15);\nLocalDate tomorrow = today.plusDays(1);\n\n// LocalTime - time without date\nLocalTime now = LocalTime.now();\nLocalTime midday = LocalTime.of(12, 0);\n\n// LocalDateTime - date and time\nLocalDateTime dateTime = LocalDateTime.now();\nLocalDateTime specific = LocalDateTime.of(2024, 1, 1, 10, 30);\n\n// ZonedDateTime - with timezone\nZonedDateTime zonedNow = ZonedDateTime.now();\nZonedDateTime tokyo = ZonedDateTime.now(ZoneId.of(\"Asia/Tokyo\"));\n\n// Instant - timestamp\nInstant timestamp = Instant.now();\nlong epochSeconds = timestamp.getEpochSecond();\n\n// Duration - time-based\nDuration duration = Duration.between(now, midday);\nlong minutes = duration.toMinutes();\n\n// Period - date-based\nPeriod period = Period.between(birthday, today);\nint years = period.getYears();\n\n// Formatting\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\nString formatted = dateTime.format(formatter);\nLocalDateTime parsed = LocalDateTime.parse(\"2024-01-01 10:30:00\", formatter);"
    },
    {
      "id": 53,
      "question": "What is try-with-resources in Java?",
      "answer": "try-with-resources is a statement that ensures resources are closed automatically, introduced in Java 7.\n\nFeatures:\n• Automatic resource management\n• Implements AutoCloseable interface\n• Multiple resources can be declared\n• Resources closed in reverse order\n• Suppressed exceptions tracked\n• No need for explicit finally block\n\nResources:\n• Streams (InputStream, OutputStream)\n• Readers/Writers\n• Database connections\n• Any AutoCloseable implementation",
      "explanation": "try-with-resources prevents resource leaks by automatically closing resources. Much cleaner than manual try-finally. Always use it for I/O operations.",
      "difficulty": "Easy",
      "code": "// Without try-with-resources (old way)\nBufferedReader reader = null;\ntry {\n    reader = new BufferedReader(new FileReader(\"file.txt\"));\n    String line = reader.readLine();\n} catch (IOException e) {\n    e.printStackTrace();\n} finally {\n    if (reader != null) {\n        try {\n            reader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n// With try-with-resources (Java 7+)\ntry (BufferedReader reader = new BufferedReader(new FileReader(\"file.txt\"))) {\n    String line = reader.readLine();\n} catch (IOException e) {\n    e.printStackTrace();\n}  // reader automatically closed\n\n// Multiple resources\ntry (FileInputStream in = new FileInputStream(\"in.txt\");\n     FileOutputStream out = new FileOutputStream(\"out.txt\")) {\n    // Use streams\n}  // Both closed automatically in reverse order\n\n// Custom AutoCloseable\nclass MyResource implements AutoCloseable {\n    @Override\n    public void close() {\n        System.out.println(\"Resource closed\");\n    }\n}\n\ntry (MyResource resource = new MyResource()) {\n    // Use resource\n}  // Automatically calls close()"
    },
    {
      "id": 54,
      "question": "What is StringBuilder vs StringBuffer?",
      "answer": "Both are mutable sequences of characters for efficient string manipulation.\n\nStringBuilder:\n• Not thread-safe\n• Faster (no synchronization overhead)\n• Introduced in Java 5\n• Preferred for single-threaded scenarios\n\nStringBuffer:\n• Thread-safe (synchronized methods)\n• Slower due to synchronization\n• Legacy class from Java 1.0\n• Use only when thread-safety needed\n\nWhy mutable matters:\n• String concatenation creates new objects\n• StringBuilder/StringBuffer modify in-place",
      "explanation": "Always prefer StringBuilder over StringBuffer unless you need thread-safety. String concatenation in loops is inefficient - use StringBuilder. Compiler automatically uses StringBuilder for string concatenation in single statements.",
      "difficulty": "Easy",
      "code": "// String - immutable (inefficient in loops)\nString s = \"\";\nfor (int i = 0; i < 1000; i++) {\n    s += i;  // Creates 1000 new String objects!\n}\n\n// StringBuilder - mutable (efficient)\nStringBuilder sb = new StringBuilder();\nfor (int i = 0; i < 1000; i++) {\n    sb.append(i);  // Modifies same object\n}\nString result = sb.toString();\n\n// Common methods\nStringBuilder builder = new StringBuilder(\"Hello\");\nbuilder.append(\" World\");     // \"Hello World\"\nbuilder.insert(5, \",\");        // \"Hello, World\"\nbuilder.delete(5, 6);          // \"Hello World\"\nbuilder.reverse();             // \"dlroW olleH\"\nbuilder.setCharAt(0, 'D');    // \"DlroW olleH\"\n\n// StringBuffer - same API, synchronized\nStringBuffer buffer = new StringBuffer();\nbuffer.append(\"Thread-safe\");\n\n// Capacity management\nStringBuilder sb2 = new StringBuilder(100);  // Initial capacity\nsb2.ensureCapacity(200);"
    },
    {
      "id": 55,
      "question": "What are important methods of the Object class?",
      "answer": "Object is the root class of all Java classes. Key methods:\n\nequals(Object obj):\n• Check logical equality\n• Default: reference equality (==)\n\nhashCode():\n• Return hash code for hashing collections\n• Must be consistent with equals()\n\ntoString():\n• String representation\n• Default: ClassName@hashCode\n\nclone():\n• Create copy of object\n• Requires Cloneable interface\n\nfinalize():\n• Called before GC (deprecated)\n\ngetClass():\n• Returns Class object\n\nnotify/notifyAll/wait:\n• Thread synchronization",
      "explanation": "These methods define fundamental object behavior. Always override equals, hashCode, and toString for domain objects. Understanding these is crucial for working with collections.",
      "difficulty": "Easy",
      "code": "class Person {\n    String name;\n    int age;\n    \n    // equals - logical equality\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;\n        if (obj == null || getClass() != obj.getClass()) return false;\n        Person p = (Person) obj;\n        return age == p.age && Objects.equals(name, p.name);\n    }\n    \n    // hashCode - consistent with equals\n    @Override\n    public int hashCode() {\n        return Objects.hash(name, age);\n    }\n    \n    // toString - readable representation\n    @Override\n    public String toString() {\n        return \"Person{name='\" + name + \"', age=\" + age + \"}\";\n    }\n    \n    // clone - create copy\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();  // Shallow copy\n    }\n}\n\n// Usage\nPerson p1 = new Person(\"John\", 25);\nPerson p2 = new Person(\"John\", 25);\n\nSystem.out.println(p1.equals(p2));  // true\nSystem.out.println(p1.hashCode() == p2.hashCode());  // true\nSystem.out.println(p1);  // Person{name='John', age=25}\nSystem.out.println(p1.getClass());  // class Person"
    },
    {
      "id": 56,
      "question": "What is varargs in Java?",
      "answer": "Varargs (variable arguments) allows methods to accept variable number of arguments of the same type.\n\nSyntax: type... variableName\n\nRules:\n• Only one varargs parameter per method\n• Must be the last parameter\n• Treated as an array inside method\n• Can pass array or individual values\n• Can pass zero arguments\n\nIntroduced in Java 5.",
      "explanation": "Varargs simplifies methods that need flexible number of arguments. Common in utility methods like String.format(), Arrays.asList(). Behind the scenes, it's just an array.",
      "difficulty": "Easy",
      "code": "// Varargs method\npublic static int sum(int... numbers) {\n    int total = 0;\n    for (int num : numbers) {  // Treated as array\n        total += num;\n    }\n    return total;\n}\n\n// Multiple ways to call\nsum();                  // 0 arguments\nsum(1);                 // 1 argument\nsum(1, 2, 3);          // 3 arguments\nsum(1, 2, 3, 4, 5);    // 5 arguments\n\nint[] array = {1, 2, 3};\nsum(array);            // Pass array directly\n\n// Varargs with other parameters (must be last)\npublic static void print(String prefix, int... numbers) {\n    System.out.print(prefix + \": \");\n    for (int num : numbers) {\n        System.out.print(num + \" \");\n    }\n}\n\nprint(\"Numbers\", 1, 2, 3);  // \"Numbers: 1 2 3\"\n\n// Common varargs methods\nString.format(\"%s %s %s\", \"a\", \"b\", \"c\");\nArrays.asList(1, 2, 3, 4, 5);\nCollections.addAll(list, \"a\", \"b\", \"c\");"
    },
    {
      "id": 57,
      "question": "What is the difference between static and dynamic binding?",
      "answer": "Binding is the connection between method call and method code.\n\nStatic Binding (Early Binding):\n• Resolved at compile time\n• Used for private, static, final methods\n• Method overloading\n• Faster (no runtime lookup)\n\nDynamic Binding (Late Binding):\n• Resolved at runtime\n• Used for overridden methods\n• Method overriding\n• Enables polymorphism\n• Slightly slower (runtime lookup)",
      "explanation": "Static binding is when compiler knows which method to call. Dynamic binding is when JVM decides at runtime based on actual object type. Dynamic binding enables polymorphism - key to OOP.",
      "difficulty": "Medium",
      "code": "class Animal {\n    static void staticMethod() {\n        System.out.println(\"Animal static\");\n    }\n    \n    final void finalMethod() {\n        System.out.println(\"Animal final\");\n    }\n    \n    void instanceMethod() {\n        System.out.println(\"Animal instance\");\n    }\n}\n\nclass Dog extends Animal {\n    static void staticMethod() {  // Hiding, not overriding\n        System.out.println(\"Dog static\");\n    }\n    \n    // Cannot override final method\n    \n    @Override\n    void instanceMethod() {\n        System.out.println(\"Dog instance\");\n    }\n}\n\n// Static binding\nAnimal animal = new Dog();\nanimal.staticMethod();    // \"Animal static\" (compile-time)\nanimal.finalMethod();     // \"Animal final\" (compile-time)\n\n// Dynamic binding\nanimal.instanceMethod();  // \"Dog instance\" (runtime - polymorphism)\n\n// Method overloading (static binding)\nclass Calculator {\n    int add(int a, int b) { return a + b; }\n    double add(double a, double b) { return a + b; }\n}\nCalculator calc = new Calculator();\ncalc.add(1, 2);      // Compile-time: calls int version\ncalc.add(1.0, 2.0);  // Compile-time: calls double version"
    },
    {
      "id": 58,
      "question": "What are marker interfaces in Java?",
      "answer": "Marker interfaces are empty interfaces (no methods or fields) that provide metadata about a class.\n\nCommon marker interfaces:\n• Serializable: Object can be serialized\n• Cloneable: Object can be cloned\n• Remote: Object can be accessed remotely (RMI)\n\nPurpose:\n• Signal to compiler/JVM\n• Enable special treatment\n• Categorize classes\n\nModern alternative:\n• Annotations are preferred (more flexible)",
      "explanation": "Marker interfaces are legacy way to add metadata. They enable JVM to treat implementing classes specially. Annotations are now preferred for new designs as they're more flexible and explicit.",
      "difficulty": "Easy",
      "code": "// Marker interfaces\npublic interface Serializable { }  // Empty\npublic interface Cloneable { }     // Empty\n\n// Usage\nclass Person implements Serializable {\n    String name;\n    int age;\n}\n\n// JVM checks marker interface\ntry (ObjectOutputStream out = new ObjectOutputStream(\n        new FileOutputStream(\"person.ser\"))) {\n    Person p = new Person();\n    out.writeObject(p);  // OK because Person implements Serializable\n}\n\n// Without Serializable\nclass NotSerializable { }\nNotSerializable obj = new NotSerializable();\n// out.writeObject(obj);  // NotSerializableException!\n\n// Cloneable example\nclass Point implements Cloneable {\n    int x, y;\n    \n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();  // OK because implements Cloneable\n    }\n}\n\n// Modern alternative - annotations\n@Entity  // Annotation instead of marker interface\nclass User {\n    // ...\n}"
    },
    {
      "id": 59,
      "question": "What is the classpath and classloading in Java?",
      "answer": "Classpath:\n• Location where JVM searches for classes and resources\n• Set via -cp or -classpath option\n• Can include directories and JAR files\n\nClassloading:\n• Process of loading classes into JVM\n• Three built-in classloaders:\n  1. Bootstrap: Loads core Java classes (rt.jar)\n  2. Extension: Loads extension classes\n  3. Application: Loads application classes\n• Delegation model: child delegates to parent\n• Classes loaded on-demand (lazy loading)\n\nPrinciples:\n• Delegation: Ask parent first\n• Visibility: Child sees parent classes, not vice versa\n• Uniqueness: Class loaded only once",
      "explanation": "Understanding classloading is crucial for debugging ClassNotFoundException and understanding frameworks. Delegation model ensures core classes can't be overridden by application classes.",
      "difficulty": "Hard",
      "code": "// Run Java with classpath\n// java -cp \"lib/*:classes\" com.example.Main\n\n// Programmatic class loading\nClassLoader classLoader = MyClass.class.getClassLoader();\nClass<?> clazz = classLoader.loadClass(\"com.example.SomeClass\");\n\n// Get classloader hierarchy\nSystem.out.println(\"Application: \" + \n    ClassLoader.getSystemClassLoader());\nSystem.out.println(\"Extension: \" + \n    ClassLoader.getSystemClassLoader().getParent());\nSystem.out.println(\"Bootstrap: \" + \n    ClassLoader.getSystemClassLoader().getParent().getParent());  // null\n\n// String class loaded by Bootstrap\nSystem.out.println(String.class.getClassLoader());  // null\n\n// Custom classloader\nclassCustomLoader extends ClassLoader {\n    @Override\n    public Class<?> findClass(String name) throws ClassNotFoundException {\n        // Load class bytes from custom source\n        byte[] classBytes = loadClassBytes(name);\n        return defineClass(name, classBytes, 0, classBytes.length);\n    }\n}\n\n// Get resource from classpath\nInputStream is = getClass().getResourceAsStream(\"/config.properties\");\nURL resource = getClass().getResource(\"/config.properties\");"
    },
    {
      "id": 60,
      "question": "What is the JVM architecture?",
      "answer": "JVM consists of three main components:\n\n1. Class Loader Subsystem:\n• Loading, linking, initialization\n• Bootstrap, Extension, Application classloaders\n\n2. Runtime Data Areas:\n• Method Area: Class metadata, static variables\n• Heap: Objects and arrays\n• Stack: Thread-local method frames\n• PC Register: Current instruction per thread\n• Native Method Stack: Native method calls\n\n3. Execution Engine:\n• Interpreter: Executes bytecode line by line\n• JIT Compiler: Compiles hot code to native\n• Garbage Collector: Manages memory",
      "explanation": "Understanding JVM architecture helps with performance tuning and debugging. Heap and Stack are most important - heap for objects (shared), stack for method calls (thread-local). JIT compiler optimizes frequently-executed code.",
      "difficulty": "Hard",
      "code": "// Memory areas behavior\n\n// Method Area - class metadata, static\nclass Example {\n    static int staticVar = 10;  // Method Area\n    int instanceVar;             // Blueprint in Method Area\n}\n\n// Heap - objects\nExample obj = new Example();  // Object in Heap\nobj.instanceVar = 20;         // Instance variable in Heap\n\n// Stack - method frames\nvoid method() {\n    int localVar = 30;  // Local variable in Stack\n    method2();          // New frame pushed to Stack\n}  // Frame popped when method returns\n\n// JVM options for tuning\n// -Xms: Initial heap size\n// -Xmx: Maximum heap size\n// -Xss: Thread stack size\n// -XX:+UseG1GC: Use G1 garbage collector\n// java -Xms512m -Xmx2g -XX:+UseG1GC MyApp\n\n// Check memory\nRuntime runtime = Runtime.getRuntime();\nlong maxMemory = runtime.maxMemory();    // Max heap\nlong totalMemory = runtime.totalMemory();// Current heap\nlong freeMemory = runtime.freeMemory();  // Free heap\n\n// Trigger GC (suggestion only)\nSystem.gc();\n\n// Get JIT compilation info\n// -XX:+PrintCompilation"
    },
    {
      "id": 61,
      "question": "What are OutOfMemoryError types in Java?",
      "answer": "Common OutOfMemoryError types:\n\n1. Java heap space:\n• Heap is full\n• Too many objects created\n• Solution: Increase heap (-Xmx), fix memory leak\n\n2. GC Overhead limit exceeded:\n• GC taking too much time (>98%)\n• Solution: Increase heap, optimize code\n\n3. Metaspace (PermGen in Java 7):\n• Too many classes loaded\n• Solution: Increase metaspace (-XX:MaxMetaspaceSize)\n\n4. Unable to create new native thread:\n• OS limit on threads reached\n• Solution: Reduce thread count, increase OS limit\n\n5. Direct buffer memory:\n• NIO direct buffers exhausted",
      "explanation": "OutOfMemoryError indicates memory exhaustion. Always analyze heap dumps to find root cause. Use profilers like VisualVM or MAT to identify memory leaks.",
      "difficulty": "Hard",
      "code": "// 1. Heap Space error\nList<byte[]> list = new ArrayList<>();\nwhile (true) {\n    list.add(new byte[1024 * 1024]);  // 1MB each\n}  // OutOfMemoryError: Java heap space\n\n// 2. Metaspace error (too many classes)\nwhile (true) {\n    ClassLoader loader = new CustomClassLoader();\n    loader.loadClass(\"SomeClass\");\n}  // OutOfMemoryError: Metaspace\n\n// 3. Too many threads\nwhile (true) {\n    new Thread(() -> {\n        try { Thread.sleep(Long.MAX_VALUE); }\n        catch (InterruptedException e) {}\n    }).start();\n}  // OutOfMemoryError: unable to create new native thread\n\n// Prevention strategies\n// 1. Increase heap: -Xmx2g\n// 2. Analyze heap dump: -XX:+HeapDumpOnOutOfMemoryError\n// 3. Monitor with jstat, jconsole, VisualVM\n// 4. Fix memory leaks\n// 5. Use memory profilers"
    },
    {
      "id": 62,
      "question": "What are WeakReference, SoftReference, and PhantomReference?",
      "answer": "Reference types affect garbage collection behavior:\n\nStrongReference (default):\n• obj = new Object()\n• Never garbage collected while reachable\n\nWeakReference:\n• Collected in next GC cycle\n• Used for caches that shouldn't prevent GC\n• WeakHashMap uses weak keys\n\nSoftReference:\n• Collected only when memory is low\n• Used for memory-sensitive caches\n• JVM considers available memory\n\nPhantomReference:\n• Always null when get() called\n• Used for cleanup actions\n• Must use ReferenceQueue",
      "explanation": "Special references let you implement caches that don't prevent GC. WeakReference for temporary caches, SoftReference for memory-sensitive caches. PhantomReference for post-GC cleanup.",
      "difficulty": "Hard",
      "code": "// Strong reference (normal)\nObject obj = new Object();  // Won't be collected while obj exists\n\n// WeakReference - collected eagerly\nWeakReference<Object> weakRef = new WeakReference<>(new Object());\nSystem.gc();\nif (weakRef.get() == null) {\n    System.out.println(\"Collected\");  // Likely collected\n}\n\n// SoftReference - collected when memory low\nSoftReference<byte[]> softRef = new SoftReference<>(new byte[1024]);\nSystem.gc();\nif (softRef.get() != null) {\n    System.out.println(\"Still alive\");  // Likely still alive\n}\n\n// WeakHashMap - weak keys\nMap<Key, Value> cache = new WeakHashMap<>();\nKey key = new Key();\ncache.put(key, value);\nkey = null;  // Now key can be collected\nSystem.gc();\n// Entry removed from map when key is collected\n\n// PhantomReference - for cleanup\nReferenceQueue<Object> queue = new ReferenceQueue<>();\nPhantomReference<Object> phantom = \n    new PhantomReference<>(new Object(), queue);\nSystem.gc();\nReference<?> ref = queue.poll();\nif (ref != null) {\n    // Perform cleanup\n}"
    },
    {
      "id": 63,
      "question": "What is immutability in Java and how to create immutable class?",
      "answer": "Immutable class is a class whose state cannot be changed after creation.\n\nBenefits:\n• Thread-safe by nature\n• Safe to share\n• Good hash keys\n• Cacheable\n\nRules for immutable class:\n1. Make class final (prevent inheritance)\n2. Make all fields private final\n3. No setters\n4. Initialize fields in constructor\n5. Deep copy mutable objects in constructor/getter\n6. Don't allow subclasses to override methods\n\nExamples: String, Integer, LocalDate",
      "explanation": "Immutability ensures thread-safety without synchronization. String is immutable - that's why it's safe in concurrent contexts. Always return defensive copies of mutable fields.",
      "difficulty": "Medium",
      "code": "// Immutable class\npublic final class ImmutablePerson {\n    private final String name;\n    private final int age;\n    private final List<String> hobbies;\n    \n    public ImmutablePerson(String name, int age, List<String> hobbies) {\n        this.name = name;\n        this.age = age;\n        // Deep copy mutable parameter\n        this.hobbies = new ArrayList<>(hobbies);\n    }\n    \n    // Only getters, no setters\n    public String getName() {\n        return name;\n    }\n    \n    public int getAge() {\n        return age;\n    }\n    \n    public List<String> getHobbies() {\n        // Return defensive copy\n        return new ArrayList<>(hobbies);\n    }\n}\n\n// Usage - cannot modify\nList<String> hobbies = Arrays.asList(\"Reading\", \"Coding\");\nImmutablePerson person = new ImmutablePerson(\"John\", 25, hobbies);\n\n// These don't affect the object\nhobbies.set(0, \"Gaming\");  // Original list modified\nperson.getHobbies().add(\"New\");  // Returns copy, no effect\n\n// Immutable String example\nString str = \"Hello\";\nstr.concat(\" World\");  // Returns new String, str unchanged\nSystem.out.println(str);  // Still \"Hello\""
    },
    {
      "id": 64,
      "question": "What is the Producer-Consumer problem in Java?",
      "answer": "Classic synchronization problem where producers create items and consumers use them, sharing a bounded buffer.\n\nChallenges:\n• Synchronize access to shared buffer\n• Producer waits when buffer full\n• Consumer waits when buffer empty\n• Avoid race conditions\n\nSolutions:\n1. wait/notify with synchronized\n2. BlockingQueue (preferred)\n3. ReentrantLock with Conditions\n4. Semaphores",
      "explanation": "Producer-Consumer is fundamental to understanding thread coordination. BlockingQueue handles synchronization automatically - always prefer it over manual wait/notify.",
      "difficulty": "Hard",
      "code": "// Solution 1: BlockingQueue (best)\nclass ProducerConsumer {\n    private BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(10);\n    \n    class Producer implements Runnable {\n        public void run() {\n            try {\n                for (int i = 0; i < 100; i++) {\n                    queue.put(i);  // Blocks when full\n                    System.out.println(\"Produced: \" + i);\n                }\n            } catch (InterruptedException e) {}\n        }\n    }\n    \n    class Consumer implements Runnable {\n        public void run() {\n            try {\n                while (true) {\n                    Integer item = queue.take();  // Blocks when empty\n                    System.out.println(\"Consumed: \" + item);\n                }\n            } catch (InterruptedException e) {}\n        }\n    }\n}\n\n// Solution 2: wait/notify (manual)\nclass Buffer {\n    private Queue<Integer> queue = new LinkedList<>();\n    private int capacity = 10;\n    \n    public synchronized void produce(int item) throws InterruptedException {\n        while (queue.size() == capacity) {\n            wait();  // Wait until space available\n        }\n        queue.add(item);\n        notifyAll();  // Notify consumers\n    }\n    \n    public synchronized int consume() throws InterruptedException {\n        while (queue.isEmpty()) {\n            wait();  // Wait until item available\n        }\n        int item = queue.remove();\n        notifyAll();  // Notify producers\n        return item;\n    }\n}"
    },
    {
      "id": 65,
      "question": "What is the Fork/Join framework in Java?",
      "answer": "Fork/Join framework is designed for parallelizing divide-and-conquer algorithms, introduced in Java 7.\n\nKey concepts:\n• Fork: Split task into subtasks\n• Join: Wait for subtasks to complete\n• Work-stealing: Idle threads steal tasks from busy threads\n• ForkJoinPool: Special executor for Fork/Join tasks\n• RecursiveTask<V>: Returns result\n• RecursiveAction: No result\n\nBest for:\n• Recursive algorithms\n• Large data processing\n• Parallel algorithms",
      "explanation": "Fork/Join is perfect for problems that can be broken into smaller subproblems. Work-stealing makes it efficient - idle threads don't stay idle. Used internally by parallel streams.",
      "difficulty": "Hard",
      "code": "// RecursiveTask - returns result\nclass SumTask extends RecursiveTask<Long> {\n    private static final int THRESHOLD = 10000;\n    private int[] array;\n    private int start, end;\n    \n    SumTask(int[] array, int start, int end) {\n        this.array = array;\n        this.start = start;\n        this.end = end;\n    }\n    \n    @Override\n    protected Long compute() {\n        if (end - start <= THRESHOLD) {\n            // Small enough - compute directly\n            long sum = 0;\n            for (int i = start; i < end; i++) {\n                sum += array[i];\n            }\n            return sum;\n        } else {\n            // Fork into subtasks\n            int mid = (start + end) / 2;\n            SumTask left = new SumTask(array, start, mid);\n            SumTask right = new SumTask(array, mid, end);\n            \n            left.fork();   // Async execution\n            long rightResult = right.compute();  // Compute in current thread\n            long leftResult = left.join();       // Wait for forked task\n            \n            return leftResult + rightResult;\n        }\n    }\n}\n\n// Usage\nint[] array = new int[100000];\nForkJoinPool pool = new ForkJoinPool();\nlong sum = pool.invoke(new SumTask(array, 0, array.length));\n\n// ForkJoinPool.commonPool() - shared pool\nForkJoinPool.commonPool().invoke(new SumTask(array, 0, array.length));"
    },
    {
      "id": 66,
      "question": "What are Record classes in Java?",
      "answer": "Records are immutable data classes introduced in Java 14 (preview) and finalized in Java 16.\n\nFeatures:\n• Concise syntax for data carriers\n• Automatically generates: constructor, getters, equals, hashCode, toString\n• Implicitly final and immutable\n• All fields are private final\n• Cannot extend other classes (extends Record)\n• Can implement interfaces\n• Can have static members and methods\n• Compact constructors for validation",
      "explanation": "Records eliminate boilerplate for simple data classes. Perfect for DTOs, value objects, and immutable data carriers. Much cleaner than traditional POJOs.",
      "difficulty": "Medium",
      "code": "// Traditional class (verbose)\nclass PersonOld {\n    private final String name;\n    private final int age;\n    \n    public PersonOld(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public String name() { return name; }\n    public int age() { return age; }\n    \n    @Override\n    public boolean equals(Object obj) { /* ... */ }\n    @Override\n    public int hashCode() { /* ... */ }\n    @Override\n    public String toString() { /* ... */ }\n}\n\n// Record (concise) - Java 16+\nrecord Person(String name, int age) {\n    // All above methods generated automatically!\n    \n    // Compact constructor for validation\n    public Person {\n        if (age < 0) {\n            throw new IllegalArgumentException(\"Age cannot be negative\");\n        }\n    }\n    \n    // Additional methods allowed\n    public boolean isAdult() {\n        return age >= 18;\n    }\n    \n    // Static members allowed\n    public static Person defaultPerson() {\n        return new Person(\"Unknown\", 0);\n    }\n}\n\n// Usage\nPerson p = new Person(\"John\", 25);\nSystem.out.println(p.name());  // Accessor, not getter\nSystem.out.println(p);  // Auto-generated toString"
    },
    {
      "id": 67,
      "question": "What are Sealed classes in Java?",
      "answer": "Sealed classes restrict which classes can extend/implement them, introduced in Java 15 (preview) and finalized in Java 17.\n\nKeywords:\n• sealed: Class/interface restricts subclasses\n• permits: Declares allowed subclasses\n• final: Cannot be extended further\n• sealed: Can have own permitted subclasses\n• non-sealed: Open for extension\n\nBenefits:\n• Controlled inheritance hierarchy\n• Pattern matching exhaustiveness\n• Better domain modeling\n• API design control",
      "explanation": "Sealed classes close the gap between open (any can extend) and final (none can extend). Perfect for modeling closed domain hierarchies like payment types, shapes, etc.",
      "difficulty": "Medium",
      "code": "// Sealed class with permitted subclasses\nsealed class Shape\n    permits Circle, Rectangle, Triangle {\n    abstract double area();\n}\n\nfinal class Circle extends Shape {\n    double radius;\n    double area() { return Math.PI * radius * radius; }\n}\n\nfinal class Rectangle extends Shape {\n    double width, height;\n    double area() { return width * height; }\n}\n\nsealed class Triangle extends Shape\n    permits EquilateralTriangle {\n    double base, height;\n    double area() { return 0.5 * base * height; }\n}\n\nfinal class EquilateralTriangle extends Triangle { }\n\n// class Square extends Shape { }  // Compile error - not permitted!\n\n// Pattern matching with sealed classes\ndouble getArea(Shape shape) {\n    return switch (shape) {  // Exhaustive - all cases covered\n        case Circle c -> c.area();\n        case Rectangle r -> r.area();\n        case Triangle t -> t.area();\n        // No default needed - compiler knows all types\n    };\n}\n\n// Sealed interface\nsealed interface Payment\n    permits CreditCard, DebitCard, Cash {\n    void process();\n}"
    },
    {
      "id": 68,
      "question": "What is Pattern Matching in Java?",
      "answer": "Pattern matching simplifies type checking and casting, introduced incrementally from Java 14.\n\nFeatures:\n\ninstanceof patterns (Java 16):\n• Combined type test and cast\n• Eliminates explicit casting\n\nSwitch patterns (Java 17+ preview):\n• Pattern matching in switch\n• Type patterns\n• Guarded patterns\n\nRecord patterns (Java 19+ preview):\n• Destructure records in patterns",
      "explanation": "Pattern matching makes code more concise and readable. Eliminates boilerplate type checking and casting. Particularly powerful with sealed classes and records.",
      "difficulty": "Medium",
      "code": "// Before pattern matching (old way)\nObject obj = \"Hello\";\nif (obj instanceof String) {\n    String str = (String) obj;  // Explicit cast\n    System.out.println(str.length());\n}\n\n// With instanceof pattern (Java 16+)\nif (obj instanceof String str) {\n    System.out.println(str.length());  // str automatically cast\n}\n\n// Switch patterns (Java 17+ preview)\nstatic String format(Object obj) {\n    return switch (obj) {\n        case Integer i -> String.format(\"int: %d\", i);\n        case String s -> String.format(\"String: %s\", s);\n        case Long l -> String.format(\"long: %d\", l);\n        case null -> \"null\";\n        default -> obj.toString();\n    };\n}\n\n// Guarded patterns\nstatic String describe(Object obj) {\n    return switch (obj) {\n        case String s when s.length() > 5 -> \"Long string\";\n        case String s -> \"Short string\";\n        case Integer i when i > 0 -> \"Positive\";\n        case Integer i -> \"Non-positive\";\n        default -> \"Other\";\n    };\n}\n\n// Record patterns (Java 19+ preview)\nrecord Point(int x, int y) { }\n\nstatic void printPoint(Object obj) {\n    if (obj instanceof Point(int x, int y)) {\n        System.out.println(\"x=\" + x + \", y=\" + y);\n    }\n}"
    },
    {
      "id": 69,
      "question": "What are Text Blocks in Java?",
      "answer": "Text blocks are multi-line string literals introduced in Java 15.\n\nSyntax: \"\"\" ... \"\"\"\n\nFeatures:\n• Multi-line strings without concatenation\n• Preserves formatting\n• No need for escape sequences in most cases\n• Automatic indentation management\n• Cleaner SQL, JSON, HTML embedding\n\nEscape sequences:\n• \\s: Space (preserved)\n• \\n: New line\n• \\\\ : Line continuation (removes newline)",
      "explanation": "Text blocks make multi-line strings readable and maintainable. Perfect for embedded SQL, JSON, HTML, or any multi-line text. No more messy string concatenation!",
      "difficulty": "Easy",
      "code": "// Before text blocks (messy)\nString html = \"<html>\\n\" +\n              \"  <body>\\n\" +\n              \"    <p>Hello</p>\\n\" +\n              \"  </body>\\n\" +\n              \"</html>\";\n\n// With text blocks (clean) - Java 15+\nString htmlBlock = \"\"\"\n    <html>\n      <body>\n        <p>Hello</p>\n      </body>\n    </html>\n    \"\"\";\n\n// SQL query\nString query = \"\"\"\n    SELECT id, name, email\n    FROM users\n    WHERE age > 18\n      AND status = 'active'\n    ORDER BY name\n    \"\"\";\n\n// JSON\nString json = \"\"\"\n    {\n      \"name\": \"John\",\n      \"age\": 25,\n      \"city\": \"NYC\"\n    }\n    \"\"\";\n\n// String interpolation (use formatted())\nString name = \"John\";\nint age = 25;\nString message = \"\"\"\n    Hello, %s!\n    You are %d years old.\n    \"\"\".formatted(name, age);\n\n// Line continuation\nString continued = \"\"\"\n    This is a very long line \\\n    that continues on the next line.\n    \"\"\";"
    },
    {
      "id": 70,
      "question": "What is the var keyword in Java?",
      "answer": "var is a reserved type name for local variable type inference, introduced in Java 10.\n\nFeatures:\n• Compiler infers type from initializer\n• Only for local variables\n• Must be initialized\n• Cannot be null initialized\n• Cannot be used for: fields, method parameters, return types\n\nBenefits:\n• Reduces verbosity\n• Improves readability (when type is obvious)\n• Easier refactoring",
      "explanation": "var is not dynamic typing - type is inferred at compile time and cannot change. Use it when type is obvious from right side. Avoid when it reduces readability.",
      "difficulty": "Easy",
      "code": "// Traditional way\nArrayList<String> list = new ArrayList<String>();\nHashMap<Integer, String> map = new HashMap<>();\n\n// With var (Java 10+)\nvar list = new ArrayList<String>();  // ArrayList<String>\nvar map = new HashMap<Integer, String>();  // HashMap<Integer, String>\n\n// Good uses of var (type is obvious)\nvar num = 10;  // int\nvar name = \"John\";  // String\nvar users = getUserList();  // Type clear from method name\n\n// var in loops\nfor (var entry : map.entrySet()) {\n    System.out.println(entry.getKey());\n}\n\nfor (var i = 0; i < 10; i++) {\n    System.out.println(i);\n}\n\n// Bad uses (reduces readability)\nvar result = process();  // What type???\nvar data = x > 0 ? 1 : \"error\";  // Unclear type\n\n// Cannot use var for:\n// - Fields: var field = 10;  // Error\n// - Method parameters: void method(var param) { }  // Error\n// - Return types: var method() { }  // Error\n// - Without initializer: var x;  // Error\n// - Null initializer: var n = null;  // Error\n\n// Diamond operator works well with var\nvar list2 = new ArrayList<>();  // Type inferred from <>"
    },
    {
      "id": 71,
      "question": "What is the Module System (JPMS) in Java?",
      "answer": "Java Platform Module System (JPMS) introduced in Java 9 for better encapsulation and dependency management.\n\nKey concepts:\n• Module: Named group of packages\n• module-info.java: Module descriptor\n• exports: Makes package public\n• requires: Declares dependency\n• Strong encapsulation: Internal packages not accessible\n• Reliable configuration: Missing dependencies detected at startup\n\nBenefits:\n• Better encapsulation\n• Smaller runtime images\n• Improved performance\n• Explicit dependencies",
      "explanation": "Modules solve JAR hell and provide strong encapsulation. JDK itself is modularized. Not required for most applications but useful for large projects and libraries.",
      "difficulty": "Hard",
      "code": "// module-info.java\nmodule com.example.myapp {\n    // Export packages (public API)\n    exports com.example.api;\n    exports com.example.util to com.example.client;  // Qualified export\n    \n    // Declare dependencies\n    requires java.sql;\n    requires java.logging;\n    requires transitive java.xml;  // Transitive dependency\n    \n    // Service usage\n    uses com.example.service.MyService;\n    provides com.example.service.MyService\n        with com.example.impl.MyServiceImpl;\n    \n    // Reflection access\n    opens com.example.model to com.fasterxml.jackson.databind;\n}\n\n// Package structure\ncom.example.myapp/\n├── module-info.java\n├── com/\n│   └── example/\n│       ├── api/          (exported)\n│       ├── util/         (exported qualified)\n│       └── internal/     (not accessible outside)\n\n// Compile modular app\njavac -d out --module-source-path src $(find src -name \"*.java\")\n\n// Run modular app\njava --module-path out -m com.example.myapp/com.example.Main\n\n// Create custom runtime image\njlink --module-path out --add-modules com.example.myapp --output myapp\n\n// List modules\njava --list-modules"
    },
    {
      "id": 72,
      "question": "What is File I/O and NIO in Java?",
      "answer": "Java provides two APIs for file operations:\n\nOld I/O (java.io):\n• File class (legacy)\n• Stream-based (InputStream, OutputStream)\n• Blocking operations\n• Limited capabilities\n\nNIO (java.nio - New I/O):\n• Path and Files classes\n• Channel-based with Buffers\n• Non-blocking I/O possible\n• Memory-mapped files\n• File watching\n• Better performance\n\nNIO.2 (Java 7+):\n• Files utility class\n• Path interface\n• FileVisitor for directory traversal",
      "explanation": "NIO.2 (java.nio.file) is the modern way to do file I/O. More features, better performance, cleaner API. Always prefer Files over old File class for new code.",
      "difficulty": "Medium",
      "code": "// NIO.2 - modern way (Java 7+)\nimport java.nio.file.*;\n\n// Read file\nString content = Files.readString(Path.of(\"file.txt\"));\nList<String> lines = Files.readAllLines(Path.of(\"file.txt\"));\nbyte[] bytes = Files.readAllBytes(Path.of(\"file.txt\"));\n\n// Write file\nFiles.writeString(Path.of(\"output.txt\"), \"Hello\");\nFiles.write(Path.of(\"output.txt\"), lines);\n\n// Stream lines (memory efficient)\ntry (Stream<String> stream = Files.lines(Path.of(\"large.txt\"))) {\n    stream.filter(line -> line.contains(\"error\"))\n          .forEach(System.out::println);\n}\n\n// Copy, move, delete\nFiles.copy(source, target, StandardCopyOption.REPLACE_EXISTING);\nFiles.move(source, target);\nFiles.delete(path);\nFiles.deleteIfExists(path);\n\n// Check file\nboolean exists = Files.exists(path);\nboolean isDirectory = Files.isDirectory(path);\nlong size = Files.size(path);\n\n// List directory\ntry (Stream<Path> paths = Files.list(Path.of(\".\"))) {\n    paths.filter(Files::isRegularFile)\n         .forEach(System.out::println);\n}\n\n// Walk directory tree\nFiles.walk(Path.of(\".\"))\n     .filter(p -> p.toString().endsWith(\".java\"))\n     .forEach(System.out::println);\n\n// Watch directory for changes\nWatchService watcher = FileSystems.getDefault().newWatchService();\npath.register(watcher, StandardWatchEventKinds.ENTRY_CREATE);"
    },
    {
      "id": 73,
      "question": "What are best practices for Exception Handling in Java?",
      "answer": "Best practices:\n\n1. Specific exceptions:\n• Catch specific exceptions, not generic Exception\n• Multiple catch blocks for different handling\n\n2. Don't swallow exceptions:\n• Always log or handle exceptions\n• Don't catch and ignore\n\n3. Use try-with-resources:\n• Automatic resource management\n\n4. Clean up resources:\n• Use finally or try-with-resources\n\n5. Custom exceptions:\n• Create meaningful domain exceptions\n\n6. Don't use exceptions for control flow:\n• Expensive and unclear\n\n7. Document exceptions:\n• Use @throws in Javadoc",
      "explanation": "Good exception handling makes code robust and maintainable. Exceptions should be exceptional - don't use for normal flow. Always provide context in custom exceptions.",
      "difficulty": "Medium",
      "code": "// Good practices\npublic void goodExample() {\n    // 1. Specific exceptions\n    try {\n        processFile(\"data.txt\");\n    } catch (FileNotFoundException e) {\n        log.error(\"File not found: \" + e.getMessage());\n        // Handle specifically\n    } catch (IOException e) {\n        log.error(\"I/O error: \" + e.getMessage());\n        // Different handling\n    }\n    \n    // 2. try-with-resources\n    try (BufferedReader reader = new BufferedReader(new FileReader(\"file.txt\"))) {\n        String line = reader.readLine();\n    } catch (IOException e) {\n        log.error(\"Error reading file\", e);\n    }\n}\n\n// Bad practices to avoid\npublic void badExample() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {  // Too generic!\n        // Empty catch - swallows exception!\n    }\n    \n    // Exception for control flow - BAD!\n    try {\n        return array[index];\n    } catch (IndexOutOfBoundsException e) {\n        return null;  // Use if statement instead!\n    }\n}\n\n// Custom exception with context\npublic class InsufficientBalanceException extends Exception {\n    private final double balance;\n    private final double requested;\n    \n    public InsufficientBalanceException(double balance, double requested) {\n        super(String.format(\"Insufficient balance: %.2f, requested: %.2f\",\n                          balance, requested));\n        this.balance = balance;\n        this.requested = requested;\n    }\n    \n    public double getBalance() { return balance; }\n    public double getRequested() { return requested; }\n}"
    },
    {
      "id": 74,
      "question": "What are SOLID principles in Java?",
      "answer": "SOLID principles are design principles for maintainable OOP code:\n\nS - Single Responsibility:\n• Class should have one reason to change\n• One class, one job\n\nO - Open/Closed:\n• Open for extension, closed for modification\n• Use inheritance and interfaces\n\nL - Liskov Substitution:\n• Subclass should be substitutable for superclass\n• Subtypes must be behaviorally compatible\n\nI - Interface Segregation:\n• Many specific interfaces better than one general\n• Clients shouldn't depend on unused methods\n\nD - Dependency Inversion:\n• Depend on abstractions, not concretions\n• High-level modules shouldn't depend on low-level",
      "explanation": "SOLID principles lead to flexible, maintainable code. They're guidelines, not strict rules. Understanding them improves design skills and code quality.",
      "difficulty": "Medium",
      "code": "// S - Single Responsibility\n// Bad: Multiple responsibilities\nclass User {\n    void saveToDatabase() { }  // Persistence\n    void sendEmail() { }       // Communication\n    void generateReport() { }  // Reporting\n}\n\n// Good: Separate responsibilities\nclass User { }\nclass UserRepository { void save(User u) { } }\nclass EmailService { void send(User u) { } }\nclass ReportGenerator { void generate(User u) { } }\n\n// O - Open/Closed\n// Use abstraction for extension\ninterface Shape { double area(); }\nclass Circle implements Shape {\n    public double area() { /* ... */ }\n}\nclass Rectangle implements Shape {\n    public double area() { /* ... */ }\n}\n// Add new shapes without modifying existing code\n\n// L - Liskov Substitution\n// Bad: Violates LSP\nclass Bird { void fly() { } }\nclass Penguin extends Bird {\n    void fly() { throw new UnsupportedOperationException(); }  // BAD!\n}\n\n// Good: Proper hierarchy\nclass Bird { }\nclass FlyingBird extends Bird { void fly() { } }\nclass Penguin extends Bird { void swim() { } }\n\n// I - Interface Segregation\n// Bad: Fat interface\ninterface Worker { void work(); void eat(); void sleep(); }\n\n// Good: Segregated interfaces\ninterface Workable { void work(); }\ninterface Eatable { void eat(); }\ninterface Sleepable { void sleep(); }\n\n// D - Dependency Inversion\nclass OrderService {\n    private Repository repository;  // Depend on abstraction\n    OrderService(Repository repo) { this.repository = repo; }\n}"
    },
    {
      "id": 75,
      "question": "What is Dependency Injection in Java?",
      "answer": "Dependency Injection (DI) is a design pattern where objects receive dependencies from external sources rather than creating them.\n\nTypes:\n\n1. Constructor Injection:\n• Dependencies passed via constructor\n• Preferred (immutable, testable)\n\n2. Setter Injection:\n• Dependencies via setter methods\n• Optional dependencies\n\n3. Field Injection:\n• Direct field assignment (reflection)\n• Least preferred\n\nBenefits:\n• Loose coupling\n• Testability\n• Flexibility\n• Single Responsibility",
      "explanation": "DI inverts control - objects don't create dependencies, they receive them. This makes code testable and flexible. Frameworks like Spring use DI extensively. Constructor injection is generally best.",
      "difficulty": "Medium",
      "code": "// Without DI - tight coupling\nclass OrderService {\n    private MySQLDatabase db = new MySQLDatabase();  // Hardcoded!\n    \n    void processOrder(Order order) {\n        db.save(order);  // Tightly coupled to MySQL\n    }\n}\n\n// With DI - loose coupling\ninterface Database {\n    void save(Order order);\n}\n\nclass MySQLDatabase implements Database {\n    public void save(Order order) { /* ... */ }\n}\n\nclass PostgreSQLDatabase implements Database {\n    public void save(Order order) { /* ... */ }\n}\n\n// 1. Constructor Injection (preferred)\nclass OrderService {\n    private final Database database;\n    \n    public OrderService(Database database) {  // Injected\n        this.database = database;\n    }\n    \n    void processOrder(Order order) {\n        database.save(order);  // Works with any Database implementation\n    }\n}\n\n// Usage\nDatabase db = new MySQLDatabase();\nOrderService service = new OrderService(db);  // Inject dependency\n\n// Easy to test with mock\nDatabase mockDb = mock(Database.class);\nOrderService testService = new OrderService(mockDb);\n\n// 2. Setter Injection\nclass OrderService {\n    private Database database;\n    \n    public void setDatabase(Database database) {\n        this.database = database;\n    }\n}\n\n// Spring Framework DI\n@Component\nclass OrderService {\n    private final Database database;\n    \n    @Autowired  // Spring injects automatically\n    public OrderService(Database database) {\n        this.database = database;\n    }\n}"
    },
    {
      "id": 76,
      "question": "What is the difference between deep copy and clone() method?",
      "answer": "Cloning vs Deep Copy:\n\nclone() method:\n• Protected method from Object class\n• Requires Cloneable interface\n• Default is shallow copy\n• Can be overridden for deep copy\n• Throws CloneNotSupportedException\n• Considered problematic by many experts\n\nDeep Copy:\n• Copies object and all referenced objects recursively\n• No standard implementation\n• Must be implemented manually\n• Alternatives: Copy constructors, factory methods, serialization\n\nBest practice: Avoid clone(), use copy constructors or builders",
      "explanation": "clone() has design flaws - requires casting, checked exception, fragile contract. Modern Java prefers copy constructors, static factory methods, or libraries like Apache Commons or builder pattern.",
      "difficulty": "Medium",
      "code": "// Using clone() - traditional way\nclass Person implements Cloneable {\n    String name;\n    Address address;\n    \n    @Override\n    public Person clone() throws CloneNotSupportedException {\n        Person cloned = (Person) super.clone();  // Shallow copy\n        cloned.address = address.clone();         // Deep copy reference\n        return cloned;\n    }\n}\n\n// Better: Copy constructor\nclass Person {\n    String name;\n    Address address;\n    \n    // Copy constructor\n    public Person(Person other) {\n        this.name = other.name;\n        this.address = new Address(other.address);  // Deep copy\n    }\n}\n\n// Usage\nPerson p1 = new Person(\"John\", new Address(\"NYC\"));\nPerson p2 = new Person(p1);  // Deep copy\n\n// Static factory method\nclass Person {\n    public static Person copyOf(Person other) {\n        return new Person(other.name, new Address(other.address));\n    }\n}\n\nPerson p3 = Person.copyOf(p1);\n\n// Builder pattern with copy\nPerson p4 = Person.builder()\n    .from(p1)\n    .withName(\"Jane\")  // Override specific field\n    .build();\n\n// Serialization-based deep copy (slow but works)\nclass DeepCopy {\n    static <T extends Serializable> T deepCopy(T object) {\n        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();\n             ObjectOutputStream oos = new ObjectOutputStream(bos)) {\n            oos.writeObject(object);\n            byte[] bytes = bos.toByteArray();\n            try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes);\n                 ObjectInputStream ois = new ObjectInputStream(bis)) {\n                return (T) ois.readObject();\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}"
    },
    {
      "id": 77,
      "question": "What is the difference between Path, Iterator and Stream in collections?",
      "answer": "Three ways to process collections:\n\nPath (forEach):\n• External iteration\n• Simple but imperative\n• Cannot be parallelized easily\n• Side effects okay\n\nIterator:\n• External iteration\n• More control (can remove elements)\n• Cannot be parallelized\n• Fail-fast behavior\n\nStream:\n• Internal iteration\n• Functional style\n• Can be parallelized\n• Lazy evaluation\n• Cannot modify collection\n• More abstract and composable",
      "explanation": "Stream is the modern approach - functional, composable, parallelizable. Use Iterator when you need to remove elements during iteration. forEach is simplest for side-effects. Streams shine with complex transformations.",
      "difficulty": "Medium",
      "code": "List<String> names = Arrays.asList(\"John\", \"Jane\", \"Bob\", \"Alice\");\n\n// 1. Path (forEach) - simple, external iteration\nfor (String name : names) {\n    System.out.println(name);  // Side effect\n}\n\nnames.forEach(name -> System.out.println(name));  // Lambda version\n\n// 2. Iterator - more control\nIterator<String> iterator = names.iterator();\nwhile (iterator.hasNext()) {\n    String name = iterator.next();\n    if (name.startsWith(\"B\")) {\n        iterator.remove();  // Can modify collection\n    }\n}\n\n// 3. Stream - functional, composable\nnames.stream()\n     .filter(name -> name.startsWith(\"J\"))\n     .map(String::toUpperCase)\n     .sorted()\n     .forEach(System.out::println);\n\n// Stream advantages\n// - Lazy evaluation\nStream<String> stream = names.stream()\n    .filter(name -> {  // Not executed until terminal operation\n        System.out.println(\"Filtering: \" + name);\n        return name.startsWith(\"J\");\n    });\n// Nothing printed yet!\nlong count = stream.count();  // Now executed\n\n// - Parallelization\nlong count = names.parallelStream()\n    .filter(name -> name.length() > 3)\n    .count();  // Automatically parallel\n\n// Cannot modify collection in stream\nnames.stream()\n     // .remove(\"John\");  // No remove method!\n     .collect(Collectors.toList());  // Create new collection instead"
    },
    {
      "id": 78,
      "question": "What is the difference between intermediate and terminal operations in Streams?",
      "answer": "Stream operations are divided into two types:\n\nIntermediate Operations:\n• Return a Stream\n• Lazy (not executed immediately)\n• Can be chained\n• Examples: filter, map, sorted, distinct, limit, skip\n• Form a pipeline\n\nTerminal Operations:\n• Return non-Stream result or void\n• Eager (trigger execution)\n• Close the stream\n• Examples: collect, forEach, reduce, count, anyMatch, findFirst\n• Stream can't be reused after\n\nShort-circuiting:\n• Some operations don't need to process all elements\n• Examples: findFirst, anyMatch, limit",
      "explanation": "Understanding lazy vs eager is crucial for Stream performance. Intermediate operations build a pipeline, terminal operations execute it. This enables optimization - only necessary elements are processed.",
      "difficulty": "Medium",
      "code": "List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\n// Intermediate operations (lazy - not executed)\nStream<Integer> stream = numbers.stream()\n    .filter(n -> {  // Not executed yet!\n        System.out.println(\"Filter: \" + n);\n        return n % 2 == 0;\n    })\n    .map(n -> {  // Not executed yet!\n        System.out.println(\"Map: \" + n);\n        return n * 2;\n    });\n\nSystem.out.println(\"Stream created\");  // No output from filter/map\n\n// Terminal operation (triggers execution)\nList<Integer> result = stream.collect(Collectors.toList());\n// NOW filter and map are executed\n\n// Common intermediate operations\nnumbers.stream()\n    .filter(n -> n > 5)        // Filter\n    .map(n -> n * 2)           // Transform\n    .distinct()                 // Remove duplicates\n    .sorted()                   // Sort\n    .limit(3)                   // Take first 3\n    .skip(1)                    // Skip first\n    .peek(System.out::println)  // Debug (side effect)\n    .collect(Collectors.toList());  // Terminal\n\n// Common terminal operations\nlong count = numbers.stream().count();\nOptional<Integer> first = numbers.stream().findFirst();\nOptional<Integer> any = numbers.stream().findAny();\nboolean allEven = numbers.stream().allMatch(n -> n % 2 == 0);\nboolean anyEven = numbers.stream().anyMatch(n -> n % 2 == 0);\nboolean noneNegative = numbers.stream().noneMatch(n -> n < 0);\nInteger sum = numbers.stream().reduce(0, Integer::sum);\n\n// Stream can't be reused\nStream<Integer> s = numbers.stream();\ns.count();\n// s.sum();  // IllegalStateException - stream already operated upon!\n\n// Short-circuiting optimization\nnumbers.stream()\n    .peek(n -> System.out.println(\"Processing: \" + n))\n    .filter(n -> n > 5)\n    .findFirst();  // Stops as soon as first match found!"
    },
    {
      "id": 79,
      "question": "What is Method Hiding in Java?",
      "answer": "Method Hiding occurs when a static method in a subclass has the same signature as a static method in the superclass.\n\nCharacteristics:\n• Only applies to static methods\n• Not polymorphic (no runtime binding)\n• Resolved at compile time\n• Called based on reference type, not object type\n• Different from method overriding\n\nOverriding (instance methods):\n• Runtime polymorphism\n• Resolved at runtime\n• Called based on object type\n\nHiding (static methods):\n• Compile-time resolution\n• Resolved at compile time\n• Called based on reference type",
      "explanation": "Method hiding is why static methods can't be truly overridden - they're not polymorphic. The method called is determined by the reference type, not the actual object type. This is a common interview question about static methods.",
      "difficulty": "Medium",
      "code": "class Parent {\n    // Static method\n    static void staticMethod() {\n        System.out.println(\"Parent static\");\n    }\n    \n    // Instance method\n    void instanceMethod() {\n        System.out.println(\"Parent instance\");\n    }\n}\n\nclass Child extends Parent {\n    // Method hiding (static)\n    static void staticMethod() {\n        System.out.println(\"Child static\");\n    }\n    \n    // Method overriding (instance)\n    @Override\n    void instanceMethod() {\n        System.out.println(\"Child instance\");\n    }\n}\n\n// Method hiding behavior\nParent p1 = new Parent();\nParent p2 = new Child();  // Parent reference, Child object\nChild c = new Child();\n\n// Static method - resolved by reference type (method hiding)\np1.staticMethod();  // \"Parent static\"\np2.staticMethod();  // \"Parent static\" (reference type is Parent!)\nc.staticMethod();   // \"Child static\"\nChild.staticMethod();  // \"Child static\" (best practice - call via class)\n\n// Instance method - resolved by object type (polymorphism)\np1.instanceMethod();  // \"Parent instance\"\np2.instanceMethod();  // \"Child instance\" (object is Child - polymorphism!)\nc.instanceMethod();   // \"Child instance\"\n\n// Key difference\n// Static: Reference type matters\n// Instance: Object type matters"
    },
    {
      "id": 80,
      "question": "What is the volatile keyword and when to use it?",
      "answer": "volatile is a keyword ensuring visibility of variable changes across threads.\n\nGuarantees:\n• Reads from main memory (not CPU cache)\n• Writes to main memory immediately\n• Happens-before relationship\n• No instruction reordering around volatile\n\nDoes NOT provide:\n• Atomicity (i++ is not atomic even with volatile)\n• Mutual exclusion\n\nUse cases:\n• Status flags\n• Single-writer, multiple-reader scenarios\n• Double-checked locking\n\nWhen NOT to use:\n• Compound operations (use AtomicInteger)\n• Multiple variables (use synchronized)",
      "explanation": "volatile solves visibility problem but not atomicity. For atomic operations, use Atomic classes or synchronized. Common use: boolean flag to stop threads. Remember: volatile != synchronized.",
      "difficulty": "Hard",
      "code": "// Example 1: Without volatile (problem)\nclass TaskRunner {\n    private boolean running = true;  // NOT volatile\n    \n    public void run() {\n        while (running) {  // May never see update!\n            // Thread caches 'running', may never reload\n        }\n    }\n    \n    public void stop() {\n        running = false;  // Other thread may not see this!\n    }\n}\n\n// Example 2: With volatile (solution)\nclass TaskRunner {\n    private volatile boolean running = true;  // VOLATILE\n    \n    public void run() {\n        while (running) {  // Always sees latest value\n            // Work\n        }\n    }\n    \n    public void stop() {\n        running = false;  // Immediately visible to all threads\n    }\n}\n\n// Example 3: volatile doesn't ensure atomicity\nclass Counter {\n    private volatile int count = 0;  // Visible but not atomic!\n    \n    public void increment() {\n        count++;  // NOT atomic! (read-modify-write)\n        // Thread A: read 0\n        // Thread B: read 0\n        // Thread A: write 1\n        // Thread B: write 1 (lost update!)\n    }\n}\n\n// Solution: Use AtomicInteger\nclass Counter {\n    private AtomicInteger count = new AtomicInteger(0);\n    \n    public void increment() {\n        count.incrementAndGet();  // Atomic\n    }\n}\n\n// Example 4: Double-checked locking (famous volatile use)\nclass Singleton {\n    private static volatile Singleton instance;  // Must be volatile!\n    \n    public static Singleton getInstance() {\n        if (instance == null) {  // First check (no locking)\n            synchronized (Singleton.class) {\n                if (instance == null) {  // Second check (locked)\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}"
    },
    {
      "id": 81,
      "question": "What are the different ways to create threads in Java?",
      "answer": "Four main ways to create threads:\n\n1. Extend Thread class:\n• Override run() method\n• Call start() to begin execution\n• Single inheritance limitation\n\n2. Implement Runnable interface:\n• Override run() method\n• Pass to Thread constructor\n• Preferred (composition over inheritance)\n\n3. Implement Callable interface:\n• Returns result and can throw exceptions\n• Used with ExecutorService\n• Returns Future<V>\n\n4. Lambda expressions (Java 8+):\n• Concise syntax for Runnable/Callable\n• Functional interface implementation",
      "explanation": "Runnable is preferred over extending Thread - it's more flexible and follows composition principle. Callable is for tasks that return results. Modern code uses ExecutorService with Runnable/Callable rather than creating Thread objects directly.",
      "difficulty": "Easy",
      "code": "// 1. Extend Thread class\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"Thread using Thread class\");\n    }\n}\nMyThread t1 = new MyThread();\nt1.start();\n\n// 2. Implement Runnable (preferred)\nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"Thread using Runnable\");\n    }\n}\nThread t2 = new Thread(new MyRunnable());\nt2.start();\n\n// 3. Implement Callable\nclass MyCallable implements Callable<Integer> {\n    @Override\n    public Integer call() throws Exception {\n        return 42;  // Can return value\n    }\n}\nExecutorService executor = Executors.newSingleThreadExecutor();\nFuture<Integer> future = executor.submit(new MyCallable());\nInteger result = future.get();\n\n// 4. Lambda expressions (Java 8+)\nThread t3 = new Thread(() -> {\n    System.out.println(\"Thread using lambda\");\n});\nt3.start();\n\n// Modern approach with ExecutorService\nExecutorService executor = Executors.newFixedThreadPool(5);\nexecutor.execute(() -> System.out.println(\"Task 1\"));\nexecutor.submit(() -> {\n    System.out.println(\"Task 2\");\n    return \"Result\";\n});\nexecutor.shutdown();"
    },
    {
      "id": 82,
      "question": "What is a Singleton pattern and how to implement it thread-safe?",
      "answer": "Singleton ensures only one instance of a class exists.\n\nImplementation approaches:\n\n1. Eager initialization:\n• Instance created at class loading\n• Thread-safe automatically\n• Wastes memory if never used\n\n2. Lazy initialization:\n• Instance created when needed\n• Requires synchronization\n\n3. Double-checked locking:\n• Lazy + minimizes synchronization\n• Requires volatile keyword\n\n4. Bill Pugh (best):\n• Uses static inner class\n• Lazy, thread-safe, no synchronization\n\n5. Enum (Joshua Bloch recommendation):\n• Simplest, serialization-safe",
      "explanation": "Bill Pugh's approach using static inner class is generally best - lazy loaded, thread-safe without synchronization. Enum is the simplest and handles serialization. Avoid double-checked locking unless you fully understand it.",
      "difficulty": "Medium",
      "code": "// 1. Eager initialization\nclass Singleton {\n    private static final Singleton instance = new Singleton();\n    private Singleton() { }\n    public static Singleton getInstance() { return instance; }\n}\n\n// 2. Lazy with synchronized method (inefficient)\nclass Singleton {\n    private static Singleton instance;\n    private Singleton() { }\n    public static synchronized Singleton getInstance() {  // Slow!\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n\n// 3. Double-checked locking (complex but efficient)\nclass Singleton {\n    private static volatile Singleton instance;  // volatile is crucial!\n    private Singleton() { }\n    public static Singleton getInstance() {\n        if (instance == null) {\n            synchronized (Singleton.class) {\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n\n// 4. Bill Pugh approach (best)\nclass Singleton {\n    private Singleton() { }\n    // Static inner class loaded only when getInstance() called\n    private static class SingletonHolder {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n    public static Singleton getInstance() {\n        return SingletonHolder.INSTANCE;  // Thread-safe, lazy\n    }\n}\n\n// 5. Enum (simplest, serialization-safe)\nenum Singleton {\n    INSTANCE;\n    public void doSomething() { }\n}\nSingleton.INSTANCE.doSomething();"
    },
    {
      "id": 83,
      "question": "What is Covariant Return Type in Java?",
      "answer": "Covariant return type allows overriding method to return a subtype of the return type declared in the parent method.\n\nIntroduced in Java 5.\n\nRules:\n• Return type must be subclass of parent's return type\n• Only applicable to non-primitive return types\n• Helps avoid explicit casting\n• Improves type safety\n\nExample: clone() method returns Object but can be overridden to return specific type\n\nBenefits:\n• More specific return types\n• Better type safety\n• Less casting needed",
      "explanation": "Covariant return types make APIs more type-safe and convenient. No need to cast the return value. Common in factory methods and fluent APIs where you want to return the specific type.",
      "difficulty": "Medium",
      "code": "// Parent class\nclass Animal {\n    Animal getAnimal() {\n        return new Animal();\n    }\n}\n\n// Child class with covariant return type\nclass Dog extends Animal {\n    @Override\n    Dog getAnimal() {  // Returns Dog, not Animal (covariant!)\n        return new Dog();\n    }\n}\n\n// Usage\nDog dog = new Dog();\nDog myDog = dog.getAnimal();  // No casting needed!\n// vs without covariant: Animal animal = dog.getAnimal(); Dog myDog = (Dog) animal;\n\n// Real-world example: clone()\nclass Person implements Cloneable {\n    String name;\n    \n    @Override\n    public Person clone() throws CloneNotSupportedException {  // Not Object!\n        return (Person) super.clone();\n    }\n}\n\nPerson p1 = new Person();\nPerson p2 = p1.clone();  // No cast needed!\n\n// Builder pattern with covariant return types\nclass Animal {\n    static class Builder {\n        Builder setName(String name) { return this; }\n        Animal build() { return new Animal(); }\n    }\n}\n\nclass Dog extends Animal {\n    static class Builder extends Animal.Builder {\n        @Override\n        Builder setName(String name) { return this; }\n        \n        @Override\n        Dog build() { return new Dog(); }  // Covariant return\n    }\n}\n\nDog dog = new Dog.Builder().setName(\"Buddy\").build();  // Returns Dog!"
    },
    {
      "id": 84,
      "question": "What is the difference between StringBuilder, StringBuffer, and String?",
      "answer": "Three classes for handling strings with different characteristics:\n\nString:\n• Immutable\n• Thread-safe by nature\n• Stored in String Pool\n• Use for: Constant strings, hash keys\n\nStringBuilder:\n• Mutable\n• Not thread-safe\n• Faster (no synchronization)\n• Use for: Single-threaded string manipulation\n\nStringBuffer:\n• Mutable\n• Thread-safe (synchronized methods)\n• Slower than StringBuilder\n• Use for: Multi-threaded string manipulation\n\nPerformance: StringBuilder > StringBuffer > String (for concatenation)",
      "explanation": "Always use StringBuilder for string concatenation in loops - it's much faster than String concatenation. Only use StringBuffer if multiple threads access the same instance. String is immutable so each concatenation creates new object.",
      "difficulty": "Easy",
      "code": "// String - immutable (inefficient for loops)\nString s = \"\";\nfor (int i = 0; i < 1000; i++) {\n    s += i;  // Creates 1000 new String objects!\n}\n\n// StringBuilder - mutable, not thread-safe (best for single thread)\nStringBuilder sb = new StringBuilder();\nfor (int i = 0; i < 1000; i++) {\n    sb.append(i);  // Modifies same object - fast!\n}\nString result = sb.toString();\n\n// StringBuffer - mutable, thread-safe (for multi-threading)\nStringBuffer sbf = new StringBuffer();\nfor (int i = 0; i < 1000; i++) {\n    sbf.append(i);  // Thread-safe but slower\n}\n\n// Common methods (same for StringBuilder and StringBuffer)\nStringBuilder builder = new StringBuilder(\"Hello\");\nbuilder.append(\" World\");          // \"Hello World\"\nbuilder.insert(5, \",\");             // \"Hello, World\"\nbuilder.replace(0, 5, \"Hi\");       // \"Hi, World\"\nbuilder.delete(2, 3);               // \"Hi World\"\nbuilder.reverse();                  // \"dlroW iH\"\nbuilder.setLength(5);               // \"dlroW\"\nint capacity = builder.capacity();  // Current capacity\n\n// Performance comparison\n// String: O(n²) for n concatenations\n// StringBuilder/StringBuffer: O(n) amortized\n\n// Compiler optimization\nString s1 = \"Hello\" + \" \" + \"World\";  // Compiler uses StringBuilder\n// BUT in loops, you must use StringBuilder explicitly!"
    },
    {
      "id": 85,
      "question": "What are the differences between ArrayList and Vector?",
      "answer": "Both are dynamic arrays, but with key differences:\n\nArrayList:\n• Not synchronized (not thread-safe)\n• Faster\n• Increases capacity by 50% when full\n• Iterator is fail-fast\n• Introduced in Java 1.2 (Collections Framework)\n• Preferred in modern code\n\nVector:\n• Synchronized (thread-safe)\n• Slower due to synchronization\n• Doubles capacity when full\n• Has legacy methods (addElement, etc.)\n• Introduced in Java 1.0 (legacy)\n• Considered obsolete\n\nRecommendation: Use ArrayList with external synchronization if needed, or CopyOnWriteArrayList",
      "explanation": "Vector is legacy and generally avoided in modern code. ArrayList is faster and you can synchronize externally if needed using Collections.synchronizedList() or use CopyOnWriteArrayList for concurrent scenarios.",
      "difficulty": "Easy",
      "code": "// ArrayList - modern, not synchronized\nList<String> arrayList = new ArrayList<>();\narrayList.add(\"Item\");\n// Not thread-safe - multiple threads may cause issues\n\n// Vector - legacy, synchronized\nVector<String> vector = new Vector<>();\nvector.add(\"Item\");  // Synchronized method - thread-safe but slow\nvector.addElement(\"Item\");  // Legacy method\n\n// Growth rate difference\n// ArrayList: newCapacity = oldCapacity + (oldCapacity >> 1)  // 1.5x\n// Vector: newCapacity = oldCapacity * 2  // 2x\n\n// Modern alternatives for thread-safety\n\n// Option 1: Synchronized wrapper\nList<String> syncList = Collections.synchronizedList(new ArrayList<>());\nsyncList.add(\"Item\");  // Thread-safe\n\n// But iteration needs manual synchronization\nsynchronized(syncList) {\n    for (String s : syncList) {\n        System.out.println(s);\n    }\n}\n\n// Option 2: CopyOnWriteArrayList (Java 5+)\nList<String> cowList = new CopyOnWriteArrayList<>();\ncowList.add(\"Item\");  // Thread-safe, no ConcurrentModificationException\n// Good for: mostly reads, few writes\n\n// Performance comparison for 10000 adds\n// ArrayList: ~2ms\n// Vector: ~5ms (synchronized overhead)\n// CopyOnWriteArrayList: ~500ms (copies on each write)\n\n// Iteration safety\nList<String> list = new ArrayList<>(Arrays.asList(\"A\", \"B\", \"C\"));\nfor (String s : list) {\n    // list.remove(s);  // ConcurrentModificationException!\n}\n\n// Vector enumeration (legacy)\nVector<String> v = new Vector<>(Arrays.asList(\"A\", \"B\", \"C\"));\nEnumeration<String> e = v.elements();  // Legacy iterator\nwhile (e.hasMoreElements()) {\n    System.out.println(e.nextElement());\n}"
    },
    {
      "id": 86,
      "question": "What is type erasure in Java Generics?",
      "answer": "Type Erasure is the process where compiler removes all generic type information after compilation.\n\nHow it works:\n1. Replace type parameters with bounds (or Object)\n2. Insert type casts where needed\n3. Generate bridge methods for polymorphism\n\nImplications:\n• Cannot create generic array: new T[]\n• Cannot use instanceof with parameterized types\n• Cannot have overloaded methods differing only in generic type\n• Cannot create instances: new T()\n• Type information lost at runtime\n• List<String> and List<Integer> become List at runtime",
      "explanation": "Type erasure enables backward compatibility with pre-generic code but has limitations. It's why you can't create generic arrays or check instanceof with parameterized types. Understanding erasure explains many generic limitations.",
      "difficulty": "Hard",
      "code": "// Type erasure example\nclass Box<T> {\n    private T value;\n    public void set(T value) { this.value = value; }\n    public T get() { return value; }\n}\n\n// After erasure (what compiler generates)\nclass Box {\n    private Object value;  // T replaced with Object\n    public void set(Object value) { this.value = value; }\n    public Object get() { return value; }\n}\n\n// Usage with casts inserted by compiler\nBox<String> box = new Box<>();\nbox.set(\"Hello\");\nString s = box.get();  // Compiler inserts cast: (String) box.get()\n\n// Limitations due to type erasure\n\n// 1. Cannot create generic array\nT[] array = new T[10];  // Compile error!\nList<String>[] lists = new List<String>[10];  // Compile error!\nList<?>[] lists = new List<?>[10];  // OK (unbounded)\n\n// 2. Cannot use instanceof\nif (list instanceof List<String>) { }  // Compile error!\nif (list instanceof List<?>) { }  // OK\n\n// 3. Runtime type information lost\nList<String> strings = new ArrayList<>();\nList<Integer> integers = new ArrayList<>();\nSystem.out.println(strings.getClass() == integers.getClass());  // true!\n// Both are just ArrayList at runtime\n\n// 4. Cannot overload based on generics\nclass Processor {\n    void process(List<String> list) { }\n    // void process(List<Integer> list) { }  // Compile error!\n    // After erasure, both are process(List)\n}\n\n// 5. Cannot create instances\nclass Factory<T> {\n    T create() {\n        // return new T();  // Compile error!\n        return null;\n    }\n}\n\n// Workarounds\n// Use Class<T> parameter\nclass Factory<T> {\n    T create(Class<T> clazz) throws Exception {\n        return clazz.newInstance();  // Reflection\n    }\n}\n\n// For arrays, use reflection\n@SuppressWarnings(\"unchecked\")\nT[] createArray(Class<T> clazz, int size) {\n    return (T[]) Array.newInstance(clazz, size);\n}"
    },
    {
      "id": 87,
      "question": "What is the diamond problem and how does Java handle it?",
      "answer": "Diamond problem occurs in multiple inheritance when a class inherits from two classes that have a common ancestor.\n\nProblem:\n• Which parent's method to inherit?\n• Ambiguity in method resolution\n\nJava's solutions:\n\n1. No multiple class inheritance:\n• Class can extend only one class\n• Avoids diamond problem entirely\n\n2. Multiple interface inheritance (allowed):\n• Java 8+ allows default methods in interfaces\n• Diamond problem can occur\n• Resolution: Class must override conflicting methods\n• Or specify which interface's method to use\n\nRules:\n• Class methods beat interface default methods\n• More specific interface wins\n• Explicit override required for ambiguity",
      "explanation": "Java avoids diamond problem by disallowing multiple class inheritance. With interfaces and default methods (Java 8+), diamond problem can occur but Java has clear resolution rules. Classes must override ambiguous methods.",
      "difficulty": "Hard",
      "code": "// Diamond problem setup\ninterface A {\n    default void doSomething() {\n        System.out.println(\"A's implementation\");\n    }\n}\n\ninterface B extends A {\n    default void doSomething() {\n        System.out.println(\"B's implementation\");\n    }\n}\n\ninterface C extends A {\n    default void doSomething() {\n        System.out.println(\"C's implementation\");\n    }\n}\n\n// Diamond: D inherits from both B and C, which inherit from A\nclass D implements B, C {\n    // Compile error without override - ambiguous!\n    @Override\n    public void doSomething() {\n        // Must override to resolve ambiguity\n        System.out.println(\"D's implementation\");\n        \n        // Can call specific interface method\n        B.super.doSomething();  // Call B's version\n        C.super.doSomething();  // Call C's version\n    }\n}\n\n// Resolution rules\n\n// Rule 1: Class wins over interface\ninterface Interface {\n    default void method() { System.out.println(\"Interface \"); }\n}\n\nclass Parent {\n    public void method() { System.out.println(\"Parent\"); }\n}\n\nclass Child extends Parent implements Interface {\n    // Parent's method wins, no override needed\n}\n\nnew Child().method();  // Prints \"Parent\"\n\n// Rule 2: More specific interface wins\ninterface General {\n    default void method() { System.out.println(\"General\"); }\n}\n\ninterface Specific extends General {\n    default void method() { System.out.println(\"Specific\"); }\n}\n\nclass Impl implements General, Specific {\n    // Specific wins, no override needed\n}\n\nnew Impl().method();  // Prints \"Specific\"\n\n// Rule 3: Ambiguous - must override\ninterface X {\n    default void method() { System.out.println(\"X\"); }\n}\n\ninterface Y {\n    default void method() { System.out.println(\"Y\"); }\n}\n\nclass Z implements X, Y {\n    @Override\n    public void method() {  // Must override!\n        X.super.method();  // Choose explicitly\n    }\n}"
    },
    {
      "id": 88,
      "question": "What is the difference between PriorityQueue and Queue?",
      "answer": "Queue vs PriorityQueue:\n\nQueue (interface):\n• FIFO (First-In-First-Out) ordering\n• Elements processed in insertion order\n• Implementations: LinkedList, ArrayDeque\n\nPriorityQueue (class):\n• Heap-based implementation\n• Elements ordered by priority (natural ordering or Comparator)\n• Head is smallest/highest priority element\n• Not strictly FIFO\n• Not thread-safe\n• O(log n) for insertion/removal\n• O(1) for peek\n• Does not allow null elements\n\nUse PriorityQueue when elements need priority-based processing",
      "explanation": "PriorityQueue is perfect for scenarios where you need to process elements by priority, not insertion order. Internally uses a binary heap. Common in scheduling, Dijkstra's algorithm, and event-driven systems.",
      "difficulty": "Medium",
      "code": "// Regular Queue - FIFO\nQueue<Integer> queue = new LinkedList<>();\nqueue.offer(3);\nqueue.offer(1);\nqueue.offer(2);\nSystem.out.println(queue.poll());  // 3 (first inserted)\nSystem.out.println(queue.poll());  // 1\nSystem.out.println(queue.poll());  // 2\n\n// PriorityQueue - priority order (min-heap by default)\nQueue<Integer> pq = new PriorityQueue<>();\npq.offer(3);\npq.offer(1);\npq.offer(2);\nSystem.out.println(pq.poll());  // 1 (smallest/highest priority)\nSystem.out.println(pq.poll());  // 2\nSystem.out.println(pq.poll());  // 3\n\n// PriorityQueue with custom comparator (max-heap)\nQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());\nmaxHeap.offer(3);\nmaxHeap.offer(1);\nmaxHeap.offer(2);\nSystem.out.println(maxHeap.poll());  // 3 (largest first)\n\n// PriorityQueue with custom objects\nclass Task implements Comparable<Task> {\n    String name;\n    int priority;\n    \n    @Override\n    public int compareTo(Task other) {\n        return Integer.compare(this.priority, other.priority);\n    }\n}\n\nPriorityQueue<Task> tasks = new PriorityQueue<>();\ntasks.offer(new Task(\"Low\", 3));\ntasks.offer(new Task(\"High\", 1));\ntasks.offer(new Task(\"Medium\", 2));\n\nwhile (!tasks.isEmpty()) {\n    Task t = tasks.poll();\n    System.out.println(t.name);  // High, Medium, Low\n}\n\n// Using comparator\nPriorityQueue<Task> tasks2 = new PriorityQueue<>(\n    (t1, t2) -> Integer.compare(t2.priority, t1.priority)  // Reverse\n);\n\n// Thread-safe alternative\nBlockingQueue<Integer> pq = new PriorityBlockingQueue<>();"
    },
    {
      "id": 89,
      "question": "What is switch expression in Java?",
      "answer": "Switch expression (Java 12+ preview, finalized in Java 14) is an enhanced switch that can return values.\n\nKey features:\n\nArrow syntax (->):\n• No fall-through\n• No break needed\n• Can return values\n\nMultiple case labels:\n• case 1, 2, 3 -> ...\n\nYield keyword:\n• Return value from block\n• Similar to return but for switch\n\nExhaustiveness:\n• Compiler ensures all cases covered\n\nBenefits:\n• More concise\n• No fall-through bugs\n• Can use as expression\n• Better for pattern matching",
      "explanation": "Switch expressions make code cleaner and safer - no fall-through bugs, and they return values directly. Traditional switch is statement, new switch can be expression. This is foundation for pattern matching in switch.",
      "difficulty": "Medium",
      "code": "// Traditional switch statement (old)\nString day = \"MONDAY\";\nint numLetters;\nswitch (day) {\n    case \"MONDAY\":\n    case \"FRIDAY\":\n    case \"SUNDAY\":\n        numLetters = 6;\n        break;\n    case \"TUESDAY\":\n        numLetters = 7;\n        break;\n    default:\n        numLetters = 0;\n}\n\n// Switch expression with arrow (Java 14+)\nint numLetters = switch (day) {\n    case \"MONDAY\", \"FRIDAY\", \"SUNDAY\" -> 6;  // Multiple cases, no break\n    case \"TUESDAY\" -> 7;\n    case \"THURSDAY\", \"SATURDAY\" -> 8;\n    case \"WEDNESDAY\" -> {\n        System.out.println(\"Wednesday\");\n        yield 9;  // yield for blocks\n    }\n    default -> 0;\n};\n\n// Traditional switch can't return value\nString result;\nswitch (value) {\n    case 1:\n        result = \"One\";\n        break;\n    case 2:\n        result = \"Two\";\n        break;\n    default:\n        result = \"Other\";\n}\n\n// Switch expression returns value directly\nString result = switch (value) {\n    case 1 -> \"One\";\n    case 2 -> \"Two\";\n    default -> \"Other\";\n};\n\n// With enums (exhaustiveness checking)\nenum Day { MONDAY, TUESDAY, WEDNESDAY }\n\nDay day = Day.MONDAY;\nString type = switch (day) {\n    case MONDAY, FRIDAY -> \"Start/End\";\n    case TUESDAY, WEDNESDAY, THURSDAY -> \"Midweek\";\n    // No default needed - all cases covered!\n};\n\n// Multiple statements with yield\nint result = switch (x) {\n    case 1 -> {\n        System.out.println(\"Processing 1\");\n        int temp = compute();\n        yield temp * 2;\n    }\n    case 2 -> {\n        System.out.println(\"Processing 2\");\n        yield 20;\n    }\n    default -> 0;\n};\n\n// Pattern matching in switch (Java 17+ preview)\nObject obj = \"Hello\";\nString result = switch (obj) {\n    case Integer i -> \"Integer: \" + i;\n    case String s -> \"String: \" + s;\n    case null -> \"Null\";\n    default -> \"Other\";\n};"
    },
    {
      "id": 90,
      "question": "What is the Builder pattern and when to use it?",
      "answer": "Builder pattern constructs complex objects step by step, separating construction from representation.\n\nWhen to use:\n• Many constructor parameters (>4-5)\n• Many optional parameters\n• Immutable objects\n• Readable object construction\n• Telescoping constructor anti-pattern\n\nBenefits:\n• Readable code\n• Immutable objects\n• Step-by-step construction\n• No need for many constructors\n• Parameter validation in build()\n• Fluent interface\n\nPopularized by Joshua Bloch in Effective Java",
      "explanation": "Builder pattern solves telescoping constructor problem and makes object creation readable. Perfect for immutable objects with many fields. Much better than having constructors with 10+ parameters or many setter methods.",
      "difficulty": "Medium",
      "code": "// Without Builder (telescoping constructors - bad)\nclass Person {\n    Person(String name) { }\n    Person(String name, int age) { }\n    Person(String name, int age, String email) { }\n    Person(String name, int age, String email, String phone) { }\n    // Gets messy with many parameters!\n}\n\n// With Builder pattern\nclass Person {\n    // Required fields\n    private final String name;  // final = immutable\n    \n    // Optional fields\n    private final int age;\n    private final String email;\n    private final String phone;\n    private final String address;\n    \n    // Private constructor\n    private Person(Builder builder) {\n        this.name = builder.name;\n        this.age = builder.age;\n        this.email = builder.email;\n        this.phone = builder.phone;\n        this.address = builder.address;\n    }\n    \n    // Static nested Builder class\n    public static class Builder {\n        // Required fields\n        private final String name;\n        \n        // Optional fields - with defaults\n        private int age = 0;\n        private String email = \"\";\n        private String phone = \"\";\n        private String address = \"\";\n        \n        // Constructor with required fields\n        public Builder(String name) {\n            this.name = name;\n        }\n        \n        // Fluent setters for optional fields\n        public Builder age(int age) {\n            this.age = age;\n            return this;\n        }\n        \n        public Builder email(String email) {\n            this.email = email;\n            return this;\n        }\n        \n        public Builder phone(String phone) {\n            this.phone = phone;\n            return this;\n        }\n        \n        public Builder address(String address) {\n            this.address = address;\n            return this;\n        }\n        \n        // Build method with validation\n        public Person build() {\n            // Validate\n            if (age < 0) {\n                throw new IllegalStateException(\"Age cannot be negative\");\n            }\n            return new Person(this);\n        }\n    }\n    \n    // Getters only (no setters - immutable)\n    public String getName() { return name; }\n    public int getAge() { return age; }\n}\n\n// Usage - readable and fluent\nPerson person = new Person.Builder(\"John\")  // Required\n    .age(25)                                 // Optional\n    .email(\"john@example.com\")              // Optional\n    .phone(\"123-456-7890\")                  // Optional\n    .build();\n\n// Lombok @Builder annotation (generates builder automatically)\n@Builder\nclass Person {\n    private String name;\n    private int age;\n    private String email;\n}\n\nPerson p = Person.builder()\n    .name(\"John\")\n    .age(25)\n    .build();"
    },
    {
      "id": 91,
      "question": "What is the Factory pattern in Java?",
      "answer": "Factory pattern provides an interface for creating objects without specifying exact class.\n\nTypes:\n\n1. Simple Factory:\n• Static method creates objects\n• Not a formal pattern\n\n2. Factory Method:\n• Subclasses decide which class to instantiate\n• Define interface for creating objects\n\n3. Abstract Factory:\n• Factory of factories\n• Create families of related objects\n\nBenefits:\n• Loose coupling\n• Hide creation logic\n• Centralized object creation\n• Easy to extend\n• Follows Open/Closed principle",
      "explanation": "Factory pattern is fundamental for loose coupling. Simple factory is most common - use valueOf(), of(), getInstance() naming. Factory method when subclasses need different implementations. Abstract factory for creating related object families.",
      "difficulty": "Medium",
      "code": "// 1. Simple Factory\nclass ShapeFactory {\n    public static Shape createShape(String type) {\n        return switch (type.toLowerCase()) {\n            case \"circle\" -> new Circle();\n            case \"rectangle\" -> new Rectangle();\n            case \"triangle\" -> new Triangle();\n            default -> throw new IllegalArgumentException(\"Unknown shape\");\n        };\n    }\n}\n\n// Usage\nShape shape = ShapeFactory.createShape(\"circle\");\n\n// Real-world examples\nInteger.valueOf(10);  // Factory method\nOptional.of(value);   // Factory method\nCollections.singletonList(item);  // Factory method\n\n// 2. Factory Method Pattern\ninterface Shape {\n    void draw();\n}\n\nclass Circle implements Shape {\n    public void draw() { System.out.println(\"Circle\"); }\n}\n\nclass Rectangle implements Shape {\n    public void draw() { System.out.println(\"Rectangle\"); }\n}\n\n// Creator\nabstract class ShapeCreator {\n    // Factory method\n    abstract Shape createShape();\n    \n    public void renderShape() {\n        Shape shape = createShape();  // Subclass decides\n        shape.draw();\n    }\n}\n\n// Concrete creators\nclass CircleCreator extends ShapeCreator {\n    @Override\n    Shape createShape() {\n        return new Circle();\n    }\n}\n\nclass RectangleCreator extends ShapeCreator {\n    @Override\n    Shape createShape() {\n        return new Rectangle();\n    }\n}\n\n// Usage\nShapeCreator creator = new CircleCreator();\ncreator.renderShape();  // Draws circle\n\n// 3. Abstract Factory Pattern\ninterface GUIFactory {\n    Button createButton();\n    TextField createTextField();\n}\n\nclass WindowsFactory implements GUIFactory {\n    public Button createButton() { return new WindowsButton(); }\n    public TextField createTextField() { return new WindowsTextField(); }\n}\n\nclass MacFactory implements GUIFactory {\n    public Button createButton() { return new MacButton(); }\n    public TextField createTextField() { return new MacTextField(); }\n}\n\n// Usage\nGUIFactory factory = new WindowsFactory();\nButton button = factory.createButton();  // Windows button\nTextField textField = factory.createTextField();  // Windows text field"
    },
    {
      "id": 92,
      "question": "What is the Observer pattern in Java?",
      "answer": "Observer pattern defines one-to-many dependency where when one object changes state, all dependents are notified automatically.\n\nComponents:\n\nSubject:\n• Maintains list of observers\n• Notifies observers of state changes\n• attach(), detach(), notify()\n\nObserver:\n• Gets notified of changes\n• update() method\n\nUse cases:\n• Event handling\n• MVC pattern\n• Pub-Sub systems\n• GUI frameworks\n\nJava support:\n• Observable class (deprecated in Java 9)\n• PropertyChangeListener\n• Modern: Use interfaces, not Observable class",
      "explanation": "Observer pattern is fundamental for event-driven programming. Observable/Observer classes are deprecated - use custom implementation or frameworks. Core of many GUI frameworks and reactive programming.",
      "difficulty": "Medium",
      "code": "// Modern Observer pattern implementation\n\n// Observer interface\ninterface Observer {\n    void update(String message);\n}\n\n// Subject interface\ninterface Subject {\n    void attach(Observer observer);\n    void detach(Observer observer);\n    void notifyObservers();\n}\n\n// Concrete Subject\nclass NewsAgency implements Subject {\n    private List<Observer> observers = new ArrayList<>();\n    private String news;\n    \n    @Override\n    public void attach(Observer observer) {\n        observers.add(observer);\n    }\n    \n    @Override\n    public void detach(Observer observer) {\n        observers.remove(observer);\n    }\n    \n    @Override\n    public void notifyObservers() {\n        for (Observer observer : observers) {\n            observer.update(news);\n        }\n    }\n    \n    public void setNews(String news) {\n        this.news = news;\n        notifyObservers();  // Notify all observers\n    }\n}\n\n// Concrete Observers\nclass NewsChannel implements Observer {\n    private String name;\n    \n    NewsChannel(String name) { this.name = name; }\n    \n    @Override\n    public void update(String news) {\n        System.out.println(name + \" received: \" + news);\n    }\n}\n\n// Usage\nNewsAgency agency = new NewsAgency();\nNewsChannel channel1 = new NewsChannel(\"BBC\");\nNewsChannel channel2 = new NewsChannel(\"CNN\");\n\nagency.attach(channel1);\nagency.attach(channel2);\n\nagency.setNews(\"Breaking news!\");  // Both channels notified\n\nagency.detach(channel1);\nagency.setNews(\"Another update\");  // Only CNN notified\n\n// Using Java PropertyChangeSupport (built-in)\nimport java.beans.*;\n\nclass NewsAgency2 {\n    private PropertyChangeSupport support = new PropertyChangeSupport(this);\n    private String news;\n    \n    public void addObserver(PropertyChangeListener listener) {\n        support.addPropertyChangeListener(listener);\n    }\n    \n    public void removeObserver(PropertyChangeListener listener) {\n        support.removePropertyChangeListener(listener);\n    }\n    \n    public void setNews(String news) {\n        String old = this.news;\n        this.news = news;\n        support.firePropertyChange(\"news\", old, news);\n    }\n}\n\n// Usage with PropertyChangeListener\nNewsAgency2 agency2 = new NewsAgency2();\nagency2.addObserver(evt -> {\n    System.out.println(\"News changed: \" + evt.getNewValue());\n});"
    },
    {
      "id": 93,
      "question": "What is the difference between composition and inheritance?",
      "answer": "Two ways to achieve code reuse:\n\nInheritance (IS-A):\n• Subclass extends superclass\n• White-box reuse (internals visible)\n• Compile-time relationship\n• Tight coupling\n• Can break encapsulation\n• Single inheritance in Java\n\nComposition (HAS-A):\n• Object contains other objects\n• Black-box reuse (internals hidden)\n• Runtime relationship\n• Loose coupling\n• Better encapsulation\n• More flexible\n\nPrinciple: \"Favor composition over inheritance\"\n\nWhen to use:\n• Inheritance: True IS-A relationship\n• Composition: HAS-A or implementation reuse",
      "explanation": "Favor composition over inheritance is a key design principle. Composition is more flexible - you can change behavior at runtime and aren't locked into inheritance hierarchy. Use inheritance only for true IS-A relationships.",
      "difficulty": "Medium",
      "code": "// Inheritance example (IS-A relationship)\nclass Vehicle {\n    void start() { System.out.println(\"Starting...\"); }\n    void stop() { System.out.println(\"Stopping...\"); }\n}\n\nclass Car extends Vehicle {  // Car IS-A Vehicle\n    void drive() { System.out.println(\"Driving...\"); }\n}\n\nCar car = new Car();\ncar.start();  // Inherited method\ncar.drive();  // Own method\n\n// Problem with inheritance\nclass Stack extends ArrayList {  // BAD! Stack is not a list!\n    // Now Stack has unnecessary methods like add(index, element)\n    // Breaks Stack semantics\n}\n\n// Composition example (HAS-A relationship)\nclass Engine {\n    void start() { System.out.println(\"Engine starting...\"); }\n    void stop() { System.out.println(\"Engine stopping...\"); }\n}\n\nclass Car2 {  // Car HAS-AN Engine\n    private Engine engine = new Engine();  // Composition\n    \n    void start() {\n        engine.start();  // Delegate to engine\n    }\n    \n    void stop() {\n        engine.stop();  // Delegate to engine\n    }\n    \n    void drive() {\n        System.out.println(\"Driving...\");\n    }\n}\n\nCar2 car2 = new Car2();\ncar2.start();  // Uses engine internally\n\n// Composition with interface (even better)\ninterface Engine {\n    void start();\n    void stop();\n}\n\nclass ElectricEngine implements Engine {\n    public void start() { System.out.println(\"Electric start\"); }\n    public void stop() { System.out.println(\"Electric stop\"); }\n}\n\nclass GasEngine implements Engine {\n    public void start() { System.out.println(\"Gas start\"); }\n    public void stop() { System.out.println(\"Gas stop\"); }\n}\n\nclass Car3 {\n    private Engine engine;  // Can switch implementation!\n    \n    Car3(Engine engine) {\n        this.engine = engine;  // Inject dependency\n    }\n    \n    void start() { engine.start(); }\n}\n\n// Can use different engines at runtime\nCar3 electricCar = new Car3(new ElectricEngine());\nCar3 gasCar = new Car3(new GasEngine());\n\n// Proper Stack using composition\nclass Stack<T> {\n    private List<T> elements = new ArrayList<>();  // Composition\n    \n    void push(T item) { elements.add(item); }\n    T pop() { return elements.remove(elements.size() - 1); }\n    // Only Stack operations exposed!\n}"
    },
    {
      "id": 94,
      "question": "What is the Strategy pattern in Java?",
      "answer": "Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable.\n\nComponents:\n\nStrategy interface:\n• Defines algorithm interface\n\nConcrete strategies:\n• Implement different algorithms\n\nContext:\n• Uses Strategy interface\n• Can switch strategies at runtime\n\nBenefits:\n• Eliminates conditional logic\n• Open/Closed principle\n• Runtime algorithm selection\n• Testable strategies\n\nUse when:\n• Multiple algorithms for same task\n• Need to switch algorithms dynamically\n• Avoid complex conditional logic",
      "explanation": "Strategy pattern eliminates if-else chains and switch statements for algorithm selection. Perfect for payment methods, sorting algorithms, validation rules. Makes code more maintainable and testable.",
      "difficulty": "Medium",
      "code": "// Without Strategy pattern (bad - many if-else)\nclass PaymentProcessor {\n    void processPayment(String type, double amount) {\n        if (type.equals(\"CREDIT_CARD\")) {\n            // Credit card logic\n        } else if (type.equals(\"PAYPAL\")) {\n            // PayPal logic\n        } else if (type.equals(\"BITCOIN\")) {\n            // Bitcoin logic\n        }\n        // Adding new payment method requires modifying this class!\n    }\n}\n\n// With Strategy pattern (good)\n\n// Strategy interface\ninterface PaymentStrategy {\n    void pay(double amount);\n}\n\n// Concrete strategies\nclass CreditCardPayment implements PaymentStrategy {\n    private String cardNumber;\n    \n    CreditCardPayment(String cardNumber) {\n        this.cardNumber = cardNumber;\n    }\n    \n    @Override\n    public void pay(double amount) {\n        System.out.println(\"Paid $\" + amount + \" with credit card\");\n    }\n}\n\nclass PayPalPayment implements PaymentStrategy {\n    private String email;\n    \n    PayPalPayment(String email) {\n        this.email = email;\n    }\n    \n    @Override\n    public void pay(double amount) {\n        System.out.println(\"Paid $\" + amount + \" via PayPal\");\n    }\n}\n\nclass BitcoinPayment implements PaymentStrategy {\n    private String walletAddress;\n    \n    BitcoinPayment(String walletAddress) {\n        this.walletAddress = walletAddress;\n    }\n    \n    @Override\n    public void pay(double amount) {\n        System.out.println(\"Paid $\" + amount + \" in Bitcoin\");\n    }\n}\n\n// Context\nclass ShoppingCart {\n    private PaymentStrategy paymentStrategy;\n    \n    void setPaymentStrategy(PaymentStrategy strategy) {\n        this.paymentStrategy = strategy;\n    }\n    \n    void checkout(double amount) {\n        paymentStrategy.pay(amount);  // Delegate to strategy\n    }\n}\n\n// Usage - switch strategies at runtime\nShoppingCart cart = new ShoppingCart();\n\ncart.setPaymentStrategy(new CreditCardPayment(\"1234-5678-9012-3456\"));\ncart.checkout(100.0);  // Pay with credit card\n\ncart.setPaymentStrategy(new PayPalPayment(\"user@example.com\"));\ncart.checkout(50.0);   // Pay with PayPal\n\n// Modern approach with lambdas\ninterface DiscountStrategy {\n    double applyDiscount(double price);\n}\n\nclass PriceCalculator {\n    double calculate(double price, DiscountStrategy strategy) {\n        return strategy.applyDiscount(price);\n    }\n}\n\n// Use lambdas as strategies\nPriceCalculator calc = new PriceCalculator();\ndouble price = 100.0;\n\ndouble regularPrice = calc.calculate(price, p -> p);  // No discount\ndouble tenPercent = calc.calculate(price, p -> p * 0.9);  // 10% off\ndouble twentyDollars = calc.calculate(price, p -> p - 20);  // $20 off"
    },
    {
      "id": 95,
      "question": "What is the difference between throw and throws?",
      "answer": "throw and throws are different keywords for exception handling:\n\nthrow:\n• Keyword to explicitly throw an exception\n• Used inside method body\n• Throws actual exception instance\n• Used with new Exception()\n• Execution stops at throw statement\n• Can throw only one exception at a time\n\nthrows:\n• Keyword in method signature\n• Declares that method might throw exceptions\n• Lets caller handle exception\n• Can declare multiple exceptions\n• Used for checked exceptions\n• Part of method contract",
      "explanation": "throw actually throws an exception object. throws declares that method may throw exceptions. throw is for action, throws is for declaration. Understanding this difference is crucial for exception handling design.",
      "difficulty": "Easy",
      "code": "// throws - declare in method signature\npublic void readFile(String path) throws IOException, FileNotFoundException {\n    // Method might throw these exceptions\n    // Caller must handle or declare\n}\n\n// throw - actually throw exception\npublic void validateAge(int age) {\n    if (age < 0) {\n        throw new IllegalArgumentException(\"Age cannot be negative\");  // Throw\n    }\n    if (age < 18) {\n        throw new IllegalArgumentException(\"Must be 18 or older\");  // Throw\n    }\n}\n\n// Using both together\npublic void processFile(String path) throws IOException {  // throws\n    File file = new File(path);\n    if (!file.exists()) {\n        throw new IOException(\"File not found: \" + path);  // throw\n    }\n    // Process file\n}\n\n// Catching thrown exceptions\ntry {\n    validateAge(-5);  // Will throw exception\n} catch (IllegalArgumentException e) {\n    System.out.println(\"Caught: \" + e.getMessage());\n}\n\n// Rethrowing exceptions\npublic void method() throws Exception {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        System.out.println(\"Logging error\");\n        throw e;  // Rethrow same exception\n    }\n}\n\n// Throwing new exception with cause\npublic void method() throws CustomException {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        throw new CustomException(\"Custom message\", e);  // Wrap original\n    }\n}\n\n// Custom exception\nclass InsufficientFundsException extends Exception {\n    public InsufficientFundsException(String message) {\n        super(message);\n    }\n}\n\npublic void withdraw(double amount) throws InsufficientFundsException {\n    if (balance < amount) {\n        throw new InsufficientFundsException(\"Insufficient balance\");\n    }\n    balance -= amount;\n}"
    },
    {
      "id": 96,
      "question": "What is the transient keyword in Java?",
      "answer": "transient is a keyword that prevents a field from being serialized.\n\nCharacteristics:\n• Field marked transient is not saved during serialization\n• Value becomes default after deserialization (null/0/false)\n• Only affects Serializable objects\n• Cannot be used with static fields (already not serialized)\n• Used for: Sensitive data, derived fields, caches\n\nUse cases:\n• Passwords and sensitive information\n• Temporary cached values\n• Derived/calculated fields\n• Objects that can't be serialized\n• Thread-specific data",
      "explanation": "transient is crucial for security and efficiency in serialization. Use it for passwords, temporary data, and values that can be recalculated. Remember: transient fields become null/0/false after deserialization - reinitialize in readObject() if needed.",
      "difficulty": "Easy",
      "code": "// Class with transient fields\nclass User implements Serializable {\n    private static final long serialVersionUID = 1L;\n    \n    private String username;           // Will be serialized\n    private transient String password; // NOT serialized (security!)\n    private transient int loginCount;  // NOT serialized (temporary)\n    private transient Cache cache;     // NOT serialized (derived)\n    \n    // After deserialization, call this to reinitialize transients\n    private void readObject(ObjectInputStream in) \n            throws IOException, ClassNotFoundException {\n        in.defaultReadObject();  // Deserialize non-transient fields\n        \n        // Reinitialize transient fields\n        this.loginCount = 0;\n        this.cache = new Cache();\n        // password remains null (as it should for security)\n    }\n}\n\n// Serialization example\nUser user = new User();\nuser.username = \"john\";\nuser.password = \"secret123\";  // Won't be saved\nuser.loginCount = 5;           // Won't be saved\n\n// Serialize\ntry (ObjectOutputStream out = new ObjectOutputStream(\n        new FileOutputStream(\"user.ser\"))) {\n    out.writeObject(user);\n}\n\n// Deserialize\ntry (ObjectInputStream in = new ObjectInputStream(\n        new FileInputStream(\"user.ser\"))) {\n    User loaded = (User) in.readObject();\n    \n    System.out.println(loaded.username);   // \"john\"\n    System.out.println(loaded.password);   // null (transient!)\n    System.out.println(loaded.loginCount); // 0 (transient!)\n}\n\n// Transient with computed fields\nclass Rectangle implements Serializable {\n    private double width;\n    private double height;\n    private transient double area;  // Computed, no need to serialize\n    \n    public double getArea() {\n        if (area == 0) {  // Lazy computation\n            area = width * height;\n        }\n        return area;\n    }\n    \n    private void readObject(ObjectInputStream in) \n            throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        // area will be recalculated on first getArea() call\n    }\n}\n\n// Note: static fields are never serialized (with or without transient)\nclass Example implements Serializable {\n    private static int staticField = 10;  // Never serialized\n    private transient static int field = 20;  // Redundant - already not serialized\n}"
    },
    {
      "id": 97,
      "question": "What is the native keyword in Java?",
      "answer": "native keyword indicates that a method is implemented in platform-specific code (usually C/C++) using JNI (Java Native Interface).\n\nCharacteristics:\n• Method has no body in Java\n• Implementation in native language\n• Loaded via System.loadLibrary()\n• Platform-dependent\n• Used for: Performance-critical code, OS-level operations, legacy code integration\n\nJNI (Java Native Interface):\n• Bridge between Java and native code\n• Allows calling C/C++ from Java\n• Allows calling Java from C/C++\n\nUse cases:\n• Hardware access\n• Performance-critical algorithms\n• Using existing C/C++ libraries\n• Platform-specific features",
      "explanation": "native methods break Java's platform independence but provide access to OS features and performance. Common in JDK internals (Object.hashCode(), System.currentTimeMillis()). Avoid unless absolutely necessary - JNI adds complexity and debugging difficulty.",
      "difficulty": "Hard",
      "code": "// Native method declaration\npublic class NativeExample {\n    // Load native library\n    static {\n        System.loadLibrary(\"nativelib\");  // Loads nativelib.dll or libnativelib.so\n    }\n    \n    // Native method declaration\n    public native void nativeMethod();       // No body\n    public native int add(int a, int b);\n    public static native long getSystemTime();\n    \n    public static void main(String[] args) {\n        NativeExample example = new NativeExample();\n        example.nativeMethod();\n        int result = example.add(5, 3);      // Calls C implementation\n    }\n}\n\n// Steps to use native methods:\n// 1. Declare native method in Java\n// 2. Compile Java class: javac NativeExample.java\n// 3. Generate C header: javac -h . NativeExample.java\n// 4. Implement method in C/C++:\n\n/* C Implementation (NativeExample.c)\n#include <jni.h>\n#include \"NativeExample.h\"\n\nJNIEXPORT void JNICALL\nJava_NativeExample_nativeMethod(JNIEnv *env, jobject obj) {\n    printf(\"Called from C!\\n\");\n}\n\nJNIEXPORT jint JNICALL\nJava_NativeExample_add(JNIEnv *env, jobject obj, jint a, jint b) {\n    return a + b;  // C implementation\n}\n*/\n\n// 5. Compile C code to shared library (.dll or .so)\n// 6. Run Java with library in path\n\n// Native methods in JDK\nclass Object {\n    public native int hashCode();     // Native in JDK\n    public final native Class<?> getClass();\n    public final native void notify();\n    public final native void notifyAll();\n    public final native void wait(long timeout);\n}\n\nclass System {\n    public static native long currentTimeMillis();  // Native\n    public static native void arraycopy(Object src, int srcPos,\n                                       Object dest, int destPos, int length);\n}\n\nclass Thread {\n    public static native void sleep(long millis);   // Native\n    public static native void yield();\n}\n\n// Security concerns\n// - Native code can crash JVM\n// - No memory safety\n// - Platform-dependent\n// - Harder to debug\n// - Security vulnerabilities\n\n// Modern alternatives\n// - Panama Project (Foreign Function & Memory API)\n// - JNA (Java Native Access) - easier than JNI\n// - Pure Java solutions when possible"
    },
    {
      "id": 98,
      "question": "What is the strictfp keyword in Java?",
      "answer": "strictfp (strict floating point) is a keyword that ensures consistent floating-point calculations across different platforms.\n\nCharacteristics:\n• Can be applied to class, interface, or method\n• Forces IEEE 754 standard for floating-point\n• Ensures consistent results on all JVMs\n• Restricts floating-point precision\n• Rarely used in practice\n\nWithout strictfp:\n• JVM may use extended precision on some platforms\n• Results might differ slightly across platforms\n\nWith strictfp:\n• All floating-point operations follow IEEE 754 strictly\n• Same results on all platforms\n• May be slower on some platforms\n\nNote: Less relevant in modern Java - floating-point behavior is more standardized",
      "explanation": "strictfp guarantees that floating-point computations produce identical results on all platforms. Rarely needed unless you require exact reproducibility of floating-point calculations across different CPUs. Most applications don't need it.",
      "difficulty": "Easy",
      "code": "// strictfp applied to class\nstrictfp class MathOperations {\n    // All methods use strict floating-point\n    double calculate(double x, double y) {\n        return x * y + x / y;  // Strict IEEE 754\n    }\n}\n\n// strictfp applied to method\nclass Calculator {\n    // Only this method uses strict floating-point\n    strictfp double preciseCalculation(double x, double y) {\n        return Math.sqrt(x * x + y * y);\n    }\n    \n    // This method may use extended precision\n    double normalCalculation(double x, double y) {\n        return x + y;\n    }\n}\n\n// strictfp applied to interface\nstrictfp interface MathInterface {\n    double calculate(double x, double y);\n}\n\n// Implementing class inherits strictfp\nclass MathImpl implements MathInterface {\n    // This is implicitly strictfp\n    public double calculate(double x, double y) {\n        return x * y;\n    }\n}\n\n// Why strictfp exists\n// Without strictfp:\n// Platform 1 (x86 with 80-bit FPU): uses 80-bit intermediate results\n// Platform 2 (ARM with 64-bit FPU): uses 64-bit intermediate results\n// Result: Slightly different final values!\n\n// With strictfp:\n// All platforms: forced to use 64-bit IEEE 754\n// Result: Identical values everywhere\n\n// Example showing potential difference (exaggerated)\ndouble withoutStrictfp() {\n    double x = 1.0;\n    for (int i = 0; i < 1000000; i++) {\n        x += 0.0000001;\n    }\n    return x;  // Might differ across platforms by tiny amount\n}\n\nstrictfp double withStrictfp() {\n    double x = 1.0;\n    for (int i = 0; i < 1000000; i++) {\n        x += 0.0000001;\n    }\n    return x;  // Guaranteed same across all platforms\n}\n\n// When to use strictfp:\n// - Scientific calculations requiring reproducibility\n// - Cryptography (rare)\n// - Compliance with specific standards\n// - Distributed computing with result verification\n\n// When NOT to use:\n// - Most business applications\n// - When performance matters more than exact reproducibility\n// - Modern Java on standard platforms (already consistent)"
    },
    {
      "id": 99,
      "question": "What is the assert keyword in Java?",
      "answer": "assert is a keyword for debugging, used to test assumptions during development.\n\nSyntax:\n• assert condition;\n• assert condition : message;\n\nBehavior:\n• Throws AssertionError if condition is false\n• Disabled by default in production\n• Enabled with -ea or -enableassertions flag\n\nUse cases:\n• Internal invariants\n• Preconditions (non-public methods)\n• Postconditions\n• Control flow invariants\n\nDon't use for:\n• Public method argument validation\n• Production logic\n• Side effects in assertions",
      "explanation": "Assertions are for development/testing - they're disabled in production by default. Use for internal checks, not public API validation. Never put code with side effects in assertions since they might be disabled.",
      "difficulty": "Easy",
      "code": "// Basic assertion\npublic void process(int value) {\n    assert value > 0;  // Throws AssertionError if false\n    // Process...\n}\n\n// Assertion with message\npublic void process(int value) {\n    assert value > 0 : \"Value must be positive, got: \" + value;\n    // Process...\n}\n\n// Enable assertions when running\n// java -ea MyProgram    // Enable all\n// java -ea:com.example... MyProgram  // Enable for package\n// java -da MyProgram    // Disable all\n\n// Use cases\n\n// 1. Internal invariants\nclass Stack<T> {\n    private int size = 0;\n    \n    void pop() {\n        assert size > 0 : \"Stack is empty\";  // Should never happen\n        size--;\n    }\n}\n\n// 2. Preconditions (private/internal methods)\nprivate void internalMethod(Object obj) {\n    assert obj != null;  // OK for private/internal\n    // Process...\n}\n\n// WRONG for public methods!\npublic void publicMethod(Object obj) {\n    // Don't use assert for public API validation!\n    // assert obj != null;  // BAD - disabled in production!\n    \n    // Use explicit check instead:\n    if (obj == null) {\n        throw new IllegalArgumentException(\"obj cannot be null\");\n    }\n}\n\n// 3. Postconditions\npublic int[] sort(int[] array) {\n    // Sort implementation...\n    assert isSorted(array) : \"Array not sorted correctly\";\n    return array;\n}\n\n// 4. Control flow invariants\nint x = getValue();\nif (x > 0) {\n    // handle positive\n} else if (x < 0) {\n    // handle negative\n} else {\n    assert x == 0;  // Should never reach here if x != 0\n}\n\n// Switch statement with unreachable default\nenum Color { RED, GREEN, BLUE }\n\nvoid processColor(Color color) {\n    switch (color) {\n        case RED: /* ... */ break;\n        case GREEN: /* ... */ break;\n        case BLUE: /* ... */ break;\n        default:\n            assert false : \"Unknown color: \" + color;\n    }\n}\n\n// WRONG: Side effects in assertions\nint count = 0;\nassert count++ > 0;  // BAD! count not incremented if assertions disabled!\n\n// RIGHT: No side effects\nint count = 0;\ncount++;\nassert count > 0;  // OK\n\n// Testing if assertions are enabled\nboolean assertionsEnabled = false;\nassert assertionsEnabled = true;  // Runs only if enabled\nif (assertionsEnabled) {\n    System.out.println(\"Assertions are ON\");\n} else {\n    System.out.println(\"Assertions are OFF\");\n}"
    },
    {
      "id": 100,
      "question": "What are Memory Leaks in Java and how to prevent them?",
      "answer": "Memory leak occurs when objects are no longer needed but cannot be garbage collected due to unintentional references.\n\nCommon causes:\n\n1. Static collections holding objects\n2. Unclosed resources\n3. Listeners not removed\n4. ThreadLocal not cleaned\n5. Inner classes holding outer reference\n6. Caches without eviction\n7. ClassLoader leaks\n\nPrevention:\n• Use try-with-resources\n• Remove listeners when done\n• Clear ThreadLocal\n• Use WeakReference for caches\n• Use static nested class instead of inner\n• Monitor heap with profilers\n• Regular code reviews",
      "explanation": "Java has GC but memory leaks still happen - objects can't be collected if still referenced. Most common: collections that keep growing, unclosed resources, and listeners. Use memory profilers (VisualVM, MAT) to detect leaks.",
      "difficulty": "Hard",
      "code": "// 1. Static collection leak\nclass UserService {\n    private static List<User> users = new ArrayList<>();  // Never cleared!\n    \n    void addUser(User user) {\n        users.add(user);  // Keeps growing, never removed\n    }\n    // Solution: Clear when appropriate or use WeakHashMap\n}\n\n// 2. Unclosed resources leak\nvoid badMethod() {\n    Connection conn = getConnection();\n    // Process...\n    // conn never closed - leak!\n}\n\nvoid goodMethod() {\n    try (Connection conn = getConnection()) {  // Auto-closed\n        // Process...\n    }\n}\n\n// 3. Listener leak\nclass UI {\n    void addComponent(Component comp) {\n        comp.addListener(event -> handleEvent(event));\n        // Listener keeps component alive even after UI destroyed!\n    }\n    \n    // Solution: Remove listener\n    void removeComponent(Component comp) {\n        comp.removeListener(listener);\n    }\n}\n\n// 4. ThreadLocal leak\nclass RequestContext {\n    private static ThreadLocal<User> currentUser = new ThreadLocal<>();\n    \n    void setUser(User user) {\n        currentUser.set(user);  // Thread in pool keeps reference!\n    }\n    \n    // Solution: Always clear in finally\n    void processRequest() {\n        try {\n            setUser(getUser());\n            // Process...\n        } finally {\n            currentUser.remove();  // MUST clear!\n        }\n    }\n}\n\n// 5. Inner class leak\nclass Outer {\n    private byte[] data = new byte[1000000];  // Large data\n    \n    class Inner {  // Non-static inner class\n        void doSomething() { }\n        // Holds reference to Outer (including large data)!\n    }\n    \n    // Solution: Use static nested class\n    static class StaticNested {\n        void doSomething() { }\n        // No reference to Outer\n    }\n}\n\n// 6. Cache leak\nclass Cache {\n    private Map<String, Object> cache = new HashMap<>();  // Unbounded!\n    \n    void put(String key, Object value) {\n        cache.put(key, value);  // Grows indefinitely\n    }\n}\n\n// Solution 1: Use WeakHashMap\nclass Cache {\n    private Map<String, Object> cache = new WeakHashMap<>();  // Auto-evicts\n}\n\n// Solution 2: Use cache library with eviction\nCache<String, Object> cache = CacheBuilder.newBuilder()\n    .maximumSize(1000)\n    .expireAfterWrite(10, TimeUnit.MINUTES)\n    .build();\n\n// 7. Custom collection leak\nclass MyStack {\n    private Object[] elements;\n    private int size = 0;\n    \n    public Object pop() {\n        if (size == 0) throw new EmptyStackException();\n        return elements[--size];  // Leak! Still referenced in array\n    }\n    \n    // Solution: Clear reference\n    public Object pop() {\n        if (size == 0) throw new EmptyStackException();\n        Object result = elements[--size];\n        elements[size] = null;  // Clear reference\n        return result;\n    }\n}\n\n// Detection tools\n// - jmap: Heap dump\n// - jhat: Analyze heap dump\n// - VisualVM: Profile memory\n// - Eclipse MAT: Memory Analyzer\n// - YourKit, JProfiler: Commercial profilers"
    },
    {
      "id": 101,
      "question": "What is Java?",
      "answer": "Java is a high-level, class-based, object-oriented programming language designed to have as few implementation dependencies as possible.\n\nKey facts:\n• Created by James Gosling at Sun Microsystems (1995)\n• Currently owned by Oracle Corporation\n• Write Once, Run Anywhere (WORA) principle\n• Compiled to bytecode, then interpreted/JIT-compiled by JVM\n• Strongly typed, statically typed language\n\nJava is used for:\n• Enterprise web applications (Spring, Jakarta EE)\n• Android mobile development\n• Desktop applications\n• Big Data processing (Hadoop, Spark)\n• Embedded systems and IoT",
      "explanation": "Java's WORA principle means code compiled once runs on any platform with a JVM - Windows, Linux, Mac, etc. Its managed memory (garbage collection) and strong type system make it reliable for large enterprise systems. Java is consistently in the top 3 most popular programming languages globally.",
      "difficulty": "Easy",
      "code": "// Hello World - the classic Java program\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}\n\n// Compilation and execution steps:\n// 1. javac HelloWorld.java  →  produces HelloWorld.class (bytecode)\n// 2. java HelloWorld        →  JVM interprets/runs the bytecode\n\n// Java version check\n// java -version   (shows runtime version)\n// javac -version  (shows compiler version)"
    },
    {
      "id": 102,
      "question": "What are the characteristics of Java?",
      "answer": "Java has 12 defining characteristics as described by James Gosling:\n\n1. Simple: Familiar C/C++ syntax, no pointers, no manual memory management\n\n2. Object-Oriented: Everything is an object (except primitives). Encapsulation, inheritance, polymorphism, abstraction\n\n3. Platform Independent (WORA): Bytecode runs on any JVM regardless of OS\n\n4. Secured: No explicit pointers, JVM sandbox, bytecode verification before execution\n\n5. Robust: Strong type checking, exception handling, garbage collection, no pointer arithmetic\n\n6. Architecture Neutral: Bytecode format is independent of CPU architecture\n\n7. Portable: Primitive data types have fixed sizes (int is always 32-bit on all platforms)\n\n8. High Performance: JIT compilation converts hot bytecode paths to native machine code\n\n9. Distributed: Built-in networking via java.net (RMI, sockets, HTTP)\n\n10. Multi-threaded: Built-in support for concurrent execution via Thread class and java.util.concurrent\n\n11. Dynamic: Classes loaded dynamically at runtime via ClassLoader; supports reflection\n\n12. Interpreted: Bytecode is interpreted by JVM (also JIT compiled for performance)",
      "explanation": "The most important characteristics for interviews: platform independence (WORA through JVM), object-oriented (4 OOP pillars), robust (GC + exceptions + type safety), and multi-threaded (built-in concurrency). Platform independence is achieved because JVM is platform-specific but bytecode is platform-neutral.",
      "difficulty": "Easy",
      "code": "// 1. Platform Independence\n// Same .class file runs on Windows, Linux, Mac - any OS with a JVM\n\n// 2. Strong typing (Robust)\nint x = 10;\n// x = \"hello\"; // Compile error - Java prevents type mismatches\n\n// 3. Multi-threading built-in\nThread t = new Thread(() -> System.out.println(\"Running in thread\"));\nt.start();\n\n// 4. Automatic memory management (Robust)\nString s = new String(\"hello\"); // GC handles cleanup automatically\n// No manual delete/free needed\n\n// 5. Exception handling (Robust)\ntry {\n    int result = 10 / 0;\n} catch (ArithmeticException e) {\n    System.out.println(\"Caught: \" + e.getMessage());\n}\n\n// 6. Fixed primitive sizes (Portable - same on ALL platforms)\nSystem.out.println(Integer.SIZE);  // Always 32 bits\nSystem.out.println(Long.SIZE);     // Always 64 bits\nSystem.out.println(Double.SIZE);   // Always 64 bits"
    },
    {
      "id": 103,
      "question": "What is JVM?",
      "answer": "JVM (Java Virtual Machine) is an abstract/virtual computing machine that provides the runtime environment to execute Java bytecode.\n\nKey responsibilities:\n• Loads .class files (bytecode) via ClassLoader\n• Verifies bytecode for security and correctness\n• Executes bytecode (interprets and/or JIT compiles)\n• Manages memory (heap allocation, garbage collection)\n• Provides runtime data areas (heap, stack, method area)\n• Handles exceptions and threading\n\nJVM Architecture:\n1. Class Loader Subsystem: Bootstrap, Extension, Application classloaders\n2. Runtime Data Areas:\n   - Method Area: Class metadata, static variables, method bytecode\n   - Heap: Object allocation (shared across threads)\n   - Stack: Per-thread, stores frames (local variables, operand stack)\n   - PC Register: Current instruction pointer (per thread)\n   - Native Method Stack: For JNI native method calls\n3. Execution Engine: Interpreter + JIT Compiler + Garbage Collector\n4. Native Interface (JNI): Bridge to native C/C++ libraries\n\nJVM is platform-DEPENDENT (different for each OS), which is what makes Java platform-INDEPENDENT.",
      "explanation": "The JVM is the magic behind Java's WORA. Same bytecode (.class) runs on any JVM regardless of OS/hardware. The JVM is platform-specific (Windows JVM vs Linux JVM) but they all understand the same bytecode format. Other languages also target JVM: Kotlin, Scala, Groovy, Clojure.",
      "difficulty": "Easy",
      "code": "// JVM Memory Areas in action\n\n// HEAP - shared memory, holds all objects\nString s = new String(\"hello\"); // Allocated on heap\nint[] arr = new int[100];        // Also on heap\n\n// STACK - per-thread, holds method call frames\npublic static int add(int a, int b) {\n    int result = a + b; // a, b, result are in stack frame\n    return result;      // frame popped on return\n}\n\n// METHOD AREA (Metaspace in Java 8+)\n// Holds class definitions, static fields, method bytecode\nclass MyClass {\n    static int counter = 0; // Stored in Method Area\n}\n\n// JVM tuning flags\n// java -Xms256m        - initial heap size\n// java -Xmx1g          - max heap size  \n// java -Xss512k        - stack size per thread\n// java -XX:+UseG1GC    - use G1 garbage collector\n// java -verbose:gc     - print GC logs\n\n// JVM monitoring tools\n// jps       - list running JVM processes\n// jmap      - heap dump and memory map\n// jstack    - thread dump\n// jstat     - GC statistics\n// jconsole  - GUI monitoring"
    },
    {
      "id": 104,
      "question": "What is JRE?",
      "answer": "JRE (Java Runtime Environment) is the minimum package required to run (not develop) Java applications.\n\nJRE contains:\n• JVM (Java Virtual Machine)\n• Core Java class libraries:\n  - java.lang (String, Object, Math, Thread, System...)\n  - java.util (Collections, Date, Scanner, Random...)\n  - java.io (File, Stream, Reader, Writer...)\n  - java.net (Socket, URL, HttpURLConnection...)\n  - java.sql (Connection, Statement, ResultSet...)\n  - And many more standard libraries\n• Supporting configuration files and property files\n\nJRE does NOT contain:\n• javac (Java compiler)\n• javadoc (documentation generator)\n• jdb (debugger)\n• Other development tools\n\nJRE use cases:\n• End users running Java applications\n• Production deployment servers\n• When compilation is not needed\n\nNote: Since Java 11, Oracle discontinued separate JRE downloads. Use JDK for all purposes or create a custom minimal runtime with 'jlink'.",
      "explanation": "Think of JRE as the 'player' and JDK as the 'player + development studio'. JRE = JVM + standard libraries. If a user needs to run a Java desktop game, they install JRE. Since Java 11, Oracle recommends using JDK everywhere. With 'jlink' (Java 9+) you can create a custom minimal JRE with only the modules your application needs.",
      "difficulty": "Easy",
      "code": "// Libraries included in JRE (available at runtime)\nimport java.lang.String;\nimport java.lang.Math;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.io.File;\nimport java.net.URL;\nimport java.sql.Connection;\n\n// Running a Java application (only needs JRE)\n// java HelloWorld\n// java -jar myapp.jar\n\n// Custom minimal runtime with jlink (Java 9+)\n// jlink \\\n//   --module-path $JAVA_HOME/jmods \\\n//   --add-modules java.base,java.sql,java.net.http \\\n//   --compress=2 \\\n//   --output ./my-custom-jre\n// Result: A minimal JRE with only what your app needs\n// Useful for Docker images - reduces image size significantly\n\n// Check JRE version\n// java -version\n// Output example:\n// openjdk version \"17.0.1\" 2021-10-19\n// OpenJDK Runtime Environment (build 17.0.1+12)\n// OpenJDK 64-Bit Server VM (build 17.0.1+12, mixed mode)"
    },
    {
      "id": 105,
      "question": "What is JDK?",
      "answer": "JDK (Java Development Kit) is the full software development environment for developing Java applications, containing everything needed to write, compile, debug, and run Java programs.\n\nJDK contains:\n• JRE (JVM + runtime libraries)\n• javac - Java compiler (source → bytecode)\n• java - Java application launcher\n• javap - Class file disassembler (view bytecode)\n• javadoc - API documentation generator\n• jdb - Java debugger\n• jar - JAR/archive tool\n• jshell - Interactive REPL (Java 9+)\n• jlink - Custom runtime creator (Java 9+)\n• jpackage - Native installer creator (Java 14+)\n• jmap, jstack, jstat, jconsole - profiling/monitoring tools\n\nJDK distributions (all based on OpenJDK):\n• Oracle JDK - commercial use requires license\n• OpenJDK - free and open source\n• Amazon Corretto - free, long-term support\n• Eclipse Temurin (Adoptium) - community-driven, free\n• GraalVM - polyglot VM with AOT compilation\n• Microsoft OpenJDK - free, Azure optimized\n\nRelationship: JDK ⊇ JRE ⊇ JVM",
      "explanation": "JDK is the developer's toolkit. The hierarchy is: JVM (executes code) ⊂ JRE (runs programs) ⊂ JDK (develops + runs programs). Always install JDK for development. OpenJDK is the free, open-source reference implementation. For production, any certified OpenJDK distribution works perfectly.",
      "difficulty": "Easy",
      "code": "// Full development workflow using JDK tools\n\n// 1. Write: Hello.java\npublic class Hello {\n    /**\n     * Main entry point\n     * @param args command line arguments\n     */\n    public static void main(String[] args) {\n        System.out.println(\"Hello, \" + args[0] + \"!\");\n    }\n}\n\n// 2. Compile with javac\n// javac Hello.java           → produces Hello.class\n// javac -d out Hello.java    → output to 'out' directory\n\n// 3. Run with java\n// java Hello World           → prints: Hello, World!\n// java -cp out Hello World   → with classpath\n\n// 4. Package with jar\n// jar cf hello.jar Hello.class\n// jar cfe hello.jar Hello Hello.class  (with Main-Class)\n// java -jar hello.jar World\n\n// 5. Generate docs with javadoc\n// javadoc -d docs Hello.java\n\n// 6. Inspect bytecode with javap\n// javap Hello.class          → shows public API\n// javap -c Hello.class       → shows bytecode instructions\n\n// 7. Interactive shell with jshell (Java 9+)\n// $ jshell\n// jshell> var x = 42\n// jshell> System.out.println(x * 2)  // prints 84\n\n// Check versions\n// javac -version  →  javac 17.0.1\n// java -version   →  java version \"17.0.1\""
    },
    {
      "id": 106,
      "question": "What is Java bytecode?",
      "answer": "Java bytecode is the intermediate representation of a Java program — the compiled output of the Java compiler (javac). It is NOT native machine code; it is a set of instructions designed for the JVM.\n\nCharacteristics:\n• Stored in .class files\n• Platform-independent (same bytecode runs on any JVM)\n• Instructions are 1-byte opcode + optional operands (hence 'bytecode')\n• JVM interprets or JIT-compiles bytecode to native machine code at runtime\n\nCompilation flow:\n  .java source  →[javac]→  .class bytecode  →[JVM]→  native machine code\n\nWhy bytecode matters:\n• Enables platform independence (WORA)\n• Bytecode verifier checks it for security before execution\n• JIT optimizer can profile and optimize hot paths at runtime\n\nCommon bytecode instructions:\n• iload, istore — load/store int variables\n• iadd, isub, imul — integer arithmetic\n• invokevirtual, invokestatic — method calls\n• new, newarray — object/array creation\n• goto, ifeq, ifnull — control flow",
      "explanation": "Bytecode is the secret behind Java's WORA. javac compiles source to platform-neutral bytecode; each platform's JVM then translates it to native code. You can inspect bytecode with 'javap -c ClassName'. The JIT compiler identifies frequently-executed bytecode ('hot paths') and compiles them to native code for maximum performance.",
      "difficulty": "Easy",
      "code": "// Source: Calculator.java\npublic class Calculator {\n    public int add(int a, int b) {\n        return a + b;\n    }\n}\n\n// Step 1 - Compile\n// javac Calculator.java  →  Calculator.class\n\n// Step 2 - Inspect bytecode: javap -c Calculator\n// public int add(int, int);\n//   Code:\n//      0: iload_1   // push 'a' onto operand stack\n//      1: iload_2   // push 'b' onto operand stack\n//      2: iadd      // pop two ints, add, push result\n//      3: ireturn   // return top int\n\n// Same .class runs unchanged on all platforms:\n// java Calculator   (Windows)\n// java Calculator   (Linux)   ← same bytecode!\n// java Calculator   (Mac)     ← same bytecode!\n\n// Other JVM languages also produce bytecode:\n// Kotlin, Scala, Groovy → .class files → same JVM"
    },
    {
      "id": 107,
      "question": "What is the difference between PATH and CLASSPATH?",
      "answer": "PATH and CLASSPATH are both environment variables but serve entirely different purposes:\n\nPATH (OS-level variable):\n• Tells the operating system where to find executable programs\n• Used by the shell/terminal to locate commands like java, javac, jar\n• Example: C:\\Program Files\\Java\\jdk-17\\bin\n• Without correct PATH: 'java' is not recognized as a command\n\nCLASSPATH (Java-level variable):\n• Tells the JVM and compiler where to find compiled .class files and JAR libraries\n• Used by both java (runtime) and javac (compiler)\n• Can include: directories, JAR files, ZIP files\n• Default classpath is the current directory (.)\n• Without correct CLASSPATH: ClassNotFoundException at runtime\n\nKey distinction:\n• PATH = tells the OS where Java tools (executables) live\n• CLASSPATH = tells Java tools where your code and libraries live",
      "explanation": "PATH lets you type 'java' anywhere in the terminal and have it work. CLASSPATH tells the JVM where to find your .class files and dependencies. In modern development, Maven and Gradle manage classpath automatically, so you rarely set CLASSPATH manually. IDEs like IntelliJ and Eclipse also handle it automatically.",
      "difficulty": "Easy",
      "code": "// --- PATH setup ---\n// Windows\n// set PATH=%PATH%;C:\\Program Files\\Java\\jdk-17\\bin\n//\n// Linux/Mac (~/.bashrc or ~/.zshrc)\n// export PATH=$PATH:/usr/lib/jvm/java-17/bin\n\n// Without PATH → error:\n// 'javac' is not recognized as an internal or external command\n\n// --- CLASSPATH setup ---\n// Windows\n// set CLASSPATH=.;C:\\myapp\\classes;C:\\myapp\\lib\\mylib.jar\n//\n// Linux/Mac\n// export CLASSPATH=.:/myapp/classes:/myapp/lib/mylib.jar\n\n// Preferred: use -cp flag (overrides CLASSPATH env variable)\n// javac -cp lib/mylib.jar MyApp.java\n// java  -cp .:lib/mylib.jar:classes MyApp   (Linux/Mac)\n// java  -cp .;lib/mylib.jar;classes MyApp   (Windows)\n\n// Maven handles classpath automatically:\n// mvn compile          → resolves all dependencies\n// mvn exec:java -Dexec.mainClass=com.example.Main"
    },
    {
      "id": 108,
      "question": "What is the difference between sourcepath and classpath?",
      "answer": "Both are used with javac but point to different types of files:\n\nCLASSPATH:\n• Points to directories and JARs containing compiled .class files\n• Used by both javac (compiler) and java (runtime)\n• For pre-compiled libraries and dependencies\n• javac uses it to resolve already-compiled types\n• java uses it to load classes at runtime\n\nSOURCEPATH:\n• Points to directories containing .java source files\n• Used only by javac — not by java at runtime\n• Tells javac where to find source files of dependent classes\n• If a required source file is found and not yet compiled, javac compiles it automatically\n• Rarely set manually — build tools handle it\n\nKey difference:\n• CLASSPATH → finds compiled .class / JAR files\n• SOURCEPATH → finds uncompiled .java source files\n\nPriority: javac prefers CLASSPATH (compiled) over SOURCEPATH (source)",
      "explanation": "CLASSPATH is for already-compiled code; SOURCEPATH is for source files the compiler should find and compile on the fly. In practice, Maven and Gradle manage both transparently. SOURCEPATH is most useful in projects where you want the compiler to auto-compile dependencies from source rather than pre-built JARs.",
      "difficulty": "Easy",
      "code": "// Project layout:\n// src/com/example/Main.java    (uses Helper)\n// src/com/example/Helper.java  (dependency)\n// lib/external.jar             (pre-compiled library)\n// classes/                     (output directory)\n\n// Using -classpath for pre-compiled deps\n// javac -cp lib/external.jar -d classes src/com/example/Main.java\n\n// Using -sourcepath for source deps\n// javac -sourcepath src -d classes src/com/example/Main.java\n// javac auto-finds and compiles Helper.java from src/\n\n// Using both together\n// javac \\\n//   -cp lib/external.jar \\\n//   -sourcepath src \\\n//   -d classes \\\n//   src/com/example/Main.java\n//\n// Result:\n//   external.jar resolved via classpath\n//   Helper.java found and compiled via sourcepath\n//   All .class files written to classes/\n\n// Maven equivalents (automatic):\n// classpath  → target/classes + ~/.m2/repository/**/*.jar\n// sourcepath → src/main/java"
    },
    {
      "id": 109,
      "question": "What are the different memory areas allocated by the JVM?",
      "answer": "The JVM allocates five distinct runtime data areas:\n\n1. Method Area (Metaspace in Java 8+):\n• Shared across all threads\n• Stores: class structures, method bytecode, constant pool, static variables, field metadata\n• Java 8+: stored in native memory (not heap), called Metaspace\n\n2. Heap:\n• Shared across all threads\n• Stores all Java objects and arrays\n• Where garbage collection happens\n• Divided into: Young Generation (Eden + S0 + S1) and Old Generation\n• Configured with -Xms (initial) and -Xmx (max)\n\n3. JVM Stack (per thread):\n• Each thread has its own private stack\n• Stores stack frames for each method call\n• Each frame holds: local variables, operand stack, frame data\n• StackOverflowError if recursion is too deep\n• Configured with -Xss\n\n4. PC Register (per thread):\n• Holds the address of the currently executing JVM instruction\n• Undefined for native methods\n\n5. Native Method Stack (per thread):\n• Supports execution of native (JNI) methods written in C/C++\n• Works like JVM Stack but for native code",
      "explanation": "Key for interviews: HEAP (objects live here, GC runs here), STACK (method calls + local variables, private per thread), METASPACE (class metadata). Heap is shared → thread-safety issues arise. Stack is private per thread → local variables are inherently thread-safe. Common errors: OutOfMemoryError: Java heap space (heap full), StackOverflowError (too-deep recursion), OutOfMemoryError: Metaspace (too many loaded classes).",
      "difficulty": "Medium",
      "code": "public class MemoryDemo {\n\n    // Static field → Method Area / Metaspace\n    static int staticCounter = 0;\n\n    // Instance field → Heap (part of the object)\n    int instanceValue;\n\n    void methodA() {\n        int local = 10;                 // local var → Stack frame\n        MemoryDemo obj = new MemoryDemo(); // object → Heap, ref → Stack\n        methodB();                      // new frame pushed\n    }                                   // methodA frame popped\n\n    void methodB() {\n        int x = 5;                      // Stack frame of methodB\n    }                                   // frame popped on return\n\n    void infinite() {\n        infinite(); // StackOverflowError — stack exhausted\n    }\n\n    void heapOOM() {\n        List<byte[]> list = new ArrayList<>();\n        while (true) list.add(new byte[1024 * 1024]); // OutOfMemoryError\n    }\n}\n\n// Tuning flags:\n// -Xms512m                  initial heap size\n// -Xmx2g                    max heap size\n// -Xss1m                    stack size per thread\n// -XX:MetaspaceSize=128m    initial metaspace size\n// -XX:MaxMetaspaceSize=256m cap metaspace"
    },
    {
      "id": 110,
      "question": "What is the difference between PermGen and Metaspace?",
      "answer": "Both store class metadata, but they differ in location and behaviour:\n\nPermGen (Permanent Generation) — Java 7 and earlier:\n• Part of the JVM heap — fixed maximum size\n• Default max ~64–128 MB depending on platform\n• Must be tuned manually: -XX:MaxPermSize=256m\n• Throws java.lang.OutOfMemoryError: PermGen space when full\n• Stored: class metadata, interned strings (Java 6), static variables\n\nMetaspace — Java 8+ (replaces PermGen):\n• Stored in native OS memory (off-heap) — NOT in JVM heap\n• Grows dynamically by default — no fixed upper limit\n• Optional cap: -XX:MaxMetaspaceSize=512m\n• Only throws OutOfMemoryError: Metaspace if MaxMetaspaceSize is set and exhausted\n• Static variables and String pool moved to heap\n\nWhy Metaspace is better:\n• Eliminates the notorious PermGen OOM error\n• Better handles dynamic class loading (app servers, hot-reload)\n• Native memory is more elastic than fixed heap regions",
      "explanation": "PermGen's fixed size caused frequent OOM errors in applications loading thousands of classes (Tomcat with many WARs, OSGi bundles). Metaspace uses native memory and auto-resizes, essentially solving that problem. The flags -XX:PermSize and -XX:MaxPermSize are silently ignored in Java 8+. If you see 'PermGen space' errors you are running Java 6 or 7.",
      "difficulty": "Medium",
      "code": "// Java 7 and earlier — PermGen tuning\n// -XX:PermSize=64m       initial size\n// -XX:MaxPermSize=256m   max size\n//\n// Classic error on Tomcat with many apps:\n// java.lang.OutOfMemoryError: PermGen space\n\n// Java 8+ — Metaspace (no tuning needed for most apps)\n// Default: unlimited (grows as native memory allows)\n//\n// Optional cap:\n// -XX:MetaspaceSize=128m      GC triggered when this threshold hit\n// -XX:MaxMetaspaceSize=512m   hard limit (default: unlimited)\n\n// Java 8 changes summary:\n// PermGen → Metaspace  (native memory, auto-sizing)\n// String pool  → Heap  (moved in Java 7)\n// Static fields → Heap (moved in Java 8)\n\n// Monitor Metaspace usage:\n// jstat -gcmetacapacity <pid>\n// jcmd  <pid> VM.native_memory\n\n// OutOfMemoryError: Metaspace — solutions:\n// 1. Set higher limit: -XX:MaxMetaspaceSize=512m\n// 2. Check for classloader leaks (CGLIB, dynamic proxies, frameworks)\n// 3. Profile with VisualVM or Eclipse MAT"
    },
    {
      "id": 111,
      "question": "What is garbage collection in Java?",
      "answer": "Garbage Collection (GC) is Java's automatic memory management process that identifies and removes objects that are no longer reachable, freeing heap memory.\n\nHow it works (Mark-Sweep-Compact):\n1. Mark: Starting from GC roots (stack refs, static fields, JNI refs), traverse the object graph and mark all reachable objects\n2. Sweep: Remove all unmarked (unreachable) objects and reclaim memory\n3. Compact (optional): Defragment the heap by moving live objects together\n\nGenerational GC (default approach):\n• Young Generation (Eden + S0 + S1): New objects allocated here. Minor GC runs frequently and fast\n• Old Generation (Tenured): Long-lived objects promoted here. Major/Full GC runs less often but is slower\n• Metaspace: Class metadata (not collected by normal GC)\n\nGC algorithms in Java:\n• Serial GC: Single-threaded, for small apps (-XX:+UseSerialGC)\n• Parallel GC: Multi-threaded throughput GC (-XX:+UseParallelGC)\n• G1 GC (default Java 9+): Balanced latency/throughput (-XX:+UseG1GC)\n• ZGC / Shenandoah: Ultra-low pause times (Java 11+)",
      "explanation": "GC eliminates manual memory management and prevents most memory leaks. You cannot force GC — System.gc() is only a hint. Understanding GC helps tune application performance: use -verbose:gc or GC logs to monitor. The most important concept: objects are eligible for GC when no live thread can reach them through any reference chain.",
      "difficulty": "Medium",
      "code": "// Objects become eligible for GC when unreachable\npublic void example() {\n    String s = new String(\"hello\"); // object created\n    s = null;                       // eligible for GC now\n    // No guarantee WHEN GC collects it\n}\n\n// GC roots - objects always considered reachable:\n// - Local variables on any thread's stack\n// - Static fields\n// - JNI references\n\n// System.gc() - just a suggestion, JVM may ignore it\nSystem.gc();  // Don't rely on this!\n\n// GC-friendly practices:\n// 1. Nullify references when done with large objects\nlarge = null;\n\n// 2. Use try-with-resources (auto-closes, helps GC)\ntry (InputStream is = new FileInputStream(\"file\")) {\n    // is closed and eligible for GC after this block\n}\n\n// 3. Avoid unnecessary object retention\n// BAD:\nstatic List<Object> cache = new ArrayList<>(); // Grows forever!\n// GOOD:\nstatic Map<Key, WeakReference<Object>> cache = new WeakHashMap<>();\n\n// JVM GC flags:\n// -XX:+UseG1GC           use G1 collector (default Java 9+)\n// -XX:+UseZGC            use ZGC (low latency, Java 15+)\n// -Xlog:gc               print GC logs\n// -XX:+PrintGCDetails    detailed GC output"
    },
    {
      "id": 112,
      "question": "What is JIT compilation in Java?",
      "answer": "JIT (Just-In-Time) compilation is the process where the JVM dynamically compiles frequently-executed bytecode ('hot methods') into native machine code at runtime, rather than interpreting each instruction every time.\n\nHow it works:\n1. JVM starts by interpreting bytecode (slow but immediate)\n2. The JIT compiler profiles execution and identifies 'hot' methods/loops\n3. Hot bytecode is compiled to optimized native machine code\n4. Subsequent calls execute the native code directly (much faster)\n\nJIT optimizations include:\n• Inlining: Replaces method calls with the method body\n• Dead code elimination: Removes code that never executes\n• Loop unrolling: Reduces loop overhead\n• Escape analysis: Allocates objects on stack instead of heap\n• Branch prediction optimization\n\nHotSpot JVM has two JIT compilers:\n• C1 (Client compiler): Fast compilation, fewer optimizations — good for startup\n• C2 (Server compiler): Slower compilation, aggressive optimizations — best throughput\n• Tiered compilation (default, Java 8+): Uses C1 first, then C2 for hottest methods",
      "explanation": "JIT is why Java performance is comparable to C++ for long-running applications. The JVM adapts at runtime based on actual usage patterns — it can even deoptimize and recompile when assumptions change (e.g., a new subclass is loaded). This is called 'adaptive optimization'. Warmup time is why benchmarks should run JVM code for a while before measuring.",
      "difficulty": "Medium",
      "code": "// JIT is transparent — you don't call it directly\n// But you can observe its effect:\n\npublic class JITDemo {\n    public static long sum(int n) {\n        long total = 0;\n        for (int i = 0; i < n; i++) total += i;\n        return total;\n    }\n\n    public static void main(String[] args) {\n        // First calls: interpreted (slower)\n        for (int i = 0; i < 1000; i++) sum(1000);\n\n        // After threshold (~10,000 calls): JIT kicks in\n        // Method compiled to native code\n        long start = System.nanoTime();\n        for (int i = 0; i < 1000000; i++) sum(1000); // much faster\n        System.out.println(System.nanoTime() - start + \" ns\");\n    }\n}\n\n// JIT-related JVM flags:\n// -Xint                   disable JIT (interpret only — very slow)\n// -XX:+PrintCompilation   print methods as they are JIT compiled\n// -XX:CompileThreshold=10000  calls before JIT compiles (default 10000)\n// -XX:+TieredCompilation  enable tiered compilation (default in Java 8+)\n\n// JIT inlining example (transparent to developer):\n// Before JIT:\n// result = Math.abs(x);   // method call overhead\n\n// After JIT inlining — JVM replaces with equivalent of:\n// result = x < 0 ? -x : x;  // no call overhead\n\n// This is why small accessor methods (getters/setters) are fast in Java"
    },
    {
      "id": 113,
      "question": "How do you configure Java heap space?",
      "answer": "Java heap space is configured using JVM command-line flags:\n\nKey flags:\n• -Xms<size>: Sets the initial (minimum) heap size\n• -Xmx<size>: Sets the maximum heap size\n• Size units: k/K (kilobytes), m/M (megabytes), g/G (gigabytes)\n\nBest practices:\n• Set -Xms equal to -Xmx in production to avoid heap resizing pauses\n• Max heap is typically 50–75% of available RAM\n• Leave memory for OS, JVM overhead, Metaspace, and off-heap usage\n• Too small → frequent GC, OutOfMemoryError\n• Too large → longer GC pause times\n\nGenerational heap flags:\n• -XX:NewSize=<size>: Initial Young Generation size\n• -XX:MaxNewSize=<size>: Max Young Generation size\n• -XX:NewRatio=<n>: Ratio of Old:Young (default 2 = Old is 2x Young)\n• -XX:SurvivorRatio=<n>: Eden:Survivor ratio within Young Gen\n\nDiagnosing heap issues:\n• OutOfMemoryError: Java heap space → increase -Xmx or fix memory leaks\n• Frequent GC → heap too small, or objects staying alive too long",
      "explanation": "Setting -Xms equal to -Xmx is the most common production recommendation — it prevents the JVM from wasting time growing the heap during execution. For microservices, keep heap small (256m-512m) to reduce GC pauses. For batch processing or large in-memory data, use larger heaps (4g-16g) with G1 or ZGC to manage pause times.",
      "difficulty": "Easy",
      "code": "// Basic heap configuration\n// java -Xms512m -Xmx2g MyApplication\n//   Initial heap: 512 MB\n//   Max heap:     2 GB\n\n// Production recommendation: set both equal\n// java -Xms2g -Xmx2g MyApp\n// Avoids heap resizing pauses during execution\n\n// Microservice (small footprint)\n// java -Xms128m -Xmx256m -jar myservice.jar\n\n// Large data processing\n// java -Xms8g -Xmx8g -XX:+UseG1GC -jar mybatch.jar\n\n// Young/Old generation tuning\n// java -Xms4g -Xmx4g \\\n//      -XX:NewSize=1g \\\n//      -XX:MaxNewSize=1g \\\n//      -XX:+UseG1GC MyApp\n\n// Check current heap usage at runtime\nRuntime rt = Runtime.getRuntime();\nlong maxHeap   = rt.maxMemory()  / (1024 * 1024); // bytes → MB\nlong totalHeap = rt.totalMemory()/ (1024 * 1024);\nlong usedHeap  = totalHeap - rt.freeMemory() / (1024 * 1024);\nSystem.out.println(\"Max: \" + maxHeap + \" MB\");\nSystem.out.println(\"Used: \" + usedHeap + \" MB\");\n\n// Spring Boot application.properties\n// (doesn't set heap — use JVM flags or JAVA_OPTS)\n// JAVA_OPTS=\"-Xms512m -Xmx1g\"\n// java $JAVA_OPTS -jar app.jar\n\n// Docker: set heap relative to container memory\n// java -XX:MaxRAMPercentage=75.0 -jar app.jar\n// Automatically uses 75% of container RAM (Java 10+)"
    },
    {
      "id": 114,
      "question": "How do you configure Java stack size?",
      "answer": "Java stack size (per-thread stack) is configured with the -Xss JVM flag:\n\n-Xss<size>: Sets the stack size for each thread\n• Units: k/K, m/M, g/G\n• Default: 512k–1m depending on OS and JVM version (64-bit JVM default is usually 512k or 1m)\n\nWhen to increase -Xss:\n• StackOverflowError from deep recursion\n• Code with many levels of nested method calls\n• Deeply recursive algorithms (parsers, tree traversal)\n\nWhen to decrease -Xss:\n• Applications creating thousands of threads\n• Lower memory per thread = more threads fit in RAM\n• Thread pools with many threads\n\nStack memory = thread count × stack size per thread\n• 1000 threads × 1m stack = 1 GB just for stacks!\n\nAlternatives to large stacks:\n• Rewrite recursion as iteration (use explicit stack/queue)\n• Use virtual threads (Java 21+) — much smaller stack, managed by JVM",
      "explanation": "Each Java thread gets its own stack. The default stack size (often 512k-1m) works for most code. StackOverflowError means either your recursion is too deep (fix the algorithm) or the stack is too small (increase -Xss). For applications spinning up thousands of threads, reducing -Xss saves significant memory. Java 21 virtual threads solve this problem fundamentally — they use a tiny initial stack.",
      "difficulty": "Easy",
      "code": "// Set stack size to 2MB per thread\n// java -Xss2m MyApplication\n\n// Common scenario: deep recursion causes StackOverflowError\npublic int factorial(int n) {\n    if (n <= 1) return 1;\n    return n * factorial(n - 1); // deep recursion\n}\n// factorial(10000) → StackOverflowError with default stack\n// Solution 1: increase stack\n// java -Xss4m MyApp\n// Solution 2: rewrite iteratively (better)\npublic long factorialIterative(int n) {\n    long result = 1;\n    for (int i = 2; i <= n; i++) result *= i;\n    return result; // No stack overflow risk\n}\n\n// Many threads — reduce stack to save memory\n// 10000 threads × 256k stack = 2.5 GB\n// java -Xss256k -jar highThreadApp.jar\n\n// Check default stack size\n// java -XX:+PrintFlagsFinal -version | grep ThreadStackSize\n\n// Virtual threads (Java 21+) — tiny stack, scales to millions\nThread vt = Thread.ofVirtual().start(() -> {\n    System.out.println(\"Virtual thread — minimal stack\");\n});\n// Virtual threads are managed by JVM, not OS\n// Default stack much smaller, grows only as needed"
    },
    {
      "id": 115,
      "question": "What is a ClassLoader in Java?",
      "answer": "A ClassLoader is a part of the JVM responsible for loading .class files into memory at runtime. It finds bytecode for a given class name and loads it into the JVM.\n\nWhat ClassLoader does:\n1. Finds the .class file (from file system, JAR, network, etc.)\n2. Reads the bytecode\n3. Passes it to the JVM which verifies and defines the Class object\n4. Caches the Class object — same class is only loaded once per ClassLoader\n\nClass loading process:\n1. Loading: Find and read bytecode\n2. Linking:\n   a. Verification: Bytecode safety check\n   b. Preparation: Allocate memory for static fields, set defaults\n   c. Resolution: Resolve symbolic references to actual references\n3. Initialization: Execute static initializers and assign static field values\n\nKey property — Classes are unique per ClassLoader:\n• Same .class file loaded by two different ClassLoaders = two different Class objects\n• They are NOT equal and cannot be cast to each other\n• This is used in application servers to isolate different applications",
      "explanation": "ClassLoaders enable Java's dynamic class loading — classes are loaded on demand, not all at startup. This enables hot deployment, plugins, and modular systems. The delegation model (parent-first) prevents malicious code from replacing core JDK classes. OSGi, application servers (Tomcat), and frameworks (Spring) all use custom ClassLoaders for isolation.",
      "difficulty": "Medium",
      "code": "// Getting the ClassLoader for a class\nClassLoader cl = MyClass.class.getClassLoader();\nSystem.out.println(cl); // e.g. jdk.internal.loader.ClassLoaders$AppClassLoader\n\n// Bootstrap classes have null ClassLoader (loaded by JVM itself)\nClassLoader bootstrapCL = String.class.getClassLoader();\nSystem.out.println(bootstrapCL); // null\n\n// Loading a class dynamically by name\ntry {\n    Class<?> clazz = Class.forName(\"com.example.MyPlugin\");\n    Object instance = clazz.getDeclaredConstructor().newInstance();\n} catch (ClassNotFoundException e) {\n    System.out.println(\"Class not found\");\n}\n\n// Custom ClassLoader example\nclass MyClassLoader extends ClassLoader {\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        byte[] bytecode = loadBytecodeFromCustomSource(name); // your logic\n        return defineClass(name, bytecode, 0, bytecode.length);\n    }\n\n    private byte[] loadBytecodeFromCustomSource(String name) {\n        // e.g., read from encrypted JAR, network, database...\n        return new byte[0];\n    }\n}\n\n// Check class identity\nClassLoader cl1 = new MyClassLoader();\nClassLoader cl2 = new MyClassLoader();\nClass<?> c1 = cl1.loadClass(\"com.example.Foo\");\nClass<?> c2 = cl2.loadClass(\"com.example.Foo\");\nSystem.out.println(c1 == c2); // false — same bytecode, different loaders!"
    },
    {
      "id": 116,
      "question": "What are the types of ClassLoaders in Java?",
      "answer": "Java uses three built-in ClassLoaders, organized in a parent-child hierarchy with delegation:\n\n1. Bootstrap ClassLoader (Primordial ClassLoader):\n• Built into the JVM (written in C/C++, not Java)\n• Loads core Java classes: java.lang, java.util, java.io, etc.\n• Loads from JAVA_HOME/lib (rt.jar in Java 8, java.base module in Java 9+)\n• No parent — it IS the root\n• Returns null when asked for its ClassLoader reference\n\n2. Extension ClassLoader (Platform ClassLoader in Java 9+):\n• Child of Bootstrap ClassLoader\n• Loads classes from JAVA_HOME/lib/ext directory or java.ext.dirs\n• In Java 9+: loads platform modules — renamed Platform ClassLoader\n\n3. Application ClassLoader (System ClassLoader):\n• Child of Extension/Platform ClassLoader\n• Loads classes from the application classpath (-cp / CLASSPATH)\n• This is the ClassLoader used by your application code\n\nDelegation Model (Parent-First):\n1. ClassLoader receives a load request\n2. Delegates to parent first (before trying itself)\n3. Parent delegates to its parent, all the way to Bootstrap\n4. If Bootstrap can't find it → Extension/Platform tries\n5. If Extension can't find it → Application tries\n6. If none find it → ClassNotFoundException",
      "explanation": "The parent-first delegation model is a security feature: it ensures core Java classes (java.lang.String, etc.) always come from the Bootstrap ClassLoader and cannot be overridden by malicious code on the classpath. Application servers (Tomcat, JBoss) break this model intentionally for each web app, using child-first loading so deployed apps get their own isolated class versions.",
      "difficulty": "Medium",
      "code": "// Check ClassLoader hierarchy\nClass<?> myClass = MyApp.class;\nClassLoader app = myClass.getClassLoader();\nSystem.out.println(\"App:       \" + app);\n// jdk.internal.loader.ClassLoaders$AppClassLoader\n\nClassLoader ext = app.getParent();\nSystem.out.println(\"Extension: \" + ext);\n// jdk.internal.loader.ClassLoaders$PlatformClassLoader\n\nClassLoader bootstrap = ext.getParent();\nSystem.out.println(\"Bootstrap: \" + bootstrap);\n// null (Bootstrap has no parent)\n\n// Bootstrap ClassLoader loads core classes\nClassLoader stringCL = String.class.getClassLoader();\nSystem.out.println(stringCL); // null ← Bootstrap\n\n// System ClassLoader = Application ClassLoader\nClassLoader systemCL = ClassLoader.getSystemClassLoader();\nSystem.out.println(systemCL); // AppClassLoader\n\n// Delegation model in action:\n// 1. App asks AppClassLoader for java.lang.String\n// 2. AppClassLoader delegates to PlatformClassLoader\n// 3. PlatformClassLoader delegates to Bootstrap\n// 4. Bootstrap finds it in java.base module → returns Class\n// AppClassLoader and PlatformClassLoader never even try\n\n// Custom ClassLoader (breaks delegation for specific packages)\nclass PluginClassLoader extends URLClassLoader {\n    PluginClassLoader(URL[] urls) {\n        super(urls, null); // null parent = no delegation to App CL\n    }\n}"
    },
    {
      "id": 117,
      "question": "What is 'public static void main' and what happens if you change the order?",
      "answer": "public static void main(String[] args) is the entry point of every Java application. Each keyword has a specific required meaning:\n\n• public: Accessible by the JVM from outside the class\n• static: Can be called without creating an instance (JVM calls it before any objects exist)\n• void: Returns nothing to the JVM\n• main: The exact method name the JVM looks for\n• String[] args: Command-line arguments passed to the program\n\nWhat happens if you change things:\n• Non-public → JVM cannot access it → error at runtime\n• Non-static → JVM cannot call without an instance → error at runtime\n• Non-void (e.g. int) → Compile fine, but JVM won't recognize it as entry point\n• Different name (e.g. Main) → JVM won't find entry point → error\n• No String[] args → Compile fine, but JVM won't recognize it as entry point\n\nCan you change the ORDER of modifiers?\n• static public void main → YES, compiles and runs fine\n• public void static main → NO, syntax error (return type must come right before method name)\n\nJava 21+ note: Unnamed classes and instance main methods (preview feature) allow simpler entry points.",
      "explanation": "The JVM specifically looks for a method named 'main' with signature (String[]) that is public static void. The order of 'public' and 'static' modifiers can be swapped — Java allows modifiers in any order. But void must directly precede the method name. Forgetting 'static' compiles fine but gives a runtime error, which confuses beginners.",
      "difficulty": "Easy",
      "code": "// Standard - correct\npublic class MyApp {\n    public static void main(String[] args) {\n        System.out.println(\"Running\");\n    }\n}\n\n// Swapping public and static - ALSO WORKS\npublic class MyApp {\n    static public void main(String[] args) { // OK!\n        System.out.println(\"Running\");\n    }\n}\n\n// Missing static - COMPILES but fails at runtime!\npublic class MyApp {\n    public void main(String[] args) { // No static!\n        // Error: Main method is not static\n    }\n}\n\n// Wrong return type - COMPILES but JVM ignores it as entry point\npublic class MyApp {\n    public static int main(String[] args) { // returns int\n        return 0;\n        // Error: Main method must return a value of type void\n    }\n}\n\n// varargs also accepted (Java 5+)\npublic class MyApp {\n    public static void main(String... args) { // varargs OK\n        System.out.println(\"Works too!\");\n    }\n}\n\n// Reading command-line arguments\npublic class MyApp {\n    public static void main(String[] args) {\n        if (args.length > 0) {\n            System.out.println(\"First arg: \" + args[0]);\n        }\n    }\n}\n// Run: java MyApp Hello World\n// Output: First arg: Hello"
    },
    {
      "id": 118,
      "question": "Can you execute code before the main method in Java?",
      "answer": "Yes. Code in static initializer blocks runs before main() — it runs when the class is loaded by the JVM, which happens before main() is called.\n\nStatic initializer block:\n• Declared with static { }\n• Runs when the class is loaded (before main)\n• Runs in order from top to bottom\n• Can have multiple static blocks — all run in declaration order\n• Used for: complex static field initialization, loading native libraries, registering drivers\n\nOther class loading triggers (besides explicit class loading):\n1. Creating an instance of the class\n2. Calling a static method\n3. Reading/writing a static field\n4. Running the class (the JVM loads it to find main)\n\nNote: Instance initializer blocks run before the constructor each time an object is created, but after static blocks (which run only once).",
      "explanation": "Static blocks are the standard way to execute code before main. They are typically used for one-time setup that is too complex for a single-line field initialization (e.g., loading properties, setting up caches, registering JDBC drivers). Multiple static blocks run in top-to-bottom order. If a static block throws an exception, it becomes an ExceptionInInitializerError.",
      "difficulty": "Easy",
      "code": "public class Demo {\n\n    static int value;\n\n    // Static initializer block - runs BEFORE main\n    static {\n        System.out.println(\"Static block 1 - class loading\");\n        value = computeValue(); // Complex initialization\n    }\n\n    static {\n        System.out.println(\"Static block 2 - also before main\");\n        // Multiple static blocks run in order\n    }\n\n    static int computeValue() {\n        return 42;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"main() - value = \" + value);\n    }\n}\n\n// Output:\n// Static block 1 - class loading\n// Static block 2 - also before main\n// main() - value = 42\n\n// Real-world usage 1: Loading native library\nclass NativeHelper {\n    static {\n        System.loadLibrary(\"mylib\"); // Must happen before any native calls\n    }\n    public native void doWork();\n}\n\n// Real-world usage 2: Registering JDBC driver (old style)\nclass DatabaseHelper {\n    static {\n        try {\n            Class.forName(\"com.mysql.cj.jdbc.Driver\"); // Load driver\n        } catch (ClassNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n\n// Instance initializer runs before constructor, after static:\nclass Example {\n    static { System.out.println(\"1. Static block\"); }\n    { System.out.println(\"2. Instance block\"); }  // runs before constructor\n    Example() { System.out.println(\"3. Constructor\"); }\n}\n// new Example() prints: 1 (once) and then 2, 3 each time"
    },
    {
      "id": 119,
      "question": "What is the difference between break and continue?",
      "answer": "Both are control flow statements used inside loops, but they do different things:\n\nbreak:\n• Terminates the entire loop immediately\n• Execution jumps to the first statement AFTER the loop\n• Also used in switch statements to exit a case\n• Can use labeled break to exit nested loops\n\ncontinue:\n• Skips the rest of the current iteration\n• Jumps to the next iteration (loop condition is re-evaluated)\n• The loop itself continues running\n• Can use labeled continue to skip to next iteration of an outer loop\n\nKey difference:\n• break = stop the loop entirely\n• continue = skip this iteration, keep looping",
      "explanation": "break and continue are simple but a common interview question. Remember: break exits the loop, continue skips to the next iteration. Both can use labels for nested loops. A common use of break is exiting an infinite loop (while(true)) when a condition is met. A common use of continue is skipping invalid data in a processing loop.",
      "difficulty": "Easy",
      "code": "// break - exits the loop entirely\nfor (int i = 0; i < 10; i++) {\n    if (i == 5) break; // Stop when i is 5\n    System.out.print(i + \" \");\n}\n// Output: 0 1 2 3 4\n\n// continue - skips current iteration\nfor (int i = 0; i < 10; i++) {\n    if (i == 5) continue; // Skip when i is 5\n    System.out.print(i + \" \");\n}\n// Output: 0 1 2 3 4 6 7 8 9  (5 is skipped)\n\n// break in while loop\nint i = 0;\nwhile (true) { // Infinite loop\n    if (i >= 5) break; // Exit condition\n    System.out.print(i + \" \");\n    i++;\n}\n// Output: 0 1 2 3 4\n\n// continue - skip invalid data\nString[] data = {\"1\", null, \"3\", \"\", \"5\"};\nfor (String s : data) {\n    if (s == null || s.isEmpty()) continue; // Skip bad data\n    System.out.println(Integer.parseInt(s));\n}\n// Output: 1, 3, 5\n\n// Labeled break - exit specific outer loop\nouter:\nfor (int row = 0; row < 3; row++) {\n    for (int col = 0; col < 3; col++) {\n        if (row == 1 && col == 1) break outer; // Exit both loops\n        System.out.println(row + \",\" + col);\n    }\n}\n// Output: 0,0  0,1  0,2  1,0  (stops at 1,1)\n\n// Labeled continue - skip to next outer iteration\nouter:\nfor (int row = 0; row < 3; row++) {\n    for (int col = 0; col < 3; col++) {\n        if (col == 1) continue outer; // Skip to next row\n        System.out.println(row + \",\" + col);\n    }\n}\n// Output: 0,0  1,0  2,0  (col 1,2 always skipped)"
    },
    {
      "id": 120,
      "question": "What is the difference between float and double in Java?",
      "answer": "float and double are both primitive floating-point types, but differ in size and precision:\n\nfloat (single precision):\n• 32-bit IEEE 754 floating-point\n• Precision: ~7 decimal digits\n• Range: approximately ±3.4 × 10^38\n• Literal suffix: f or F required (e.g. 3.14f)\n• Wrapper class: Float\n• Memory: 4 bytes\n\ndouble (double precision):\n• 64-bit IEEE 754 floating-point\n• Precision: ~15–16 decimal digits\n• Range: approximately ±1.7 × 10^308\n• Default type for floating-point literals (no suffix needed)\n• Wrapper class: Double\n• Memory: 8 bytes\n\nKey rules:\n• Default floating-point literal is double: 3.14 is a double\n• To use float: must add f suffix: 3.14f\n• double is the preferred type for floating-point in Java\n• Neither float nor double is suitable for monetary calculations (use BigDecimal)",
      "explanation": "Always prefer double over float unless memory is a serious concern (e.g., large float arrays in graphics/ML). The precision difference matters: float has ~7 digits of precision, so 1.0f/3.0f gives 0.33333334, while 1.0/3.0 gives 0.3333333333333333. For money/finance, never use float or double — use BigDecimal to avoid rounding errors.",
      "difficulty": "Easy",
      "code": "// float - requires 'f' suffix\nfloat f1 = 3.14f;        // OK\nfloat f2 = 3.14;         // Compile error: cannot convert double to float\nfloat f3 = (float) 3.14; // OK with explicit cast\n\n// double - default for literals\ndouble d1 = 3.14;        // OK (default is double)\ndouble d2 = 3.14d;       // OK (explicit, rarely used)\n\n// Precision comparison\nfloat  fResult = 1.0f / 3.0f;\ndouble dResult = 1.0  / 3.0;\nSystem.out.println(fResult); // 0.33333334  (only ~7 digits)\nSystem.out.println(dResult); // 0.3333333333333333 (~16 digits)\n\n// Size\nSystem.out.println(Float.SIZE);  // 32 bits = 4 bytes\nSystem.out.println(Double.SIZE); // 64 bits = 8 bytes\n\n// Equality issue (applies to both)\ndouble x = 0.1 + 0.2;\nSystem.out.println(x == 0.3);        // false! (floating-point rounding)\nSystem.out.println(Math.abs(x - 0.3) < 1e-10); // true (correct comparison)\n\n// NEVER use float/double for money!\ndouble price = 0.1 + 0.2;\nSystem.out.println(price); // 0.30000000000000004 ← wrong!\n\n// Use BigDecimal instead\nimport java.math.BigDecimal;\nBigDecimal correctPrice = new BigDecimal(\"0.1\").add(new BigDecimal(\"0.2\"));\nSystem.out.println(correctPrice); // 0.3 ← correct!\n\n// Wrapper class methods\nSystem.out.println(Float.MAX_VALUE);  // 3.4028235E38\nSystem.out.println(Double.MAX_VALUE); // 1.7976931348623157E308\nSystem.out.println(Double.isNaN(0.0 / 0.0));      // true\nSystem.out.println(Double.isInfinite(1.0 / 0.0)); // true"
    },
    {
      "id": 121,
      "question": "Why would you need a break in switch statements?",
      "answer": "In Java, switch statements use fall-through behavior by default: without a break, execution continues into the next case regardless of whether it matches.\n\nWithout break → Fall-through:\n• After matching a case, ALL subsequent case blocks execute until a break or the end of the switch\n• This is non-intuitive and a common source of bugs\n• Java inherited this from C\n\nWith break → Normal behavior:\n• Execution exits the switch block after the matched case\n• Only the matched case's code runs\n\nWhen is fall-through intentional?\n• Multiple cases sharing the same code (grouping)\n• e.g. case 'A': case 'B': case 'C': (same block for all three)\n• Intentional fall-through should always be commented\n\nSwitch expressions (Java 14+):\n• Arrow syntax (->) does NOT fall through\n• Cleaner and recommended for new code",
      "explanation": "Fall-through is the most common switch-related bug. Always add break after each case unless intentional fall-through is documented. Better yet, use switch expressions (Java 14+) with arrow syntax which eliminates fall-through entirely. Static analysis tools (SonarQube, Checkstyle) flag unintentional fall-through.",
      "difficulty": "Easy",
      "code": "// WITHOUT break — fall-through bug!\nint day = 2;\nswitch (day) {\n    case 1:\n        System.out.println(\"Monday\");\n    case 2:\n        System.out.println(\"Tuesday\"); // Matched here\n    case 3:\n        System.out.println(\"Wednesday\"); // Falls through!\n    case 4:\n        System.out.println(\"Thursday\"); // Falls through!\n    default:\n        System.out.println(\"Other\");     // Falls through!\n}\n// Output: Tuesday, Wednesday, Thursday, Other — likely a bug!\n\n// WITH break — correct\nswitch (day) {\n    case 1:\n        System.out.println(\"Monday\");\n        break;\n    case 2:\n        System.out.println(\"Tuesday\");\n        break; // Exits switch after this\n    case 3:\n        System.out.println(\"Wednesday\");\n        break;\n    default:\n        System.out.println(\"Other\");\n}\n// Output: Tuesday\n\n// Intentional fall-through (grouping)\nchar grade = 'B';\nswitch (grade) {\n    case 'A':\n    case 'B': // intentional fall-through\n    case 'C': // intentional fall-through\n        System.out.println(\"Pass\");\n        break;\n    case 'F':\n        System.out.println(\"Fail\");\n        break;\n}\n\n// Java 14+ switch expression — NO fall-through!\nString result = switch (day) {\n    case 1 -> \"Monday\";\n    case 2 -> \"Tuesday\"; // Arrow syntax, no break needed\n    case 3 -> \"Wednesday\";\n    default -> \"Other\";\n};\nSystem.out.println(result); // Tuesday"
    },
    {
      "id": 122,
      "question": "What are the primitive types in Java?",
      "answer": "Java has 8 primitive types (stored by value on the stack, not objects):\n\n1. byte   — 8-bit signed integer,  range: -128 to 127\n2. short  — 16-bit signed integer, range: -32,768 to 32,767\n3. int    — 32-bit signed integer, range: -2^31 to 2^31-1 (~2.1 billion)\n4. long   — 64-bit signed integer, range: -2^63 to 2^63-1, literal suffix: L\n5. float  — 32-bit IEEE 754 floating-point, ~7 digits precision, suffix: f\n6. double — 64-bit IEEE 754 floating-point, ~15-16 digits precision\n7. char   — 16-bit Unicode character, range: 0 to 65,535 (unsigned)\n8. boolean — true or false (size is JVM-dependent, ~1 bit logically)\n\nKey facts:\n• All are lowercase (unlike wrapper classes like Integer, Double)\n• Default values when class fields (not local vars): int/short/byte=0, long=0L, float=0.0f, double=0.0, char='\\u0000', boolean=false\n• String is NOT a primitive — it's a class\n• char can be used in arithmetic (it's numeric internally)",
      "explanation": "Primitives are the building blocks of Java's type system. They are stored by value (not reference) and live on the stack (or in-line in objects). Java is unique among major OOP languages in having primitives alongside objects — this was a performance decision. Each has a corresponding wrapper class (Integer, Double, etc.) for use in collections and generics.",
      "difficulty": "Easy",
      "code": "// All 8 primitives\nbyte   b = 127;           // -128 to 127 (8 bits)\nshort  s = 32767;         // -32,768 to 32,767 (16 bits)\nint    i = 2_147_483_647; // ~2.1 billion (32 bits)\nlong   l = 9_223_372_036_854_775_807L; // (64 bits, needs L)\nfloat  f = 3.14f;         // ~7 decimal digits (32 bits, needs f)\ndouble d = 3.14159265359; // ~15 decimal digits (64 bits)\nchar   c = 'A';           // Unicode U+0000 to U+FFFF (16 bits)\nboolean bool = true;      // true or false\n\n// Sizes in bits\nSystem.out.println(Byte.SIZE);    // 8\nSystem.out.println(Short.SIZE);   // 16\nSystem.out.println(Integer.SIZE); // 32\nSystem.out.println(Long.SIZE);    // 64\nSystem.out.println(Float.SIZE);   // 32\nSystem.out.println(Double.SIZE);  // 64\nSystem.out.println(Character.SIZE); // 16\n// boolean: not defined in spec, typically 1 bit logical\n\n// Default values (class fields, not local variables)\nclass Defaults {\n    byte    defaultByte;    // 0\n    short   defaultShort;   // 0\n    int     defaultInt;     // 0\n    long    defaultLong;    // 0L\n    float   defaultFloat;   // 0.0f\n    double  defaultDouble;  // 0.0\n    char    defaultChar;    // '\\u0000' (null char)\n    boolean defaultBoolean; // false\n}\n\n// char arithmetic\nchar ch = 'A';\nSystem.out.println(ch + 1);         // 66 (int)\nSystem.out.println((char)(ch + 1)); // 'B'\n\n// Widening: smaller → larger (automatic)\nbyte by = 10;\nint num = by; // auto-widened, no cast needed"
    },
    {
      "id": 123,
      "question": "What is the default value of local variables in Java?",
      "answer": "Local variables in Java have NO default value.\n\n• Local variables must be explicitly initialized before use\n• The Java compiler enforces this — code that reads an uninitialized local variable will NOT compile\n• This is a compile-time error, not a runtime error\n\nContrast with instance variables and class (static) variables:\n• Instance variables (fields): get default values automatically\n• Static variables: get default values automatically\n• Local variables: NO default — must initialize before use\n\nDefault values for fields (instance/static):\n• byte, short, int, long → 0\n• float → 0.0f\n• double → 0.0\n• char → '\\u0000' (null character)\n• boolean → false\n• Object references → null",
      "explanation": "This is by design — it prevents bugs from accidentally using garbage values. The Java compiler performs 'definite assignment' analysis to ensure every local variable path initializes the variable before use. Note that even final local variables need initialization before use (though they can only be assigned once).",
      "difficulty": "Easy",
      "code": "// LOCAL VARIABLES — no default value, must initialize!\npublic void method() {\n    int x;                    // declared but not initialized\n    System.out.println(x);   // COMPILE ERROR: variable x might not have been initialized\n}\n\n// Must initialize before use\npublic void method2() {\n    int x = 0;              // initialized\n    System.out.println(x);  // OK: 0\n}\n\n// Even in branches — must be definitely assigned\npublic void method3(boolean flag) {\n    int x;\n    if (flag) {\n        x = 10;\n    }\n    // What if flag is false? x may not be set\n    System.out.println(x); // COMPILE ERROR\n}\n\n// Fix: cover all paths\npublic void method4(boolean flag) {\n    int x;\n    if (flag) {\n        x = 10;\n    } else {\n        x = 0; // Now definitely assigned on all paths\n    }\n    System.out.println(x); // OK\n}\n\n// INSTANCE VARIABLES — get defaults automatically\nclass MyClass {\n    int count;        // default: 0\n    String name;      // default: null\n    boolean valid;    // default: false\n    double ratio;     // default: 0.0\n\n    void show() {\n        System.out.println(count);  // 0\n        System.out.println(name);   // null\n        System.out.println(valid);  // false\n    }\n}"
    },
    {
      "id": 124,
      "question": "Can a double value be cast to a byte in Java?",
      "answer": "Yes, a double can be cast to a byte — but it requires an explicit (narrowing) cast and data loss will occur.\n\nThis is called a narrowing primitive conversion:\n• double (64-bit) → byte (8-bit)\n• The fractional part is truncated (not rounded)\n• If the value is out of byte range (-128 to 127), the result is a modulo reduction of the integer part — it wraps around\n• You MUST use an explicit cast: (byte) — otherwise it won't compile\n\nConversion steps (double → byte):\n1. double is first narrowed to int (fractional part dropped)\n2. int is then narrowed to byte (lowest 8 bits taken)\n\nBe aware:\n• Information is lost: precision, magnitude\n• No exception is thrown — silent data corruption",
      "explanation": "Narrowing conversions are always explicit in Java — the language forces you to acknowledge the potential data loss with a cast. The conversion is: truncate to int first, then take the lowest 8 bits. This is why 256 → 0, 257 → 1, -1 → -1. This behavior surprises many developers. Always validate the range before narrowing.",
      "difficulty": "Medium",
      "code": "// Explicit cast required (narrowing conversion)\ndouble d = 9.99;\nbyte b = (byte) d; // Explicit cast required!\nSystem.out.println(b); // 9 — fractional part truncated\n\n// Without cast — COMPILE ERROR\ndouble d2 = 100.0;\nbyte b2 = d2; // Error: incompatible types: possible lossy conversion from double to byte\n\n// Range and overflow examples\ndouble d3 = 127.9;\nbyte b3 = (byte) d3;\nSystem.out.println(b3); // 127 — truncated, still in range\n\ndouble d4 = 128.0;  // Just outside byte range\nbyte b4 = (byte) d4;\nSystem.out.println(b4); // -128 — wraps around!\n\ndouble d5 = 256.0;\nbyte b5 = (byte) d5;\nSystem.out.println(b5); // 0 — wraps around to 0\n\ndouble d6 = 257.5;\nbyte b6 = (byte) d6;\nSystem.out.println(b6); // 1 — (257 % 256 = 1)\n\n// How narrowing works: double → int → byte\n// Step 1: (int) 257.5 = 257  (truncate fraction)\n// Step 2: 257 in binary: 100000001\n//         Take lowest 8 bits: 00000001 = 1\n\n// Safe narrowing with range check\ndouble value = 100.0;\nif (value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE) {\n    byte safe = (byte) value;\n    System.out.println(\"Safe: \" + safe);\n} else {\n    System.out.println(\"Out of byte range!\");\n}"
    },
    {
      "id": 125,
      "question": "Can a byte value be cast to a double in Java?",
      "answer": "Yes — and it happens automatically without any cast. This is called a widening primitive conversion.\n\n• byte (8-bit) → double (64-bit)\n• No data loss — byte can be represented exactly as a double\n• Implicit/automatic — no cast needed, Java does it for you\n• This is always safe\n\nWidening conversion order (each can widen to any rightward type):\nbyte → short → int → long → float → double\n               char ↗\n\nKey facts:\n• Explicit cast is also allowed but unnecessary\n• The value is exactly preserved\n• No information is lost going from byte to double",
      "explanation": "Widening is always safe so Java makes it implicit. The reason double can represent all byte values is that a 64-bit double has a 52-bit mantissa, which can exactly represent all integers up to 2^53. Since byte only has 256 values (-128 to 127), they all fit perfectly. Widening conversions are automatic in assignments, method calls, and arithmetic expressions.",
      "difficulty": "Easy",
      "code": "// Widening: byte → double (automatic, no cast needed)\nbyte b = 42;\ndouble d = b; // Implicit widening — no cast needed!\nSystem.out.println(d); // 42.0 — exact, no data loss\n\n// Explicit cast also works (but unnecessary)\ndouble d2 = (double) b; // OK but redundant\n\n// All widening conversions work automatically\nbyte  bt = 10;\nshort sh = bt;  // byte → short (automatic)\nint   in = bt;  // byte → int   (automatic)\nlong  ln = bt;  // byte → long  (automatic)\nfloat fl = bt;  // byte → float (automatic)\ndouble db = bt; // byte → double (automatic)\n\n// In method arguments — widening happens automatically\npublic static void printDouble(double d) {\n    System.out.println(d);\n}\nbyte myByte = 100;\nprintDouble(myByte); // byte automatically widened to double\n// Output: 100.0\n\n// In arithmetic — byte widened for calculations\nbyte a = 10;\nbyte bVal = 20;\n// byte + byte = int in Java! (arithmetic always widens to at least int)\nint result = a + bVal;  // 30\ndouble dResult = a + bVal; // also 30.0\n\n// Comparing widening vs narrowing\nbyte small = 50;\ndouble big = small;   // widening: automatic, safe ✓\nbyte back = (byte) big; // narrowing: explicit cast, safe here since value fits ✓\nSystem.out.println(back); // 50"
    },
    {
      "id": 126,
      "question": "How can you break out of a nested loop in Java?",
      "answer": "Java provides labeled break to exit a specific outer loop from inside a nested loop.\n\nOptions for breaking from nested loops:\n\n1. Labeled break (Java built-in):\n• Add a label before the outer loop: outerLoop:\n• Use break outerLoop; inside the inner loop\n• Exits directly to after the labeled loop\n\n2. Flag variable:\n• Use a boolean flag\n• Set flag = true when you want to break\n• Check flag in outer loop condition\n\n3. Return from method:\n• Put loops in a method\n• Use return to exit all loops and the method\n\n4. Labeled continue:\n• continue outerLabel; skips to the next iteration of the outer loop (without exiting it)\n\nLabeled break is the idiomatic Java solution. Using flags is more verbose but sometimes preferred for readability.",
      "explanation": "Java labels on loops are rarely used but important to know for interviews. A label is any identifier followed by a colon, placed directly before a loop or switch. break <label> exits that labeled block. continue <label> skips to the next iteration of that labeled loop. Overuse of labels is a code smell, but they are the correct tool for nested loop control.",
      "difficulty": "Easy",
      "code": "// 1. Labeled break — exits the labeled outer loop directly\nfound:\nfor (int i = 0; i < 5; i++) {\n    for (int j = 0; j < 5; j++) {\n        if (i == 2 && j == 3) {\n            System.out.println(\"Found at \" + i + \",\" + j);\n            break found; // Jump out of both loops\n        }\n    }\n}\nSystem.out.println(\"After loops\");\n// Output: Found at 2,3 → After loops\n\n// 2. Flag variable\nboolean found = false;\nfor (int i = 0; i < 5 && !found; i++) {\n    for (int j = 0; j < 5; j++) {\n        if (i == 2 && j == 3) {\n            found = true;\n            break; // Breaks inner loop; outer checks flag\n        }\n    }\n}\n\n// 3. Extract to method and use return\npublic static int[] findTarget(int[][] matrix, int target) {\n    for (int i = 0; i < matrix.length; i++) {\n        for (int j = 0; j < matrix[i].length; j++) {\n            if (matrix[i][j] == target) {\n                return new int[]{i, j}; // Exits all loops AND method\n            }\n        }\n    }\n    return new int[]{-1, -1}; // Not found\n}\n\n// 4. Labeled continue — skip to next outer iteration\nouter:\nfor (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n        if (j == 1) continue outer; // Skip rest of inner, go to next i\n        System.out.println(i + \",\" + j);\n    }\n}\n// Output: 0,0  1,0  2,0  (j=1 and j=2 always skipped)"
    },
    {
      "id": 127,
      "question": "What are the access modifiers in Java?",
      "answer": "Java has 4 access modifiers that control the visibility of classes, methods, and fields:\n\n1. public:\n• Accessible from everywhere (same class, package, subclass, other packages)\n\n2. protected:\n• Accessible within the same package\n• Also accessible in subclasses (even in different packages)\n\n3. (default) / package-private (no keyword):\n• Accessible only within the same package\n• Not accessible from other packages, even subclasses in other packages\n\n4. private:\n• Accessible only within the same class\n• Not accessible from subclasses, other classes, or other packages\n\nSummary table:\n| Modifier   | Same Class | Same Package | Subclass | Other Package |\n|------------|-----------|--------------|----------|---------------|\n| public     | ✓         | ✓            | ✓        | ✓             |\n| protected  | ✓         | ✓            | ✓        | ✗             |\n| (default)  | ✓         | ✓            | ✗        | ✗             |\n| private    | ✓         | ✗            | ✗        | ✗             |\n\nNote: Classes (top-level) can only be public or default. Only nested classes can be private or protected.",
      "explanation": "Access modifiers enforce encapsulation — one of OOP's core principles. The default choice should be private for fields, with getters/setters for controlled access. Use protected when designing for inheritance. Use public for APIs. package-private (default) is useful for implementation classes that shouldn't be exposed outside the package.",
      "difficulty": "Easy",
      "code": "package com.example.a;\n\npublic class AccessDemo {\n    public    int pub  = 1; // Accessible everywhere\n    protected int prot = 2; // Accessible in same package + subclasses\n    int           def  = 3; // Package-private: same package only\n    private   int priv = 4; // Only within this class\n\n    public void show() {\n        System.out.println(pub + \" \" + prot + \" \" + def + \" \" + priv); // All OK\n    }\n}\n\n// Same package — com.example.a\nclass SamePackage {\n    void test() {\n        AccessDemo a = new AccessDemo();\n        System.out.println(a.pub);   // OK\n        System.out.println(a.prot);  // OK\n        System.out.println(a.def);   // OK (same package)\n        System.out.println(a.priv);  // COMPILE ERROR: private\n    }\n}\n\n// Different package, subclass — com.example.b\npackage com.example.b;\nimport com.example.a.AccessDemo;\n\nclass SubClass extends AccessDemo {\n    void test() {\n        System.out.println(pub);     // OK (public)\n        System.out.println(prot);    // OK (protected, via inheritance)\n        System.out.println(def);     // COMPILE ERROR: not accessible\n        System.out.println(priv);    // COMPILE ERROR: private\n    }\n}\n\n// Different package, unrelated class — com.example.b\nclass OtherClass {\n    void test() {\n        AccessDemo a = new AccessDemo();\n        System.out.println(a.pub);   // OK\n        System.out.println(a.prot);  // COMPILE ERROR (no inheritance)\n        System.out.println(a.def);   // COMPILE ERROR\n        System.out.println(a.priv);  // COMPILE ERROR\n    }\n}"
    },
    {
      "id": 128,
      "question": "What are the variable scope types in Java?",
      "answer": "Variable scope defines where a variable is accessible. Java has four scope levels:\n\n1. Class (Static) Scope:\n• Variables declared with static at class level\n• Accessible from anywhere using ClassName.field (or just field within the class)\n• Shared across all instances — one copy per class\n• Lifetime: entire duration of the program\n\n2. Instance (Object) Scope:\n• Variables declared at class level without static (instance fields)\n• Each object has its own copy\n• Accessible via object reference or this.field within the class\n• Lifetime: as long as the object exists\n\n3. Method / Local Scope:\n• Variables declared inside a method\n• Only accessible within that method\n• Must be initialized before use (no default value)\n• Lifetime: from declaration to end of the method\n\n4. Block Scope:\n• Variables declared inside a block: {}, if, for, while\n• Only accessible within that block\n• Lifetime: from declaration to end of the block\n• Loop variables (for(int i=...)) are scoped to the loop",
      "explanation": "Understanding scope is essential for avoiding NameErrors, memory issues, and unintended side effects. Variable shadowing occurs when a local variable has the same name as a field — the local variable takes precedence within its scope. Use this.fieldName to explicitly refer to the instance field when shadowing occurs.",
      "difficulty": "Easy",
      "code": "public class ScopeDemo {\n\n    // 1. Class (static) scope — shared across all instances\n    static int classCount = 0;\n\n    // 2. Instance scope — each object has its own copy\n    String name;\n    int value = 10;\n\n    public ScopeDemo(String name) {\n        // 3. Method/local scope — only inside this constructor\n        int localVar = 99;\n        this.name = name; // 'this' distinguishes instance field from parameter\n        classCount++;\n        System.out.println(localVar); // OK\n    }\n\n    public void method() {\n        // localVar is NOT accessible here — different scope\n        // System.out.println(localVar); // COMPILE ERROR\n\n        System.out.println(name);       // OK (instance scope)\n        System.out.println(classCount); // OK (class scope)\n\n        // 4. Block scope\n        if (value > 5) {\n            int blockVar = 42; // Only accessible inside this if block\n            System.out.println(blockVar); // OK\n        }\n        // System.out.println(blockVar); // COMPILE ERROR: out of scope\n\n        // Loop variable scoped to the loop\n        for (int i = 0; i < 3; i++) {\n            System.out.println(i); // OK inside loop\n        }\n        // System.out.println(i); // COMPILE ERROR: out of scope\n    }\n\n    // Shadowing: local var hides instance field\n    public void shadowDemo() {\n        int value = 99; // Shadows instance field 'value'\n        System.out.println(value);       // 99 — local variable\n        System.out.println(this.value);  // 10 — instance field\n    }\n}"
    },
    {
      "id": 129,
      "question": "What does the static modifier do in Java?",
      "answer": "static indicates that a member belongs to the class itself, not to any specific instance.\n\nStatic fields (class variables):\n• One copy shared across ALL instances of the class\n• Initialized when the class is loaded\n• Accessed via ClassName.field (or just field within the class)\n• Use for: counters, constants (with final), shared configuration\n\nStatic methods:\n• Can be called without creating an instance\n• Cannot access instance fields or methods directly (no 'this')\n• Can only directly access other static members\n• Use for: utility methods (Math.sqrt), factory methods\n\nStatic blocks:\n• Run once when the class is first loaded\n• Used for complex static initialization\n\nStatic nested classes:\n• Nested class that doesn't need an outer class instance\n• Unlike inner classes, static nested classes have no outer 'this'\n\nStatic import:\n• import static java.lang.Math.*; allows using sqrt() without Math.sqrt()",
      "explanation": "static is one of the most important modifiers. Key rule: static methods cannot access non-static members directly because there's no 'this' (no instance). This is why main() must be static — the JVM calls it before any objects exist. Static fields are useful for counters and constants but overuse can lead to hidden shared state (hard to test).",
      "difficulty": "Easy",
      "code": "public class Counter {\n    // Static field — shared across ALL instances\n    private static int count = 0;\n\n    // Instance field — each object has its own\n    private String name;\n\n    public Counter(String name) {\n        this.name = name;\n        count++; // Increment shared counter\n    }\n\n    // Static method — callable without an instance\n    public static int getCount() {\n        return count;\n        // return name; // COMPILE ERROR: cannot access instance field\n    }\n\n    // Instance method — requires an object\n    public String getName() {\n        return name;\n    }\n}\n\n// Usage\nCounter c1 = new Counter(\"First\");\nCounter c2 = new Counter(\"Second\");\nCounter c3 = new Counter(\"Third\");\n\nSystem.out.println(Counter.getCount()); // 3 — shared count\nSystem.out.println(c1.getName());       // First — own name\n\n// Calling static method via instance (works but bad practice)\nSystem.out.println(c1.getCount()); // 3 — but prefer Counter.getCount()\n\n// Static constant (static final)\npublic class MathConstants {\n    public static final double PI = 3.14159265358979;\n    public static final int MAX_SIZE = 100;\n}\nSystem.out.println(MathConstants.PI); // 3.14159...\n\n// Static utility method\npublic class StringUtils {\n    public static String capitalize(String s) {\n        if (s == null || s.isEmpty()) return s;\n        return Character.toUpperCase(s.charAt(0)) + s.substring(1);\n    }\n}\nStringUtils.capitalize(\"hello\"); // No instance needed\n\n// Static block\nclass Config {\n    static final Map<String, String> PROPS;\n    static {\n        PROPS = new HashMap<>();\n        PROPS.put(\"host\", \"localhost\");\n        PROPS.put(\"port\", \"8080\");\n    }\n}"
    },
    {
      "id": 130,
      "question": "Is Java pass-by-value or pass-by-reference?",
      "answer": "Java is strictly pass-by-value — always.\n\nFor primitives:\n• The actual value is copied\n• Changes inside the method do NOT affect the original\n\nFor objects (references):\n• The reference (address) is copied — not the object itself\n• Both the caller and method now hold a copy of the same reference\n• Changes to the OBJECT'S DATA through the reference ARE visible to the caller\n• BUT reassigning the reference parameter inside the method does NOT affect the caller's reference\n\nThis is why Java is sometimes confusingly called 'pass-by-reference-value' or 'pass reference by value'. The key insight:\n• You CAN mutate the object the reference points to (visible outside)\n• You CANNOT change which object the caller's variable points to\n\nContrast with true pass-by-reference (C++ int& x):\n• In true pass-by-reference, reassigning the parameter WOULD change the caller's variable",
      "explanation": "This is one of the most frequently misunderstood Java concepts. The confusion arises because object mutations inside methods ARE visible outside — but that's because both sides hold copies of the same reference (pointer), not because Java passes by reference. To truly understand: Java passes a copy of the bits in the variable, and for object variables, those bits are an address.",
      "difficulty": "Medium",
      "code": "// PRIMITIVES — copy of value, original unchanged\npublic static void incrementPrimitive(int x) {\n    x = x + 10; // Modifies LOCAL copy only\n}\nint num = 5;\nincrementPrimitive(num);\nSystem.out.println(num); // 5 — unchanged!\n\n// OBJECTS — copy of reference; mutation IS visible\npublic static void addItem(List<String> list) {\n    list.add(\"new item\"); // Mutates the object the reference points to\n}\nList<String> myList = new ArrayList<>();\nmyList.add(\"original\");\naddItem(myList);\nSystem.out.println(myList); // [original, new item] — mutation visible!\n\n// REASSIGNING reference — does NOT affect caller\npublic static void reassign(List<String> list) {\n    list = new ArrayList<>(); // Only changes local copy of reference\n    list.add(\"new list\");\n}\nList<String> myList2 = new ArrayList<>();\nmyList2.add(\"original\");\nreassign(myList2);\nSystem.out.println(myList2); // [original] — reassignment had no effect!\n\n// SWAP example — why swap doesn't work in Java\npublic static void swap(String a, String b) {\n    String temp = a;\n    a = b;       // Only swaps local copies\n    b = temp;\n}\nString x = \"Hello\", y = \"World\";\nswap(x, y);\nSystem.out.println(x + \" \" + y); // Hello World — not swapped!\n\n// Memory model visualization:\n// caller:  num [5] ──────────────→ (value 5)\n// method:  x   [5 copy] ────────→ (different copy)\n//\n// caller:  myList [ref@100] ────┐\n//                               ↓ Same ArrayList object\n// method:  list   [ref@100] ────┘ (copy of same address)"
    },
    {
      "id": 131,
      "question": "What is the initial value of instance variables in Java?",
      "answer": "Instance variables (fields declared at class level, non-static) are automatically initialized to default values when an object is created — unlike local variables which must be explicitly initialized.\n\nDefault values by type:\n• byte, short, int → 0\n• long → 0L\n• float → 0.0f\n• double → 0.0\n• char → '\\u0000' (null/empty character, Unicode code point 0)\n• boolean → false\n• Object references (String, arrays, any class) → null\n\nWhy does this happen?\n• The JVM zero-initializes all memory allocated for objects\n• This prevents reading garbage values from memory\n• It ensures consistent, predictable behavior\n\nStatic variables also get the same defaults when the class is loaded.",
      "explanation": "Instance variables being auto-initialized is a deliberate Java safety feature. It means you can use an object's fields without a NullPointerException from an uninitialized primitive, though object references default to null which can cause NPEs if not handled. In contrast, local variable non-initialization is caught at compile time.",
      "difficulty": "Easy",
      "code": "public class Employee {\n    // Instance variables — all get default values automatically\n    int employeeId;       // default: 0\n    long salary;          // default: 0L\n    double rating;        // default: 0.0\n    float bonus;          // default: 0.0f\n    boolean isActive;     // default: false\n    char grade;           // default: '\\u0000' (empty char)\n    String name;          // default: null (object reference)\n    int[] scores;         // default: null (array reference)\n\n    public void printDefaults() {\n        System.out.println(\"employeeId: \" + employeeId);  // 0\n        System.out.println(\"salary:     \" + salary);      // 0\n        System.out.println(\"rating:     \" + rating);      // 0.0\n        System.out.println(\"bonus:      \" + bonus);        // 0.0\n        System.out.println(\"isActive:   \" + isActive);    // false\n        System.out.println(\"grade:      '\" + grade + \"'\"); // ''\n        System.out.println(\"name:       \" + name);         // null\n        System.out.println(\"scores:     \" + scores);      // null\n    }\n}\n\nEmployee e = new Employee();\ne.printDefaults();\n\n// Watch out for null reference!\nEmployee e2 = new Employee();\n// e2.name is null\nif (e2.name != null) {\n    System.out.println(e2.name.length()); // Safe\n}\n// e2.name.length(); // NullPointerException if called without null check!\n\n// Compare: local variable has NO default\npublic void method() {\n    int x;                    // NOT initialized\n    System.out.println(x);   // COMPILE ERROR — must initialize"
    },
    {
      "id": 132,
      "question": "How does a constructor work in Java?",
      "answer": "A constructor is a special method that initializes a new object when it is created with the new keyword.\n\nKey characteristics:\n• Same name as the class\n• No return type (not even void)\n• Called automatically by new\n• Can be overloaded (multiple constructors with different parameters)\n• If you define NO constructor, Java provides a default no-arg constructor\n• If you define ANY constructor, Java no longer provides the default one\n\nWhat the constructor does:\n1. Memory is allocated for the object\n2. Instance variables are set to default values\n3. The constructor body executes (your initialization code)\n4. The reference to the new object is returned\n\nTypes:\n• No-arg constructor: takes no parameters\n• Parameterized constructor: takes one or more parameters\n• Copy constructor: takes an instance of the same class (Java convention, not built-in)\n\nOrder of initialization within constructor:\n1. super() call (explicit or implicit — always first)\n2. Instance variable defaults\n3. Instance initializer blocks run (top to bottom)\n4. Rest of constructor body executes",
      "explanation": "Constructors establish an object's initial state. The first statement in any constructor is always a super() or this() call — if you don't write one, Java inserts super() automatically. This ensures the parent class is initialized first. Constructors cannot be abstract, static, final, or synchronized (they're not inherited).",
      "difficulty": "Easy",
      "code": "public class Person {\n    String name;\n    int age;\n\n    // No-arg constructor\n    public Person() {\n        this.name = \"Unknown\";\n        this.age = 0;\n        System.out.println(\"No-arg constructor called\");\n    }\n\n    // Parameterized constructor\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n        System.out.println(\"Parameterized constructor called\");\n    }\n}\n\n// Usage\nPerson p1 = new Person();               // Calls no-arg constructor\nPerson p2 = new Person(\"Alice\", 30);    // Calls parameterized constructor\n\nSystem.out.println(p1.name); // Unknown\nSystem.out.println(p2.name); // Alice\n\n// Inheritance and constructors\nclass Animal {\n    String type;\n    Animal(String type) {\n        this.type = type;\n        System.out.println(\"Animal constructor: \" + type);\n    }\n}\n\nclass Dog extends Animal {\n    String breed;\n    Dog(String breed) {\n        super(\"Dog\"); // Must be first statement — calls Animal constructor\n        this.breed = breed;\n        System.out.println(\"Dog constructor: \" + breed);\n    }\n}\n\nnew Dog(\"Labrador\");\n// Output:\n// Animal constructor: Dog\n// Dog constructor: Labrador\n\n// If no constructor defined:\nclass Simple {\n    int x; // Java silently adds: public Simple() { super(); }\n}\nSimple s = new Simple(); // Uses auto-generated default constructor"
    },
    {
      "id": 133,
      "question": "What is constructor overloading in Java?",
      "answer": "Constructor overloading is defining multiple constructors in the same class, each with a different parameter list.\n\nRules:\n• Same class name (same as constructors)\n• Different parameter lists (number, type, or order of parameters)\n• Return type doesn't apply to constructors\n• The compiler selects the appropriate constructor based on the arguments provided at call time\n\nBenefits:\n• Provides multiple ways to create an object\n• Some parameters can have defaults (by calling other constructors)\n• Improves API flexibility\n\nConstructor chaining with this():\n• One constructor can call another in the same class using this()\n• this() must be the first statement\n• Avoids code duplication by delegating to a 'master' constructor",
      "explanation": "Constructor overloading is a form of compile-time polymorphism. The canonical Java pattern is to have one 'master' constructor with all parameters, and delegate shorter constructors to it using this(). This ensures initialization logic is in one place. The Builder pattern is often used as an alternative for classes with many optional parameters.",
      "difficulty": "Easy",
      "code": "public class Connection {\n    String host;\n    int    port;\n    int    timeout;\n    boolean ssl;\n\n    // Master constructor — all parameters\n    public Connection(String host, int port, int timeout, boolean ssl) {\n        this.host    = host;\n        this.port    = port;\n        this.timeout = timeout;\n        this.ssl     = ssl;\n    }\n\n    // Overloaded: no timeout (uses default)\n    public Connection(String host, int port, boolean ssl) {\n        this(host, port, 30, ssl); // Delegates to master constructor\n    }\n\n    // Overloaded: no ssl, no timeout\n    public Connection(String host, int port) {\n        this(host, port, 30, false); // Delegates to master constructor\n    }\n\n    // Overloaded: only host (all defaults)\n    public Connection(String host) {\n        this(host, 8080, 30, false); // Delegates to master constructor\n    }\n\n    @Override\n    public String toString() {\n        return host + \":\" + port + \" (timeout=\" + timeout + \", ssl=\" + ssl + \")\";\n    }\n}\n\n// Usage — all valid\nConnection c1 = new Connection(\"db.server.com\", 5432, 60, true);\nConnection c2 = new Connection(\"db.server.com\", 5432, true);\nConnection c3 = new Connection(\"db.server.com\", 5432);\nConnection c4 = new Connection(\"db.server.com\");\n\nSystem.out.println(c1); // db.server.com:5432 (timeout=60, ssl=true)\nSystem.out.println(c4); // db.server.com:8080 (timeout=30, ssl=false)\n\n// Compile error — ambiguous if types could match multiple constructors\n// Connection ambiguous = new Connection(\"host\", 80, 60); // Ambiguous? No — no (String,int,int) overload\n\n// this() must be FIRST statement\npublic Connection(String host, int port, int timeout) {\n    System.out.println(\"Creating...\"); // COMPILE ERROR if before this()\n    this(host, port, timeout, false);  // this() must be first!\n}"
    },
    {
      "id": 134,
      "question": "What is a copy constructor in Java?",
      "answer": "A copy constructor is a constructor that takes an object of the same class as its parameter and creates a new object with the same field values.\n\nKey points:\n• Java does NOT provide a copy constructor automatically (unlike C++)\n• You write it yourself\n• Used to create a deep or shallow copy of an object\n\nShallow copy:\n• Primitive fields are copied by value — independent\n• Object references are copied — both copies point to the SAME nested objects\n• Modifying nested objects through one copy affects the other\n\nDeep copy:\n• Primitives copied by value\n• Nested objects are also copied (new instances created)\n• Both copies are fully independent\n\nAlternatives to copy constructor:\n• clone() method from Object (requires Cloneable, generally discouraged)\n• Copy factory method: static Person copy(Person p)\n• Serialization/deserialization for deep copy\n• Libraries: Apache Commons BeanUtils, MapStruct",
      "explanation": "Copy constructors are preferred over clone() in Java because clone() is broken — it's error-prone, uses a cast, and requires handling CloneNotSupportedException. Joshua Bloch (Effective Java) recommends copy constructors or copy factory methods instead. Deep vs. shallow copy is critical to understand: a shallow copy shares mutable nested objects, which can cause subtle bugs.",
      "difficulty": "Medium",
      "code": "public class Address {\n    String city;\n    String country;\n\n    Address(String city, String country) {\n        this.city = city;\n        this.country = country;\n    }\n\n    // Copy constructor for Address (deep copy support)\n    Address(Address other) {\n        this.city    = other.city;\n        this.country = other.country;\n    }\n}\n\npublic class Person {\n    String name;\n    int    age;\n    Address address; // Mutable nested object!\n\n    Person(String name, int age, Address address) {\n        this.name    = name;\n        this.age     = age;\n        this.address = address;\n    }\n\n    // SHALLOW copy constructor — shares Address reference!\n    Person(Person other) {\n        this.name    = other.name;\n        this.age     = other.age;\n        this.address = other.address; // Same Address object!\n    }\n\n    // DEEP copy constructor — creates new Address\n    // Person(Person other) {\n    //     this.name    = other.name;\n    //     this.age     = other.age;\n    //     this.address = new Address(other.address); // New copy!\n    // }\n}\n\n// Shallow copy problem\nAddress addr = new Address(\"London\", \"UK\");\nPerson original = new Person(\"Alice\", 30, addr);\nPerson copy = new Person(original); // Shallow copy\n\ncopy.address.city = \"Paris\"; // Modifies SHARED Address!\nSystem.out.println(original.address.city); // Paris — original affected!\n\n// Deep copy solution — original unaffected\nPerson deepCopy = new Person(\n    original.name,\n    original.age,\n    new Address(original.address) // New Address object\n);\ndeepCopy.address.city = \"Tokyo\";\nSystem.out.println(original.address.city); // Paris — unchanged!"
    },
    {
      "id": 135,
      "question": "What is the 'this' keyword in Java?",
      "answer": "this is a reference to the current object — the instance on which the current method or constructor is being invoked.\n\nUses of this:\n\n1. Disambiguate instance variables from parameters (same name):\n• this.name = name; — left is field, right is parameter\n\n2. Call another constructor in the same class (constructor chaining):\n• this(args) — must be the first statement in the constructor\n\n3. Pass the current object as an argument:\n• someMethod(this) — passes the current instance to another method\n\n4. Return the current object (fluent/builder pattern):\n• return this; — allows method chaining\n\n5. Refer to instance methods explicitly:\n• this.methodName() — rarely needed, but possible\n\nthis cannot be used in static methods (no current instance context).",
      "explanation": "this is one of Java's implicit references. Every non-static method and constructor has a hidden 'this' parameter pointing to the calling object. The most common use is to resolve name conflicts between fields and parameters. Constructor chaining with this() reduces code duplication. The fluent builder pattern (return this) relies heavily on this for method chaining.",
      "difficulty": "Easy",
      "code": "public class Builder {\n    private String name;\n    private int age;\n    private String email;\n\n    // Use 1: Disambiguate field vs parameter\n    public Builder setName(String name) {\n        this.name = name; // this.name = field, name = parameter\n        return this;      // Use 4: Return current object for chaining\n    }\n\n    public Builder setAge(int age) {\n        this.age = age;\n        return this;\n    }\n\n    public Builder setEmail(String email) {\n        this.email = email;\n        return this;\n    }\n\n    public String build() {\n        return name + \", \" + age + \", \" + email;\n    }\n}\n\n// Method chaining via 'return this'\nString result = new Builder()\n    .setName(\"Alice\")\n    .setAge(30)\n    .setEmail(\"alice@example.com\")\n    .build();\n// \"Alice, 30, alice@example.com\"\n\n// Use 2: Constructor chaining with this()\npublic class Connection {\n    String host; int port; int timeout;\n\n    Connection(String host, int port, int timeout) {\n        this.host = host; this.port = port; this.timeout = timeout;\n    }\n    Connection(String host, int port) {\n        this(host, port, 30); // Calls 3-arg constructor (must be FIRST)\n    }\n    Connection(String host) {\n        this(host, 8080);     // Calls 2-arg constructor\n    }\n}\n\n// Use 3: Pass current object as argument\npublic class EventSource {\n    void register(EventListener listener) { /* ... */ }\n\n    void init() {\n        EventBus.register(this); // Pass current instance\n    }\n}\n\n// Static method — 'this' is NOT available\nclass MyClass {\n    int x = 10;\n    static void staticMethod() {\n        // System.out.println(this.x); // COMPILE ERROR: cannot use 'this' in static context\n    }\n}"
    },
    {
      "id": 136,
      "question": "What is constructor chaining in Java?",
      "answer": "Constructor chaining is the process of one constructor calling another constructor.\n\nTwo forms:\n1. Within the same class — using this():\n• this() calls another constructor in the same class\n• Must be the first statement in the constructor\n• Creates a chain: constructor A → constructor B → constructor C\n\n2. From subclass to parent class — using super():\n• super() calls the parent class constructor\n• Must be the first statement in the constructor\n• Java automatically inserts super() if you don't write it (calls no-arg parent constructor)\n• If parent has no no-arg constructor, you must explicitly call super(args)\n\nNote: You cannot use both this() and super() in the same constructor — only one is allowed, and it must be the first statement.\n\nBenefit:\n• Avoids code duplication\n• Ensures all constructors go through one initialization path",
      "explanation": "Constructor chaining is fundamental to Java's class hierarchy. Every object creation triggers a chain up to Object (the root class). Java guarantees that the entire hierarchy is initialized before you get control in your constructor's body. If you forget super() in a subclass and the parent has no default constructor, you get a compile error.",
      "difficulty": "Medium",
      "code": "// this() chaining — within same class\nclass Pizza {\n    String size;\n    String crust;\n    boolean cheese;\n    boolean pepperoni;\n\n    // Master constructor\n    Pizza(String size, String crust, boolean cheese, boolean pepperoni) {\n        this.size      = size;\n        this.crust     = crust;\n        this.cheese    = cheese;\n        this.pepperoni = pepperoni;\n        System.out.println(\"Creating pizza: \" + size);\n    }\n\n    // Chains to master constructor\n    Pizza(String size, String crust) {\n        this(size, crust, true, false); // 1st statement!\n    }\n\n    // Chains to above\n    Pizza(String size) {\n        this(size, \"thin\"); // 1st statement!\n    }\n}\n\nnew Pizza(\"large\"); // Calls Pizza(String) → Pizza(String,String) → Pizza(String,String,boolean,boolean)\n// Output: Creating pizza: large\n\n// super() chaining — parent to child\nclass Shape {\n    String color;\n    Shape(String color) {\n        this.color = color;\n        System.out.println(\"Shape created: \" + color);\n    }\n}\n\nclass Circle extends Shape {\n    double radius;\n    Circle(String color, double radius) {\n        super(color); // Must be FIRST — calls Shape constructor\n        this.radius = radius;\n        System.out.println(\"Circle created: r=\" + radius);\n    }\n    Circle(double radius) {\n        this(\"red\", radius); // this() → Circle(String,double) → super()\n    }\n}\n\nnew Circle(5.0);\n// Output: Shape created: red → Circle created: r=5.0\n\n// Cannot use both this() and super()\nclass Bad extends Shape {\n    Bad() {\n        this(\"blue\");     // this() is first\n        super(\"blue\");   // COMPILE ERROR: cannot have both!\n    }\n    Bad(String color) { super(color); }\n}"
    },
    {
      "id": 137,
      "question": "What are wrapper classes in Java?",
      "answer": "Wrapper classes are object representations of Java's 8 primitive types. They 'wrap' the primitive value in an object.\n\nPrimitive → Wrapper class:\n• byte    → Byte\n• short   → Short\n• int     → Integer\n• long    → Long\n• float   → Float\n• double  → Double\n• char    → Character\n• boolean → Boolean\n\nWhy are wrapper classes needed?\n1. Collections (ArrayList, HashMap) only store objects, not primitives\n2. Generics require object types (List<Integer>, not List<int>)\n3. Nullable values — Integer can be null, int cannot\n4. Utility methods — Integer.parseInt(), Double.compare(), etc.\n5. Reflection and APIs that work with Object type\n\nKey features:\n• Immutable — the wrapped value cannot change\n• Provide constants: Integer.MAX_VALUE, Integer.MIN_VALUE\n• Provide utility methods: parseInt, valueOf, compareTo, toString\n• Integer cache: Integer.valueOf(-128 to 127) returns cached objects",
      "explanation": "Wrapper classes enable primitives to participate in the Java Collections Framework and generics. Autoboxing (auto-conversion between primitive and wrapper) was added in Java 5 to reduce boilerplate. However, be careful with null wrappers — unboxing a null Integer throws NullPointerException. Also avoid == comparison with wrappers (compares references, not values) — use equals() instead.",
      "difficulty": "Easy",
      "code": "// Each primitive has a wrapper class\nInteger intObj    = Integer.valueOf(42);   // explicit wrapping\nDouble  doubleObj = Double.valueOf(3.14);\nBoolean boolObj   = Boolean.valueOf(true);\nCharacter charObj = Character.valueOf('A');\n\n// Unboxing — wrapper to primitive\nint primitive = intObj.intValue();\n\n// Autoboxing — automatic conversion (Java 5+)\nInteger auto = 100;         // int → Integer automatically\nint unboxed  = auto;        // Integer → int automatically\n\n// Needed for Collections\nList<Integer> numbers = new ArrayList<>();\nnumbers.add(1);  // int 1 autoboxed to Integer\nnumbers.add(2);\nnumbers.add(3);\nint first = numbers.get(0); // Integer unboxed to int\n\n// Utility methods\nint parsed = Integer.parseInt(\"42\");           // String → int\nString str = Integer.toString(42);             // int → String\nint max = Integer.max(10, 20);                 // 20\nint min = Integer.min(10, 20);                 // 10\nString binary = Integer.toBinaryString(10);    // \"1010\"\nString hex    = Integer.toHexString(255);      // \"ff\"\n\n// Constants\nSystem.out.println(Integer.MAX_VALUE);  // 2147483647\nSystem.out.println(Integer.MIN_VALUE);  // -2147483648\nSystem.out.println(Double.MAX_VALUE);   // 1.7976931348623157E308\n\n// Integer cache (-128 to 127)\nInteger a = 127;\nInteger b = 127;\nSystem.out.println(a == b);      // true  — same cached object!\nInteger c = 128;\nInteger d = 128;\nSystem.out.println(c == d);      // false — different objects (out of cache)\nSystem.out.println(c.equals(d)); // true  — always use equals() for wrappers!\n\n// Null danger\nInteger nullInt = null;\nint x = nullInt; // NullPointerException on unboxing!"
    },
    {
      "id": 138,
      "question": "What is autoboxing and unboxing in Java?",
      "answer": "Autoboxing and unboxing are automatic conversions between primitive types and their corresponding wrapper classes, introduced in Java 5.\n\nAutoboxing:\n• Automatic conversion from a primitive to its wrapper object\n• int → Integer, double → Double, boolean → Boolean, etc.\n• Happens implicitly in: assignments, method arguments, collections\n\nUnboxing:\n• Automatic conversion from a wrapper object back to a primitive\n• Integer → int, Double → double, etc.\n• Happens implicitly in: arithmetic, comparisons, assignments to primitive variable\n\nHow it works under the hood:\n• Autoboxing: Integer i = 42; compiles to Integer i = Integer.valueOf(42);\n• Unboxing: int x = i; compiles to int x = i.intValue();\n\nCommon pitfalls:\n1. NullPointerException: unboxing null → NPE\n2. Performance: excessive autoboxing in loops creates many temporary objects\n3. == vs equals(): wrapper == wrapper compares references\n4. Integer cache: Integer.valueOf(-128 to 127) uses cached objects",
      "explanation": "Autoboxing was added to Java 5 to eliminate verbose manual boxing code. Before Java 5, you had to write Integer.valueOf(x) and intValue() everywhere. The compiler silently inserts these calls. Be cautious with null: `Integer x = null; int y = x;` throws NPE at the unboxing point. Also, avoid autoboxing in tight loops — use primitives directly for performance.",
      "difficulty": "Easy",
      "code": "// Autoboxing examples\nInteger i1 = 42;           // int → Integer (compiler: Integer.valueOf(42))\nDouble  d1 = 3.14;         // double → Double\nBoolean b1 = true;         // boolean → Boolean\nLong    l1 = 100L;         // long → Long\n\n// Unboxing examples\nInteger wrapped = Integer.valueOf(10);\nint primitive = wrapped;   // Integer → int (compiler: wrapped.intValue())\ndouble dPrim  = d1;        // Double → double\n\n// In collections (requires autoboxing)\nList<Integer> list = new ArrayList<>();\nlist.add(1);   // autoboxed: Integer.valueOf(1)\nlist.add(2);   // autoboxed: Integer.valueOf(2)\nint val = list.get(0); // unboxed: .intValue()\n\n// In arithmetic (unboxing)\nInteger a = 10;\nInteger b = 20;\nint sum = a + b; // unboxed: a.intValue() + b.intValue()\n\n// PITFALL 1: NullPointerException\nInteger nullVal = null;\n// int x = nullVal; // NPE here! Cannot unbox null\n\n// PITFALL 2: Performance in loops\nLong total = 0L; // AVOID: wrapper in loop\nfor (long i = 0; i < 1_000_000; i++) {\n    total += i; // Repeated auto-unboxing AND autoboxing — SLOW!\n}\n// Better:\nlong totalPrim = 0L; // primitive\nfor (long i = 0; i < 1_000_000; i++) {\n    totalPrim += i; // No boxing — FAST\n}\n\n// PITFALL 3: == compares references, not values!\nInteger x = 200;\nInteger y = 200;\nSystem.out.println(x == y);       // false (different objects, outside cache)\nSystem.out.println(x.equals(y));  // true (use equals for wrappers!)\n\n// Cache range: -128 to 127 — same object\nInteger p = 100;\nInteger q = 100;\nSystem.out.println(p == q); // true (cached!)"
    },
    {
      "id": 139,
      "question": "What is the Singleton design pattern in Java?",
      "answer": "The Singleton pattern ensures that a class has only one instance throughout the application's lifetime, and provides a global access point to that instance.\n\nWhen to use:\n• Database connection pools\n• Configuration/settings objects\n• Logging services\n• Cache managers\n• Thread pools\n\nImplementation approaches:\n\n1. Eager initialization:\n• Instance created when class loads\n• Thread-safe (class loading is thread-safe)\n• Wastes memory if never used\n\n2. Lazy initialization (not thread-safe):\n• Instance created on first call\n• Not safe for multi-threaded use\n\n3. Synchronized lazy (thread-safe but slow):\n• synchronized getInstance()\n• Every call acquires a lock — very slow\n\n4. Double-checked locking (thread-safe and fast):\n• Only first call(s) synchronize\n• volatile field required\n• Recommended for most cases\n\n5. Enum Singleton (best practice — Joshua Bloch):\n• Thread-safe by JVM\n• Protects against serialization/reflection attacks\n• Most robust approach",
      "explanation": "Singleton is simple but commonly misimplemented. The classic pitfalls are: not handling multi-threading (two threads creating two instances), and serialization/reflection breaking the singleton (creating new instances). The enum approach avoids all these. In Spring/DI frameworks, beans are singletons by default — you rarely need to implement the pattern manually.",
      "difficulty": "Medium",
      "code": "// 1. Eager initialization\npublic class EagerSingleton {\n    private static final EagerSingleton INSTANCE = new EagerSingleton();\n    private EagerSingleton() {}   // Private constructor\n    public static EagerSingleton getInstance() { return INSTANCE; }\n}\n\n// 2. Lazy — NOT thread-safe\npublic class LazySingleton {\n    private static LazySingleton instance;\n    private LazySingleton() {}\n    public static LazySingleton getInstance() {\n        if (instance == null) {    // Two threads can pass this check!\n            instance = new LazySingleton();\n        }\n        return instance;\n    }\n}\n\n// 3. Double-checked locking (thread-safe + lazy)\npublic class DoubleCheckedSingleton {\n    private static volatile DoubleCheckedSingleton instance; // volatile required!\n    private DoubleCheckedSingleton() {}\n\n    public static DoubleCheckedSingleton getInstance() {\n        if (instance == null) {                        // 1st check (no lock)\n            synchronized (DoubleCheckedSingleton.class) {\n                if (instance == null) {                // 2nd check (with lock)\n                    instance = new DoubleCheckedSingleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n\n// 4. Enum Singleton — BEST PRACTICE\npublic enum ConfigManager {\n    INSTANCE;\n    private String dbUrl = \"jdbc:mysql://localhost/mydb\";\n\n    public String getDbUrl() { return dbUrl; }\n    public void setDbUrl(String url) { this.dbUrl = url; }\n}\n// Usage:\nConfigManager.INSTANCE.getDbUrl();\n\n// 5. Bill Pugh / Holder pattern (lazy + thread-safe without sync)\npublic class HolderSingleton {\n    private HolderSingleton() {}\n    private static class Holder {\n        static final HolderSingleton INSTANCE = new HolderSingleton();\n    }\n    public static HolderSingleton getInstance() {\n        return Holder.INSTANCE; // Loaded on first access\n    }\n}"
    },
    {
      "id": 140,
      "question": "What does the final keyword do in Java?",
      "answer": "final is a modifier with different meanings depending on where it's applied:\n\n1. final variable:\n• Can only be assigned once\n• For primitives: the value cannot change\n• For objects: the reference cannot be reassigned (but the object's contents CAN change)\n• Local final variables must be initialized before use\n• Instance final fields must be initialized in constructor or declaration\n\n2. final method:\n• Cannot be overridden in subclasses\n• Still inherited and called normally\n• Use when behavior must not be changed by subclasses\n\n3. final class:\n• Cannot be extended (subclassed)\n• Prevents inheritance entirely\n• Examples: String, Integer, Double — all final classes\n\n4. final parameter:\n• Cannot be reassigned within the method body\n• Common in lambdas/anonymous classes that capture variables from enclosing scope (effectively final)\n\nstatic final = constant (convention: ALL_CAPS_SNAKE_CASE)",
      "explanation": "final prevents unintended modification. Immutable classes (where all fields are final) are inherently thread-safe. Understanding that final on an object reference doesn't freeze the object's content is a common interview trap. String's immutability comes from more than just final — it has no mutating methods and its char array is private. Making classes final is a security practice to prevent subclass attacks.",
      "difficulty": "Easy",
      "code": "// 1. final variable\nfinal int MAX = 100;\n// MAX = 200; // COMPILE ERROR: cannot assign a value to final variable\n\n// final reference — reference locked, not the object!\nfinal List<String> list = new ArrayList<>();\nlist.add(\"OK\");              // OK — modifying the object is fine\n// list = new ArrayList<>(); // COMPILE ERROR — cannot reassign reference\n\n// 2. static final constant\npublic class Constants {\n    public static final double PI = 3.14159265358979;\n    public static final int MAX_CONNECTIONS = 100;\n    // Convention: ALL_CAPS_SNAKE_CASE for static final\n}\n\n// 3. final method — cannot be overridden\nclass Parent {\n    final void criticalMethod() {\n        System.out.println(\"Cannot be overridden\");\n    }\n}\nclass Child extends Parent {\n    // void criticalMethod() {} // COMPILE ERROR: cannot override final method\n}\n\n// 4. final class — cannot be subclassed\nfinal class ImmutablePoint {\n    private final int x, y;\n    ImmutablePoint(int x, int y) { this.x = x; this.y = y; }\n    int getX() { return x; }\n    int getY() { return y; }\n}\n// class SubPoint extends ImmutablePoint {} // COMPILE ERROR\n\n// 5. final parameter\nvoid method(final String name) {\n    // name = \"other\"; // COMPILE ERROR\n    System.out.println(name);\n}\n\n// Effectively final (Java 8+) — lambdas and anonymous classes\nString msg = \"Hello\"; // Not declared final, but never reassigned\nRunnable r = () -> System.out.println(msg); // OK — effectively final\n// msg = \"Hi\"; // If you add this, lambda won't compile!"
    },
    {
      "id": 141,
      "question": "What is encapsulation in Java?",
      "answer": "Encapsulation is the OOP principle of bundling data (fields) and the methods that operate on that data within a single class, while restricting direct external access to the internal state.\n\nHow to achieve encapsulation:\n1. Make fields private (cannot be accessed directly from outside)\n2. Provide public getter/setter methods for controlled access\n3. Add validation logic in setters to enforce business rules\n\nBenefits:\n• Data hiding — internal implementation details are hidden\n• Controlled access — validation can be added to setters\n• Flexibility — can change internal implementation without affecting callers\n• Maintainability — reduces coupling between classes\n• Thread safety — easier to synchronize access through methods\n\nRead-only class: only getters, no setters → immutable-like access\nWrite-only class: only setters (rare) → logging, accumulator",
      "explanation": "Encapsulation is often described as 'data hiding.' The key insight is that by making fields private and controlling access through methods, you maintain control over how your object's state changes. Callers depend on the public API (methods), not the internal implementation (fields). This enables you to change the internal storage without breaking any code that uses your class.",
      "difficulty": "Easy",
      "code": "// BAD — No encapsulation (fields public, no validation)\nclass BadAccount {\n    public double balance; // Anyone can set any value!\n}\nBadAccount bad = new BadAccount();\nbad.balance = -1000000; // No validation, direct access!\n\n// GOOD — Encapsulation: private fields + controlled access\npublic class BankAccount {\n    private String owner;\n    private double balance;\n    private String accountNumber;\n\n    public BankAccount(String owner, double initialBalance) {\n        this.owner   = owner;\n        setBalance(initialBalance); // Use setter for validation\n        this.accountNumber = generateAccountNumber();\n    }\n\n    // Getter — read-only access\n    public double getBalance() {\n        return balance;\n    }\n\n    // Getter — read-only access\n    public String getOwner() {\n        return owner;\n    }\n\n    // No getter for accountNumber — completely hidden\n\n    // Setter with validation\n    private void setBalance(double balance) {\n        if (balance < 0) {\n            throw new IllegalArgumentException(\"Balance cannot be negative\");\n        }\n        this.balance = balance;\n    }\n\n    // Business method — controlled mutation\n    public void deposit(double amount) {\n        if (amount <= 0) throw new IllegalArgumentException(\"Amount must be positive\");\n        this.balance += amount;\n    }\n\n    public void withdraw(double amount) {\n        if (amount > balance) throw new IllegalStateException(\"Insufficient funds\");\n        this.balance -= amount;\n    }\n\n    private String generateAccountNumber() {\n        return \"ACC-\" + System.currentTimeMillis();\n    }\n}\n\nBankAccount acc = new BankAccount(\"Alice\", 1000.0);\nacc.deposit(500);\nacc.withdraw(200);\nSystem.out.println(acc.getBalance()); // 1300.0\n// acc.balance = -999; // COMPILE ERROR — private field!"
    },
    {
      "id": 142,
      "question": "What is abstraction in Java?",
      "answer": "Abstraction is the OOP principle of exposing only essential features of an object while hiding the complex implementation details.\n\nAbstraction focuses on 'WHAT' an object does, not 'HOW' it does it.\n\nHow to achieve abstraction in Java:\n\n1. Abstract classes (abstract keyword):\n• Cannot be instantiated directly\n• Can have abstract methods (no implementation) AND concrete methods\n• Subclasses must implement all abstract methods (or be abstract themselves)\n• Can have constructors, fields, static methods\n\n2. Interfaces:\n• Complete abstraction (Java 7 and earlier: only abstract methods)\n• Java 8+: can have default and static methods (with implementations)\n• Java 9+: can have private methods\n• A class can implement multiple interfaces\n\nDifference — abstract class vs interface:\n• Abstract class: 'is-a' relationship, single inheritance, can have state\n• Interface: 'can-do' relationship, multiple implementation, no instance state\n\nAbstraction vs Encapsulation:\n• Abstraction: hides complexity at design/API level\n• Encapsulation: hides data at implementation level",
      "explanation": "Abstraction defines the contract — what operations are available — without specifying how they work. A List interface is abstraction: you know it has add(), get(), remove() but you don't care if it's an ArrayList or LinkedList. This is the principle behind 'program to an interface, not an implementation.' Abstract classes are useful when you have shared behavior plus required customization points.",
      "difficulty": "Easy",
      "code": "// Abstract class — partial abstraction\npublic abstract class Shape {\n    String color;\n\n    Shape(String color) {\n        this.color = color;\n    }\n\n    // Abstract methods — subclass MUST implement\n    public abstract double area();\n    public abstract double perimeter();\n\n    // Concrete method — shared implementation\n    public void printInfo() {\n        System.out.printf(\"%s [%s] area=%.2f%n\",\n            getClass().getSimpleName(), color, area());\n    }\n}\n\n// Shape shape = new Shape(\"red\"); // COMPILE ERROR — cannot instantiate abstract class\n\nclass Circle extends Shape {\n    double radius;\n    Circle(String color, double radius) {\n        super(color);\n        this.radius = radius;\n    }\n    @Override public double area()      { return Math.PI * radius * radius; }\n    @Override public double perimeter() { return 2 * Math.PI * radius; }\n}\n\nclass Rectangle extends Shape {\n    double width, height;\n    Rectangle(String color, double w, double h) {\n        super(color); this.width = w; this.height = h;\n    }\n    @Override public double area()      { return width * height; }\n    @Override public double perimeter() { return 2 * (width + height); }\n}\n\n// Interface — full abstraction contract\npublic interface Drawable {\n    void draw();                          // Abstract\n    default void show() {                 // Default (Java 8+)\n        System.out.println(\"Showing: \");\n        draw();\n    }\n}\n\n// Using abstraction — program to the interface\nShape s1 = new Circle(\"red\", 5);\nShape s2 = new Rectangle(\"blue\", 4, 6);\nList<Shape> shapes = List.of(s1, s2);\nfor (Shape shape : shapes) {\n    shape.printInfo(); // Calls overridden area() — polymorphism!\n}"
    },
    {
      "id": 143,
      "question": "What are marker interfaces in Java?",
      "answer": "A marker interface (also called tag interface) is an interface with no methods or fields — it's empty. Its sole purpose is to mark or tag a class as having a certain property, which is then checked by the JVM or framework using instanceof.\n\nBuilt-in Java marker interfaces:\n• Serializable (java.io) — marks a class as eligible for serialization\n• Cloneable (java.lang) — marks a class as supporting Object.clone()\n• RandomAccess (java.util) — marks a List as supporting O(1) random access\n• Remote (java.rmi) — marks an object as a remote service\n\nHow they work:\n1. Implement the interface: class MyClass implements Serializable {}\n2. JVM or framework checks: if (obj instanceof Serializable)\n3. If the check passes, special behavior is triggered\n\nModern alternative — Annotations:\n• @Deprecated, @FunctionalInterface, @Override\n• More expressive: can carry data (like @Entity(name=\"users\"))\n• Annotations are generally preferred over marker interfaces today\n\nWhen to still use marker interfaces:\n• When you need to use instanceof checks (type system benefit)\n• When targeting pre-Java 5 code\n• As a type constraint in generics: <T extends Serializable>",
      "explanation": "Marker interfaces use Java's type system to convey intent. Serializable is the classic example — if you forget to implement it, ObjectOutputStream throws NotSerializableException. Annotations replaced much of this role in Java 5, but marker interfaces still have the advantage of compile-time type checking in generics (List<T extends Serializable>) and instanceof checks.",
      "difficulty": "Medium",
      "code": "// Built-in marker interface — Serializable\nimport java.io.Serializable;\n\npublic class User implements Serializable {\n    // serialVersionUID recommended for explicit versioning\n    private static final long serialVersionUID = 1L;\n\n    String name;\n    int    age;\n\n    User(String name, int age) {\n        this.name = name;\n        this.age  = age;\n    }\n}\n\n// Serialize\ntry (ObjectOutputStream oos = new ObjectOutputStream(\n         new FileOutputStream(\"user.ser\"))) {\n    oos.writeObject(new User(\"Alice\", 30)); // Works — Serializable\n}\n\n// Class without Serializable\nclass Config { String host; }  // No Serializable\n// oos.writeObject(new Config()); // NotSerializableException!\n\n// Checking at runtime with instanceof\nObject obj = new User(\"Bob\", 25);\nif (obj instanceof Serializable) {\n    System.out.println(\"Can serialize this object\");\n}\n\n// Custom marker interface\npublic interface Auditable {\n    // No methods — just marks the class for audit logging\n}\n\npublic class Order implements Auditable {\n    String orderId;\n    double amount;\n}\n\n// Framework/service checks the marker\npublic class AuditService {\n    public void save(Object entity) {\n        if (entity instanceof Auditable) {\n            log(\"Saving auditable entity: \" + entity.getClass().getName());\n        }\n        // proceed with save...\n    }\n    private void log(String message) { System.out.println(message); }\n}\n\n// Modern alternative: annotation\n@interface AuditableAnnotation {}  // No body\n@AuditableAnnotation\npublic class Product { String id; }"
    },
    {
      "id": 144,
      "question": "What is method overriding in Java?",
      "answer": "Method overriding is when a subclass provides its own implementation of a method that is already defined in its parent class.\n\nRules for overriding:\n1. Same method name\n2. Same parameter list (same signature)\n3. Same or covariant return type (return type can be a subtype)\n4. Access modifier cannot be more restrictive (can be same or broader)\n5. Cannot throw new or broader checked exceptions\n6. Method must not be static, final, or private in parent (those cannot be overridden)\n7. @Override annotation is strongly recommended (compile-time check)\n\nRuntime polymorphism:\n• Which method runs is determined at runtime, not compile time\n• Based on the actual object type, not the reference type\n• Also called dynamic method dispatch\n\nsuper.method() in overriding:\n• Calls the parent's version of the method from within the override",
      "explanation": "Method overriding is the foundation of runtime polymorphism in Java. When you call a method on a reference, Java looks up the actual class of the object at runtime and calls that class's version. This is what enables List<Shape> to call the correct area() for each shape. @Override is critical — it catches bugs where you think you're overriding but have the wrong signature (you're actually overloading).",
      "difficulty": "Easy",
      "code": "class Animal {\n    String name;\n    Animal(String name) { this.name = name; }\n\n    // Method to be overridden\n    public String sound() {\n        return \"...\";\n    }\n\n    public void describe() {\n        System.out.println(name + \" says: \" + sound()); // Calls overridden version!\n    }\n}\n\nclass Dog extends Animal {\n    Dog(String name) { super(name); }\n\n    @Override // Annotation verifies we're actually overriding\n    public String sound() {\n        return \"Woof!\";\n    }\n}\n\nclass Cat extends Animal {\n    Cat(String name) { super(name); }\n\n    @Override\n    public String sound() {\n        return \"Meow!\";\n    }\n}\n\n// Runtime polymorphism — method called depends on ACTUAL type\nAnimal a1 = new Dog(\"Rex\");  // Dog object, Animal reference\nAnimal a2 = new Cat(\"Kitty\");\nAnimal a3 = new Animal(\"Generic\");\n\na1.describe(); // Rex says: Woof!   — Dog.sound() called\na2.describe(); // Kitty says: Meow! — Cat.sound() called\na3.describe(); // Generic says: ... — Animal.sound() called\n\n// Calling parent's version with super\nclass Puppy extends Dog {\n    Puppy(String name) { super(name); }\n\n    @Override\n    public String sound() {\n        return super.sound() + super.sound(); // Calls Dog.sound()\n    }\n}\nnew Puppy(\"Spot\").describe(); // Spot says: Woof!Woof!\n\n// @Override prevents bugs\nclass BadDog extends Animal {\n    BadDog(String name) { super(name); }\n    // @Override\n    public String Sound() { // Wrong name! Without @Override this compiles but doesn't override\n        return \"Woof\";\n    }\n}\nnew BadDog(\"Bad\").describe(); // Bad says: ... — Bug! Sound() never called"
    },
    {
      "id": 145,
      "question": "What is the super class of all classes in Java?",
      "answer": "java.lang.Object is the super class of all classes in Java. Every class you define, either explicitly or implicitly, extends Object.\n\nIf you write: class MyClass {}  — Java treats it as: class MyClass extends Object {}\n\nKey methods provided by Object (available to ALL objects):\n\n1. toString() — String representation. Default: ClassName@hexHashCode\n2. equals(Object obj) — Logical equality. Default: reference comparison (==)\n3. hashCode() — Hash code for hash-based collections. Must be consistent with equals()\n4. getClass() — Returns the runtime Class object\n5. clone() — Creates a copy (requires Cloneable)\n6. finalize() — Called by GC before collection (deprecated in Java 9, removed in 18)\n7. wait() / notify() / notifyAll() — Thread synchronization primitives\n\nequals() and hashCode() contract:\n• If a.equals(b) is true, then a.hashCode() == b.hashCode() must be true\n• The reverse is not required (hash collisions are allowed)\n• Always override both together — never just one",
      "explanation": "Object being the root class means every Java object has these methods. toString() and equals()/hashCode() are the most commonly overridden. IDEs can generate them automatically. The equals/hashCode contract is critical for correct behavior in HashMap, HashSet, etc. — if you override equals but not hashCode, objects that are equal may not be found in hash-based collections.",
      "difficulty": "Easy",
      "code": "// Every class implicitly extends Object\nclass MyClass {\n    // Implicitly: extends Object\n}\n\n// All Object methods are available\nMyClass obj = new MyClass();\nSystem.out.println(obj.toString());    // MyClass@1b6d3586 (default)\nSystem.out.println(obj.hashCode());    // Integer hash\nSystem.out.println(obj.getClass());    // class MyClass\nSystem.out.println(obj.equals(obj));   // true\n\n// Overriding Object methods\npublic class Person {\n    String name;\n    int age;\n\n    Person(String name, int age) {\n        this.name = name; this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person{name='\" + name + \"', age=\" + age + \"}\";\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;            // Same reference\n        if (!(obj instanceof Person)) return false; // Type check\n        Person other = (Person) obj;\n        return age == other.age && Objects.equals(name, other.name);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(name, age);          // Must be consistent with equals!\n    }\n}\n\nPerson p1 = new Person(\"Alice\", 30);\nPerson p2 = new Person(\"Alice\", 30);\nSystem.out.println(p1.equals(p2));             // true (overridden equals)\nSystem.out.println(p1.hashCode() == p2.hashCode()); // true (contract respected)\n\n// Without overriding — default behavior\nMyClass a = new MyClass();\nMyClass b = new MyClass();\nSystem.out.println(a.equals(b));  // false (same as a == b, different objects)\n\n// getClass() vs instanceof\nObject o = new String(\"hi\");\nSystem.out.println(o.getClass() == String.class); // true — exact type\nSystem.out.println(o instanceof CharSequence);    // true — type hierarchy"
    },
    {
      "id": 146,
      "question": "What is the difference between the == operator and the equals() method in Java?",
      "answer": "== operator:\n• Compares references (memory addresses) for objects\n• Compares actual values for primitives\n• For objects: true only if both variables point to the SAME object in memory\n• Cannot be overridden\n\nequals() method:\n• Defined in Object class — default behavior is same as ==\n• Meant to compare logical equality (content/value)\n• Should be overridden by classes to provide meaningful comparison\n• String, Integer, and most standard classes override it to compare values\n\nKey examples:\n• Two String literals with same value: == may be true (String pool), but use equals() for safety\n• Two new String(\"abc\"): == is false (different objects), equals() is true\n• Primitives: == always compares values (only option — primitives can't call methods)\n\nRule of thumb:\n• Always use equals() to compare object content\n• Use == only to check if two references point to the same object, or for null checks (obj == null)",
      "explanation": "The == vs equals() confusion is one of Java's most common bugs. String comparison is the classic example: 'hello' == 'hello' may be true due to String pool interning, but 'new String(\"hello\") == new String(\"hello\")' is always false. Always use equals() for content comparison. For null-safe comparison, use Objects.equals(a, b) which handles null gracefully.",
      "difficulty": "Easy",
      "code": "// PRIMITIVES — == compares values\nint a = 5, b = 5;\nSystem.out.println(a == b); // true — same value\n\n// STRINGS — tricky!\nString s1 = \"hello\";        // String pool literal\nString s2 = \"hello\";        // Same pool reference (might be same object)\nString s3 = new String(\"hello\"); // Explicit new object — different reference\n\nSystem.out.println(s1 == s2);       // true  — same pool object (but not guaranteed!)\nSystem.out.println(s1 == s3);       // false — different objects\nSystem.out.println(s1.equals(s2));  // true  — same content\nSystem.out.println(s1.equals(s3));  // true  — same content\n\n// OBJECTS — == compares references\nclass Point { int x, y; Point(int x, int y){this.x=x; this.y=y;} }\nPoint p1 = new Point(1, 2);\nPoint p2 = new Point(1, 2);\nPoint p3 = p1; // Same reference!\n\nSystem.out.println(p1 == p2);        // false — different objects\nSystem.out.println(p1 == p3);        // true  — same reference\nSystem.out.println(p1.equals(p2));   // false — Object.equals() not overridden, falls back to ==\n\n// After overriding equals in Point:\n// System.out.println(p1.equals(p2)); // true  — if overridden to compare x and y\n\n// Integer cache (gotcha!)\nInteger i1 = 127;\nInteger i2 = 127;\nSystem.out.println(i1 == i2);       // true  — cached!\nInteger i3 = 128;\nInteger i4 = 128;\nSystem.out.println(i3 == i4);       // false — not cached, different objects\nSystem.out.println(i3.equals(i4));  // true  — always use equals!\n\n// Null safe comparison\nString name = null;\n// name.equals(\"Alice\") — NullPointerException!\n\"Alice\".equals(name);               // false — safe (no NPE)\nObjects.equals(name, \"Alice\");      // false — null-safe utility method\nObjects.equals(null, null);         // true"
    },
    {
      "id": 147,
      "question": "What is the difference between method overloading and method overriding?",
      "answer": "Overloading (Compile-time polymorphism):\n• Multiple methods with the SAME name but DIFFERENT parameter lists in the SAME class\n• Return type can differ (but alone is not enough to distinguish)\n• Resolved at compile time by the compiler (static binding)\n• Can overload constructors too\n• Not related to inheritance\n\nOverriding (Runtime polymorphism):\n• Subclass provides its own implementation of a method from the PARENT class\n• SAME name, SAME parameter list, same/covariant return type\n• Resolved at runtime based on actual object type (dynamic binding)\n• Requires inheritance (@Override annotation recommended)\n• access modifier cannot be more restrictive; exceptions cannot be broader\n\nKey differences:\n| Aspect        | Overloading          | Overriding                |\n|---------------|----------------------|---------------------------|\n| Where         | Same class           | Parent-child classes      |\n| Parameters    | Must differ          | Must be same              |\n| Return type   | Can differ           | Same or covariant         |\n| Binding       | Compile time (early) | Runtime (late)            |\n| Inheritance   | Not needed           | Required                  |\n| @Override     | Not applicable       | Strongly recommended      |",
      "explanation": "Overloading = same name, different signatures (parameters). Overriding = same signature, different class in hierarchy. Overloading is resolved by the compiler at compile time (which overload to call is decided based on declared parameter types). Overriding is resolved by the JVM at runtime (which version of the method to call is decided by the actual object type). This is why overriding enables polymorphism.",
      "difficulty": "Medium",
      "code": "// OVERLOADING — same class, different parameter lists\npublic class Calculator {\n    // Same name 'add', different parameters\n    public int add(int a, int b) {\n        return a + b;\n    }\n    public double add(double a, double b) {\n        return a + b;\n    }\n    public int add(int a, int b, int c) {\n        return a + b + c;\n    }\n    public String add(String a, String b) {\n        return a + b;  // String concatenation\n    }\n}\n\nCalculator calc = new Calculator();\ncalc.add(1, 2);           // Calls int version\ncalc.add(1.0, 2.0);       // Calls double version\ncalc.add(1, 2, 3);        // Calls 3-param version\ncalc.add(\"Hi\", \" World\"); // Calls String version\n// Resolved at COMPILE TIME based on argument types\n\n// OVERRIDING — parent-child, same signature\nclass Animal {\n    public String speak() { return \"...\"; }\n}\nclass Dog extends Animal {\n    @Override\n    public String speak() { return \"Woof!\"; } // Same signature, different class\n}\nclass Cat extends Animal {\n    @Override\n    public String speak() { return \"Meow!\"; }\n}\n\n// Resolved at RUNTIME based on actual object\nAnimal a = new Dog(); // Reference type: Animal, Object type: Dog\nSystem.out.println(a.speak()); // Woof! — Dog.speak() called at runtime\na = new Cat();\nSystem.out.println(a.speak()); // Meow! — Cat.speak() called at runtime\n\n// Return type alone cannot distinguish overloads:\nclass Bad {\n    // int compute()    { return 1; }  // COMPILE ERROR if both exist\n    // double compute() { return 1.0; }// Same name + same params = duplicate method\n}"
    },
    {
      "id": 148,
      "question": "Can static methods be overridden in Java?",
      "answer": "No. Static methods cannot be overridden — they can only be hidden (method hiding).\n\nWhy?\n• Overriding is resolved at runtime based on the OBJECT's actual type (dynamic dispatch)\n• Static methods belong to the CLASS, not to any instance\n• Static method calls are resolved at compile time based on the REFERENCE type (static binding)\n• There is no dynamic dispatch for static methods\n\nMethod hiding (NOT overriding):\n• If you define a static method in a subclass with the same signature as a static method in the parent, it hides the parent's method\n• The method that is called depends on the REFERENCE TYPE, not the object type\n• @Override annotation on a static method causes a COMPILE ERROR (correctly flagging this)\n\nKey difference:\n• Overriding: call depends on the actual runtime object type\n• Hiding: call depends on the compile-time reference type\n\nStatic context rules:\n• private methods are also not overridden (they're not visible to subclasses)\n• final methods cannot be overridden\n• static methods are hidden, not overridden",
      "explanation": "Method hiding vs overriding is a subtle but important Java distinction. In true overriding, Animal ref = new Dog(); ref.speak() calls Dog.speak() because of dynamic dispatch. With static method hiding, Animal ref = new Dog(); Animal.staticMethod() (or ref.staticMethod()) calls Animal's version — the reference type determines the call, not the actual object. @Override on a static method fails to compile, which is the clearest indication that it's not overriding.",
      "difficulty": "Medium",
      "code": "class Parent {\n    // Static method\n    public static void staticMethod() {\n        System.out.println(\"Parent.staticMethod()\");\n    }\n\n    // Instance method\n    public void instanceMethod() {\n        System.out.println(\"Parent.instanceMethod()\");\n    }\n}\n\nclass Child extends Parent {\n    // This HIDES Parent.staticMethod() — NOT overriding!\n    public static void staticMethod() {\n        System.out.println(\"Child.staticMethod()\");\n    }\n\n    // This OVERRIDES Parent.instanceMethod()\n    @Override\n    public void instanceMethod() {\n        System.out.println(\"Child.instanceMethod()\");\n    }\n\n    // @Override\n    // public static void staticMethod() { ... }\n    // COMPILE ERROR: static methods cannot be annotated @Override\n}\n\n// Reference type = Parent, Object type = Child\nParent obj = new Child();\n\n// Static method call — resolved by REFERENCE TYPE (method hiding)\nobj.staticMethod();    // Parent.staticMethod() — calls PARENT's version!\nParent.staticMethod(); // Parent.staticMethod()\nChild.staticMethod();  // Child.staticMethod()  — direct class call\n\n// Instance method call — resolved by OBJECT TYPE (overriding)\nobj.instanceMethod();  // Child.instanceMethod() — calls CHILD's version!\n\n// Summary:\n// Static:   Parent ref → Parent's staticMethod()  (hiding, compile-time binding)\n// Instance: Parent ref → Child's instanceMethod() (overriding, runtime binding)\n\n// Attempting to use @Override on static method:\nclass AnotherChild extends Parent {\n    // @Override                 // COMPILE ERROR: Method does not override\n    public static void staticMethod() {\n        System.out.println(\"Hiding, not overriding!\");\n    }\n}"
    }
  ]
}