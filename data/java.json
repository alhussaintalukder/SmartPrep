{
  "topic": "Java",
  "questions": [
    {
      "id": 1,
      "question": "What is the difference between JDK, JRE, and JVM?",
      "answer": "JVM (Java Virtual Machine): Executes Java bytecode and provides platform independence.\n\nJRE (Java Runtime Environment): Contains JVM + libraries needed to run Java applications.\n\nJDK (Java Development Kit): Contains JRE + development tools (compiler, debugger) to develop Java applications.",
      "explanation": "Think of it as layers: JVM is the core engine, JRE wraps it with libraries for running apps, and JDK adds development tools on top. You need JDK to develop, JRE to run, and JVM is always running underneath.",
      "difficulty": "Easy",
      "code": "// Check Java version\njava -version  // Shows JRE version\njavac -version // Shows JDK version (compiler)"
    },
    {
      "id": 2,
      "question": "What are the main principles of OOP in Java?",
      "answer": "The four main principles are:\n\n1. Encapsulation: Bundling data and methods together, hiding internal state using access modifiers.\n\n2. Inheritance: A class can inherit properties and methods from another class using 'extends'.\n\n3. Polymorphism: Objects can take multiple forms - method overloading (compile-time) and overriding (runtime).\n\n4. Abstraction: Hiding complex implementation details, showing only necessary features using abstract classes and interfaces.",
      "explanation": "These principles help create modular, reusable, and maintainable code. Encapsulation protects data, inheritance promotes code reuse, polymorphism enables flexibility, and abstraction simplifies complexity.",
      "difficulty": "Easy"
    },
    {
      "id": 3,
      "question": "What is the difference between == and .equals() in Java?",
      "answer": "== compares references (memory addresses) - checks if two variables point to the same object.\n\n.equals() compares values/content - checks if two objects are logically equal.\n\nFor primitives, == compares values directly. For objects, always use .equals() for content comparison.",
      "explanation": "This is a common source of bugs. String s1 = new String(\"hello\"); String s2 = new String(\"hello\"); s1 == s2 is false (different objects), but s1.equals(s2) is true (same content).",
      "difficulty": "Easy",
      "code": "String s1 = new String(\"hello\");\nString s2 = new String(\"hello\");\n\nSystem.out.println(s1 == s2);      // false (different objects)\nSystem.out.println(s1.equals(s2)); // true (same content)\n\n// String pool exception\nString s3 = \"hello\";\nString s4 = \"hello\";\nSystem.out.println(s3 == s4);      // true (same pool reference)"
    },
    {
      "id": 4,
      "question": "What is the difference between Abstract Class and Interface?",
      "answer": "Abstract Class:\n• Can have abstract and concrete methods\n• Can have instance variables\n• Single inheritance only\n• Can have constructors\n• Use 'extends' keyword\n\nInterface:\n• All methods are abstract (before Java 8)\n• Can have default and static methods (Java 8+)\n• Only constants (public static final)\n• Multiple inheritance supported\n• Use 'implements' keyword",
      "explanation": "Use abstract class when classes share common behavior with some implementation. Use interface to define a contract that multiple unrelated classes can implement. Since Java 8, interfaces can have default methods, blurring the line.",
      "difficulty": "Medium",
      "code": "// Abstract Class\nabstract class Animal {\n    String name;\n    abstract void sound();\n    void sleep() { System.out.println(\"Sleeping...\"); }\n}\n\n// Interface\ninterface Flyable {\n    void fly();\n    default void land() { System.out.println(\"Landing...\"); }\n}\n\nclass Bird extends Animal implements Flyable {\n    void sound() { System.out.println(\"Chirp\"); }\n    public void fly() { System.out.println(\"Flying\"); }\n}"
    },
    {
      "id": 5,
      "question": "What is the String Pool in Java?",
      "answer": "String Pool is a special memory area in the heap where Java stores String literals. When you create a String literal, Java first checks if it exists in the pool. If yes, it returns the reference; if no, it creates a new String in the pool.\n\nThis saves memory by reusing immutable String objects.",
      "explanation": "String pool is why s1 == s2 returns true for literals but false for new String(). The intern() method can add strings to the pool manually.",
      "difficulty": "Medium",
      "code": "String s1 = \"hello\";  // Goes to String Pool\nString s2 = \"hello\";  // Returns same reference from pool\nString s3 = new String(\"hello\"); // Creates new object in heap\n\nSystem.out.println(s1 == s2);  // true\nSystem.out.println(s1 == s3);  // false\nSystem.out.println(s1 == s3.intern()); // true (intern adds to pool)"
    },
    {
      "id": 6,
      "question": "What are the differences between ArrayList and LinkedList?",
      "answer": "ArrayList:\n• Backed by dynamic array\n• Fast random access O(1)\n• Slow insertion/deletion O(n) - needs shifting\n• Less memory overhead\n• Better for read-heavy operations\n\nLinkedList:\n• Doubly linked list structure\n• Slow random access O(n)\n• Fast insertion/deletion O(1) at known position\n• More memory (stores prev/next pointers)\n• Better for frequent add/remove operations",
      "explanation": "Choose ArrayList for most cases due to cache locality and random access. Use LinkedList only when you need frequent insertions/deletions at the beginning or middle of the list.",
      "difficulty": "Medium",
      "code": "List<String> arrayList = new ArrayList<>();\narrayList.add(\"A\");     // O(1) amortized\narrayList.get(0);       // O(1) - fast\narrayList.remove(0);    // O(n) - slow, needs shifting\n\nList<String> linkedList = new LinkedList<>();\nlinkedList.add(\"A\");    // O(1)\nlinkedList.get(0);      // O(n) - slow, traversal\nlinkedList.removeFirst(); // O(1) - fast"
    },
    {
      "id": 7,
      "question": "What is the difference between HashMap and HashTable?",
      "answer": "HashMap:\n• Not synchronized (not thread-safe)\n• Allows one null key and multiple null values\n• Faster performance\n• Part of Collections framework\n• Use ConcurrentHashMap for thread-safety\n\nHashTable:\n• Synchronized (thread-safe)\n• Does not allow null keys or values\n• Slower due to synchronization\n• Legacy class\n• Considered obsolete",
      "explanation": "Always prefer HashMap over HashTable. For thread-safety, use ConcurrentHashMap which provides better performance than HashTable through segment-level locking.",
      "difficulty": "Medium",
      "code": "// HashMap - preferred\nMap<String, Integer> hashMap = new HashMap<>();\nhashMap.put(null, 1);  // OK\nhashMap.put(\"key\", null); // OK\n\n// HashTable - legacy, avoid\nMap<String, Integer> hashTable = new Hashtable<>();\n// hashTable.put(null, 1);  // NullPointerException\n\n// For thread-safety, use:\nMap<String, Integer> concurrentMap = new ConcurrentHashMap<>();"
    },
    {
      "id": 8,
      "question": "What is the difference between final, finally, and finalize?",
      "answer": "final:\n• Keyword to declare constants, prevent inheritance, or prevent method overriding\n• final variable = constant\n• final method = cannot override\n• final class = cannot extend\n\nfinally:\n• Block that always executes after try-catch\n• Used for cleanup (closing resources)\n\nfinalize:\n• Method called by garbage collector before destroying object\n• Deprecated in Java 9+, avoid using",
      "explanation": "These three have completely different purposes despite similar names. 'final' is for immutability, 'finally' for cleanup, and 'finalize' was for pre-destruction cleanup (now deprecated).",
      "difficulty": "Easy",
      "code": "// final\nfinal int MAX = 100;  // constant\nfinal class Utility {} // cannot extend\n\n// finally\ntry {\n    // code\n} catch (Exception e) {\n    // handle\n} finally {\n    // always runs - cleanup\n}\n\n// finalize (deprecated)\n@Override\nprotected void finalize() throws Throwable {\n    // cleanup before GC\n}"
    },
    {
      "id": 9,
      "question": "What is Java Garbage Collection and how does it work?",
      "answer": "Garbage Collection (GC) is automatic memory management that identifies and removes objects no longer in use.\n\nHow it works:\n1. Mark: Identifies reachable objects from GC roots\n2. Sweep: Removes unmarked (unreachable) objects\n3. Compact: Defragments memory (optional)\n\nGenerations:\n• Young Generation: New objects, frequent GC (Minor GC)\n• Old Generation: Long-lived objects, less frequent GC (Major GC)\n• Metaspace: Class metadata (replaced PermGen in Java 8)",
      "explanation": "GC eliminates memory leaks and manual memory management. However, you cannot force GC - System.gc() is only a suggestion. Understanding GC helps optimize application performance.",
      "difficulty": "Medium"
    },
    {
      "id": 10,
      "question": "What are Java Streams and how do they work?",
      "answer": "Streams are a sequence of elements supporting sequential and parallel aggregate operations. Introduced in Java 8.\n\nKey characteristics:\n• Not a data structure - processes data from sources\n• Lazy evaluation - intermediate operations not executed until terminal operation\n• Can be parallelized easily\n• Cannot be reused after terminal operation\n\nOperations:\n• Intermediate: filter, map, sorted (return Stream)\n• Terminal: collect, forEach, reduce (produce result)",
      "explanation": "Streams enable functional-style operations on collections. They make code more readable and can be parallelized for better performance on multi-core processors.",
      "difficulty": "Medium",
      "code": "List<String> names = Arrays.asList(\"John\", \"Jane\", \"Bob\", \"Alice\");\n\n// Filter, transform, collect\nList<String> result = names.stream()\n    .filter(n -> n.startsWith(\"J\"))  // intermediate\n    .map(String::toUpperCase)         // intermediate\n    .sorted()                          // intermediate\n    .collect(Collectors.toList());    // terminal\n\n// Result: [\"JANE\", \"JOHN\"]\n\n// Parallel processing\nnames.parallelStream()\n    .forEach(System.out::println);"
    },
    {
      "id": 11,
      "question": "What is the difference between Checked and Unchecked Exceptions?",
      "answer": "Checked Exceptions:\n• Checked at compile-time\n• Must be handled (try-catch) or declared (throws)\n• Extend Exception class\n• Examples: IOException, SQLException\n\nUnchecked Exceptions:\n• Not checked at compile-time\n• No mandatory handling required\n• Extend RuntimeException\n• Examples: NullPointerException, ArrayIndexOutOfBoundsException",
      "explanation": "Checked exceptions force you to handle predictable errors (file not found, network issues). Unchecked exceptions are programming errors that should be fixed in code rather than caught.",
      "difficulty": "Easy",
      "code": "// Checked - must handle\npublic void readFile() throws IOException {\n    FileReader fr = new FileReader(\"file.txt\");\n}\n\n// Or use try-catch\npublic void readFile() {\n    try {\n        FileReader fr = new FileReader(\"file.txt\");\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n\n// Unchecked - no mandatory handling\npublic void process() {\n    String s = null;\n    s.length(); // NullPointerException - runtime error\n}"
    },
    {
      "id": 12,
      "question": "What is the difference between method overloading and overriding?",
      "answer": "Method Overloading:\n• Same method name, different parameters\n• Compile-time polymorphism\n• Within the same class\n• Return type can be different\n• Access modifier can be different\n\nMethod Overriding:\n• Same method signature in parent and child class\n• Runtime polymorphism\n• Between parent and child class\n• Return type must be same or covariant\n• Access modifier cannot be more restrictive",
      "explanation": "Overloading provides multiple ways to call a method with different arguments. Overriding allows child class to provide specific implementation of a method already defined in parent class.",
      "difficulty": "Easy",
      "code": "// Overloading - same class, different params\nclass Calculator {\n    int add(int a, int b) { return a + b; }\n    double add(double a, double b) { return a + b; }\n    int add(int a, int b, int c) { return a + b + c; }\n}\n\n// Overriding - child class changes behavior\nclass Animal {\n    void sound() { System.out.println(\"Some sound\"); }\n}\n\nclass Dog extends Animal {\n    @Override\n    void sound() { System.out.println(\"Bark\"); }\n}"
    },
    {
      "id": 13,
      "question": "What is the volatile keyword in Java?",
      "answer": "volatile is a keyword used in multi-threading to ensure that a variable's value is always read from main memory, not from thread's local cache.\n\nEffects:\n• Guarantees visibility across threads\n• Prevents caching of variable in CPU registers\n• Ensures happens-before relationship\n• Does NOT provide atomicity\n\nUse when:\n• Variable is accessed by multiple threads\n• No compound operations (i++ is not atomic)",
      "explanation": "Without volatile, threads may see stale values due to CPU caching. volatile solves visibility but not atomicity - for atomic operations use AtomicInteger or synchronized.",
      "difficulty": "Hard",
      "code": "class SharedResource {\n    // Without volatile - threads may not see updates\n    private boolean running = true;\n    \n    // With volatile - guaranteed visibility\n    private volatile boolean flag = true;\n    \n    public void stop() {\n        flag = false; // Other threads will see this immediately\n    }\n    \n    public void run() {\n        while (flag) {\n            // work\n        }\n    }\n}"
    },
    {
      "id": 14,
      "question": "What is the difference between synchronized block and method?",
      "answer": "Synchronized Method:\n• Locks the entire method\n• Lock on 'this' object (instance method) or Class object (static method)\n• Simple syntax\n• Less granular control\n\nSynchronized Block:\n• Locks only specific code section\n• Can lock on any object\n• More granular control\n• Better performance (less locking time)\n• Can have different locks for different blocks",
      "explanation": "Prefer synchronized blocks for finer control and better performance. Synchronized methods lock the entire method which may be overkill and can cause unnecessary thread contention.",
      "difficulty": "Medium",
      "code": "// Synchronized method - locks 'this'\npublic synchronized void method1() {\n    // entire method is synchronized\n}\n\n// Synchronized block - more control\npublic void method2() {\n    // non-synchronized code\n    synchronized(this) {\n        // only this block is synchronized\n    }\n    // more non-synchronized code\n}\n\n// Different locks for different resources\nprivate final Object lock1 = new Object();\nprivate final Object lock2 = new Object();\n\npublic void method3() {\n    synchronized(lock1) { /* access resource1 */ }\n    synchronized(lock2) { /* access resource2 */ }\n}"
    },
    {
      "id": 15,
      "question": "What is the Java Memory Model?",
      "answer": "Java Memory Model (JMM) defines how threads interact through memory and what behaviors are allowed in concurrent execution.\n\nKey areas:\n• Heap: Shared memory for objects (all threads access)\n• Stack: Thread-local memory for method calls and local variables\n• Metaspace: Class metadata\n\nKey concepts:\n• Happens-before relationship\n• Visibility guarantees\n• Atomicity rules\n• Ordering guarantees",
      "explanation": "JMM ensures predictable behavior in multi-threaded programs. It defines when changes made by one thread become visible to others and prevents certain compiler/hardware optimizations that could break thread safety.",
      "difficulty": "Hard"
    },
    {
      "id": 16,
      "question": "What are Functional Interfaces in Java?",
      "answer": "A Functional Interface is an interface with exactly one abstract method. It can have multiple default or static methods.\n\nUsed as target types for lambda expressions and method references.\n\nBuilt-in examples:\n• Runnable: void run()\n• Callable<V>: V call()\n• Comparator<T>: int compare(T, T)\n• Function<T,R>: R apply(T)\n• Predicate<T>: boolean test(T)\n• Consumer<T>: void accept(T)\n• Supplier<T>: T get()",
      "explanation": "Functional interfaces enable functional programming in Java. The @FunctionalInterface annotation is optional but helps catch errors if you accidentally add more abstract methods.",
      "difficulty": "Medium",
      "code": "@FunctionalInterface\ninterface Calculator {\n    int calculate(int a, int b);\n    \n    // default methods are allowed\n    default void print() { }\n}\n\n// Using with lambda\nCalculator add = (a, b) -> a + b;\nCalculator multiply = (a, b) -> a * b;\n\nSystem.out.println(add.calculate(5, 3));      // 8\nSystem.out.println(multiply.calculate(5, 3)); // 15\n\n// Built-in functional interfaces\nPredicate<String> isEmpty = s -> s.isEmpty();\nFunction<String, Integer> length = String::length;\nConsumer<String> printer = System.out::println;"
    },
    {
      "id": 17,
      "question": "What is Optional in Java and why use it?",
      "answer": "Optional<T> is a container object that may or may not contain a non-null value. Introduced in Java 8 to avoid NullPointerException.\n\nKey methods:\n• Optional.of(value) - creates Optional, throws if null\n• Optional.ofNullable(value) - creates Optional, allows null\n• Optional.empty() - creates empty Optional\n• isPresent() - checks if value exists\n• orElse(default) - returns value or default\n• orElseThrow() - returns value or throws exception\n• map(), flatMap() - transform value",
      "explanation": "Optional forces developers to explicitly handle the absence of a value, making code more expressive and reducing null checks. It's particularly useful as return type for methods that might not return a value.",
      "difficulty": "Medium",
      "code": "// Without Optional - null checks everywhere\nString name = user.getName();\nif (name != null) {\n    System.out.println(name.toUpperCase());\n}\n\n// With Optional - cleaner\nOptional<String> optName = Optional.ofNullable(user.getName());\noptName.ifPresent(n -> System.out.println(n.toUpperCase()));\n\n// Chain operations\nString result = Optional.ofNullable(user)\n    .map(User::getName)\n    .map(String::toUpperCase)\n    .orElse(\"UNKNOWN\");\n\n// Method returning Optional\npublic Optional<User> findById(Long id) {\n    User user = repository.find(id);\n    return Optional.ofNullable(user);\n}"
    },
    {
      "id": 18,
      "question": "What is the difference between Comparable and Comparator?",
      "answer": "Comparable:\n• Interface implemented by the class itself\n• Single sorting sequence (natural ordering)\n• compareTo(Object o) method\n• Modifies the original class\n• java.lang package\n\nComparator:\n• Separate class for comparison logic\n• Multiple sorting sequences possible\n• compare(Object o1, Object o2) method\n• Does not modify original class\n• java.util package",
      "explanation": "Use Comparable for natural/default ordering (like String, Integer). Use Comparator when you need multiple sort orders or can't modify the class being sorted.",
      "difficulty": "Medium",
      "code": "// Comparable - natural ordering\nclass Employee implements Comparable<Employee> {\n    String name;\n    int salary;\n    \n    @Override\n    public int compareTo(Employee e) {\n        return this.salary - e.salary; // sort by salary\n    }\n}\n\n// Comparator - custom ordering\nComparator<Employee> byName = (e1, e2) -> e1.name.compareTo(e2.name);\nComparator<Employee> bySalaryDesc = (e1, e2) -> e2.salary - e1.salary;\n\n// Using\nCollections.sort(employees);           // uses Comparable\nCollections.sort(employees, byName);   // uses Comparator\nemployees.sort(bySalaryDesc);          // Java 8+ List.sort"
    },
    {
      "id": 19,
      "question": "What is the difference between fail-fast and fail-safe iterators?",
      "answer": "Fail-Fast Iterators:\n• Throw ConcurrentModificationException if collection modified during iteration\n• Work on original collection\n• Examples: ArrayList, HashMap iterators\n• Faster, less memory\n\nFail-Safe Iterators:\n• Do not throw exception on modification\n• Work on a copy of the collection\n• Examples: CopyOnWriteArrayList, ConcurrentHashMap\n• Slower, more memory (due to copying)",
      "explanation": "Fail-fast helps detect bugs early in single-threaded scenarios. Fail-safe is designed for concurrent access but may not reflect latest changes during iteration.",
      "difficulty": "Hard",
      "code": "// Fail-Fast - ArrayList\nList<String> list = new ArrayList<>();\nlist.add(\"A\"); list.add(\"B\");\n\nfor (String s : list) {\n    list.remove(s); // ConcurrentModificationException!\n}\n\n// Fail-Safe - CopyOnWriteArrayList\nList<String> safeList = new CopyOnWriteArrayList<>();\nsafeList.add(\"A\"); safeList.add(\"B\");\n\nfor (String s : safeList) {\n    safeList.remove(s); // OK - works on copy\n}\n\n// Safe removal with iterator\nIterator<String> it = list.iterator();\nwhile (it.hasNext()) {\n    it.next();\n    it.remove(); // Safe way to remove\n}"
    },
    {
      "id": 20,
      "question": "What is the difference between wait() and sleep()?",
      "answer": "wait():\n• Defined in Object class\n• Releases the lock/monitor\n• Must be called from synchronized context\n• Wakes up by notify()/notifyAll() or timeout\n• Used for inter-thread communication\n\nsleep():\n• Defined in Thread class\n• Does NOT release the lock\n• Can be called from anywhere\n• Wakes up after specified time\n• Used to pause execution for a duration",
      "explanation": "wait() is for thread coordination - a thread waits for a condition and releases the lock for others. sleep() just pauses the current thread without affecting locks.",
      "difficulty": "Medium",
      "code": "// wait() - releases lock, needs synchronized\nsynchronized(lock) {\n    while (!condition) {\n        lock.wait(); // releases lock, waits\n    }\n    // proceed when notified\n}\n\n// notify from another thread\nsynchronized(lock) {\n    condition = true;\n    lock.notify(); // wakes up waiting thread\n}\n\n// sleep() - does NOT release lock\nsynchronized(lock) {\n    Thread.sleep(1000); // still holds lock!\n}"
    },
    {
      "id": 21,
      "question": "What is the static keyword in Java?",
      "answer": "static is a keyword that belongs to the class rather than instance.\n\nCan be applied to:\n• Variables: Shared by all instances, one copy per class\n• Methods: Can be called without creating instance\n• Blocks: Executed once when class is loaded\n• Nested classes: Can be instantiated without outer class instance\n\nCharacteristics:\n• Cannot access non-static members directly\n• Loaded at class loading time\n• Memory efficient (single copy)",
      "explanation": "static members are useful for constants, utility methods, and counters that should be shared across all instances. Main method is static so JVM can call it without creating object.",
      "difficulty": "Easy",
      "code": "class Counter {\n    static int count = 0;  // Shared by all instances\n    int id;\n    \n    Counter() {\n        count++;  // Increment shared counter\n        id = count;\n    }\n    \n    static void displayCount() {  // Static method\n        System.out.println(\"Total: \" + count);\n        // System.out.println(id);  // Error: can't access non-static\n    }\n    \n    static {  // Static block\n        System.out.println(\"Class loaded\");\n    }\n}\n\n// Usage\nCounter.displayCount();  // Call without instance\nCounter c1 = new Counter();\nCounter c2 = new Counter();\nCounter.count;  // 2"
    },
    {
      "id": 22,
      "question": "What is the difference between this and super keywords?",
      "answer": "this:\n• Refers to current instance of the class\n• Access current class members\n• Call current class constructor (this())\n• Used to differentiate between instance and local variables\n\nsuper:\n• Refers to parent class instance\n• Access parent class members\n• Call parent class constructor (super())\n• Used to invoke overridden methods from parent",
      "explanation": "this is for the current object, super is for the parent object. Both must be the first statement when calling constructors.",
      "difficulty": "Easy",
      "code": "class Parent {\n    String name = \"Parent\";\n    \n    Parent() {\n        System.out.println(\"Parent constructor\");\n    }\n    \n    void display() {\n        System.out.println(\"Parent display\");\n    }\n}\n\nclass Child extends Parent {\n    String name = \"Child\";\n    \n    Child() {\n        super();  // Call parent constructor (must be first)\n        System.out.println(\"Child constructor\");\n    }\n    \n    void show() {\n        System.out.println(this.name);   // Child\n        System.out.println(super.name);  // Parent\n        super.display();  // Call parent method\n    }\n}"
    },
    {
      "id": 23,
      "question": "What are the different types of constructors in Java?",
      "answer": "Types of constructors:\n\n1. Default Constructor: No parameters, provided by compiler if no constructor defined\n\n2. No-arg Constructor: Explicitly defined with no parameters\n\n3. Parameterized Constructor: Accepts parameters to initialize object\n\n4. Copy Constructor: Creates object by copying another object (not built-in in Java)\n\nRules:\n• Constructor name must match class name\n• No return type (not even void)\n• Can be overloaded\n• First line is super() or this() call (implicit if not specified)",
      "explanation": "If you define any constructor, the compiler won't provide default constructor. Use constructor overloading to provide multiple ways to initialize objects.",
      "difficulty": "Easy",
      "code": "class Person {\n    String name;\n    int age;\n    \n    // Default constructor (only if no other constructor)\n    // Person() { }\n    \n    // No-arg constructor\n    Person() {\n        name = \"Unknown\";\n        age = 0;\n    }\n    \n    // Parameterized constructor\n    Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    // Copy constructor (manual implementation)\n    Person(Person other) {\n        this.name = other.name;\n        this.age = other.age;\n    }\n}\n\n// Usage\nPerson p1 = new Person();\nPerson p2 = new Person(\"John\", 25);\nPerson p3 = new Person(p2);  // Copy"
    },
    {
      "id": 24,
      "question": "What are access modifiers in Java?",
      "answer": "Access modifiers control visibility of classes, methods, and variables:\n\npublic:\n• Accessible from anywhere\n• Classes, methods, variables\n\nprotected:\n• Accessible within package and by subclasses\n• Methods, variables (not top-level classes)\n\ndefault (no modifier):\n• Package-private, accessible within same package only\n• Classes, methods, variables\n\nprivate:\n• Accessible only within the same class\n• Methods, variables (not top-level classes)",
      "explanation": "Choose the most restrictive access level that makes sense. This is encapsulation - hiding internal details and exposing only what's necessary.",
      "difficulty": "Easy",
      "code": "// File: Person.java\npublic class Person {\n    public String name;        // Accessible everywhere\n    protected int age;         // Package + subclasses\n    String address;            // Default - package only\n    private String ssn;        // Only within Person\n    \n    public void publicMethod() { }\n    protected void protectedMethod() { }\n    void defaultMethod() { }\n    private void privateMethod() { }\n    \n    // Getter for private field\n    public String getSsn() {\n        return ssn;\n    }\n}"
    },
    {
      "id": 25,
      "question": "What is autoboxing and unboxing in Java?",
      "answer": "Autoboxing: Automatic conversion of primitive types to their corresponding wrapper objects\n\nUnboxing: Automatic conversion of wrapper objects to primitive types\n\nWrapper Classes:\n• byte → Byte\n• short → Short\n• int → Integer\n• long → Long\n• float → Float\n• double → Double\n• char → Character\n• boolean → Boolean\n\nIntroduced in Java 5 for convenience.",
      "explanation": "Autoboxing/unboxing makes code cleaner but can cause performance overhead and NullPointerException if wrapper is null. Be cautious in performance-critical loops.",
      "difficulty": "Easy",
      "code": "// Autoboxing - primitive to wrapper\nint primitive = 5;\nInteger wrapper = primitive;  // Automatic conversion\n// Equivalent to: Integer wrapper = Integer.valueOf(primitive);\n\n// Unboxing - wrapper to primitive\nInteger obj = 10;\nint value = obj;  // Automatic conversion\n// Equivalent to: int value = obj.intValue();\n\n// In collections (only objects allowed)\nList<Integer> list = new ArrayList<>();\nlist.add(5);  // Autoboxing: 5 → Integer(5)\nint num = list.get(0);  // Unboxing: Integer(5) → 5\n\n// Potential NullPointerException\nInteger nullValue = null;\n// int x = nullValue;  // NullPointerException on unboxing!"
    },
    {
      "id": 26,
      "question": "What is the equals() and hashCode() contract?",
      "answer": "The contract states:\n\n1. If two objects are equal (equals() returns true), they must have the same hashCode()\n\n2. If two objects have the same hashCode(), they may or may not be equal\n\n3. If equals() is overridden, hashCode() must also be overridden\n\n4. equals() must be reflexive, symmetric, transitive, and consistent\n\nWhy important:\n• HashMap, HashSet rely on this contract\n• Violating it causes incorrect behavior in hash-based collections",
      "explanation": "Breaking this contract leads to objects not being found in HashMaps even though they're equal, or duplicate entries in HashSets. Always override both methods together.",
      "difficulty": "Medium",
      "code": "class Person {\n    String name;\n    int age;\n    \n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;\n        if (obj == null || getClass() != obj.getClass()) return false;\n        Person person = (Person) obj;\n        return age == person.age && \n               Objects.equals(name, person.name);\n    }\n    \n    @Override\n    public int hashCode() {\n        return Objects.hash(name, age);  // Same fields as equals\n    }\n}\n\n// Usage\nPerson p1 = new Person(\"John\", 25);\nPerson p2 = new Person(\"John\", 25);\np1.equals(p2);  // true\np1.hashCode() == p2.hashCode();  // true (contract satisfied)\n\nSet<Person> set = new HashSet<>();\nset.add(p1);\nset.contains(p2);  // true (works correctly)"
    },
    {
      "id": 27,
      "question": "What is the difference between shallow copy and deep copy?",
      "answer": "Shallow Copy:\n• Copies object and its primitive fields\n• References to other objects are copied (not the objects themselves)\n• Changes to referenced objects affect both copies\n• Object.clone() performs shallow copy by default\n\nDeep Copy:\n• Copies object and all objects it references recursively\n• Complete independence between copies\n• Changes to one don't affect the other\n• Must be implemented manually",
      "explanation": "Shallow copy is faster but shared references can cause unexpected side effects. Deep copy is safer for objects with mutable referenced objects but requires more memory and processing.",
      "difficulty": "Medium",
      "code": "class Address {\n    String city;\n    Address(String city) { this.city = city; }\n}\n\nclass Person implements Cloneable {\n    String name;\n    Address address;\n    \n    // Shallow copy\n    @Override\n    public Person clone() throws CloneNotSupportedException {\n        return (Person) super.clone();  // Shallow copy\n    }\n    \n    // Deep copy\n    public Person deepClone() {\n        Person copy = new Person();\n        copy.name = this.name;\n        copy.address = new Address(this.address.city);  // New object\n        return copy;\n    }\n}\n\n// Shallow copy issue\nPerson p1 = new Person();\np1.address = new Address(\"NYC\");\nPerson p2 = p1.clone();  // Shallow copy\np2.address.city = \"LA\";\nSystem.out.println(p1.address.city);  // \"LA\" - affected!\n\n// Deep copy - independent\nPerson p3 = p1.deepClone();\np3.address.city = \"Boston\";\nSystem.out.println(p1.address.city);  // \"LA\" - not affected"
    },
    {
      "id": 28,
      "question": "What is Serialization in Java?",
      "answer": "Serialization is the process of converting an object into a byte stream for storage or transmission.\n\nDeserialization is the reverse - reconstructing object from byte stream.\n\nKey points:\n• Implement Serializable interface (marker interface)\n• serialVersionUID for version control\n• transient keyword excludes fields from serialization\n• static fields are not serialized\n• Used for: Object persistence, network transmission, caching",
      "explanation": "Serialization enables object persistence and distributed computing. Always define serialVersionUID to avoid InvalidClassException when class definition changes.",
      "difficulty": "Medium",
      "code": "class User implements Serializable {\n    private static final long serialVersionUID = 1L;\n    \n    private String username;\n    private transient String password;  // Not serialized\n    private static int count = 0;       // Not serialized\n    \n    // Constructors, methods...\n}\n\n// Serialization\nUser user = new User(\"john\", \"secret123\");\ntry (ObjectOutputStream out = new ObjectOutputStream(\n        new FileOutputStream(\"user.ser\"))) {\n    out.writeObject(user);\n}\n\n// Deserialization\ntry (ObjectInputStream in = new ObjectInputStream(\n        new FileInputStream(\"user.ser\"))) {\n    User loadedUser = (User) in.readObject();\n    System.out.println(loadedUser.username);  // \"john\"\n    System.out.println(loadedUser.password);  // null (transient)\n}"
    },
    {
      "id": 29,
      "question": "What is the Reflection API in Java?",
      "answer": "Reflection API allows inspection and manipulation of classes, methods, fields, and constructors at runtime.\n\nCapabilities:\n• Inspect class structure\n• Create objects dynamically\n• Invoke methods dynamically\n• Access/modify private fields\n• Discover annotations\n\nKey classes:\n• Class<T>: Represents classes\n• Method, Field, Constructor: Represent members\n• Modifier: Check access modifiers",
      "explanation": "Reflection is powerful but breaks encapsulation and has performance overhead. Used in frameworks (Spring, Hibernate), testing tools, and serialization. Prefer direct access when possible.",
      "difficulty": "Hard",
      "code": "class Person {\n    private String name;\n    \n    public Person(String name) { this.name = name; }\n    \n    private void secret() {\n        System.out.println(\"Secret method\");\n    }\n}\n\n// Get Class object\nClass<?> clazz = Person.class;\n// or: Class.forName(\"com.example.Person\");\n\n// Create instance\nConstructor<?> constructor = clazz.getConstructor(String.class);\nObject person = constructor.newInstance(\"John\");\n\n// Access private field\nField field = clazz.getDeclaredField(\"name\");\nfield.setAccessible(true);  // Bypass private\nSystem.out.println(field.get(person));  // \"John\"\n\n// Invoke private method\nMethod method = clazz.getDeclaredMethod(\"secret\");\nmethod.setAccessible(true);\nmethod.invoke(person);  // Calls secret()\n\n// List all methods\nfor (Method m : clazz.getDeclaredMethods()) {\n    System.out.println(m.getName());\n}"
    },
    {
      "id": 30,
      "question": "What are Annotations in Java?",
      "answer": "Annotations are metadata that provide information about code to compiler, runtime, or tools.\n\nBuilt-in annotations:\n• @Override: Ensures method overrides parent method\n• @Deprecated: Marks code as outdated\n• @SuppressWarnings: Suppresses compiler warnings\n• @FunctionalInterface: Marks functional interface\n• @SafeVarargs: Suppresses varargs warnings\n\nRetention policies:\n• SOURCE: Discarded after compilation\n• CLASS: In bytecode, not at runtime\n• RUNTIME: Available at runtime via reflection",
      "explanation": "Annotations enable declarative programming. Frameworks use them extensively - @Entity, @Autowired, @Test. You can create custom annotations for cross-cutting concerns.",
      "difficulty": "Medium",
      "code": "// Using built-in annotations\nclass Parent {\n    void display() { }\n}\n\nclass Child extends Parent {\n    @Override  // Compile error if not actually overriding\n    void display() { }\n    \n    @Deprecated\n    void oldMethod() { }  // Warns when used\n    \n    @SuppressWarnings(\"unchecked\")\n    void problematic() { }\n}\n\n// Custom annotation\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@interface Test {\n    String value() default \"\";\n    int timeout() default 0;\n}\n\n// Usage\nclass MyTest {\n    @Test(value = \"testAdd\", timeout = 1000)\n    void testMethod() { }\n}\n\n// Reading at runtime\nMethod method = MyTest.class.getMethod(\"testMethod\");\nif (method.isAnnotationPresent(Test.class)) {\n    Test test = method.getAnnotation(Test.class);\n    System.out.println(test.value());  // \"testAdd\"\n}"
    },
    {
      "id": 31,
      "question": "What are Generics in Java and why use them?",
      "answer": "Generics enable type parameters in classes, interfaces, and methods, providing compile-time type safety.\n\nBenefits:\n• Type safety: Compile-time type checking\n• No casting required\n• Code reusability\n• Catch errors at compile time, not runtime\n\nKey concepts:\n• Type parameters: <T>, <E>, <K,V>\n• Bounded type parameters: <T extends Number>\n• Wildcards: <? extends T>, <? super T>\n• Type erasure: Generic types removed at runtime",
      "explanation": "Generics are fundamental to Collections framework. They prevent ClassCastException and make code more maintainable. Type erasure means List<String> and List<Integer> become List at runtime.",
      "difficulty": "Medium",
      "code": "// Without generics - unsafe\nList list = new ArrayList();\nlist.add(\"String\");\nlist.add(123);  // No compile error!\nString s = (String) list.get(1);  // ClassCastException!\n\n// With generics - type safe\nList<String> safeList = new ArrayList<>();\nsafeList.add(\"String\");\n// safeList.add(123);  // Compile error!\nString str = safeList.get(0);  // No casting needed\n\n// Generic class\nclass Box<T> {\n    private T value;\n    \n    void set(T value) { this.value = value; }\n    T get() { return value; }\n}\n\nBox<Integer> intBox = new Box<>();\nintBox.set(123);\n// intBox.set(\"String\");  // Compile error!\n\n// Generic method\npublic <T> void printArray(T[] array) {\n    for (T element : array) {\n        System.out.println(element);\n    }\n}\n\n// Bounded type parameter\nclass NumberBox<T extends Number> {\n    T value;\n    double doubleValue() { return value.doubleValue(); }\n}"
    },
    {
      "id": 32,
      "question": "What are wildcards in Java Generics?",
      "answer": "Wildcards represent unknown types in generics:\n\nUnbounded wildcard (?):\n• Represents any type\n• Use when type doesn't matter\n• Example: List<?>\n\nUpper bounded wildcard (? extends T):\n• Any type that is T or subclass of T\n• Read-only scenario\n• Example: List<? extends Number>\n\nLower bounded wildcard (? super T):\n• Any type that is T or superclass of T\n• Write scenario\n• Example: List<? super Integer>\n\nPECS principle: Producer Extends, Consumer Super",
      "explanation": "Wildcards provide flexibility. Use extends for reading, super for writing. Unbounded wildcard for operations that don't depend on type parameter.",
      "difficulty": "Hard",
      "code": "// Unbounded wildcard\nvoid printList(List<?> list) {\n    for (Object obj : list) {  // Can only read as Object\n        System.out.println(obj);\n    }\n    // list.add(\"something\");  // Compile error!\n}\n\n// Upper bounded - read from producer\nvoid sumNumbers(List<? extends Number> numbers) {\n    double sum = 0;\n    for (Number n : numbers) {  // Read as Number\n        sum += n.doubleValue();\n    }\n    // numbers.add(5);  // Compile error! (unknown exact type)\n}\nsumNumbers(new ArrayList<Integer>());  // OK\nsumNumbers(new ArrayList<Double>());   // OK\n\n// Lower bounded - write to consumer\nvoid addIntegers(List<? super Integer> list) {\n    list.add(5);      // OK - can add Integer\n    list.add(10);     // OK\n    // Integer n = list.get(0);  // Compile error!\n    Object obj = list.get(0);    // Can only read as Object\n}\naddIntegers(new ArrayList<Integer>());  // OK\naddIntegers(new ArrayList<Number>());   // OK\naddIntegers(new ArrayList<Object>());   // OK"
    },
    {
      "id": 33,
      "question": "What is an Enum in Java?",
      "answer": "Enum is a special class that represents a group of constants (fixed set of instances).\n\nFeatures:\n• Type-safe constants\n• Can have fields, methods, constructors\n• Implicitly public static final\n• Cannot be instantiated directly\n• Can implement interfaces\n• Automatically provides values() and valueOf() methods\n• Can be used in switch statements",
      "explanation": "Enums are better than int constants - they provide type safety, namespace, and can contain behavior. Use enums for fixed sets of constants like days, directions, status codes.",
      "difficulty": "Easy",
      "code": "// Simple enum\nenum Day {\n    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n}\n\n// Enum with fields and methods\nenum Planet {\n    EARTH(5.976e+24, 6.37814e6),\n    MARS(6.421e+23, 3.3972e6);\n    \n    private final double mass;\n    private final double radius;\n    \n    Planet(double mass, double radius) {\n        this.mass = mass;\n        this.radius = radius;\n    }\n    \n    double surfaceGravity() {\n        return mass / (radius * radius);\n    }\n}\n\n// Usage\nDay today = Day.MONDAY;\nswitch (today) {\n    case MONDAY: System.out.println(\"Start of week\"); break;\n    case FRIDAY: System.out.println(\"Weekend soon!\"); break;\n    default: break;\n}\n\n// Iterate all values\nfor (Day d : Day.values()) {\n    System.out.println(d);\n}\n\n// String to enum\nDay day = Day.valueOf(\"TUESDAY\");\n\n// Enum methods\nSystem.out.println(Planet.EARTH.surfaceGravity());"
    },
    {
      "id": 34,
      "question": "What are the different types of inner classes in Java?",
      "answer": "Four types of inner classes:\n\n1. Member Inner Class: Non-static nested class, has access to outer class members\n\n2. Static Nested Class: Static nested class, can only access static members of outer class\n\n3. Local Inner Class: Defined inside a method, can access final/effectively final local variables\n\n4. Anonymous Inner Class: Class without name, used for one-time implementation",
      "explanation": "Inner classes provide logical grouping and encapsulation. They can access private members of outer class. Use anonymous classes for simple one-off implementations (though lambdas are often better).",
      "difficulty": "Medium",
      "code": "class Outer {\n    private int outerField = 10;\n    private static int staticField = 20;\n    \n    // 1. Member Inner Class\n    class MemberInner {\n        void display() {\n            System.out.println(outerField);  // Access outer\n        }\n    }\n    \n    // 2. Static Nested Class\n    static class StaticNested {\n        void display() {\n            System.out.println(staticField);  // Only static\n            // System.out.println(outerField);  // Error!\n        }\n    }\n    \n    void method() {\n        final int localVar = 30;\n        \n        // 3. Local Inner Class\n        class LocalInner {\n            void display() {\n                System.out.println(localVar);  // Final/effectively final\n            }\n        }\n        LocalInner local = new LocalInner();\n        local.display();\n    }\n}\n\n// 4. Anonymous Inner Class\nRunnable runnable = new Runnable() {\n    @Override\n    public void run() {\n        System.out.println(\"Anonymous\");\n    }\n};\n\n// Usage\nOuter outer = new Outer();\nOuter.MemberInner inner = outer.new MemberInner();\nOuter.StaticNested nested = new Outer.StaticNested();"
    },
    {
      "id": 35,
      "question": "What are Lambda expressions in Java?",
      "answer": "Lambda expressions are anonymous functions that provide implementation of functional interfaces in a concise way.\n\nSyntax: (parameters) -> expression or block\n\nBenefits:\n• Concise code\n• Enable functional programming\n• Improved readability\n• Support for method references\n• Easy parallelization with streams\n\nRequirements:\n• Target type must be a functional interface\n• Can access final or effectively final variables",
      "explanation": "Lambdas make code more expressive and concise, especially with collections and streams. They replace anonymous inner classes for functional interfaces.",
      "difficulty": "Medium",
      "code": "// Without lambda - anonymous inner class\nRunnable r1 = new Runnable() {\n    @Override\n    public void run() {\n        System.out.println(\"Hello\");\n    }\n};\n\n// With lambda - concise\nRunnable r2 = () -> System.out.println(\"Hello\");\n\n// Lambda with parameters\nComparator<String> comparator = (s1, s2) -> s1.length() - s2.length();\n\n// Lambda with block\nComparator<String> comp2 = (s1, s2) -> {\n    System.out.println(\"Comparing\");\n    return s1.compareTo(s2);\n};\n\n// With streams\nList<String> names = Arrays.asList(\"John\", \"Jane\", \"Bob\");\nnames.stream()\n     .filter(name -> name.startsWith(\"J\"))\n     .map(name -> name.toUpperCase())\n     .forEach(name -> System.out.println(name));\n\n// Accessing variables (must be final/effectively final)\nint factor = 2;\nFunction<Integer, Integer> multiplier = n -> n * factor;\n// factor = 3;  // Error: must be effectively final"
    },
    {
      "id": 36,
      "question": "What are Method References in Java?",
      "answer": "Method references are shorthand for lambda expressions that only call an existing method.\n\nFour types:\n\n1. Static method reference: ClassName::staticMethod\n\n2. Instance method reference: instance::instanceMethod\n\n3. Instance method of arbitrary object: ClassName::instanceMethod\n\n4. Constructor reference: ClassName::new\n\nBenefits:\n• More concise than lambda\n• Improved readability\n• Reuse existing methods",
      "explanation": "Method references make code even cleaner than lambdas when you're just calling an existing method. They're syntactic sugar for simple lambda expressions.",
      "difficulty": "Medium",
      "code": "List<String> names = Arrays.asList(\"John\", \"Jane\", \"Bob\");\n\n// Lambda vs Method Reference\n\n// 1. Static method reference\n// Lambda: s -> Integer.parseInt(s)\nFunction<String, Integer> parser = Integer::parseInt;\n\n// 2. Instance method of particular object\nSystem.out::println;  // Instead of: s -> System.out.println(s)\nnames.forEach(System.out::println);\n\n// 3. Instance method of arbitrary object\n// Lambda: (s1, s2) -> s1.compareToIgnoreCase(s2)\nComparator<String> comp = String::compareToIgnoreCase;\nnames.sort(String::compareToIgnoreCase);\n\n// 4. Constructor reference\n// Lambda: () -> new ArrayList<>()\nSupplier<List<String>> listSupplier = ArrayList::new;\nList<String> list = listSupplier.get();\n\n// With streams\nList<Integer> lengths = names.stream()\n    .map(String::length)  // Instead of: s -> s.length()\n    .collect(Collectors.toList());\n\n// Array constructor reference\nString[] array = names.stream()\n    .toArray(String[]::new);  // Instead of: size -> new String[size]"
    },
    {
      "id": 37,
      "question": "What is the Java Collection Framework hierarchy?",
      "answer": "Collection Framework hierarchy:\n\nIterable\n└── Collection\n    ├── List (ordered, allows duplicates)\n    │   ├── ArrayList\n    │   ├── LinkedList\n    │   └── Vector (legacy)\n    ├── Set (no duplicates)\n    │   ├── HashSet\n    │   ├── LinkedHashSet\n    │   └── SortedSet\n    │       └── TreeSet\n    └── Queue\n        ├── PriorityQueue\n        └── Deque\n            └── ArrayDeque\n\nMap (separate hierarchy)\n├── HashMap\n├── LinkedHashMap\n├── Hashtable (legacy)\n└── SortedMap\n    └── TreeMap",
      "explanation": "Understanding the hierarchy helps choose the right collection. List for ordered access, Set for uniqueness, Queue for FIFO, Map for key-value pairs.",
      "difficulty": "Medium",
      "code": "// List - ordered, duplicates allowed\nList<String> list = new ArrayList<>();\nlist.add(\"A\"); list.add(\"B\"); list.add(\"A\");\nlist.get(0);  // Access by index\n\n// Set - no duplicates\nSet<String> set = new HashSet<>();\nset.add(\"A\"); set.add(\"B\"); set.add(\"A\");\nSystem.out.println(set.size());  // 2 (no duplicates)\n\n// Queue - FIFO\nQueue<String> queue = new LinkedList<>();\nqueue.offer(\"First\");\nqueue.offer(\"Second\");\nqueue.poll();  // Returns \"First\"\n\n// Map - key-value pairs\nMap<String, Integer> map = new HashMap<>();\nmap.put(\"John\", 25);\nmap.put(\"Jane\", 30);\nmap.get(\"John\");  // 25\n\n// TreeSet - sorted\nSet<Integer> sortedSet = new TreeSet<>();\nsortedSet.add(5); sortedSet.add(1); sortedSet.add(3);\n// Order: [1, 3, 5]"
    },
    {
      "id": 38,
      "question": "What is the difference between HashSet, LinkedHashSet, and TreeSet?",
      "answer": "HashSet:\n• Backed by HashMap\n• No ordering guarantees\n• Fast: O(1) for add, remove, contains\n• Allows one null element\n• Best for: Fast lookups, no ordering needed\n\nLinkedHashSet:\n• Backed by LinkedHashMap\n• Maintains insertion order\n• Slightly slower: O(1) but with overhead\n• Allows one null element\n• Best for: When insertion order matters\n\nTreeSet:\n• Backed by TreeMap (Red-Black tree)\n• Sorted order (natural or comparator)\n• Slower: O(log n) operations\n• No null elements\n• Best for: Sorted data, range queries",
      "explanation": "Choose HashSet for performance, LinkedHashSet for predictable iteration, TreeSet for sorted data. All guarantee no duplicates.",
      "difficulty": "Medium",
      "code": "// HashSet - no order\nSet<String> hashSet = new HashSet<>();\nhashSet.add(\"C\"); hashSet.add(\"A\"); hashSet.add(\"B\");\nSystem.out.println(hashSet);  // [A, B, C] or any order\n\n// LinkedHashSet - insertion order\nSet<String> linkedSet = new LinkedHashSet<>();\nlinkedSet.add(\"C\"); linkedSet.add(\"A\"); linkedSet.add(\"B\");\nSystem.out.println(linkedSet);  // [C, A, B] (insertion order)\n\n// TreeSet - sorted order\nSet<String> treeSet = new TreeSet<>();\ntreeSet.add(\"C\"); treeSet.add(\"A\"); treeSet.add(\"B\");\nSystem.out.println(treeSet);  // [A, B, C] (sorted)\n\n// TreeSet with custom comparator\nSet<String> reverseSet = new TreeSet<>(Comparator.reverseOrder());\nreverseSet.add(\"C\"); reverseSet.add(\"A\"); reverseSet.add(\"B\");\nSystem.out.println(reverseSet);  // [C, B, A]\n\n// TreeSet range operations\nTreeSet<Integer> numbers = new TreeSet<>();\nnumbers.addAll(Arrays.asList(1, 3, 5, 7, 9));\nnumbers.subSet(3, 8);   // [3, 5, 7]\nnumbers.headSet(5);     // [1, 3]\nnumbers.tailSet(5);     // [5, 7, 9]"
    },
    {
      "id": 39,
      "question": "What is the difference between HashMap, LinkedHashMap, and TreeMap?",
      "answer": "HashMap:\n• Hash table based\n• No ordering guarantees\n• Fast: O(1) average for operations\n• Allows one null key, multiple null values\n• Best for: Fast key-value lookups\n\nLinkedHashMap:\n• HashMap + doubly-linked list\n• Maintains insertion order (or access order)\n• Slightly slower than HashMap\n• Allows one null key\n• Best for: LRU cache, when order matters\n\nTreeMap:\n• Red-Black tree based\n• Sorted by keys (natural or comparator)\n• Slower: O(log n) operations\n• No null keys\n• Best for: Sorted maps, range queries",
      "explanation": "HashMap is the default choice for performance. LinkedHashMap for predictable iteration. TreeMap when you need sorted keys or range operations.",
      "difficulty": "Medium",
      "code": "// HashMap - no order\nMap<String, Integer> hashMap = new HashMap<>();\nhashMap.put(\"C\", 3); hashMap.put(\"A\", 1); hashMap.put(\"B\", 2);\n// Iteration order: unpredictable\n\n// LinkedHashMap - insertion order\nMap<String, Integer> linkedMap = new LinkedHashMap<>();\nlinkedMap.put(\"C\", 3); linkedMap.put(\"A\", 1); linkedMap.put(\"B\", 2);\n// Iteration order: C, A, B\n\n// LinkedHashMap - access order (for LRU cache)\nMap<String, Integer> lruMap = new LinkedHashMap<>(16, 0.75f, true);\nlruMap.put(\"A\", 1); lruMap.put(\"B\", 2);\nlruMap.get(\"A\");  // A becomes most recently used\n// Iteration order: B, A\n\n// TreeMap - sorted order\nMap<String, Integer> treeMap = new TreeMap<>();\ntreeMap.put(\"C\", 3); treeMap.put(\"A\", 1); treeMap.put(\"B\", 2);\n// Iteration order: A, B, C (sorted by key)\n\n// TreeMap range operations\ntreeMap.subMap(\"A\", \"C\");    // Entries from A to B\ntreeMap.headMap(\"C\");        // Entries before C\ntreeMap.tailMap(\"B\");        // Entries from B onwards"
    },
    {
      "id": 40,
      "question": "What is the difference between Queue and Deque?",
      "answer": "Queue:\n• FIFO (First-In-First-Out) data structure\n• Add at rear, remove from front\n• Methods: offer(), poll(), peek()\n• Single-ended\n• Implementations: LinkedList, PriorityQueue, ArrayDeque\n\nDeque (Double-Ended Queue):\n• Add/remove from both ends\n• Can be used as Stack (LIFO) or Queue (FIFO)\n• Methods: offerFirst/Last, pollFirst/Last, peekFirst/Last\n• More flexible than Queue and Stack\n• Implementation: ArrayDeque (preferred over Stack)",
      "explanation": "Use Queue for standard FIFO operations. Use Deque when you need flexibility to add/remove from both ends. ArrayDeque is preferred over Stack class for stack operations.",
      "difficulty": "Easy",
      "code": "// Queue - FIFO\nQueue<String> queue = new LinkedList<>();\nqueue.offer(\"First\");   // Add to rear\nqueue.offer(\"Second\");\nqueue.offer(\"Third\");\nqueue.poll();           // Remove \"First\"\nqueue.peek();           // View \"Second\" without removing\n\n// Deque - as Queue (FIFO)\nDeque<String> deque = new ArrayDeque<>();\ndeque.offerLast(\"First\");\ndeque.offerLast(\"Second\");\ndeque.pollFirst();      // FIFO behavior\n\n// Deque - as Stack (LIFO)\nDeque<String> stack = new ArrayDeque<>();\nstack.push(\"First\");    // or offerFirst\nstack.push(\"Second\");\nstack.pop();            // Returns \"Second\" (LIFO)\nstack.peek();           // View \"First\"\n\n// Deque - both ends\ndeque.offerFirst(\"Front\");\ndeque.offerLast(\"Back\");\ndeque.pollFirst();      // Remove from front\ndeque.pollLast();       // Remove from back"
    },
    {
      "id": 41,
      "question": "What is ConcurrentHashMap and how does it work?",
      "answer": "ConcurrentHashMap is a thread-safe HashMap implementation without locking the entire map.\n\nKey features:\n• Segment-level locking (Java 7) / Node-level locking (Java 8+)\n• Multiple threads can read/write concurrently\n• No ConcurrentModificationException\n• Doesn't allow null keys or values\n• Better performance than Hashtable\n\nJava 8+ improvements:\n• Uses CAS (Compare-And-Swap) operations\n• Tree bins for better collision handling\n• Parallel search operations",
      "explanation": "ConcurrentHashMap allows concurrent reads and writes by locking only affected segments/nodes, not the entire map. Much better than synchronized HashMap or Hashtable for concurrent access.",
      "difficulty": "Hard",
      "code": "// ConcurrentHashMap - thread-safe\nMap<String, Integer> concurrentMap = new ConcurrentHashMap<>();\n\n// Multiple threads can access safely\nconcurrentMap.put(\"key1\", 1);\nconcurrentMap.put(\"key2\", 2);\n\n// Atomic operations\nconcurrentMap.putIfAbsent(\"key3\", 3);  // Atomic\nconcurrentMap.computeIfAbsent(\"key4\", k -> 4);  // Atomic compute\nconcurrentMap.merge(\"key1\", 10, Integer::sum);  // Atomic merge\n\n// Bulk operations (parallel in Java 8+)\nconcurrentMap.forEach((k, v) -> System.out.println(k + \":\" + v));\nconcurrentMap.search(1, (k, v) -> v > 2 ? k : null);\n\n// Won't throw ConcurrentModificationException\nfor (String key : concurrentMap.keySet()) {\n    concurrentMap.put(\"new\" + key, 0);  // Safe during iteration\n}\n\n// Compare with synchronized Map\nMap<String, Integer> syncMap = \n    Collections.synchronizedMap(new HashMap<>());\n// syncMap locks entire map on each operation"
    },
    {
      "id": 42,
      "question": "What is ThreadLocal in Java?",
      "answer": "ThreadLocal provides thread-local variables where each thread has its own independent copy of the variable.\n\nUse cases:\n• User context in web applications\n• Database connections per thread\n• Date formatters (SimpleDateFormat is not thread-safe)\n• Transaction context\n\nMethods:\n• get(): Returns thread's copy\n• set(value): Sets thread's copy\n• remove(): Clears thread's copy (important to avoid memory leaks)\n• initialValue(): Override to provide initial value",
      "explanation": "ThreadLocal isolates data per thread, preventing concurrent access issues. Always call remove() in finally block to prevent memory leaks, especially in thread pools.",
      "difficulty": "Hard",
      "code": "// ThreadLocal variable\nprivate static ThreadLocal<Integer> threadId = \n    ThreadLocal.withInitial(() -> 0);\n\n// Or override initialValue\nprivate static ThreadLocal<SimpleDateFormat> dateFormat = \n    new ThreadLocal<SimpleDateFormat>() {\n        @Override\n        protected SimpleDateFormat initialValue() {\n            return new SimpleDateFormat(\"yyyy-MM-dd\");\n        }\n    };\n\n// Usage\nclass UserContext {\n    private static ThreadLocal<String> currentUser = new ThreadLocal<>();\n    \n    public static void setUser(String user) {\n        currentUser.set(user);\n    }\n    \n    public static String getUser() {\n        return currentUser.get();\n    }\n    \n    public static void clear() {\n        currentUser.remove();  // Prevent memory leak\n    }\n}\n\n// In a web request\ntry {\n    UserContext.setUser(\"John\");\n    // Each thread sees its own user\n    System.out.println(UserContext.getUser());\n} finally {\n    UserContext.clear();  // Always clean up!\n}"
    },
    {
      "id": 43,
      "question": "What is the Executor Framework in Java?",
      "answer": "Executor Framework provides a higher-level API for managing threads, separating task submission from execution mechanics.\n\nKey interfaces:\n• Executor: Basic interface with execute() method\n• ExecutorService: Manages lifecycle, returns Future\n• ScheduledExecutorService: Schedule tasks with delays\n\nCommon implementations:\n• newFixedThreadPool: Fixed number of threads\n• newCachedThreadPool: Creates threads as needed\n• newSingleThreadExecutor: Single worker thread\n• newScheduledThreadPool: Schedule tasks",
      "explanation": "Executor framework manages thread pooling, reduces thread creation overhead, and provides better control over concurrent execution. Always shutdownGracefully when done.",
      "difficulty": "Medium",
      "code": "// Fixed thread pool\nExecutorService executor = Executors.newFixedThreadPool(5);\n\n// Submit Runnable\nexecutor.execute(() -> System.out.println(\"Task 1\"));\n\n// Submit Callable (returns result)\nFuture<Integer> future = executor.submit(() -> {\n    Thread.sleep(1000);\n    return 42;\n});\n\ntry {\n    Integer result = future.get();  // Blocks until complete\n    System.out.println(result);      // 42\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n// Submit multiple tasks\nList<Callable<String>> tasks = Arrays.asList(\n    () -> \"Task 1\",\n    () -> \"Task 2\",\n    () -> \"Task 3\"\n);\nList<Future<String>> results = executor.invokeAll(tasks);\n\n// Scheduled executor\nScheduledExecutorService scheduler = \n    Executors.newScheduledThreadPool(2);\nscheduler.schedule(() -> System.out.println(\"Delayed\"), \n                   5, TimeUnit.SECONDS);\nscheduler.scheduleAtFixedRate(() -> System.out.println(\"Periodic\"),\n                              0, 1, TimeUnit.SECONDS);\n\n// Shutdown\nexecutor.shutdown();\n// executor.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);"
    },
    {
      "id": 44,
      "question": "What is CompletableFuture in Java?",
      "answer": "CompletableFuture is a composable, asynchronous computation framework introduced in Java 8.\n\nKey features:\n• Explicit completion control\n• Compose multiple async operations\n• Exception handling\n• Combine multiple futures\n• Non-blocking callbacks\n\nCommon methods:\n• supplyAsync: Run async with return value\n• thenApply: Transform result\n• thenCompose: Chain dependent operations\n• thenCombine: Combine two futures\n• exceptionally: Handle errors",
      "explanation": "CompletableFuture provides functional-style async programming. It's more powerful than Future - you can chain operations, handle errors, and compose multiple async tasks.",
      "difficulty": "Hard",
      "code": "// Simple async operation\nCompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\n    // Runs in ForkJoinPool\n    return \"Hello\";\n});\n\n// Transform result\nCompletableFuture<String> result = future.thenApply(s -> s + \" World\");\nSystem.out.println(result.get());  // \"Hello World\"\n\n// Chain dependent operations\nCompletableFuture.supplyAsync(() -> \"User123\")\n    .thenCompose(userId -> fetchUserDetails(userId))  // Returns CF\n    .thenApply(user -> user.getName())\n    .thenAccept(name -> System.out.println(name));\n\n// Combine multiple futures\nCompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> \"Hello\");\nCompletableFuture<String> f2 = CompletableFuture.supplyAsync(() -> \"World\");\nCompletableFuture<String> combined = f1.thenCombine(f2, (s1, s2) -> s1 + \" \" + s2);\n\n// Wait for all\nCompletableFuture<Void> all = CompletableFuture.allOf(f1, f2);\nall.thenRun(() -> System.out.println(\"All complete\"));\n\n// Exception handling\nCompletableFuture.supplyAsync(() -> {\n    if (true) throw new RuntimeException(\"Error\");\n    return \"Success\";\n}).exceptionally(ex -> {\n    System.out.println(\"Handled: \" + ex.getMessage());\n    return \"Default\";\n}).thenAccept(System.out::println);"
    },
    {
      "id": 45,
      "question": "What is CountDownLatch in Java?",
      "answer": "CountDownLatch is a synchronization aid that allows threads to wait until a set of operations complete.\n\nKey concepts:\n• Initialized with a count\n• Threads call await() to wait\n• Other threads call countDown() to decrement\n• When count reaches zero, waiting threads proceed\n• Cannot be reused (count doesn't reset)\n\nUse cases:\n• Wait for multiple threads to start/complete\n• Parallel initialization\n• Wait for service dependencies",
      "explanation": "CountDownLatch is like a gate that opens when count reaches zero. Use it when you need to wait for N operations to complete before proceeding. For reusable barriers, use CyclicBarrier.",
      "difficulty": "Medium",
      "code": "// Main thread waits for 3 worker threads\nCountDownLatch latch = new CountDownLatch(3);\n\nfor (int i = 0; i < 3; i++) {\n    new Thread(() -> {\n        try {\n            System.out.println(\"Working...\");\n            Thread.sleep(1000);\n            System.out.println(\"Done\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            latch.countDown();  // Decrement count\n        }\n    }).start();\n}\n\n// Main thread waits\nSystem.out.println(\"Waiting for workers...\");\nlatch.await();  // Blocks until count = 0\nSystem.out.println(\"All workers done!\");\n\n// With timeout\nboolean completed = latch.await(5, TimeUnit.SECONDS);\nif (completed) {\n    System.out.println(\"Completed in time\");\n} else {\n    System.out.println(\"Timeout!\");\n}"
    },
    {
      "id": 46,
      "question": "What is CyclicBarrier in Java?",
      "answer": "CyclicBarrier is a synchronization aid where threads wait for each other at a barrier point.\n\nKey features:\n• Threads call await() at barrier\n• When all threads arrive, barrier breaks and all proceed\n• Can be reused (cyclic)\n• Optional barrier action runs when barrier breaks\n\nDifference from CountDownLatch:\n• Reusable (cyclic)\n• Threads wait for each other\n• Can trigger action when barrier breaks",
      "explanation": "CyclicBarrier is for coordinating threads that need to wait for each other at a common point. Unlike CountDownLatch, it can be reused for multiple rounds of synchronization.",
      "difficulty": "Medium",
      "code": "// 3 threads wait for each other\nCyclicBarrier barrier = new CyclicBarrier(3, () -> {\n    System.out.println(\"All threads arrived!\");\n});\n\nfor (int i = 0; i < 3; i++) {\n    new Thread(() -> {\n        try {\n            System.out.println(\"Thread \" + Thread.currentThread().getId() + \" working\");\n            Thread.sleep(1000);\n            \n            System.out.println(\"Thread \" + Thread.currentThread().getId() + \" waiting at barrier\");\n            barrier.await();  // Wait for others\n            \n            System.out.println(\"Thread \" + Thread.currentThread().getId() + \" proceeding\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }).start();\n}\n\n// Reusable for multiple rounds\nfor (int round = 0; round < 2; round++) {\n    // All threads call await() - barrier can be reused\n    barrier.await();\n}"
    },
    {
      "id": 47,
      "question": "What is Semaphore in Java?",
      "answer": "Semaphore maintains a set of permits to control access to a resource.\n\nKey methods:\n• acquire(): Get a permit (blocks if none available)\n• release(): Release a permit\n• tryAcquire(): Try to get permit without blocking\n• availablePermits(): Number of available permits\n\nTypes:\n• Binary Semaphore: 1 permit (like mutex)\n• Counting Semaphore: N permits\n\nUse cases:\n• Limit concurrent access\n• Connection pooling\n• Rate limiting",
      "explanation": "Semaphore controls how many threads can access a resource simultaneously. Perfect for connection pools where you want to limit concurrent connections.",
      "difficulty": "Medium",
      "code": "// Semaphore with 3 permits (max 3 concurrent threads)\nSemaphore semaphore = new Semaphore(3);\n\n// Simulate connection pool\nclass ConnectionPool {\n    private Semaphore semaphore = new Semaphore(10);  // 10 connections\n    \n    public void useConnection() {\n        try {\n            semaphore.acquire();  // Get connection\n            System.out.println(\"Using connection\");\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            semaphore.release();  // Return connection\n        }\n    }\n}\n\n// Multiple threads competing for permits\nfor (int i = 0; i < 10; i++) {\n    new Thread(() -> {\n        try {\n            semaphore.acquire();  // Wait for permit\n            System.out.println(Thread.currentThread().getId() + \" acquired\");\n            Thread.sleep(2000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            semaphore.release();\n            System.out.println(Thread.currentThread().getId() + \" released\");\n        }\n    }).start();\n}"
    },
    {
      "id": 48,
      "question": "What is ReentrantLock in Java?",
      "answer": "ReentrantLock is an explicit lock implementation that provides more flexibility than synchronized.\n\nFeatures:\n• Explicit lock/unlock\n• Try lock with timeout\n• Interruptible locking\n• Fair/unfair lock acquisition\n• Multiple condition variables\n• Lock status queries\n\nAdvantages over synchronized:\n• Can try to acquire lock without blocking\n• Can give up trying to acquire lock\n• Better for complex synchronization scenarios",
      "explanation": "ReentrantLock gives more control than synchronized keyword. Use it when you need advanced features like timeouts, interruptibility, or fairness. Always use try-finally to ensure unlock.",
      "difficulty": "Hard",
      "code": "// ReentrantLock\nprivate ReentrantLock lock = new ReentrantLock();\n\n// Basic usage - must unlock in finally\npublic void method() {\n    lock.lock();\n    try {\n        // Critical section\n        System.out.println(\"Lock acquired\");\n    } finally {\n        lock.unlock();  // Always unlock!\n    }\n}\n\n// Try lock with timeout\npublic void tryMethod() {\n    try {\n        if (lock.tryLock(1, TimeUnit.SECONDS)) {\n            try {\n                // Got lock\n            } finally {\n                lock.unlock();\n            }\n        } else {\n            System.out.println(\"Could not acquire lock\");\n        }\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n\n// Fair lock (prevents starvation)\nprivate ReentrantLock fairLock = new ReentrantLock(true);\n\n// Condition variables\nprivate Lock lock = new ReentrantLock();\nprivate Condition condition = lock.newCondition();\n\npublic void waitForCondition() throws InterruptedException {\n    lock.lock();\n    try {\n        while (!ready) {\n            condition.await();\n        }\n    } finally {\n        lock.unlock();\n    }\n}\n\npublic void signalCondition() {\n    lock.lock();\n    try {\n        ready = true;\n        condition.signalAll();\n    } finally {\n        lock.unlock();\n    }\n}"
    },
    {
      "id": 49,
      "question": "What are Atomic classes in Java?",
      "answer": "Atomic classes provide lock-free thread-safe operations using compare-and-swap (CAS) hardware instructions.\n\nCommon classes:\n• AtomicInteger, AtomicLong: Atomic numeric operations\n• AtomicBoolean: Atomic boolean operations\n• AtomicReference: Atomic object reference\n• AtomicIntegerArray: Atomic array operations\n\nKey operations:\n• get(), set(): Read/write\n• compareAndSet(): CAS operation\n• getAndIncrement(): Atomic increment\n• incrementAndGet(): Increment then get\n• updateAndGet(): Apply function atomically",
      "explanation": "Atomic classes are faster than synchronized for simple operations. They use CPU-level atomic instructions instead of locks. Perfect for counters and flags in concurrent scenarios.",
      "difficulty": "Medium",
      "code": "// AtomicInteger - thread-safe counter\nprivate AtomicInteger counter = new AtomicInteger(0);\n\n// Atomic operations\ncounter.incrementAndGet();  // Atomic ++\ncounter.decrementAndGet();  // Atomic --\ncounter.addAndGet(5);       // Atomic += 5\ncounter.get();              // Read current value\n\n// Compare and set (CAS)\nint expected = 10;\nint newValue = 20;\nboolean updated = counter.compareAndSet(expected, newValue);\nif (updated) {\n    System.out.println(\"Updated from 10 to 20\");\n}\n\n// AtomicReference\nAtomicReference<String> atomicRef = new AtomicReference<>(\"Initial\");\natomicRef.set(\"Updated\");\natomicRef.compareAndSet(\"Updated\", \"Final\");\n\n// updateAndGet with lambda\nAtomicInteger value = new AtomicInteger(5);\nint result = value.updateAndGet(v -> v * 2);  // Atomic: value = value * 2\nSystem.out.println(result);  // 10\n\n// vs synchronized (atomic is faster)\nsynchronized (this) {\n    counter++;  // Slower due to lock\n}"
    },
    {
      "id": 50,
      "question": "What are the thread states in Java?",
      "answer": "Thread lifecycle has 6 states (Thread.State enum):\n\n1. NEW: Thread created but not started\n\n2. RUNNABLE: Running or ready to run (including OS running)\n\n3. BLOCKED: Waiting for monitor lock to enter synchronized block\n\n4. WAITING: Waiting indefinitely (wait(), join(), park())\n\n5. TIMED_WAITING: Waiting for specified time (sleep(), wait(timeout))\n\n6. TERMINATED: Thread completed execution",
      "explanation": "Understanding states helps debug threading issues. Use thread dumps to see state of all threads. BLOCKED vs WAITING: BLOCKED is for locks, WAITING is for explicit wait calls.",
      "difficulty": "Easy",
      "code": "Thread thread = new Thread(() -> {\n    synchronized(lock) {\n        try {\n            Thread.sleep(1000);\n            lock.wait();\n        } catch (InterruptedException e) {}\n    }\n});\n\n// Check states\nSystem.out.println(thread.getState());  // NEW\n\nthread.start();\nSystem.out.println(thread.getState());  // RUNNABLE\n\n// Thread states during execution:\n// NEW → start() → RUNNABLE\n// RUNNABLE → sleep()/wait(timeout) → TIMED_WAITING\n// RUNNABLE → wait()/join() → WAITING\n// RUNNABLE → synchronized block → BLOCKED (if lock held)\n// Any state → complete → TERMINATED\n\n// Get all thread states\nMap<Thread, StackTraceElement[]> threads = Thread.getAllStackTraces();\nfor (Thread t : threads.keySet()) {\n    System.out.println(t.getName() + \": \" + t.getState());\n}"
    },
    {
      "id": 51,
      "question": "What is deadlock and how to prevent it?",
      "answer": "Deadlock occurs when two or more threads wait for each other's locks indefinitely.\n\nFour conditions for deadlock:\n1. Mutual exclusion: Resources can't be shared\n2. Hold and wait: Holding while waiting for more\n3. No preemption: Can't force release\n4. Circular wait: Circular chain of waiting\n\nPrevention strategies:\n• Lock ordering: Always acquire locks in same order\n• Lock timeout: Use tryLock with timeout\n• Avoid nested locks: Minimize lock holding\n• Use concurrent utilities: Higher-level abstractions\n• Detect and break: Monitor and interrupt",
      "explanation": "Deadlock is a critical issue in concurrent programming. Prevention is key - consistent lock ordering is the most common solution. Use tools like jstack for detection.",
      "difficulty": "Hard",
      "code": "// Deadlock example\nObject lock1 = new Object();\nObject lock2 = new Object();\n\nThread t1 = new Thread(() -> {\n    synchronized(lock1) {\n        System.out.println(\"T1: Holding lock1\");\n        try { Thread.sleep(50); } catch (InterruptedException e) {}\n        synchronized(lock2) {  // Waiting for lock2\n            System.out.println(\"T1: Holding lock1 & lock2\");\n        }\n    }\n});\n\nThread t2 = new Thread(() -> {\n    synchronized(lock2) {\n        System.out.println(\"T2: Holding lock2\");\n        synchronized(lock1) {  // Waiting for lock1 - DEADLOCK!\n            System.out.println(\"T2: Holding lock1 & lock2\");\n        }\n    }\n});\n\n// Solution 1: Lock ordering\nsynchronized(lock1) {  // Both threads acquire in same order\n    synchronized(lock2) {\n        // Safe\n    }\n}\n\n// Solution 2: Try lock with timeout\nReentrantLock lockA = new ReentrantLock();\nReentrantLock lockB = new ReentrantLock();\n\nif (lockA.tryLock(1000, TimeUnit.MILLISECONDS)) {\n    try {\n        if (lockB.tryLock(1000, TimeUnit.MILLISECONDS)) {\n            try {\n                // Got both locks\n            } finally {\n                lockB.unlock();\n            }\n        }\n    } finally {\n        lockA.unlock();\n    }\n}"
    },
    {
      "id": 52,
      "question": "What is the Java 8 Date and Time API?",
      "answer": "Java 8 introduced java.time package, replacing java.util.Date and Calendar.\n\nKey classes:\n• LocalDate: Date without time\n• LocalTime: Time without date\n• LocalDateTime: Date and time\n• ZonedDateTime: Date and time with timezone\n• Instant: Timestamp (epoch seconds)\n• Duration: Time-based amount\n• Period: Date-based amount\n• DateTimeFormatter: Format/parse dates\n\nBenefits:\n• Immutable and thread-safe\n• Clear API\n• Better timezone handling",
      "explanation": "Old Date/Calendar APIs were mutable, confusing, and not thread-safe. New API is immutable, fluent, and comprehensive. Always use java.time for new code.",
      "difficulty": "Medium",
      "code": "// LocalDate - date without time\nLocalDate today = LocalDate.now();\nLocalDate birthday = LocalDate.of(1990, Month.JANUARY, 15);\nLocalDate tomorrow = today.plusDays(1);\n\n// LocalTime - time without date\nLocalTime now = LocalTime.now();\nLocalTime midday = LocalTime.of(12, 0);\n\n// LocalDateTime - date and time\nLocalDateTime dateTime = LocalDateTime.now();\nLocalDateTime specific = LocalDateTime.of(2024, 1, 1, 10, 30);\n\n// ZonedDateTime - with timezone\nZonedDateTime zonedNow = ZonedDateTime.now();\nZonedDateTime tokyo = ZonedDateTime.now(ZoneId.of(\"Asia/Tokyo\"));\n\n// Instant - timestamp\nInstant timestamp = Instant.now();\nlong epochSeconds = timestamp.getEpochSecond();\n\n// Duration - time-based\nDuration duration = Duration.between(now, midday);\nlong minutes = duration.toMinutes();\n\n// Period - date-based\nPeriod period = Period.between(birthday, today);\nint years = period.getYears();\n\n// Formatting\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\nString formatted = dateTime.format(formatter);\nLocalDateTime parsed = LocalDateTime.parse(\"2024-01-01 10:30:00\", formatter);"
    },
    {
      "id": 53,
      "question": "What is try-with-resources in Java?",
      "answer": "try-with-resources is a statement that ensures resources are closed automatically, introduced in Java 7.\n\nFeatures:\n• Automatic resource management\n• Implements AutoCloseable interface\n• Multiple resources can be declared\n• Resources closed in reverse order\n• Suppressed exceptions tracked\n• No need for explicit finally block\n\nResources:\n• Streams (InputStream, OutputStream)\n• Readers/Writers\n• Database connections\n• Any AutoCloseable implementation",
      "explanation": "try-with-resources prevents resource leaks by automatically closing resources. Much cleaner than manual try-finally. Always use it for I/O operations.",
      "difficulty": "Easy",
      "code": "// Without try-with-resources (old way)\nBufferedReader reader = null;\ntry {\n    reader = new BufferedReader(new FileReader(\"file.txt\"));\n    String line = reader.readLine();\n} catch (IOException e) {\n    e.printStackTrace();\n} finally {\n    if (reader != null) {\n        try {\n            reader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n// With try-with-resources (Java 7+)\ntry (BufferedReader reader = new BufferedReader(new FileReader(\"file.txt\"))) {\n    String line = reader.readLine();\n} catch (IOException e) {\n    e.printStackTrace();\n}  // reader automatically closed\n\n// Multiple resources\ntry (FileInputStream in = new FileInputStream(\"in.txt\");\n     FileOutputStream out = new FileOutputStream(\"out.txt\")) {\n    // Use streams\n}  // Both closed automatically in reverse order\n\n// Custom AutoCloseable\nclass MyResource implements AutoCloseable {\n    @Override\n    public void close() {\n        System.out.println(\"Resource closed\");\n    }\n}\n\ntry (MyResource resource = new MyResource()) {\n    // Use resource\n}  // Automatically calls close()"
    },
    {
      "id": 54,
      "question": "What is StringBuilder vs StringBuffer?",
      "answer": "Both are mutable sequences of characters for efficient string manipulation.\n\nStringBuilder:\n• Not thread-safe\n• Faster (no synchronization overhead)\n• Introduced in Java 5\n• Preferred for single-threaded scenarios\n\nStringBuffer:\n• Thread-safe (synchronized methods)\n• Slower due to synchronization\n• Legacy class from Java 1.0\n• Use only when thread-safety needed\n\nWhy mutable matters:\n• String concatenation creates new objects\n• StringBuilder/StringBuffer modify in-place",
      "explanation": "Always prefer StringBuilder over StringBuffer unless you need thread-safety. String concatenation in loops is inefficient - use StringBuilder. Compiler automatically uses StringBuilder for string concatenation in single statements.",
      "difficulty": "Easy",
      "code": "// String - immutable (inefficient in loops)\nString s = \"\";\nfor (int i = 0; i < 1000; i++) {\n    s += i;  // Creates 1000 new String objects!\n}\n\n// StringBuilder - mutable (efficient)\nStringBuilder sb = new StringBuilder();\nfor (int i = 0; i < 1000; i++) {\n    sb.append(i);  // Modifies same object\n}\nString result = sb.toString();\n\n// Common methods\nStringBuilder builder = new StringBuilder(\"Hello\");\nbuilder.append(\" World\");     // \"Hello World\"\nbuilder.insert(5, \",\");        // \"Hello, World\"\nbuilder.delete(5, 6);          // \"Hello World\"\nbuilder.reverse();             // \"dlroW olleH\"\nbuilder.setCharAt(0, 'D');    // \"DlroW olleH\"\n\n// StringBuffer - same API, synchronized\nStringBuffer buffer = new StringBuffer();\nbuffer.append(\"Thread-safe\");\n\n// Capacity management\nStringBuilder sb2 = new StringBuilder(100);  // Initial capacity\nsb2.ensureCapacity(200);"
    },
    {
      "id": 55,
      "question": "What are important methods of the Object class?",
      "answer": "Object is the root class of all Java classes. Key methods:\n\nequals(Object obj):\n• Check logical equality\n• Default: reference equality (==)\n\nhashCode():\n• Return hash code for hashing collections\n• Must be consistent with equals()\n\ntoString():\n• String representation\n• Default: ClassName@hashCode\n\nclone():\n• Create copy of object\n• Requires Cloneable interface\n\nfinalize():\n• Called before GC (deprecated)\n\ngetClass():\n• Returns Class object\n\nnotify/notifyAll/wait:\n• Thread synchronization",
      "explanation": "These methods define fundamental object behavior. Always override equals, hashCode, and toString for domain objects. Understanding these is crucial for working with collections.",
      "difficulty": "Easy",
      "code": "class Person {\n    String name;\n    int age;\n    \n    // equals - logical equality\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;\n        if (obj == null || getClass() != obj.getClass()) return false;\n        Person p = (Person) obj;\n        return age == p.age && Objects.equals(name, p.name);\n    }\n    \n    // hashCode - consistent with equals\n    @Override\n    public int hashCode() {\n        return Objects.hash(name, age);\n    }\n    \n    // toString - readable representation\n    @Override\n    public String toString() {\n        return \"Person{name='\" + name + \"', age=\" + age + \"}\";\n    }\n    \n    // clone - create copy\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();  // Shallow copy\n    }\n}\n\n// Usage\nPerson p1 = new Person(\"John\", 25);\nPerson p2 = new Person(\"John\", 25);\n\nSystem.out.println(p1.equals(p2));  // true\nSystem.out.println(p1.hashCode() == p2.hashCode());  // true\nSystem.out.println(p1);  // Person{name='John', age=25}\nSystem.out.println(p1.getClass());  // class Person"
    },
    {
      "id": 56,
      "question": "What is varargs in Java?",
      "answer": "Varargs (variable arguments) allows methods to accept variable number of arguments of the same type.\n\nSyntax: type... variableName\n\nRules:\n• Only one varargs parameter per method\n• Must be the last parameter\n• Treated as an array inside method\n• Can pass array or individual values\n• Can pass zero arguments\n\nIntroduced in Java 5.",
      "explanation": "Varargs simplifies methods that need flexible number of arguments. Common in utility methods like String.format(), Arrays.asList(). Behind the scenes, it's just an array.",
      "difficulty": "Easy",
      "code": "// Varargs method\npublic static int sum(int... numbers) {\n    int total = 0;\n    for (int num : numbers) {  // Treated as array\n        total += num;\n    }\n    return total;\n}\n\n// Multiple ways to call\nsum();                  // 0 arguments\nsum(1);                 // 1 argument\nsum(1, 2, 3);          // 3 arguments\nsum(1, 2, 3, 4, 5);    // 5 arguments\n\nint[] array = {1, 2, 3};\nsum(array);            // Pass array directly\n\n// Varargs with other parameters (must be last)\npublic static void print(String prefix, int... numbers) {\n    System.out.print(prefix + \": \");\n    for (int num : numbers) {\n        System.out.print(num + \" \");\n    }\n}\n\nprint(\"Numbers\", 1, 2, 3);  // \"Numbers: 1 2 3\"\n\n// Common varargs methods\nString.format(\"%s %s %s\", \"a\", \"b\", \"c\");\nArrays.asList(1, 2, 3, 4, 5);\nCollections.addAll(list, \"a\", \"b\", \"c\");"
    },
    {
      "id": 57,
      "question": "What is the difference between static and dynamic binding?",
      "answer": "Binding is the connection between method call and method code.\n\nStatic Binding (Early Binding):\n• Resolved at compile time\n• Used for private, static, final methods\n• Method overloading\n• Faster (no runtime lookup)\n\nDynamic Binding (Late Binding):\n• Resolved at runtime\n• Used for overridden methods\n• Method overriding\n• Enables polymorphism\n• Slightly slower (runtime lookup)",
      "explanation": "Static binding is when compiler knows which method to call. Dynamic binding is when JVM decides at runtime based on actual object type. Dynamic binding enables polymorphism - key to OOP.",
      "difficulty": "Medium",
      "code": "class Animal {\n    static void staticMethod() {\n        System.out.println(\"Animal static\");\n    }\n    \n    final void finalMethod() {\n        System.out.println(\"Animal final\");\n    }\n    \n    void instanceMethod() {\n        System.out.println(\"Animal instance\");\n    }\n}\n\nclass Dog extends Animal {\n    static void staticMethod() {  // Hiding, not overriding\n        System.out.println(\"Dog static\");\n    }\n    \n    // Cannot override final method\n    \n    @Override\n    void instanceMethod() {\n        System.out.println(\"Dog instance\");\n    }\n}\n\n// Static binding\nAnimal animal = new Dog();\nanimal.staticMethod();    // \"Animal static\" (compile-time)\nanimal.finalMethod();     // \"Animal final\" (compile-time)\n\n// Dynamic binding\nanimal.instanceMethod();  // \"Dog instance\" (runtime - polymorphism)\n\n// Method overloading (static binding)\nclass Calculator {\n    int add(int a, int b) { return a + b; }\n    double add(double a, double b) { return a + b; }\n}\nCalculator calc = new Calculator();\ncalc.add(1, 2);      // Compile-time: calls int version\ncalc.add(1.0, 2.0);  // Compile-time: calls double version"
    },
    {
      "id": 58,
      "question": "What are marker interfaces in Java?",
      "answer": "Marker interfaces are empty interfaces (no methods or fields) that provide metadata about a class.\n\nCommon marker interfaces:\n• Serializable: Object can be serialized\n• Cloneable: Object can be cloned\n• Remote: Object can be accessed remotely (RMI)\n\nPurpose:\n• Signal to compiler/JVM\n• Enable special treatment\n• Categorize classes\n\nModern alternative:\n• Annotations are preferred (more flexible)",
      "explanation": "Marker interfaces are legacy way to add metadata. They enable JVM to treat implementing classes specially. Annotations are now preferred for new designs as they're more flexible and explicit.",
      "difficulty": "Easy",
      "code": "// Marker interfaces\npublic interface Serializable { }  // Empty\npublic interface Cloneable { }     // Empty\n\n// Usage\nclass Person implements Serializable {\n    String name;\n    int age;\n}\n\n// JVM checks marker interface\ntry (ObjectOutputStream out = new ObjectOutputStream(\n        new FileOutputStream(\"person.ser\"))) {\n    Person p = new Person();\n    out.writeObject(p);  // OK because Person implements Serializable\n}\n\n// Without Serializable\nclass NotSerializable { }\nNotSerializable obj = new NotSerializable();\n// out.writeObject(obj);  // NotSerializableException!\n\n// Cloneable example\nclass Point implements Cloneable {\n    int x, y;\n    \n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();  // OK because implements Cloneable\n    }\n}\n\n// Modern alternative - annotations\n@Entity  // Annotation instead of marker interface\nclass User {\n    // ...\n}"
    },
    {
      "id": 59,
      "question": "What is the classpath and classloading in Java?",
      "answer": "Classpath:\n• Location where JVM searches for classes and resources\n• Set via -cp or -classpath option\n• Can include directories and JAR files\n\nClassloading:\n• Process of loading classes into JVM\n• Three built-in classloaders:\n  1. Bootstrap: Loads core Java classes (rt.jar)\n  2. Extension: Loads extension classes\n  3. Application: Loads application classes\n• Delegation model: child delegates to parent\n• Classes loaded on-demand (lazy loading)\n\nPrinciples:\n• Delegation: Ask parent first\n• Visibility: Child sees parent classes, not vice versa\n• Uniqueness: Class loaded only once",
      "explanation": "Understanding classloading is crucial for debugging ClassNotFoundException and understanding frameworks. Delegation model ensures core classes can't be overridden by application classes.",
      "difficulty": "Hard",
      "code": "// Run Java with classpath\n// java -cp \"lib/*:classes\" com.example.Main\n\n// Programmatic class loading\nClassLoader classLoader = MyClass.class.getClassLoader();\nClass<?> clazz = classLoader.loadClass(\"com.example.SomeClass\");\n\n// Get classloader hierarchy\nSystem.out.println(\"Application: \" + \n    ClassLoader.getSystemClassLoader());\nSystem.out.println(\"Extension: \" + \n    ClassLoader.getSystemClassLoader().getParent());\nSystem.out.println(\"Bootstrap: \" + \n    ClassLoader.getSystemClassLoader().getParent().getParent());  // null\n\n// String class loaded by Bootstrap\nSystem.out.println(String.class.getClassLoader());  // null\n\n// Custom classloader\nclassCustomLoader extends ClassLoader {\n    @Override\n    public Class<?> findClass(String name) throws ClassNotFoundException {\n        // Load class bytes from custom source\n        byte[] classBytes = loadClassBytes(name);\n        return defineClass(name, classBytes, 0, classBytes.length);\n    }\n}\n\n// Get resource from classpath\nInputStream is = getClass().getResourceAsStream(\"/config.properties\");\nURL resource = getClass().getResource(\"/config.properties\");"
    },
    {
      "id": 60,
      "question": "What is the JVM architecture?",
      "answer": "JVM consists of three main components:\n\n1. Class Loader Subsystem:\n• Loading, linking, initialization\n• Bootstrap, Extension, Application classloaders\n\n2. Runtime Data Areas:\n• Method Area: Class metadata, static variables\n• Heap: Objects and arrays\n• Stack: Thread-local method frames\n• PC Register: Current instruction per thread\n• Native Method Stack: Native method calls\n\n3. Execution Engine:\n• Interpreter: Executes bytecode line by line\n• JIT Compiler: Compiles hot code to native\n• Garbage Collector: Manages memory",
      "explanation": "Understanding JVM architecture helps with performance tuning and debugging. Heap and Stack are most important - heap for objects (shared), stack for method calls (thread-local). JIT compiler optimizes frequently-executed code.",
      "difficulty": "Hard",
      "code": "// Memory areas behavior\n\n// Method Area - class metadata, static\nclass Example {\n    static int staticVar = 10;  // Method Area\n    int instanceVar;             // Blueprint in Method Area\n}\n\n// Heap - objects\nExample obj = new Example();  // Object in Heap\nobj.instanceVar = 20;         // Instance variable in Heap\n\n// Stack - method frames\nvoid method() {\n    int localVar = 30;  // Local variable in Stack\n    method2();          // New frame pushed to Stack\n}  // Frame popped when method returns\n\n// JVM options for tuning\n// -Xms: Initial heap size\n// -Xmx: Maximum heap size\n// -Xss: Thread stack size\n// -XX:+UseG1GC: Use G1 garbage collector\n// java -Xms512m -Xmx2g -XX:+UseG1GC MyApp\n\n// Check memory\nRuntime runtime = Runtime.getRuntime();\nlong maxMemory = runtime.maxMemory();    // Max heap\nlong totalMemory = runtime.totalMemory();// Current heap\nlong freeMemory = runtime.freeMemory();  // Free heap\n\n// Trigger GC (suggestion only)\nSystem.gc();\n\n// Get JIT compilation info\n// -XX:+PrintCompilation"
    },
    {
      "id": 61,
      "question": "What are OutOfMemoryError types in Java?",
      "answer": "Common OutOfMemoryError types:\n\n1. Java heap space:\n• Heap is full\n• Too many objects created\n• Solution: Increase heap (-Xmx), fix memory leak\n\n2. GC Overhead limit exceeded:\n• GC taking too much time (>98%)\n• Solution: Increase heap, optimize code\n\n3. Metaspace (PermGen in Java 7):\n• Too many classes loaded\n• Solution: Increase metaspace (-XX:MaxMetaspaceSize)\n\n4. Unable to create new native thread:\n• OS limit on threads reached\n• Solution: Reduce thread count, increase OS limit\n\n5. Direct buffer memory:\n• NIO direct buffers exhausted",
      "explanation": "OutOfMemoryError indicates memory exhaustion. Always analyze heap dumps to find root cause. Use profilers like VisualVM or MAT to identify memory leaks.",
      "difficulty": "Hard",
      "code": "// 1. Heap Space error\nList<byte[]> list = new ArrayList<>();\nwhile (true) {\n    list.add(new byte[1024 * 1024]);  // 1MB each\n}  // OutOfMemoryError: Java heap space\n\n// 2. Metaspace error (too many classes)\nwhile (true) {\n    ClassLoader loader = new CustomClassLoader();\n    loader.loadClass(\"SomeClass\");\n}  // OutOfMemoryError: Metaspace\n\n// 3. Too many threads\nwhile (true) {\n    new Thread(() -> {\n        try { Thread.sleep(Long.MAX_VALUE); }\n        catch (InterruptedException e) {}\n    }).start();\n}  // OutOfMemoryError: unable to create new native thread\n\n// Prevention strategies\n// 1. Increase heap: -Xmx2g\n// 2. Analyze heap dump: -XX:+HeapDumpOnOutOfMemoryError\n// 3. Monitor with jstat, jconsole, VisualVM\n// 4. Fix memory leaks\n// 5. Use memory profilers"
    },
    {
      "id": 62,
      "question": "What are WeakReference, SoftReference, and PhantomReference?",
      "answer": "Reference types affect garbage collection behavior:\n\nStrongReference (default):\n• obj = new Object()\n• Never garbage collected while reachable\n\nWeakReference:\n• Collected in next GC cycle\n• Used for caches that shouldn't prevent GC\n• WeakHashMap uses weak keys\n\nSoftReference:\n• Collected only when memory is low\n• Used for memory-sensitive caches\n• JVM considers available memory\n\nPhantomReference:\n• Always null when get() called\n• Used for cleanup actions\n• Must use ReferenceQueue",
      "explanation": "Special references let you implement caches that don't prevent GC. WeakReference for temporary caches, SoftReference for memory-sensitive caches. PhantomReference for post-GC cleanup.",
      "difficulty": "Hard",
      "code": "// Strong reference (normal)\nObject obj = new Object();  // Won't be collected while obj exists\n\n// WeakReference - collected eagerly\nWeakReference<Object> weakRef = new WeakReference<>(new Object());\nSystem.gc();\nif (weakRef.get() == null) {\n    System.out.println(\"Collected\");  // Likely collected\n}\n\n// SoftReference - collected when memory low\nSoftReference<byte[]> softRef = new SoftReference<>(new byte[1024]);\nSystem.gc();\nif (softRef.get() != null) {\n    System.out.println(\"Still alive\");  // Likely still alive\n}\n\n// WeakHashMap - weak keys\nMap<Key, Value> cache = new WeakHashMap<>();\nKey key = new Key();\ncache.put(key, value);\nkey = null;  // Now key can be collected\nSystem.gc();\n// Entry removed from map when key is collected\n\n// PhantomReference - for cleanup\nReferenceQueue<Object> queue = new ReferenceQueue<>();\nPhantomReference<Object> phantom = \n    new PhantomReference<>(new Object(), queue);\nSystem.gc();\nReference<?> ref = queue.poll();\nif (ref != null) {\n    // Perform cleanup\n}"
    },
    {
      "id": 63,
      "question": "What is immutability in Java and how to create immutable class?",
      "answer": "Immutable class is a class whose state cannot be changed after creation.\n\nBenefits:\n• Thread-safe by nature\n• Safe to share\n• Good hash keys\n• Cacheable\n\nRules for immutable class:\n1. Make class final (prevent inheritance)\n2. Make all fields private final\n3. No setters\n4. Initialize fields in constructor\n5. Deep copy mutable objects in constructor/getter\n6. Don't allow subclasses to override methods\n\nExamples: String, Integer, LocalDate",
      "explanation": "Immutability ensures thread-safety without synchronization. String is immutable - that's why it's safe in concurrent contexts. Always return defensive copies of mutable fields.",
      "difficulty": "Medium",
      "code": "// Immutable class\npublic final class ImmutablePerson {\n    private final String name;\n    private final int age;\n    private final List<String> hobbies;\n    \n    public ImmutablePerson(String name, int age, List<String> hobbies) {\n        this.name = name;\n        this.age = age;\n        // Deep copy mutable parameter\n        this.hobbies = new ArrayList<>(hobbies);\n    }\n    \n    // Only getters, no setters\n    public String getName() {\n        return name;\n    }\n    \n    public int getAge() {\n        return age;\n    }\n    \n    public List<String> getHobbies() {\n        // Return defensive copy\n        return new ArrayList<>(hobbies);\n    }\n}\n\n// Usage - cannot modify\nList<String> hobbies = Arrays.asList(\"Reading\", \"Coding\");\nImmutablePerson person = new ImmutablePerson(\"John\", 25, hobbies);\n\n// These don't affect the object\nhobbies.set(0, \"Gaming\");  // Original list modified\nperson.getHobbies().add(\"New\");  // Returns copy, no effect\n\n// Immutable String example\nString str = \"Hello\";\nstr.concat(\" World\");  // Returns new String, str unchanged\nSystem.out.println(str);  // Still \"Hello\""
    },
    {
      "id": 64,
      "question": "What is the Producer-Consumer problem in Java?",
      "answer": "Classic synchronization problem where producers create items and consumers use them, sharing a bounded buffer.\n\nChallenges:\n• Synchronize access to shared buffer\n• Producer waits when buffer full\n• Consumer waits when buffer empty\n• Avoid race conditions\n\nSolutions:\n1. wait/notify with synchronized\n2. BlockingQueue (preferred)\n3. ReentrantLock with Conditions\n4. Semaphores",
      "explanation": "Producer-Consumer is fundamental to understanding thread coordination. BlockingQueue handles synchronization automatically - always prefer it over manual wait/notify.",
      "difficulty": "Hard",
      "code": "// Solution 1: BlockingQueue (best)\nclass ProducerConsumer {\n    private BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(10);\n    \n    class Producer implements Runnable {\n        public void run() {\n            try {\n                for (int i = 0; i < 100; i++) {\n                    queue.put(i);  // Blocks when full\n                    System.out.println(\"Produced: \" + i);\n                }\n            } catch (InterruptedException e) {}\n        }\n    }\n    \n    class Consumer implements Runnable {\n        public void run() {\n            try {\n                while (true) {\n                    Integer item = queue.take();  // Blocks when empty\n                    System.out.println(\"Consumed: \" + item);\n                }\n            } catch (InterruptedException e) {}\n        }\n    }\n}\n\n// Solution 2: wait/notify (manual)\nclass Buffer {\n    private Queue<Integer> queue = new LinkedList<>();\n    private int capacity = 10;\n    \n    public synchronized void produce(int item) throws InterruptedException {\n        while (queue.size() == capacity) {\n            wait();  // Wait until space available\n        }\n        queue.add(item);\n        notifyAll();  // Notify consumers\n    }\n    \n    public synchronized int consume() throws InterruptedException {\n        while (queue.isEmpty()) {\n            wait();  // Wait until item available\n        }\n        int item = queue.remove();\n        notifyAll();  // Notify producers\n        return item;\n    }\n}"
    },
    {
      "id": 65,
      "question": "What is the Fork/Join framework in Java?",
      "answer": "Fork/Join framework is designed for parallelizing divide-and-conquer algorithms, introduced in Java 7.\n\nKey concepts:\n• Fork: Split task into subtasks\n• Join: Wait for subtasks to complete\n• Work-stealing: Idle threads steal tasks from busy threads\n• ForkJoinPool: Special executor for Fork/Join tasks\n• RecursiveTask<V>: Returns result\n• RecursiveAction: No result\n\nBest for:\n• Recursive algorithms\n• Large data processing\n• Parallel algorithms",
      "explanation": "Fork/Join is perfect for problems that can be broken into smaller subproblems. Work-stealing makes it efficient - idle threads don't stay idle. Used internally by parallel streams.",
      "difficulty": "Hard",
      "code": "// RecursiveTask - returns result\nclass SumTask extends RecursiveTask<Long> {\n    private static final int THRESHOLD = 10000;\n    private int[] array;\n    private int start, end;\n    \n    SumTask(int[] array, int start, int end) {\n        this.array = array;\n        this.start = start;\n        this.end = end;\n    }\n    \n    @Override\n    protected Long compute() {\n        if (end - start <= THRESHOLD) {\n            // Small enough - compute directly\n            long sum = 0;\n            for (int i = start; i < end; i++) {\n                sum += array[i];\n            }\n            return sum;\n        } else {\n            // Fork into subtasks\n            int mid = (start + end) / 2;\n            SumTask left = new SumTask(array, start, mid);\n            SumTask right = new SumTask(array, mid, end);\n            \n            left.fork();   // Async execution\n            long rightResult = right.compute();  // Compute in current thread\n            long leftResult = left.join();       // Wait for forked task\n            \n            return leftResult + rightResult;\n        }\n    }\n}\n\n// Usage\nint[] array = new int[100000];\nForkJoinPool pool = new ForkJoinPool();\nlong sum = pool.invoke(new SumTask(array, 0, array.length));\n\n// ForkJoinPool.commonPool() - shared pool\nForkJoinPool.commonPool().invoke(new SumTask(array, 0, array.length));"
    },
    {
      "id": 66,
      "question": "What are Record classes in Java?",
      "answer": "Records are immutable data classes introduced in Java 14 (preview) and finalized in Java 16.\n\nFeatures:\n• Concise syntax for data carriers\n• Automatically generates: constructor, getters, equals, hashCode, toString\n• Implicitly final and immutable\n• All fields are private final\n• Cannot extend other classes (extends Record)\n• Can implement interfaces\n• Can have static members and methods\n• Compact constructors for validation",
      "explanation": "Records eliminate boilerplate for simple data classes. Perfect for DTOs, value objects, and immutable data carriers. Much cleaner than traditional POJOs.",
      "difficulty": "Medium",
      "code": "// Traditional class (verbose)\nclass PersonOld {\n    private final String name;\n    private final int age;\n    \n    public PersonOld(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public String name() { return name; }\n    public int age() { return age; }\n    \n    @Override\n    public boolean equals(Object obj) { /* ... */ }\n    @Override\n    public int hashCode() { /* ... */ }\n    @Override\n    public String toString() { /* ... */ }\n}\n\n// Record (concise) - Java 16+\nrecord Person(String name, int age) {\n    // All above methods generated automatically!\n    \n    // Compact constructor for validation\n    public Person {\n        if (age < 0) {\n            throw new IllegalArgumentException(\"Age cannot be negative\");\n        }\n    }\n    \n    // Additional methods allowed\n    public boolean isAdult() {\n        return age >= 18;\n    }\n    \n    // Static members allowed\n    public static Person defaultPerson() {\n        return new Person(\"Unknown\", 0);\n    }\n}\n\n// Usage\nPerson p = new Person(\"John\", 25);\nSystem.out.println(p.name());  // Accessor, not getter\nSystem.out.println(p);  // Auto-generated toString"
    },
    {
      "id": 67,
      "question": "What are Sealed classes in Java?",
      "answer": "Sealed classes restrict which classes can extend/implement them, introduced in Java 15 (preview) and finalized in Java 17.\n\nKeywords:\n• sealed: Class/interface restricts subclasses\n• permits: Declares allowed subclasses\n• final: Cannot be extended further\n• sealed: Can have own permitted subclasses\n• non-sealed: Open for extension\n\nBenefits:\n• Controlled inheritance hierarchy\n• Pattern matching exhaustiveness\n• Better domain modeling\n• API design control",
      "explanation": "Sealed classes close the gap between open (any can extend) and final (none can extend). Perfect for modeling closed domain hierarchies like payment types, shapes, etc.",
      "difficulty": "Medium",
      "code": "// Sealed class with permitted subclasses\nsealed class Shape\n    permits Circle, Rectangle, Triangle {\n    abstract double area();\n}\n\nfinal class Circle extends Shape {\n    double radius;\n    double area() { return Math.PI * radius * radius; }\n}\n\nfinal class Rectangle extends Shape {\n    double width, height;\n    double area() { return width * height; }\n}\n\nsealed class Triangle extends Shape\n    permits EquilateralTriangle {\n    double base, height;\n    double area() { return 0.5 * base * height; }\n}\n\nfinal class EquilateralTriangle extends Triangle { }\n\n// class Square extends Shape { }  // Compile error - not permitted!\n\n// Pattern matching with sealed classes\ndouble getArea(Shape shape) {\n    return switch (shape) {  // Exhaustive - all cases covered\n        case Circle c -> c.area();\n        case Rectangle r -> r.area();\n        case Triangle t -> t.area();\n        // No default needed - compiler knows all types\n    };\n}\n\n// Sealed interface\nsealed interface Payment\n    permits CreditCard, DebitCard, Cash {\n    void process();\n}"
    },
    {
      "id": 68,
      "question": "What is Pattern Matching in Java?",
      "answer": "Pattern matching simplifies type checking and casting, introduced incrementally from Java 14.\n\nFeatures:\n\ninstanceof patterns (Java 16):\n• Combined type test and cast\n• Eliminates explicit casting\n\nSwitch patterns (Java 17+ preview):\n• Pattern matching in switch\n• Type patterns\n• Guarded patterns\n\nRecord patterns (Java 19+ preview):\n• Destructure records in patterns",
      "explanation": "Pattern matching makes code more concise and readable. Eliminates boilerplate type checking and casting. Particularly powerful with sealed classes and records.",
      "difficulty": "Medium",
      "code": "// Before pattern matching (old way)\nObject obj = \"Hello\";\nif (obj instanceof String) {\n    String str = (String) obj;  // Explicit cast\n    System.out.println(str.length());\n}\n\n// With instanceof pattern (Java 16+)\nif (obj instanceof String str) {\n    System.out.println(str.length());  // str automatically cast\n}\n\n// Switch patterns (Java 17+ preview)\nstatic String format(Object obj) {\n    return switch (obj) {\n        case Integer i -> String.format(\"int: %d\", i);\n        case String s -> String.format(\"String: %s\", s);\n        case Long l -> String.format(\"long: %d\", l);\n        case null -> \"null\";\n        default -> obj.toString();\n    };\n}\n\n// Guarded patterns\nstatic String describe(Object obj) {\n    return switch (obj) {\n        case String s when s.length() > 5 -> \"Long string\";\n        case String s -> \"Short string\";\n        case Integer i when i > 0 -> \"Positive\";\n        case Integer i -> \"Non-positive\";\n        default -> \"Other\";\n    };\n}\n\n// Record patterns (Java 19+ preview)\nrecord Point(int x, int y) { }\n\nstatic void printPoint(Object obj) {\n    if (obj instanceof Point(int x, int y)) {\n        System.out.println(\"x=\" + x + \", y=\" + y);\n    }\n}"
    },
    {
      "id": 69,
      "question": "What are Text Blocks in Java?",
      "answer": "Text blocks are multi-line string literals introduced in Java 15.\n\nSyntax: \"\"\" ... \"\"\"\n\nFeatures:\n• Multi-line strings without concatenation\n• Preserves formatting\n• No need for escape sequences in most cases\n• Automatic indentation management\n• Cleaner SQL, JSON, HTML embedding\n\nEscape sequences:\n• \\s: Space (preserved)\n• \\n: New line\n• \\\\ : Line continuation (removes newline)",
      "explanation": "Text blocks make multi-line strings readable and maintainable. Perfect for embedded SQL, JSON, HTML, or any multi-line text. No more messy string concatenation!",
      "difficulty": "Easy",
      "code": "// Before text blocks (messy)\nString html = \"<html>\\n\" +\n              \"  <body>\\n\" +\n              \"    <p>Hello</p>\\n\" +\n              \"  </body>\\n\" +\n              \"</html>\";\n\n// With text blocks (clean) - Java 15+\nString htmlBlock = \"\"\"\n    <html>\n      <body>\n        <p>Hello</p>\n      </body>\n    </html>\n    \"\"\";\n\n// SQL query\nString query = \"\"\"\n    SELECT id, name, email\n    FROM users\n    WHERE age > 18\n      AND status = 'active'\n    ORDER BY name\n    \"\"\";\n\n// JSON\nString json = \"\"\"\n    {\n      \"name\": \"John\",\n      \"age\": 25,\n      \"city\": \"NYC\"\n    }\n    \"\"\";\n\n// String interpolation (use formatted())\nString name = \"John\";\nint age = 25;\nString message = \"\"\"\n    Hello, %s!\n    You are %d years old.\n    \"\"\".formatted(name, age);\n\n// Line continuation\nString continued = \"\"\"\n    This is a very long line \\\n    that continues on the next line.\n    \"\"\";"
    },
    {
      "id": 70,
      "question": "What is the var keyword in Java?",
      "answer": "var is a reserved type name for local variable type inference, introduced in Java 10.\n\nFeatures:\n• Compiler infers type from initializer\n• Only for local variables\n• Must be initialized\n• Cannot be null initialized\n• Cannot be used for: fields, method parameters, return types\n\nBenefits:\n• Reduces verbosity\n• Improves readability (when type is obvious)\n• Easier refactoring",
      "explanation": "var is not dynamic typing - type is inferred at compile time and cannot change. Use it when type is obvious from right side. Avoid when it reduces readability.",
      "difficulty": "Easy",
      "code": "// Traditional way\nArrayList<String> list = new ArrayList<String>();\nHashMap<Integer, String> map = new HashMap<>();\n\n// With var (Java 10+)\nvar list = new ArrayList<String>();  // ArrayList<String>\nvar map = new HashMap<Integer, String>();  // HashMap<Integer, String>\n\n// Good uses of var (type is obvious)\nvar num = 10;  // int\nvar name = \"John\";  // String\nvar users = getUserList();  // Type clear from method name\n\n// var in loops\nfor (var entry : map.entrySet()) {\n    System.out.println(entry.getKey());\n}\n\nfor (var i = 0; i < 10; i++) {\n    System.out.println(i);\n}\n\n// Bad uses (reduces readability)\nvar result = process();  // What type???\nvar data = x > 0 ? 1 : \"error\";  // Unclear type\n\n// Cannot use var for:\n// - Fields: var field = 10;  // Error\n// - Method parameters: void method(var param) { }  // Error\n// - Return types: var method() { }  // Error\n// - Without initializer: var x;  // Error\n// - Null initializer: var n = null;  // Error\n\n// Diamond operator works well with var\nvar list2 = new ArrayList<>();  // Type inferred from <>"
    },
    {
      "id": 71,
      "question": "What is the Module System (JPMS) in Java?",
      "answer": "Java Platform Module System (JPMS) introduced in Java 9 for better encapsulation and dependency management.\n\nKey concepts:\n• Module: Named group of packages\n• module-info.java: Module descriptor\n• exports: Makes package public\n• requires: Declares dependency\n• Strong encapsulation: Internal packages not accessible\n• Reliable configuration: Missing dependencies detected at startup\n\nBenefits:\n• Better encapsulation\n• Smaller runtime images\n• Improved performance\n• Explicit dependencies",
      "explanation": "Modules solve JAR hell and provide strong encapsulation. JDK itself is modularized. Not required for most applications but useful for large projects and libraries.",
      "difficulty": "Hard",
      "code": "// module-info.java\nmodule com.example.myapp {\n    // Export packages (public API)\n    exports com.example.api;\n    exports com.example.util to com.example.client;  // Qualified export\n    \n    // Declare dependencies\n    requires java.sql;\n    requires java.logging;\n    requires transitive java.xml;  // Transitive dependency\n    \n    // Service usage\n    uses com.example.service.MyService;\n    provides com.example.service.MyService\n        with com.example.impl.MyServiceImpl;\n    \n    // Reflection access\n    opens com.example.model to com.fasterxml.jackson.databind;\n}\n\n// Package structure\ncom.example.myapp/\n├── module-info.java\n├── com/\n│   └── example/\n│       ├── api/          (exported)\n│       ├── util/         (exported qualified)\n│       └── internal/     (not accessible outside)\n\n// Compile modular app\njavac -d out --module-source-path src $(find src -name \"*.java\")\n\n// Run modular app\njava --module-path out -m com.example.myapp/com.example.Main\n\n// Create custom runtime image\njlink --module-path out --add-modules com.example.myapp --output myapp\n\n// List modules\njava --list-modules"
    },
    {
      "id": 72,
      "question": "What is File I/O and NIO in Java?",
      "answer": "Java provides two APIs for file operations:\n\nOld I/O (java.io):\n• File class (legacy)\n• Stream-based (InputStream, OutputStream)\n• Blocking operations\n• Limited capabilities\n\nNIO (java.nio - New I/O):\n• Path and Files classes\n• Channel-based with Buffers\n• Non-blocking I/O possible\n• Memory-mapped files\n• File watching\n• Better performance\n\nNIO.2 (Java 7+):\n• Files utility class\n• Path interface\n• FileVisitor for directory traversal",
      "explanation": "NIO.2 (java.nio.file) is the modern way to do file I/O. More features, better performance, cleaner API. Always prefer Files over old File class for new code.",
      "difficulty": "Medium",
      "code": "// NIO.2 - modern way (Java 7+)\nimport java.nio.file.*;\n\n// Read file\nString content = Files.readString(Path.of(\"file.txt\"));\nList<String> lines = Files.readAllLines(Path.of(\"file.txt\"));\nbyte[] bytes = Files.readAllBytes(Path.of(\"file.txt\"));\n\n// Write file\nFiles.writeString(Path.of(\"output.txt\"), \"Hello\");\nFiles.write(Path.of(\"output.txt\"), lines);\n\n// Stream lines (memory efficient)\ntry (Stream<String> stream = Files.lines(Path.of(\"large.txt\"))) {\n    stream.filter(line -> line.contains(\"error\"))\n          .forEach(System.out::println);\n}\n\n// Copy, move, delete\nFiles.copy(source, target, StandardCopyOption.REPLACE_EXISTING);\nFiles.move(source, target);\nFiles.delete(path);\nFiles.deleteIfExists(path);\n\n// Check file\nboolean exists = Files.exists(path);\nboolean isDirectory = Files.isDirectory(path);\nlong size = Files.size(path);\n\n// List directory\ntry (Stream<Path> paths = Files.list(Path.of(\".\"))) {\n    paths.filter(Files::isRegularFile)\n         .forEach(System.out::println);\n}\n\n// Walk directory tree\nFiles.walk(Path.of(\".\"))\n     .filter(p -> p.toString().endsWith(\".java\"))\n     .forEach(System.out::println);\n\n// Watch directory for changes\nWatchService watcher = FileSystems.getDefault().newWatchService();\npath.register(watcher, StandardWatchEventKinds.ENTRY_CREATE);"
    },
    {
      "id": 73,
      "question": "What are best practices for Exception Handling in Java?",
      "answer": "Best practices:\n\n1. Specific exceptions:\n• Catch specific exceptions, not generic Exception\n• Multiple catch blocks for different handling\n\n2. Don't swallow exceptions:\n• Always log or handle exceptions\n• Don't catch and ignore\n\n3. Use try-with-resources:\n• Automatic resource management\n\n4. Clean up resources:\n• Use finally or try-with-resources\n\n5. Custom exceptions:\n• Create meaningful domain exceptions\n\n6. Don't use exceptions for control flow:\n• Expensive and unclear\n\n7. Document exceptions:\n• Use @throws in Javadoc",
      "explanation": "Good exception handling makes code robust and maintainable. Exceptions should be exceptional - don't use for normal flow. Always provide context in custom exceptions.",
      "difficulty": "Medium",
      "code": "// Good practices\npublic void goodExample() {\n    // 1. Specific exceptions\n    try {\n        processFile(\"data.txt\");\n    } catch (FileNotFoundException e) {\n        log.error(\"File not found: \" + e.getMessage());\n        // Handle specifically\n    } catch (IOException e) {\n        log.error(\"I/O error: \" + e.getMessage());\n        // Different handling\n    }\n    \n    // 2. try-with-resources\n    try (BufferedReader reader = new BufferedReader(new FileReader(\"file.txt\"))) {\n        String line = reader.readLine();\n    } catch (IOException e) {\n        log.error(\"Error reading file\", e);\n    }\n}\n\n// Bad practices to avoid\npublic void badExample() {\n    try {\n        riskyOperation();\n    } catch (Exception e) {  // Too generic!\n        // Empty catch - swallows exception!\n    }\n    \n    // Exception for control flow - BAD!\n    try {\n        return array[index];\n    } catch (IndexOutOfBoundsException e) {\n        return null;  // Use if statement instead!\n    }\n}\n\n// Custom exception with context\npublic class InsufficientBalanceException extends Exception {\n    private final double balance;\n    private final double requested;\n    \n    public InsufficientBalanceException(double balance, double requested) {\n        super(String.format(\"Insufficient balance: %.2f, requested: %.2f\",\n                          balance, requested));\n        this.balance = balance;\n        this.requested = requested;\n    }\n    \n    public double getBalance() { return balance; }\n    public double getRequested() { return requested; }\n}"
    },
    {
      "id": 74,
      "question": "What are SOLID principles in Java?",
      "answer": "SOLID principles are design principles for maintainable OOP code:\n\nS - Single Responsibility:\n• Class should have one reason to change\n• One class, one job\n\nO - Open/Closed:\n• Open for extension, closed for modification\n• Use inheritance and interfaces\n\nL - Liskov Substitution:\n• Subclass should be substitutable for superclass\n• Subtypes must be behaviorally compatible\n\nI - Interface Segregation:\n• Many specific interfaces better than one general\n• Clients shouldn't depend on unused methods\n\nD - Dependency Inversion:\n• Depend on abstractions, not concretions\n• High-level modules shouldn't depend on low-level",
      "explanation": "SOLID principles lead to flexible, maintainable code. They're guidelines, not strict rules. Understanding them improves design skills and code quality.",
      "difficulty": "Medium",
      "code": "// S - Single Responsibility\n// Bad: Multiple responsibilities\nclass User {\n    void saveToDatabase() { }  // Persistence\n    void sendEmail() { }       // Communication\n    void generateReport() { }  // Reporting\n}\n\n// Good: Separate responsibilities\nclass User { }\nclass UserRepository { void save(User u) { } }\nclass EmailService { void send(User u) { } }\nclass ReportGenerator { void generate(User u) { } }\n\n// O - Open/Closed\n// Use abstraction for extension\ninterface Shape { double area(); }\nclass Circle implements Shape {\n    public double area() { /* ... */ }\n}\nclass Rectangle implements Shape {\n    public double area() { /* ... */ }\n}\n// Add new shapes without modifying existing code\n\n// L - Liskov Substitution\n// Bad: Violates LSP\nclass Bird { void fly() { } }\nclass Penguin extends Bird {\n    void fly() { throw new UnsupportedOperationException(); }  // BAD!\n}\n\n// Good: Proper hierarchy\nclass Bird { }\nclass FlyingBird extends Bird { void fly() { } }\nclass Penguin extends Bird { void swim() { } }\n\n// I - Interface Segregation\n// Bad: Fat interface\ninterface Worker { void work(); void eat(); void sleep(); }\n\n// Good: Segregated interfaces\ninterface Workable { void work(); }\ninterface Eatable { void eat(); }\ninterface Sleepable { void sleep(); }\n\n// D - Dependency Inversion\nclass OrderService {\n    private Repository repository;  // Depend on abstraction\n    OrderService(Repository repo) { this.repository = repo; }\n}"
    },
    {
      "id": 75,
      "question": "What is Dependency Injection in Java?",
      "answer": "Dependency Injection (DI) is a design pattern where objects receive dependencies from external sources rather than creating them.\n\nTypes:\n\n1. Constructor Injection:\n• Dependencies passed via constructor\n• Preferred (immutable, testable)\n\n2. Setter Injection:\n• Dependencies via setter methods\n• Optional dependencies\n\n3. Field Injection:\n• Direct field assignment (reflection)\n• Least preferred\n\nBenefits:\n• Loose coupling\n• Testability\n• Flexibility\n• Single Responsibility",
      "explanation": "DI inverts control - objects don't create dependencies, they receive them. This makes code testable and flexible. Frameworks like Spring use DI extensively. Constructor injection is generally best.",
      "difficulty": "Medium",
      "code": "// Without DI - tight coupling\nclass OrderService {\n    private MySQLDatabase db = new MySQLDatabase();  // Hardcoded!\n    \n    void processOrder(Order order) {\n        db.save(order);  // Tightly coupled to MySQL\n    }\n}\n\n// With DI - loose coupling\ninterface Database {\n    void save(Order order);\n}\n\nclass MySQLDatabase implements Database {\n    public void save(Order order) { /* ... */ }\n}\n\nclass PostgreSQLDatabase implements Database {\n    public void save(Order order) { /* ... */ }\n}\n\n// 1. Constructor Injection (preferred)\nclass OrderService {\n    private final Database database;\n    \n    public OrderService(Database database) {  // Injected\n        this.database = database;\n    }\n    \n    void processOrder(Order order) {\n        database.save(order);  // Works with any Database implementation\n    }\n}\n\n// Usage\nDatabase db = new MySQLDatabase();\nOrderService service = new OrderService(db);  // Inject dependency\n\n// Easy to test with mock\nDatabase mockDb = mock(Database.class);\nOrderService testService = new OrderService(mockDb);\n\n// 2. Setter Injection\nclass OrderService {\n    private Database database;\n    \n    public void setDatabase(Database database) {\n        this.database = database;\n    }\n}\n\n// Spring Framework DI\n@Component\nclass OrderService {\n    private final Database database;\n    \n    @Autowired  // Spring injects automatically\n    public OrderService(Database database) {\n        this.database = database;\n    }\n}"
    },
    {
      "id": 76,
      "question": "What is the difference between deep copy and clone() method?",
      "answer": "Cloning vs Deep Copy:\n\nclone() method:\n• Protected method from Object class\n• Requires Cloneable interface\n• Default is shallow copy\n• Can be overridden for deep copy\n• Throws CloneNotSupportedException\n• Considered problematic by many experts\n\nDeep Copy:\n• Copies object and all referenced objects recursively\n• No standard implementation\n• Must be implemented manually\n• Alternatives: Copy constructors, factory methods, serialization\n\nBest practice: Avoid clone(), use copy constructors or builders",
      "explanation": "clone() has design flaws - requires casting, checked exception, fragile contract. Modern Java prefers copy constructors, static factory methods, or libraries like Apache Commons or builder pattern.",
      "difficulty": "Medium",
      "code": "// Using clone() - traditional way\nclass Person implements Cloneable {\n    String name;\n    Address address;\n    \n    @Override\n    public Person clone() throws CloneNotSupportedException {\n        Person cloned = (Person) super.clone();  // Shallow copy\n        cloned.address = address.clone();         // Deep copy reference\n        return cloned;\n    }\n}\n\n// Better: Copy constructor\nclass Person {\n    String name;\n    Address address;\n    \n    // Copy constructor\n    public Person(Person other) {\n        this.name = other.name;\n        this.address = new Address(other.address);  // Deep copy\n    }\n}\n\n// Usage\nPerson p1 = new Person(\"John\", new Address(\"NYC\"));\nPerson p2 = new Person(p1);  // Deep copy\n\n// Static factory method\nclass Person {\n    public static Person copyOf(Person other) {\n        return new Person(other.name, new Address(other.address));\n    }\n}\n\nPerson p3 = Person.copyOf(p1);\n\n// Builder pattern with copy\nPerson p4 = Person.builder()\n    .from(p1)\n    .withName(\"Jane\")  // Override specific field\n    .build();\n\n// Serialization-based deep copy (slow but works)\nclass DeepCopy {\n    static <T extends Serializable> T deepCopy(T object) {\n        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();\n             ObjectOutputStream oos = new ObjectOutputStream(bos)) {\n            oos.writeObject(object);\n            byte[] bytes = bos.toByteArray();\n            try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes);\n                 ObjectInputStream ois = new ObjectInputStream(bis)) {\n                return (T) ois.readObject();\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}"
    },
    {
      "id": 77,
      "question": "What is the difference between Path, Iterator and Stream in collections?",
      "answer": "Three ways to process collections:\n\nPath (forEach):\n• External iteration\n• Simple but imperative\n• Cannot be parallelized easily\n• Side effects okay\n\nIterator:\n• External iteration\n• More control (can remove elements)\n• Cannot be parallelized\n• Fail-fast behavior\n\nStream:\n• Internal iteration\n• Functional style\n• Can be parallelized\n• Lazy evaluation\n• Cannot modify collection\n• More abstract and composable",
      "explanation": "Stream is the modern approach - functional, composable, parallelizable. Use Iterator when you need to remove elements during iteration. forEach is simplest for side-effects. Streams shine with complex transformations.",
      "difficulty": "Medium",
      "code": "List<String> names = Arrays.asList(\"John\", \"Jane\", \"Bob\", \"Alice\");\n\n// 1. Path (forEach) - simple, external iteration\nfor (String name : names) {\n    System.out.println(name);  // Side effect\n}\n\nnames.forEach(name -> System.out.println(name));  // Lambda version\n\n// 2. Iterator - more control\nIterator<String> iterator = names.iterator();\nwhile (iterator.hasNext()) {\n    String name = iterator.next();\n    if (name.startsWith(\"B\")) {\n        iterator.remove();  // Can modify collection\n    }\n}\n\n// 3. Stream - functional, composable\nnames.stream()\n     .filter(name -> name.startsWith(\"J\"))\n     .map(String::toUpperCase)\n     .sorted()\n     .forEach(System.out::println);\n\n// Stream advantages\n// - Lazy evaluation\nStream<String> stream = names.stream()\n    .filter(name -> {  // Not executed until terminal operation\n        System.out.println(\"Filtering: \" + name);\n        return name.startsWith(\"J\");\n    });\n// Nothing printed yet!\nlong count = stream.count();  // Now executed\n\n// - Parallelization\nlong count = names.parallelStream()\n    .filter(name -> name.length() > 3)\n    .count();  // Automatically parallel\n\n// Cannot modify collection in stream\nnames.stream()\n     // .remove(\"John\");  // No remove method!\n     .collect(Collectors.toList());  // Create new collection instead"
    },
    {
      "id": 78,
      "question": "What is the difference between intermediate and terminal operations in Streams?",
      "answer": "Stream operations are divided into two types:\n\nIntermediate Operations:\n• Return a Stream\n• Lazy (not executed immediately)\n• Can be chained\n• Examples: filter, map, sorted, distinct, limit, skip\n• Form a pipeline\n\nTerminal Operations:\n• Return non-Stream result or void\n• Eager (trigger execution)\n• Close the stream\n• Examples: collect, forEach, reduce, count, anyMatch, findFirst\n• Stream can't be reused after\n\nShort-circuiting:\n• Some operations don't need to process all elements\n• Examples: findFirst, anyMatch, limit",
      "explanation": "Understanding lazy vs eager is crucial for Stream performance. Intermediate operations build a pipeline, terminal operations execute it. This enables optimization - only necessary elements are processed.",
      "difficulty": "Medium",
      "code": "List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\n// Intermediate operations (lazy - not executed)\nStream<Integer> stream = numbers.stream()\n    .filter(n -> {  // Not executed yet!\n        System.out.println(\"Filter: \" + n);\n        return n % 2 == 0;\n    })\n    .map(n -> {  // Not executed yet!\n        System.out.println(\"Map: \" + n);\n        return n * 2;\n    });\n\nSystem.out.println(\"Stream created\");  // No output from filter/map\n\n// Terminal operation (triggers execution)\nList<Integer> result = stream.collect(Collectors.toList());\n// NOW filter and map are executed\n\n// Common intermediate operations\nnumbers.stream()\n    .filter(n -> n > 5)        // Filter\n    .map(n -> n * 2)           // Transform\n    .distinct()                 // Remove duplicates\n    .sorted()                   // Sort\n    .limit(3)                   // Take first 3\n    .skip(1)                    // Skip first\n    .peek(System.out::println)  // Debug (side effect)\n    .collect(Collectors.toList());  // Terminal\n\n// Common terminal operations\nlong count = numbers.stream().count();\nOptional<Integer> first = numbers.stream().findFirst();\nOptional<Integer> any = numbers.stream().findAny();\nboolean allEven = numbers.stream().allMatch(n -> n % 2 == 0);\nboolean anyEven = numbers.stream().anyMatch(n -> n % 2 == 0);\nboolean noneNegative = numbers.stream().noneMatch(n -> n < 0);\nInteger sum = numbers.stream().reduce(0, Integer::sum);\n\n// Stream can't be reused\nStream<Integer> s = numbers.stream();\ns.count();\n// s.sum();  // IllegalStateException - stream already operated upon!\n\n// Short-circuiting optimization\nnumbers.stream()\n    .peek(n -> System.out.println(\"Processing: \" + n))\n    .filter(n -> n > 5)\n    .findFirst();  // Stops as soon as first match found!"
    },
    {
      "id": 79,
      "question": "What is Method Hiding in Java?",
      "answer": "Method Hiding occurs when a static method in a subclass has the same signature as a static method in the superclass.\n\nCharacteristics:\n• Only applies to static methods\n• Not polymorphic (no runtime binding)\n• Resolved at compile time\n• Called based on reference type, not object type\n• Different from method overriding\n\nOverriding (instance methods):\n• Runtime polymorphism\n• Resolved at runtime\n• Called based on object type\n\nHiding (static methods):\n• Compile-time resolution\n• Resolved at compile time\n• Called based on reference type",
      "explanation": "Method hiding is why static methods can't be truly overridden - they're not polymorphic. The method called is determined by the reference type, not the actual object type. This is a common interview question about static methods.",
      "difficulty": "Medium",
      "code": "class Parent {\n    // Static method\n    static void staticMethod() {\n        System.out.println(\"Parent static\");\n    }\n    \n    // Instance method\n    void instanceMethod() {\n        System.out.println(\"Parent instance\");\n    }\n}\n\nclass Child extends Parent {\n    // Method hiding (static)\n    static void staticMethod() {\n        System.out.println(\"Child static\");\n    }\n    \n    // Method overriding (instance)\n    @Override\n    void instanceMethod() {\n        System.out.println(\"Child instance\");\n    }\n}\n\n// Method hiding behavior\nParent p1 = new Parent();\nParent p2 = new Child();  // Parent reference, Child object\nChild c = new Child();\n\n// Static method - resolved by reference type (method hiding)\np1.staticMethod();  // \"Parent static\"\np2.staticMethod();  // \"Parent static\" (reference type is Parent!)\nc.staticMethod();   // \"Child static\"\nChild.staticMethod();  // \"Child static\" (best practice - call via class)\n\n// Instance method - resolved by object type (polymorphism)\np1.instanceMethod();  // \"Parent instance\"\np2.instanceMethod();  // \"Child instance\" (object is Child - polymorphism!)\nc.instanceMethod();   // \"Child instance\"\n\n// Key difference\n// Static: Reference type matters\n// Instance: Object type matters"
    },
    {
      "id": 80,
      "question": "What is the volatile keyword and when to use it?",
      "answer": "volatile is a keyword ensuring visibility of variable changes across threads.\n\nGuarantees:\n• Reads from main memory (not CPU cache)\n• Writes to main memory immediately\n• Happens-before relationship\n• No instruction reordering around volatile\n\nDoes NOT provide:\n• Atomicity (i++ is not atomic even with volatile)\n• Mutual exclusion\n\nUse cases:\n• Status flags\n• Single-writer, multiple-reader scenarios\n• Double-checked locking\n\nWhen NOT to use:\n• Compound operations (use AtomicInteger)\n• Multiple variables (use synchronized)",
      "explanation": "volatile solves visibility problem but not atomicity. For atomic operations, use Atomic classes or synchronized. Common use: boolean flag to stop threads. Remember: volatile != synchronized.",
      "difficulty": "Hard",
      "code": "// Example 1: Without volatile (problem)\nclass TaskRunner {\n    private boolean running = true;  // NOT volatile\n    \n    public void run() {\n        while (running) {  // May never see update!\n            // Thread caches 'running', may never reload\n        }\n    }\n    \n    public void stop() {\n        running = false;  // Other thread may not see this!\n    }\n}\n\n// Example 2: With volatile (solution)\nclass TaskRunner {\n    private volatile boolean running = true;  // VOLATILE\n    \n    public void run() {\n        while (running) {  // Always sees latest value\n            // Work\n        }\n    }\n    \n    public void stop() {\n        running = false;  // Immediately visible to all threads\n    }\n}\n\n// Example 3: volatile doesn't ensure atomicity\nclass Counter {\n    private volatile int count = 0;  // Visible but not atomic!\n    \n    public void increment() {\n        count++;  // NOT atomic! (read-modify-write)\n        // Thread A: read 0\n        // Thread B: read 0\n        // Thread A: write 1\n        // Thread B: write 1 (lost update!)\n    }\n}\n\n// Solution: Use AtomicInteger\nclass Counter {\n    private AtomicInteger count = new AtomicInteger(0);\n    \n    public void increment() {\n        count.incrementAndGet();  // Atomic\n    }\n}\n\n// Example 4: Double-checked locking (famous volatile use)\nclass Singleton {\n    private static volatile Singleton instance;  // Must be volatile!\n    \n    public static Singleton getInstance() {\n        if (instance == null) {  // First check (no locking)\n            synchronized (Singleton.class) {\n                if (instance == null) {  // Second check (locked)\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}"
    },
    {
      "id": 81,
      "question": "What are the different ways to create threads in Java?",
      "answer": "Four main ways to create threads:\n\n1. Extend Thread class:\n• Override run() method\n• Call start() to begin execution\n• Single inheritance limitation\n\n2. Implement Runnable interface:\n• Override run() method\n• Pass to Thread constructor\n• Preferred (composition over inheritance)\n\n3. Implement Callable interface:\n• Returns result and can throw exceptions\n• Used with ExecutorService\n• Returns Future<V>\n\n4. Lambda expressions (Java 8+):\n• Concise syntax for Runnable/Callable\n• Functional interface implementation",
      "explanation": "Runnable is preferred over extending Thread - it's more flexible and follows composition principle. Callable is for tasks that return results. Modern code uses ExecutorService with Runnable/Callable rather than creating Thread objects directly.",
      "difficulty": "Easy",
      "code": "// 1. Extend Thread class\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"Thread using Thread class\");\n    }\n}\nMyThread t1 = new MyThread();\nt1.start();\n\n// 2. Implement Runnable (preferred)\nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"Thread using Runnable\");\n    }\n}\nThread t2 = new Thread(new MyRunnable());\nt2.start();\n\n// 3. Implement Callable\nclass MyCallable implements Callable<Integer> {\n    @Override\n    public Integer call() throws Exception {\n        return 42;  // Can return value\n    }\n}\nExecutorService executor = Executors.newSingleThreadExecutor();\nFuture<Integer> future = executor.submit(new MyCallable());\nInteger result = future.get();\n\n// 4. Lambda expressions (Java 8+)\nThread t3 = new Thread(() -> {\n    System.out.println(\"Thread using lambda\");\n});\nt3.start();\n\n// Modern approach with ExecutorService\nExecutorService executor = Executors.newFixedThreadPool(5);\nexecutor.execute(() -> System.out.println(\"Task 1\"));\nexecutor.submit(() -> {\n    System.out.println(\"Task 2\");\n    return \"Result\";\n});\nexecutor.shutdown();"
    },
    {
      "id": 82,
      "question": "What is a Singleton pattern and how to implement it thread-safe?",
      "answer": "Singleton ensures only one instance of a class exists.\n\nImplementation approaches:\n\n1. Eager initialization:\n• Instance created at class loading\n• Thread-safe automatically\n• Wastes memory if never used\n\n2. Lazy initialization:\n• Instance created when needed\n• Requires synchronization\n\n3. Double-checked locking:\n• Lazy + minimizes synchronization\n• Requires volatile keyword\n\n4. Bill Pugh (best):\n• Uses static inner class\n• Lazy, thread-safe, no synchronization\n\n5. Enum (Joshua Bloch recommendation):\n• Simplest, serialization-safe",
      "explanation": "Bill Pugh's approach using static inner class is generally best - lazy loaded, thread-safe without synchronization. Enum is the simplest and handles serialization. Avoid double-checked locking unless you fully understand it.",
      "difficulty": "Medium",
      "code": "// 1. Eager initialization\nclass Singleton {\n    private static final Singleton instance = new Singleton();\n    private Singleton() { }\n    public static Singleton getInstance() { return instance; }\n}\n\n// 2. Lazy with synchronized method (inefficient)\nclass Singleton {\n    private static Singleton instance;\n    private Singleton() { }\n    public static synchronized Singleton getInstance() {  // Slow!\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n\n// 3. Double-checked locking (complex but efficient)\nclass Singleton {\n    private static volatile Singleton instance;  // volatile is crucial!\n    private Singleton() { }\n    public static Singleton getInstance() {\n        if (instance == null) {\n            synchronized (Singleton.class) {\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n\n// 4. Bill Pugh approach (best)\nclass Singleton {\n    private Singleton() { }\n    // Static inner class loaded only when getInstance() called\n    private static class SingletonHolder {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n    public static Singleton getInstance() {\n        return SingletonHolder.INSTANCE;  // Thread-safe, lazy\n    }\n}\n\n// 5. Enum (simplest, serialization-safe)\nenum Singleton {\n    INSTANCE;\n    public void doSomething() { }\n}\nSingleton.INSTANCE.doSomething();"
    },
    {
      "id": 83,
      "question": "What is Covariant Return Type in Java?",
      "answer": "Covariant return type allows overriding method to return a subtype of the return type declared in the parent method.\n\nIntroduced in Java 5.\n\nRules:\n• Return type must be subclass of parent's return type\n• Only applicable to non-primitive return types\n• Helps avoid explicit casting\n• Improves type safety\n\nExample: clone() method returns Object but can be overridden to return specific type\n\nBenefits:\n• More specific return types\n• Better type safety\n• Less casting needed",
      "explanation": "Covariant return types make APIs more type-safe and convenient. No need to cast the return value. Common in factory methods and fluent APIs where you want to return the specific type.",
      "difficulty": "Medium",
      "code": "// Parent class\nclass Animal {\n    Animal getAnimal() {\n        return new Animal();\n    }\n}\n\n// Child class with covariant return type\nclass Dog extends Animal {\n    @Override\n    Dog getAnimal() {  // Returns Dog, not Animal (covariant!)\n        return new Dog();\n    }\n}\n\n// Usage\nDog dog = new Dog();\nDog myDog = dog.getAnimal();  // No casting needed!\n// vs without covariant: Animal animal = dog.getAnimal(); Dog myDog = (Dog) animal;\n\n// Real-world example: clone()\nclass Person implements Cloneable {\n    String name;\n    \n    @Override\n    public Person clone() throws CloneNotSupportedException {  // Not Object!\n        return (Person) super.clone();\n    }\n}\n\nPerson p1 = new Person();\nPerson p2 = p1.clone();  // No cast needed!\n\n// Builder pattern with covariant return types\nclass Animal {\n    static class Builder {\n        Builder setName(String name) { return this; }\n        Animal build() { return new Animal(); }\n    }\n}\n\nclass Dog extends Animal {\n    static class Builder extends Animal.Builder {\n        @Override\n        Builder setName(String name) { return this; }\n        \n        @Override\n        Dog build() { return new Dog(); }  // Covariant return\n    }\n}\n\nDog dog = new Dog.Builder().setName(\"Buddy\").build();  // Returns Dog!"
    },
    {
      "id": 84,
      "question": "What is the difference between StringBuilder, StringBuffer, and String?",
      "answer": "Three classes for handling strings with different characteristics:\n\nString:\n• Immutable\n• Thread-safe by nature\n• Stored in String Pool\n• Use for: Constant strings, hash keys\n\nStringBuilder:\n• Mutable\n• Not thread-safe\n• Faster (no synchronization)\n• Use for: Single-threaded string manipulation\n\nStringBuffer:\n• Mutable\n• Thread-safe (synchronized methods)\n• Slower than StringBuilder\n• Use for: Multi-threaded string manipulation\n\nPerformance: StringBuilder > StringBuffer > String (for concatenation)",
      "explanation": "Always use StringBuilder for string concatenation in loops - it's much faster than String concatenation. Only use StringBuffer if multiple threads access the same instance. String is immutable so each concatenation creates new object.",
      "difficulty": "Easy",
      "code": "// String - immutable (inefficient for loops)\nString s = \"\";\nfor (int i = 0; i < 1000; i++) {\n    s += i;  // Creates 1000 new String objects!\n}\n\n// StringBuilder - mutable, not thread-safe (best for single thread)\nStringBuilder sb = new StringBuilder();\nfor (int i = 0; i < 1000; i++) {\n    sb.append(i);  // Modifies same object - fast!\n}\nString result = sb.toString();\n\n// StringBuffer - mutable, thread-safe (for multi-threading)\nStringBuffer sbf = new StringBuffer();\nfor (int i = 0; i < 1000; i++) {\n    sbf.append(i);  // Thread-safe but slower\n}\n\n// Common methods (same for StringBuilder and StringBuffer)\nStringBuilder builder = new StringBuilder(\"Hello\");\nbuilder.append(\" World\");          // \"Hello World\"\nbuilder.insert(5, \",\");             // \"Hello, World\"\nbuilder.replace(0, 5, \"Hi\");       // \"Hi, World\"\nbuilder.delete(2, 3);               // \"Hi World\"\nbuilder.reverse();                  // \"dlroW iH\"\nbuilder.setLength(5);               // \"dlroW\"\nint capacity = builder.capacity();  // Current capacity\n\n// Performance comparison\n// String: O(n²) for n concatenations\n// StringBuilder/StringBuffer: O(n) amortized\n\n// Compiler optimization\nString s1 = \"Hello\" + \" \" + \"World\";  // Compiler uses StringBuilder\n// BUT in loops, you must use StringBuilder explicitly!"
    },
    {
      "id": 85,
      "question": "What are the differences between ArrayList and Vector?",
      "answer": "Both are dynamic arrays, but with key differences:\n\nArrayList:\n• Not synchronized (not thread-safe)\n• Faster\n• Increases capacity by 50% when full\n• Iterator is fail-fast\n• Introduced in Java 1.2 (Collections Framework)\n• Preferred in modern code\n\nVector:\n• Synchronized (thread-safe)\n• Slower due to synchronization\n• Doubles capacity when full\n• Has legacy methods (addElement, etc.)\n• Introduced in Java 1.0 (legacy)\n• Considered obsolete\n\nRecommendation: Use ArrayList with external synchronization if needed, or CopyOnWriteArrayList",
      "explanation": "Vector is legacy and generally avoided in modern code. ArrayList is faster and you can synchronize externally if needed using Collections.synchronizedList() or use CopyOnWriteArrayList for concurrent scenarios.",
      "difficulty": "Easy",
      "code": "// ArrayList - modern, not synchronized\nList<String> arrayList = new ArrayList<>();\narrayList.add(\"Item\");\n// Not thread-safe - multiple threads may cause issues\n\n// Vector - legacy, synchronized\nVector<String> vector = new Vector<>();\nvector.add(\"Item\");  // Synchronized method - thread-safe but slow\nvector.addElement(\"Item\");  // Legacy method\n\n// Growth rate difference\n// ArrayList: newCapacity = oldCapacity + (oldCapacity >> 1)  // 1.5x\n// Vector: newCapacity = oldCapacity * 2  // 2x\n\n// Modern alternatives for thread-safety\n\n// Option 1: Synchronized wrapper\nList<String> syncList = Collections.synchronizedList(new ArrayList<>());\nsyncList.add(\"Item\");  // Thread-safe\n\n// But iteration needs manual synchronization\nsynchronized(syncList) {\n    for (String s : syncList) {\n        System.out.println(s);\n    }\n}\n\n// Option 2: CopyOnWriteArrayList (Java 5+)\nList<String> cowList = new CopyOnWriteArrayList<>();\ncowList.add(\"Item\");  // Thread-safe, no ConcurrentModificationException\n// Good for: mostly reads, few writes\n\n// Performance comparison for 10000 adds\n// ArrayList: ~2ms\n// Vector: ~5ms (synchronized overhead)\n// CopyOnWriteArrayList: ~500ms (copies on each write)\n\n// Iteration safety\nList<String> list = new ArrayList<>(Arrays.asList(\"A\", \"B\", \"C\"));\nfor (String s : list) {\n    // list.remove(s);  // ConcurrentModificationException!\n}\n\n// Vector enumeration (legacy)\nVector<String> v = new Vector<>(Arrays.asList(\"A\", \"B\", \"C\"));\nEnumeration<String> e = v.elements();  // Legacy iterator\nwhile (e.hasMoreElements()) {\n    System.out.println(e.nextElement());\n}"
    },
    {
      "id": 86,
      "question": "What is type erasure in Java Generics?",
      "answer": "Type Erasure is the process where compiler removes all generic type information after compilation.\n\nHow it works:\n1. Replace type parameters with bounds (or Object)\n2. Insert type casts where needed\n3. Generate bridge methods for polymorphism\n\nImplications:\n• Cannot create generic array: new T[]\n• Cannot use instanceof with parameterized types\n• Cannot have overloaded methods differing only in generic type\n• Cannot create instances: new T()\n• Type information lost at runtime\n• List<String> and List<Integer> become List at runtime",
      "explanation": "Type erasure enables backward compatibility with pre-generic code but has limitations. It's why you can't create generic arrays or check instanceof with parameterized types. Understanding erasure explains many generic limitations.",
      "difficulty": "Hard",
      "code": "// Type erasure example\nclass Box<T> {\n    private T value;\n    public void set(T value) { this.value = value; }\n    public T get() { return value; }\n}\n\n// After erasure (what compiler generates)\nclass Box {\n    private Object value;  // T replaced with Object\n    public void set(Object value) { this.value = value; }\n    public Object get() { return value; }\n}\n\n// Usage with casts inserted by compiler\nBox<String> box = new Box<>();\nbox.set(\"Hello\");\nString s = box.get();  // Compiler inserts cast: (String) box.get()\n\n// Limitations due to type erasure\n\n// 1. Cannot create generic array\nT[] array = new T[10];  // Compile error!\nList<String>[] lists = new List<String>[10];  // Compile error!\nList<?>[] lists = new List<?>[10];  // OK (unbounded)\n\n// 2. Cannot use instanceof\nif (list instanceof List<String>) { }  // Compile error!\nif (list instanceof List<?>) { }  // OK\n\n// 3. Runtime type information lost\nList<String> strings = new ArrayList<>();\nList<Integer> integers = new ArrayList<>();\nSystem.out.println(strings.getClass() == integers.getClass());  // true!\n// Both are just ArrayList at runtime\n\n// 4. Cannot overload based on generics\nclass Processor {\n    void process(List<String> list) { }\n    // void process(List<Integer> list) { }  // Compile error!\n    // After erasure, both are process(List)\n}\n\n// 5. Cannot create instances\nclass Factory<T> {\n    T create() {\n        // return new T();  // Compile error!\n        return null;\n    }\n}\n\n// Workarounds\n// Use Class<T> parameter\nclass Factory<T> {\n    T create(Class<T> clazz) throws Exception {\n        return clazz.newInstance();  // Reflection\n    }\n}\n\n// For arrays, use reflection\n@SuppressWarnings(\"unchecked\")\nT[] createArray(Class<T> clazz, int size) {\n    return (T[]) Array.newInstance(clazz, size);\n}"
    },
    {
      "id": 87,
      "question": "What is the diamond problem and how does Java handle it?",
      "answer": "Diamond problem occurs in multiple inheritance when a class inherits from two classes that have a common ancestor.\n\nProblem:\n• Which parent's method to inherit?\n• Ambiguity in method resolution\n\nJava's solutions:\n\n1. No multiple class inheritance:\n• Class can extend only one class\n• Avoids diamond problem entirely\n\n2. Multiple interface inheritance (allowed):\n• Java 8+ allows default methods in interfaces\n• Diamond problem can occur\n• Resolution: Class must override conflicting methods\n• Or specify which interface's method to use\n\nRules:\n• Class methods beat interface default methods\n• More specific interface wins\n• Explicit override required for ambiguity",
      "explanation": "Java avoids diamond problem by disallowing multiple class inheritance. With interfaces and default methods (Java 8+), diamond problem can occur but Java has clear resolution rules. Classes must override ambiguous methods.",
      "difficulty": "Hard",
      "code": "// Diamond problem setup\ninterface A {\n    default void doSomething() {\n        System.out.println(\"A's implementation\");\n    }\n}\n\ninterface B extends A {\n    default void doSomething() {\n        System.out.println(\"B's implementation\");\n    }\n}\n\ninterface C extends A {\n    default void doSomething() {\n        System.out.println(\"C's implementation\");\n    }\n}\n\n// Diamond: D inherits from both B and C, which inherit from A\nclass D implements B, C {\n    // Compile error without override - ambiguous!\n    @Override\n    public void doSomething() {\n        // Must override to resolve ambiguity\n        System.out.println(\"D's implementation\");\n        \n        // Can call specific interface method\n        B.super.doSomething();  // Call B's version\n        C.super.doSomething();  // Call C's version\n    }\n}\n\n// Resolution rules\n\n// Rule 1: Class wins over interface\ninterface Interface {\n    default void method() { System.out.println(\"Interface \"); }\n}\n\nclass Parent {\n    public void method() { System.out.println(\"Parent\"); }\n}\n\nclass Child extends Parent implements Interface {\n    // Parent's method wins, no override needed\n}\n\nnew Child().method();  // Prints \"Parent\"\n\n// Rule 2: More specific interface wins\ninterface General {\n    default void method() { System.out.println(\"General\"); }\n}\n\ninterface Specific extends General {\n    default void method() { System.out.println(\"Specific\"); }\n}\n\nclass Impl implements General, Specific {\n    // Specific wins, no override needed\n}\n\nnew Impl().method();  // Prints \"Specific\"\n\n// Rule 3: Ambiguous - must override\ninterface X {\n    default void method() { System.out.println(\"X\"); }\n}\n\ninterface Y {\n    default void method() { System.out.println(\"Y\"); }\n}\n\nclass Z implements X, Y {\n    @Override\n    public void method() {  // Must override!\n        X.super.method();  // Choose explicitly\n    }\n}"
    },
    {
      "id": 88,
      "question": "What is the difference between PriorityQueue and Queue?",
      "answer": "Queue vs PriorityQueue:\n\nQueue (interface):\n• FIFO (First-In-First-Out) ordering\n• Elements processed in insertion order\n• Implementations: LinkedList, ArrayDeque\n\nPriorityQueue (class):\n• Heap-based implementation\n• Elements ordered by priority (natural ordering or Comparator)\n• Head is smallest/highest priority element\n• Not strictly FIFO\n• Not thread-safe\n• O(log n) for insertion/removal\n• O(1) for peek\n• Does not allow null elements\n\nUse PriorityQueue when elements need priority-based processing",
      "explanation": "PriorityQueue is perfect for scenarios where you need to process elements by priority, not insertion order. Internally uses a binary heap. Common in scheduling, Dijkstra's algorithm, and event-driven systems.",
      "difficulty": "Medium",
      "code": "// Regular Queue - FIFO\nQueue<Integer> queue = new LinkedList<>();\nqueue.offer(3);\nqueue.offer(1);\nqueue.offer(2);\nSystem.out.println(queue.poll());  // 3 (first inserted)\nSystem.out.println(queue.poll());  // 1\nSystem.out.println(queue.poll());  // 2\n\n// PriorityQueue - priority order (min-heap by default)\nQueue<Integer> pq = new PriorityQueue<>();\npq.offer(3);\npq.offer(1);\npq.offer(2);\nSystem.out.println(pq.poll());  // 1 (smallest/highest priority)\nSystem.out.println(pq.poll());  // 2\nSystem.out.println(pq.poll());  // 3\n\n// PriorityQueue with custom comparator (max-heap)\nQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());\nmaxHeap.offer(3);\nmaxHeap.offer(1);\nmaxHeap.offer(2);\nSystem.out.println(maxHeap.poll());  // 3 (largest first)\n\n// PriorityQueue with custom objects\nclass Task implements Comparable<Task> {\n    String name;\n    int priority;\n    \n    @Override\n    public int compareTo(Task other) {\n        return Integer.compare(this.priority, other.priority);\n    }\n}\n\nPriorityQueue<Task> tasks = new PriorityQueue<>();\ntasks.offer(new Task(\"Low\", 3));\ntasks.offer(new Task(\"High\", 1));\ntasks.offer(new Task(\"Medium\", 2));\n\nwhile (!tasks.isEmpty()) {\n    Task t = tasks.poll();\n    System.out.println(t.name);  // High, Medium, Low\n}\n\n// Using comparator\nPriorityQueue<Task> tasks2 = new PriorityQueue<>(\n    (t1, t2) -> Integer.compare(t2.priority, t1.priority)  // Reverse\n);\n\n// Thread-safe alternative\nBlockingQueue<Integer> pq = new PriorityBlockingQueue<>();"
    },
    {
      "id": 89,
      "question": "What is switch expression in Java?",
      "answer": "Switch expression (Java 12+ preview, finalized in Java 14) is an enhanced switch that can return values.\n\nKey features:\n\nArrow syntax (->):\n• No fall-through\n• No break needed\n• Can return values\n\nMultiple case labels:\n• case 1, 2, 3 -> ...\n\nYield keyword:\n• Return value from block\n• Similar to return but for switch\n\nExhaustiveness:\n• Compiler ensures all cases covered\n\nBenefits:\n• More concise\n• No fall-through bugs\n• Can use as expression\n• Better for pattern matching",
      "explanation": "Switch expressions make code cleaner and safer - no fall-through bugs, and they return values directly. Traditional switch is statement, new switch can be expression. This is foundation for pattern matching in switch.",
      "difficulty": "Medium",
      "code": "// Traditional switch statement (old)\nString day = \"MONDAY\";\nint numLetters;\nswitch (day) {\n    case \"MONDAY\":\n    case \"FRIDAY\":\n    case \"SUNDAY\":\n        numLetters = 6;\n        break;\n    case \"TUESDAY\":\n        numLetters = 7;\n        break;\n    default:\n        numLetters = 0;\n}\n\n// Switch expression with arrow (Java 14+)\nint numLetters = switch (day) {\n    case \"MONDAY\", \"FRIDAY\", \"SUNDAY\" -> 6;  // Multiple cases, no break\n    case \"TUESDAY\" -> 7;\n    case \"THURSDAY\", \"SATURDAY\" -> 8;\n    case \"WEDNESDAY\" -> {\n        System.out.println(\"Wednesday\");\n        yield 9;  // yield for blocks\n    }\n    default -> 0;\n};\n\n// Traditional switch can't return value\nString result;\nswitch (value) {\n    case 1:\n        result = \"One\";\n        break;\n    case 2:\n        result = \"Two\";\n        break;\n    default:\n        result = \"Other\";\n}\n\n// Switch expression returns value directly\nString result = switch (value) {\n    case 1 -> \"One\";\n    case 2 -> \"Two\";\n    default -> \"Other\";\n};\n\n// With enums (exhaustiveness checking)\nenum Day { MONDAY, TUESDAY, WEDNESDAY }\n\nDay day = Day.MONDAY;\nString type = switch (day) {\n    case MONDAY, FRIDAY -> \"Start/End\";\n    case TUESDAY, WEDNESDAY, THURSDAY -> \"Midweek\";\n    // No default needed - all cases covered!\n};\n\n// Multiple statements with yield\nint result = switch (x) {\n    case 1 -> {\n        System.out.println(\"Processing 1\");\n        int temp = compute();\n        yield temp * 2;\n    }\n    case 2 -> {\n        System.out.println(\"Processing 2\");\n        yield 20;\n    }\n    default -> 0;\n};\n\n// Pattern matching in switch (Java 17+ preview)\nObject obj = \"Hello\";\nString result = switch (obj) {\n    case Integer i -> \"Integer: \" + i;\n    case String s -> \"String: \" + s;\n    case null -> \"Null\";\n    default -> \"Other\";\n};"
    },
    {
      "id": 90,
      "question": "What is the Builder pattern and when to use it?",
      "answer": "Builder pattern constructs complex objects step by step, separating construction from representation.\n\nWhen to use:\n• Many constructor parameters (>4-5)\n• Many optional parameters\n• Immutable objects\n• Readable object construction\n• Telescoping constructor anti-pattern\n\nBenefits:\n• Readable code\n• Immutable objects\n• Step-by-step construction\n• No need for many constructors\n• Parameter validation in build()\n• Fluent interface\n\nPopularized by Joshua Bloch in Effective Java",
      "explanation": "Builder pattern solves telescoping constructor problem and makes object creation readable. Perfect for immutable objects with many fields. Much better than having constructors with 10+ parameters or many setter methods.",
      "difficulty": "Medium",
      "code": "// Without Builder (telescoping constructors - bad)\nclass Person {\n    Person(String name) { }\n    Person(String name, int age) { }\n    Person(String name, int age, String email) { }\n    Person(String name, int age, String email, String phone) { }\n    // Gets messy with many parameters!\n}\n\n// With Builder pattern\nclass Person {\n    // Required fields\n    private final String name;  // final = immutable\n    \n    // Optional fields\n    private final int age;\n    private final String email;\n    private final String phone;\n    private final String address;\n    \n    // Private constructor\n    private Person(Builder builder) {\n        this.name = builder.name;\n        this.age = builder.age;\n        this.email = builder.email;\n        this.phone = builder.phone;\n        this.address = builder.address;\n    }\n    \n    // Static nested Builder class\n    public static class Builder {\n        // Required fields\n        private final String name;\n        \n        // Optional fields - with defaults\n        private int age = 0;\n        private String email = \"\";\n        private String phone = \"\";\n        private String address = \"\";\n        \n        // Constructor with required fields\n        public Builder(String name) {\n            this.name = name;\n        }\n        \n        // Fluent setters for optional fields\n        public Builder age(int age) {\n            this.age = age;\n            return this;\n        }\n        \n        public Builder email(String email) {\n            this.email = email;\n            return this;\n        }\n        \n        public Builder phone(String phone) {\n            this.phone = phone;\n            return this;\n        }\n        \n        public Builder address(String address) {\n            this.address = address;\n            return this;\n        }\n        \n        // Build method with validation\n        public Person build() {\n            // Validate\n            if (age < 0) {\n                throw new IllegalStateException(\"Age cannot be negative\");\n            }\n            return new Person(this);\n        }\n    }\n    \n    // Getters only (no setters - immutable)\n    public String getName() { return name; }\n    public int getAge() { return age; }\n}\n\n// Usage - readable and fluent\nPerson person = new Person.Builder(\"John\")  // Required\n    .age(25)                                 // Optional\n    .email(\"john@example.com\")              // Optional\n    .phone(\"123-456-7890\")                  // Optional\n    .build();\n\n// Lombok @Builder annotation (generates builder automatically)\n@Builder\nclass Person {\n    private String name;\n    private int age;\n    private String email;\n}\n\nPerson p = Person.builder()\n    .name(\"John\")\n    .age(25)\n    .build();"
    },
    {
      "id": 91,
      "question": "What is the Factory pattern in Java?",
      "answer": "Factory pattern provides an interface for creating objects without specifying exact class.\n\nTypes:\n\n1. Simple Factory:\n• Static method creates objects\n• Not a formal pattern\n\n2. Factory Method:\n• Subclasses decide which class to instantiate\n• Define interface for creating objects\n\n3. Abstract Factory:\n• Factory of factories\n• Create families of related objects\n\nBenefits:\n• Loose coupling\n• Hide creation logic\n• Centralized object creation\n• Easy to extend\n• Follows Open/Closed principle",
      "explanation": "Factory pattern is fundamental for loose coupling. Simple factory is most common - use valueOf(), of(), getInstance() naming. Factory method when subclasses need different implementations. Abstract factory for creating related object families.",
      "difficulty": "Medium",
      "code": "// 1. Simple Factory\nclass ShapeFactory {\n    public static Shape createShape(String type) {\n        return switch (type.toLowerCase()) {\n            case \"circle\" -> new Circle();\n            case \"rectangle\" -> new Rectangle();\n            case \"triangle\" -> new Triangle();\n            default -> throw new IllegalArgumentException(\"Unknown shape\");\n        };\n    }\n}\n\n// Usage\nShape shape = ShapeFactory.createShape(\"circle\");\n\n// Real-world examples\nInteger.valueOf(10);  // Factory method\nOptional.of(value);   // Factory method\nCollections.singletonList(item);  // Factory method\n\n// 2. Factory Method Pattern\ninterface Shape {\n    void draw();\n}\n\nclass Circle implements Shape {\n    public void draw() { System.out.println(\"Circle\"); }\n}\n\nclass Rectangle implements Shape {\n    public void draw() { System.out.println(\"Rectangle\"); }\n}\n\n// Creator\nabstract class ShapeCreator {\n    // Factory method\n    abstract Shape createShape();\n    \n    public void renderShape() {\n        Shape shape = createShape();  // Subclass decides\n        shape.draw();\n    }\n}\n\n// Concrete creators\nclass CircleCreator extends ShapeCreator {\n    @Override\n    Shape createShape() {\n        return new Circle();\n    }\n}\n\nclass RectangleCreator extends ShapeCreator {\n    @Override\n    Shape createShape() {\n        return new Rectangle();\n    }\n}\n\n// Usage\nShapeCreator creator = new CircleCreator();\ncreator.renderShape();  // Draws circle\n\n// 3. Abstract Factory Pattern\ninterface GUIFactory {\n    Button createButton();\n    TextField createTextField();\n}\n\nclass WindowsFactory implements GUIFactory {\n    public Button createButton() { return new WindowsButton(); }\n    public TextField createTextField() { return new WindowsTextField(); }\n}\n\nclass MacFactory implements GUIFactory {\n    public Button createButton() { return new MacButton(); }\n    public TextField createTextField() { return new MacTextField(); }\n}\n\n// Usage\nGUIFactory factory = new WindowsFactory();\nButton button = factory.createButton();  // Windows button\nTextField textField = factory.createTextField();  // Windows text field"
    },
    {
      "id": 92,
      "question": "What is the Observer pattern in Java?",
      "answer": "Observer pattern defines one-to-many dependency where when one object changes state, all dependents are notified automatically.\n\nComponents:\n\nSubject:\n• Maintains list of observers\n• Notifies observers of state changes\n• attach(), detach(), notify()\n\nObserver:\n• Gets notified of changes\n• update() method\n\nUse cases:\n• Event handling\n• MVC pattern\n• Pub-Sub systems\n• GUI frameworks\n\nJava support:\n• Observable class (deprecated in Java 9)\n• PropertyChangeListener\n• Modern: Use interfaces, not Observable class",
      "explanation": "Observer pattern is fundamental for event-driven programming. Observable/Observer classes are deprecated - use custom implementation or frameworks. Core of many GUI frameworks and reactive programming.",
      "difficulty": "Medium",
      "code": "// Modern Observer pattern implementation\n\n// Observer interface\ninterface Observer {\n    void update(String message);\n}\n\n// Subject interface\ninterface Subject {\n    void attach(Observer observer);\n    void detach(Observer observer);\n    void notifyObservers();\n}\n\n// Concrete Subject\nclass NewsAgency implements Subject {\n    private List<Observer> observers = new ArrayList<>();\n    private String news;\n    \n    @Override\n    public void attach(Observer observer) {\n        observers.add(observer);\n    }\n    \n    @Override\n    public void detach(Observer observer) {\n        observers.remove(observer);\n    }\n    \n    @Override\n    public void notifyObservers() {\n        for (Observer observer : observers) {\n            observer.update(news);\n        }\n    }\n    \n    public void setNews(String news) {\n        this.news = news;\n        notifyObservers();  // Notify all observers\n    }\n}\n\n// Concrete Observers\nclass NewsChannel implements Observer {\n    private String name;\n    \n    NewsChannel(String name) { this.name = name; }\n    \n    @Override\n    public void update(String news) {\n        System.out.println(name + \" received: \" + news);\n    }\n}\n\n// Usage\nNewsAgency agency = new NewsAgency();\nNewsChannel channel1 = new NewsChannel(\"BBC\");\nNewsChannel channel2 = new NewsChannel(\"CNN\");\n\nagency.attach(channel1);\nagency.attach(channel2);\n\nagency.setNews(\"Breaking news!\");  // Both channels notified\n\nagency.detach(channel1);\nagency.setNews(\"Another update\");  // Only CNN notified\n\n// Using Java PropertyChangeSupport (built-in)\nimport java.beans.*;\n\nclass NewsAgency2 {\n    private PropertyChangeSupport support = new PropertyChangeSupport(this);\n    private String news;\n    \n    public void addObserver(PropertyChangeListener listener) {\n        support.addPropertyChangeListener(listener);\n    }\n    \n    public void removeObserver(PropertyChangeListener listener) {\n        support.removePropertyChangeListener(listener);\n    }\n    \n    public void setNews(String news) {\n        String old = this.news;\n        this.news = news;\n        support.firePropertyChange(\"news\", old, news);\n    }\n}\n\n// Usage with PropertyChangeListener\nNewsAgency2 agency2 = new NewsAgency2();\nagency2.addObserver(evt -> {\n    System.out.println(\"News changed: \" + evt.getNewValue());\n});"
    },
    {
      "id": 93,
      "question": "What is the difference between composition and inheritance?",
      "answer": "Two ways to achieve code reuse:\n\nInheritance (IS-A):\n• Subclass extends superclass\n• White-box reuse (internals visible)\n• Compile-time relationship\n• Tight coupling\n• Can break encapsulation\n• Single inheritance in Java\n\nComposition (HAS-A):\n• Object contains other objects\n• Black-box reuse (internals hidden)\n• Runtime relationship\n• Loose coupling\n• Better encapsulation\n• More flexible\n\nPrinciple: \"Favor composition over inheritance\"\n\nWhen to use:\n• Inheritance: True IS-A relationship\n• Composition: HAS-A or implementation reuse",
      "explanation": "Favor composition over inheritance is a key design principle. Composition is more flexible - you can change behavior at runtime and aren't locked into inheritance hierarchy. Use inheritance only for true IS-A relationships.",
      "difficulty": "Medium",
      "code": "// Inheritance example (IS-A relationship)\nclass Vehicle {\n    void start() { System.out.println(\"Starting...\"); }\n    void stop() { System.out.println(\"Stopping...\"); }\n}\n\nclass Car extends Vehicle {  // Car IS-A Vehicle\n    void drive() { System.out.println(\"Driving...\"); }\n}\n\nCar car = new Car();\ncar.start();  // Inherited method\ncar.drive();  // Own method\n\n// Problem with inheritance\nclass Stack extends ArrayList {  // BAD! Stack is not a list!\n    // Now Stack has unnecessary methods like add(index, element)\n    // Breaks Stack semantics\n}\n\n// Composition example (HAS-A relationship)\nclass Engine {\n    void start() { System.out.println(\"Engine starting...\"); }\n    void stop() { System.out.println(\"Engine stopping...\"); }\n}\n\nclass Car2 {  // Car HAS-AN Engine\n    private Engine engine = new Engine();  // Composition\n    \n    void start() {\n        engine.start();  // Delegate to engine\n    }\n    \n    void stop() {\n        engine.stop();  // Delegate to engine\n    }\n    \n    void drive() {\n        System.out.println(\"Driving...\");\n    }\n}\n\nCar2 car2 = new Car2();\ncar2.start();  // Uses engine internally\n\n// Composition with interface (even better)\ninterface Engine {\n    void start();\n    void stop();\n}\n\nclass ElectricEngine implements Engine {\n    public void start() { System.out.println(\"Electric start\"); }\n    public void stop() { System.out.println(\"Electric stop\"); }\n}\n\nclass GasEngine implements Engine {\n    public void start() { System.out.println(\"Gas start\"); }\n    public void stop() { System.out.println(\"Gas stop\"); }\n}\n\nclass Car3 {\n    private Engine engine;  // Can switch implementation!\n    \n    Car3(Engine engine) {\n        this.engine = engine;  // Inject dependency\n    }\n    \n    void start() { engine.start(); }\n}\n\n// Can use different engines at runtime\nCar3 electricCar = new Car3(new ElectricEngine());\nCar3 gasCar = new Car3(new GasEngine());\n\n// Proper Stack using composition\nclass Stack<T> {\n    private List<T> elements = new ArrayList<>();  // Composition\n    \n    void push(T item) { elements.add(item); }\n    T pop() { return elements.remove(elements.size() - 1); }\n    // Only Stack operations exposed!\n}"
    },
    {
      "id": 94,
      "question": "What is the Strategy pattern in Java?",
      "answer": "Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable.\n\nComponents:\n\nStrategy interface:\n• Defines algorithm interface\n\nConcrete strategies:\n• Implement different algorithms\n\nContext:\n• Uses Strategy interface\n• Can switch strategies at runtime\n\nBenefits:\n• Eliminates conditional logic\n• Open/Closed principle\n• Runtime algorithm selection\n• Testable strategies\n\nUse when:\n• Multiple algorithms for same task\n• Need to switch algorithms dynamically\n• Avoid complex conditional logic",
      "explanation": "Strategy pattern eliminates if-else chains and switch statements for algorithm selection. Perfect for payment methods, sorting algorithms, validation rules. Makes code more maintainable and testable.",
      "difficulty": "Medium",
      "code": "// Without Strategy pattern (bad - many if-else)\nclass PaymentProcessor {\n    void processPayment(String type, double amount) {\n        if (type.equals(\"CREDIT_CARD\")) {\n            // Credit card logic\n        } else if (type.equals(\"PAYPAL\")) {\n            // PayPal logic\n        } else if (type.equals(\"BITCOIN\")) {\n            // Bitcoin logic\n        }\n        // Adding new payment method requires modifying this class!\n    }\n}\n\n// With Strategy pattern (good)\n\n// Strategy interface\ninterface PaymentStrategy {\n    void pay(double amount);\n}\n\n// Concrete strategies\nclass CreditCardPayment implements PaymentStrategy {\n    private String cardNumber;\n    \n    CreditCardPayment(String cardNumber) {\n        this.cardNumber = cardNumber;\n    }\n    \n    @Override\n    public void pay(double amount) {\n        System.out.println(\"Paid $\" + amount + \" with credit card\");\n    }\n}\n\nclass PayPalPayment implements PaymentStrategy {\n    private String email;\n    \n    PayPalPayment(String email) {\n        this.email = email;\n    }\n    \n    @Override\n    public void pay(double amount) {\n        System.out.println(\"Paid $\" + amount + \" via PayPal\");\n    }\n}\n\nclass BitcoinPayment implements PaymentStrategy {\n    private String walletAddress;\n    \n    BitcoinPayment(String walletAddress) {\n        this.walletAddress = walletAddress;\n    }\n    \n    @Override\n    public void pay(double amount) {\n        System.out.println(\"Paid $\" + amount + \" in Bitcoin\");\n    }\n}\n\n// Context\nclass ShoppingCart {\n    private PaymentStrategy paymentStrategy;\n    \n    void setPaymentStrategy(PaymentStrategy strategy) {\n        this.paymentStrategy = strategy;\n    }\n    \n    void checkout(double amount) {\n        paymentStrategy.pay(amount);  // Delegate to strategy\n    }\n}\n\n// Usage - switch strategies at runtime\nShoppingCart cart = new ShoppingCart();\n\ncart.setPaymentStrategy(new CreditCardPayment(\"1234-5678-9012-3456\"));\ncart.checkout(100.0);  // Pay with credit card\n\ncart.setPaymentStrategy(new PayPalPayment(\"user@example.com\"));\ncart.checkout(50.0);   // Pay with PayPal\n\n// Modern approach with lambdas\ninterface DiscountStrategy {\n    double applyDiscount(double price);\n}\n\nclass PriceCalculator {\n    double calculate(double price, DiscountStrategy strategy) {\n        return strategy.applyDiscount(price);\n    }\n}\n\n// Use lambdas as strategies\nPriceCalculator calc = new PriceCalculator();\ndouble price = 100.0;\n\ndouble regularPrice = calc.calculate(price, p -> p);  // No discount\ndouble tenPercent = calc.calculate(price, p -> p * 0.9);  // 10% off\ndouble twentyDollars = calc.calculate(price, p -> p - 20);  // $20 off"
    },
    {
      "id": 95,
      "question": "What is the difference between throw and throws?",
      "answer": "throw and throws are different keywords for exception handling:\n\nthrow:\n• Keyword to explicitly throw an exception\n• Used inside method body\n• Throws actual exception instance\n• Used with new Exception()\n• Execution stops at throw statement\n• Can throw only one exception at a time\n\nthrows:\n• Keyword in method signature\n• Declares that method might throw exceptions\n• Lets caller handle exception\n• Can declare multiple exceptions\n• Used for checked exceptions\n• Part of method contract",
      "explanation": "throw actually throws an exception object. throws declares that method may throw exceptions. throw is for action, throws is for declaration. Understanding this difference is crucial for exception handling design.",
      "difficulty": "Easy",
      "code": "// throws - declare in method signature\npublic void readFile(String path) throws IOException, FileNotFoundException {\n    // Method might throw these exceptions\n    // Caller must handle or declare\n}\n\n// throw - actually throw exception\npublic void validateAge(int age) {\n    if (age < 0) {\n        throw new IllegalArgumentException(\"Age cannot be negative\");  // Throw\n    }\n    if (age < 18) {\n        throw new IllegalArgumentException(\"Must be 18 or older\");  // Throw\n    }\n}\n\n// Using both together\npublic void processFile(String path) throws IOException {  // throws\n    File file = new File(path);\n    if (!file.exists()) {\n        throw new IOException(\"File not found: \" + path);  // throw\n    }\n    // Process file\n}\n\n// Catching thrown exceptions\ntry {\n    validateAge(-5);  // Will throw exception\n} catch (IllegalArgumentException e) {\n    System.out.println(\"Caught: \" + e.getMessage());\n}\n\n// Rethrowing exceptions\npublic void method() throws Exception {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        System.out.println(\"Logging error\");\n        throw e;  // Rethrow same exception\n    }\n}\n\n// Throwing new exception with cause\npublic void method() throws CustomException {\n    try {\n        riskyOperation();\n    } catch (Exception e) {\n        throw new CustomException(\"Custom message\", e);  // Wrap original\n    }\n}\n\n// Custom exception\nclass InsufficientFundsException extends Exception {\n    public InsufficientFundsException(String message) {\n        super(message);\n    }\n}\n\npublic void withdraw(double amount) throws InsufficientFundsException {\n    if (balance < amount) {\n        throw new InsufficientFundsException(\"Insufficient balance\");\n    }\n    balance -= amount;\n}"
    },
    {
      "id": 96,
      "question": "What is the transient keyword in Java?",
      "answer": "transient is a keyword that prevents a field from being serialized.\n\nCharacteristics:\n• Field marked transient is not saved during serialization\n• Value becomes default after deserialization (null/0/false)\n• Only affects Serializable objects\n• Cannot be used with static fields (already not serialized)\n• Used for: Sensitive data, derived fields, caches\n\nUse cases:\n• Passwords and sensitive information\n• Temporary cached values\n• Derived/calculated fields\n• Objects that can't be serialized\n• Thread-specific data",
      "explanation": "transient is crucial for security and efficiency in serialization. Use it for passwords, temporary data, and values that can be recalculated. Remember: transient fields become null/0/false after deserialization - reinitialize in readObject() if needed.",
      "difficulty": "Easy",
      "code": "// Class with transient fields\nclass User implements Serializable {\n    private static final long serialVersionUID = 1L;\n    \n    private String username;           // Will be serialized\n    private transient String password; // NOT serialized (security!)\n    private transient int loginCount;  // NOT serialized (temporary)\n    private transient Cache cache;     // NOT serialized (derived)\n    \n    // After deserialization, call this to reinitialize transients\n    private void readObject(ObjectInputStream in) \n            throws IOException, ClassNotFoundException {\n        in.defaultReadObject();  // Deserialize non-transient fields\n        \n        // Reinitialize transient fields\n        this.loginCount = 0;\n        this.cache = new Cache();\n        // password remains null (as it should for security)\n    }\n}\n\n// Serialization example\nUser user = new User();\nuser.username = \"john\";\nuser.password = \"secret123\";  // Won't be saved\nuser.loginCount = 5;           // Won't be saved\n\n// Serialize\ntry (ObjectOutputStream out = new ObjectOutputStream(\n        new FileOutputStream(\"user.ser\"))) {\n    out.writeObject(user);\n}\n\n// Deserialize\ntry (ObjectInputStream in = new ObjectInputStream(\n        new FileInputStream(\"user.ser\"))) {\n    User loaded = (User) in.readObject();\n    \n    System.out.println(loaded.username);   // \"john\"\n    System.out.println(loaded.password);   // null (transient!)\n    System.out.println(loaded.loginCount); // 0 (transient!)\n}\n\n// Transient with computed fields\nclass Rectangle implements Serializable {\n    private double width;\n    private double height;\n    private transient double area;  // Computed, no need to serialize\n    \n    public double getArea() {\n        if (area == 0) {  // Lazy computation\n            area = width * height;\n        }\n        return area;\n    }\n    \n    private void readObject(ObjectInputStream in) \n            throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        // area will be recalculated on first getArea() call\n    }\n}\n\n// Note: static fields are never serialized (with or without transient)\nclass Example implements Serializable {\n    private static int staticField = 10;  // Never serialized\n    private transient static int field = 20;  // Redundant - already not serialized\n}"
    },
    {
      "id": 97,
      "question": "What is the native keyword in Java?",
      "answer": "native keyword indicates that a method is implemented in platform-specific code (usually C/C++) using JNI (Java Native Interface).\n\nCharacteristics:\n• Method has no body in Java\n• Implementation in native language\n• Loaded via System.loadLibrary()\n• Platform-dependent\n• Used for: Performance-critical code, OS-level operations, legacy code integration\n\nJNI (Java Native Interface):\n• Bridge between Java and native code\n• Allows calling C/C++ from Java\n• Allows calling Java from C/C++\n\nUse cases:\n• Hardware access\n• Performance-critical algorithms\n• Using existing C/C++ libraries\n• Platform-specific features",
      "explanation": "native methods break Java's platform independence but provide access to OS features and performance. Common in JDK internals (Object.hashCode(), System.currentTimeMillis()). Avoid unless absolutely necessary - JNI adds complexity and debugging difficulty.",
      "difficulty": "Hard",
      "code": "// Native method declaration\npublic class NativeExample {\n    // Load native library\n    static {\n        System.loadLibrary(\"nativelib\");  // Loads nativelib.dll or libnativelib.so\n    }\n    \n    // Native method declaration\n    public native void nativeMethod();       // No body\n    public native int add(int a, int b);\n    public static native long getSystemTime();\n    \n    public static void main(String[] args) {\n        NativeExample example = new NativeExample();\n        example.nativeMethod();\n        int result = example.add(5, 3);      // Calls C implementation\n    }\n}\n\n// Steps to use native methods:\n// 1. Declare native method in Java\n// 2. Compile Java class: javac NativeExample.java\n// 3. Generate C header: javac -h . NativeExample.java\n// 4. Implement method in C/C++:\n\n/* C Implementation (NativeExample.c)\n#include <jni.h>\n#include \"NativeExample.h\"\n\nJNIEXPORT void JNICALL\nJava_NativeExample_nativeMethod(JNIEnv *env, jobject obj) {\n    printf(\"Called from C!\\n\");\n}\n\nJNIEXPORT jint JNICALL\nJava_NativeExample_add(JNIEnv *env, jobject obj, jint a, jint b) {\n    return a + b;  // C implementation\n}\n*/\n\n// 5. Compile C code to shared library (.dll or .so)\n// 6. Run Java with library in path\n\n// Native methods in JDK\nclass Object {\n    public native int hashCode();     // Native in JDK\n    public final native Class<?> getClass();\n    public final native void notify();\n    public final native void notifyAll();\n    public final native void wait(long timeout);\n}\n\nclass System {\n    public static native long currentTimeMillis();  // Native\n    public static native void arraycopy(Object src, int srcPos,\n                                       Object dest, int destPos, int length);\n}\n\nclass Thread {\n    public static native void sleep(long millis);   // Native\n    public static native void yield();\n}\n\n// Security concerns\n// - Native code can crash JVM\n// - No memory safety\n// - Platform-dependent\n// - Harder to debug\n// - Security vulnerabilities\n\n// Modern alternatives\n// - Panama Project (Foreign Function & Memory API)\n// - JNA (Java Native Access) - easier than JNI\n// - Pure Java solutions when possible"
    },
    {
      "id": 98,
      "question": "What is the strictfp keyword in Java?",
      "answer": "strictfp (strict floating point) is a keyword that ensures consistent floating-point calculations across different platforms.\n\nCharacteristics:\n• Can be applied to class, interface, or method\n• Forces IEEE 754 standard for floating-point\n• Ensures consistent results on all JVMs\n• Restricts floating-point precision\n• Rarely used in practice\n\nWithout strictfp:\n• JVM may use extended precision on some platforms\n• Results might differ slightly across platforms\n\nWith strictfp:\n• All floating-point operations follow IEEE 754 strictly\n• Same results on all platforms\n• May be slower on some platforms\n\nNote: Less relevant in modern Java - floating-point behavior is more standardized",
      "explanation": "strictfp guarantees that floating-point computations produce identical results on all platforms. Rarely needed unless you require exact reproducibility of floating-point calculations across different CPUs. Most applications don't need it.",
      "difficulty": "Easy",
      "code": "// strictfp applied to class\nstrictfp class MathOperations {\n    // All methods use strict floating-point\n    double calculate(double x, double y) {\n        return x * y + x / y;  // Strict IEEE 754\n    }\n}\n\n// strictfp applied to method\nclass Calculator {\n    // Only this method uses strict floating-point\n    strictfp double preciseCalculation(double x, double y) {\n        return Math.sqrt(x * x + y * y);\n    }\n    \n    // This method may use extended precision\n    double normalCalculation(double x, double y) {\n        return x + y;\n    }\n}\n\n// strictfp applied to interface\nstrictfp interface MathInterface {\n    double calculate(double x, double y);\n}\n\n// Implementing class inherits strictfp\nclass MathImpl implements MathInterface {\n    // This is implicitly strictfp\n    public double calculate(double x, double y) {\n        return x * y;\n    }\n}\n\n// Why strictfp exists\n// Without strictfp:\n// Platform 1 (x86 with 80-bit FPU): uses 80-bit intermediate results\n// Platform 2 (ARM with 64-bit FPU): uses 64-bit intermediate results\n// Result: Slightly different final values!\n\n// With strictfp:\n// All platforms: forced to use 64-bit IEEE 754\n// Result: Identical values everywhere\n\n// Example showing potential difference (exaggerated)\ndouble withoutStrictfp() {\n    double x = 1.0;\n    for (int i = 0; i < 1000000; i++) {\n        x += 0.0000001;\n    }\n    return x;  // Might differ across platforms by tiny amount\n}\n\nstrictfp double withStrictfp() {\n    double x = 1.0;\n    for (int i = 0; i < 1000000; i++) {\n        x += 0.0000001;\n    }\n    return x;  // Guaranteed same across all platforms\n}\n\n// When to use strictfp:\n// - Scientific calculations requiring reproducibility\n// - Cryptography (rare)\n// - Compliance with specific standards\n// - Distributed computing with result verification\n\n// When NOT to use:\n// - Most business applications\n// - When performance matters more than exact reproducibility\n// - Modern Java on standard platforms (already consistent)"
    },
    {
      "id": 99,
      "question": "What is the assert keyword in Java?",
      "answer": "assert is a keyword for debugging, used to test assumptions during development.\n\nSyntax:\n• assert condition;\n• assert condition : message;\n\nBehavior:\n• Throws AssertionError if condition is false\n• Disabled by default in production\n• Enabled with -ea or -enableassertions flag\n\nUse cases:\n• Internal invariants\n• Preconditions (non-public methods)\n• Postconditions\n• Control flow invariants\n\nDon't use for:\n• Public method argument validation\n• Production logic\n• Side effects in assertions",
      "explanation": "Assertions are for development/testing - they're disabled in production by default. Use for internal checks, not public API validation. Never put code with side effects in assertions since they might be disabled.",
      "difficulty": "Easy",
      "code": "// Basic assertion\npublic void process(int value) {\n    assert value > 0;  // Throws AssertionError if false\n    // Process...\n}\n\n// Assertion with message\npublic void process(int value) {\n    assert value > 0 : \"Value must be positive, got: \" + value;\n    // Process...\n}\n\n// Enable assertions when running\n// java -ea MyProgram    // Enable all\n// java -ea:com.example... MyProgram  // Enable for package\n// java -da MyProgram    // Disable all\n\n// Use cases\n\n// 1. Internal invariants\nclass Stack<T> {\n    private int size = 0;\n    \n    void pop() {\n        assert size > 0 : \"Stack is empty\";  // Should never happen\n        size--;\n    }\n}\n\n// 2. Preconditions (private/internal methods)\nprivate void internalMethod(Object obj) {\n    assert obj != null;  // OK for private/internal\n    // Process...\n}\n\n// WRONG for public methods!\npublic void publicMethod(Object obj) {\n    // Don't use assert for public API validation!\n    // assert obj != null;  // BAD - disabled in production!\n    \n    // Use explicit check instead:\n    if (obj == null) {\n        throw new IllegalArgumentException(\"obj cannot be null\");\n    }\n}\n\n// 3. Postconditions\npublic int[] sort(int[] array) {\n    // Sort implementation...\n    assert isSorted(array) : \"Array not sorted correctly\";\n    return array;\n}\n\n// 4. Control flow invariants\nint x = getValue();\nif (x > 0) {\n    // handle positive\n} else if (x < 0) {\n    // handle negative\n} else {\n    assert x == 0;  // Should never reach here if x != 0\n}\n\n// Switch statement with unreachable default\nenum Color { RED, GREEN, BLUE }\n\nvoid processColor(Color color) {\n    switch (color) {\n        case RED: /* ... */ break;\n        case GREEN: /* ... */ break;\n        case BLUE: /* ... */ break;\n        default:\n            assert false : \"Unknown color: \" + color;\n    }\n}\n\n// WRONG: Side effects in assertions\nint count = 0;\nassert count++ > 0;  // BAD! count not incremented if assertions disabled!\n\n// RIGHT: No side effects\nint count = 0;\ncount++;\nassert count > 0;  // OK\n\n// Testing if assertions are enabled\nboolean assertionsEnabled = false;\nassert assertionsEnabled = true;  // Runs only if enabled\nif (assertionsEnabled) {\n    System.out.println(\"Assertions are ON\");\n} else {\n    System.out.println(\"Assertions are OFF\");\n}"
    },
    {
      "id": 100,
      "question": "What are Memory Leaks in Java and how to prevent them?",
      "answer": "Memory leak occurs when objects are no longer needed but cannot be garbage collected due to unintentional references.\n\nCommon causes:\n\n1. Static collections holding objects\n2. Unclosed resources\n3. Listeners not removed\n4. ThreadLocal not cleaned\n5. Inner classes holding outer reference\n6. Caches without eviction\n7. ClassLoader leaks\n\nPrevention:\n• Use try-with-resources\n• Remove listeners when done\n• Clear ThreadLocal\n• Use WeakReference for caches\n• Use static nested class instead of inner\n• Monitor heap with profilers\n• Regular code reviews",
      "explanation": "Java has GC but memory leaks still happen - objects can't be collected if still referenced. Most common: collections that keep growing, unclosed resources, and listeners. Use memory profilers (VisualVM, MAT) to detect leaks.",
      "difficulty": "Hard",
      "code": "// 1. Static collection leak\nclass UserService {\n    private static List<User> users = new ArrayList<>();  // Never cleared!\n    \n    void addUser(User user) {\n        users.add(user);  // Keeps growing, never removed\n    }\n    // Solution: Clear when appropriate or use WeakHashMap\n}\n\n// 2. Unclosed resources leak\nvoid badMethod() {\n    Connection conn = getConnection();\n    // Process...\n    // conn never closed - leak!\n}\n\nvoid goodMethod() {\n    try (Connection conn = getConnection()) {  // Auto-closed\n        // Process...\n    }\n}\n\n// 3. Listener leak\nclass UI {\n    void addComponent(Component comp) {\n        comp.addListener(event -> handleEvent(event));\n        // Listener keeps component alive even after UI destroyed!\n    }\n    \n    // Solution: Remove listener\n    void removeComponent(Component comp) {\n        comp.removeListener(listener);\n    }\n}\n\n// 4. ThreadLocal leak\nclass RequestContext {\n    private static ThreadLocal<User> currentUser = new ThreadLocal<>();\n    \n    void setUser(User user) {\n        currentUser.set(user);  // Thread in pool keeps reference!\n    }\n    \n    // Solution: Always clear in finally\n    void processRequest() {\n        try {\n            setUser(getUser());\n            // Process...\n        } finally {\n            currentUser.remove();  // MUST clear!\n        }\n    }\n}\n\n// 5. Inner class leak\nclass Outer {\n    private byte[] data = new byte[1000000];  // Large data\n    \n    class Inner {  // Non-static inner class\n        void doSomething() { }\n        // Holds reference to Outer (including large data)!\n    }\n    \n    // Solution: Use static nested class\n    static class StaticNested {\n        void doSomething() { }\n        // No reference to Outer\n    }\n}\n\n// 6. Cache leak\nclass Cache {\n    private Map<String, Object> cache = new HashMap<>();  // Unbounded!\n    \n    void put(String key, Object value) {\n        cache.put(key, value);  // Grows indefinitely\n    }\n}\n\n// Solution 1: Use WeakHashMap\nclass Cache {\n    private Map<String, Object> cache = new WeakHashMap<>();  // Auto-evicts\n}\n\n// Solution 2: Use cache library with eviction\nCache<String, Object> cache = CacheBuilder.newBuilder()\n    .maximumSize(1000)\n    .expireAfterWrite(10, TimeUnit.MINUTES)\n    .build();\n\n// 7. Custom collection leak\nclass MyStack {\n    private Object[] elements;\n    private int size = 0;\n    \n    public Object pop() {\n        if (size == 0) throw new EmptyStackException();\n        return elements[--size];  // Leak! Still referenced in array\n    }\n    \n    // Solution: Clear reference\n    public Object pop() {\n        if (size == 0) throw new EmptyStackException();\n        Object result = elements[--size];\n        elements[size] = null;  // Clear reference\n        return result;\n    }\n}\n\n// Detection tools\n// - jmap: Heap dump\n// - jhat: Analyze heap dump\n// - VisualVM: Profile memory\n// - Eclipse MAT: Memory Analyzer\n// - YourKit, JProfiler: Commercial profilers"
    }
  ]
}
