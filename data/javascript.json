{
  "topic": "JavaScript",
  "questions": [
    {
      "id": 1,
      "question": "What is JavaScript and what are its key features?",
      "answer": "JavaScript is a high-level, interpreted programming language primarily used for web development.\n\nKey Features:\n• Dynamic typing - variables can hold any data type\n• Prototype-based object orientation\n• First-class functions - functions are treated as objects\n• Event-driven and asynchronous programming support\n• Cross-platform compatibility\n• Runs on both client-side (browsers) and server-side (Node.js)\n\nCore Capabilities:\n• DOM manipulation for interactive web pages\n• Asynchronous operations with callbacks, promises, and async/await\n• Closures and lexical scoping\n• Support for functional and object-oriented programming paradigms",
      "explanation": "JavaScript is a versatile, interpreted language that enables interactive web experiences through dynamic typing, first-class functions, and both synchronous and asynchronous programming capabilities.",
      "difficulty": "Easy",
      "code": "// JavaScript can run in browsers and Node.js\nconsole.log('Hello, JavaScript!');\n\n// Dynamic typing\nlet variable = 42;        // number\nvariable = 'text';        // now string\nvariable = { key: 'value' }; // now object\n\n// First-class functions\nconst greet = function(name) {\n  return `Hello, ${name}!`;\n};\n\nconsole.log(greet('World')); // Hello, World!"
    },
    {
      "id": 2,
      "question": "What are the different data types in JavaScript?",
      "answer": "JavaScript has 8 data types divided into two categories: primitive and non-primitive.\n\nPrimitive Types (7):\n• Number - integers and floating-point numbers\n• String - text data enclosed in quotes\n• Boolean - true or false values\n• Undefined - variable declared but not assigned\n• Null - intentional absence of value\n• Symbol - unique and immutable identifier (ES6)\n• BigInt - integers larger than Number.MAX_SAFE_INTEGER (ES2020)\n\nNon-Primitive Type (1):\n• Object - collections of key-value pairs, including arrays, functions, dates, etc.\n\nKey Differences:\n• Primitives are immutable and stored by value\n• Objects are mutable and stored by reference\n• typeof null returns 'object' (historical bug)",
      "explanation": "JavaScript has 7 primitive types (Number, String, Boolean, Undefined, Null, Symbol, BigInt) and 1 non-primitive type (Object), with primitives stored by value and objects by reference.",
      "difficulty": "Easy",
      "code": "// Primitive types\nlet num = 42;                    // Number\nlet str = 'Hello';               // String\nlet bool = true;                 // Boolean\nlet undef;                       // Undefined\nlet empty = null;                // Null\nlet sym = Symbol('id');          // Symbol\nlet bigNum = 9007199254740991n;  // BigInt\n\n// Non-primitive type\nlet obj = { name: 'John' };      // Object\nlet arr = [1, 2, 3];             // Array (Object)\nlet func = function() {};        // Function (Object)\n\nconsole.log(typeof num);    // 'number'\nconsole.log(typeof str);    // 'string'\nconsole.log(typeof null);   // 'object' (bug)"
    },
    {
      "id": 3,
      "question": "What is the difference between var, let, and const?",
      "answer": "var, let, and const are keywords for variable declaration with different scoping and behavior rules.\n\nvar (ES5):\n• Function-scoped or globally-scoped\n• Can be re-declared and updated\n• Hoisted to the top with undefined initialization\n• Creates property on global object when declared globally\n\nlet (ES6):\n• Block-scoped (within {})\n• Cannot be re-declared in same scope\n• Can be updated\n• Hoisted but not initialized (Temporal Dead Zone)\n\nconst (ES6):\n• Block-scoped (within {})\n• Cannot be re-declared or reassigned\n• Must be initialized at declaration\n• Object properties can still be modified\n• Hoisted but not initialized (Temporal Dead Zone)",
      "explanation": "var is function-scoped and can be re-declared, let is block-scoped and reassignable, while const is block-scoped and cannot be reassigned but object properties can be modified.",
      "difficulty": "Easy",
      "code": "// var - function scoped\nfunction testVar() {\n  var x = 1;\n  if (true) {\n    var x = 2;  // same variable\n    console.log(x);  // 2\n  }\n  console.log(x);  // 2\n}\n\n// let - block scoped\nfunction testLet() {\n  let y = 1;\n  if (true) {\n    let y = 2;  // different variable\n    console.log(y);  // 2\n  }\n  console.log(y);  // 1\n}\n\n// const - cannot reassign\nconst z = 10;\n// z = 20;  // Error!\n\nconst obj = { name: 'John' };\nobj.name = 'Jane';  // OK - modifying property\n// obj = {};  // Error - reassigning"
    },
    {
      "id": 4,
      "question": "What is hoisting in JavaScript?",
      "answer": "Hoisting is JavaScript's default behavior of moving declarations to the top of their scope before code execution.\n\nHow It Works:\n• Variable and function declarations are hoisted to the top\n• Only declarations are hoisted, not initializations\n• Functions are hoisted completely (declaration and definition)\n• var variables are hoisted and initialized with undefined\n• let and const are hoisted but remain uninitialized (Temporal Dead Zone)\n\nFunction Hoisting:\n• Function declarations are fully hoisted\n• Function expressions are not hoisted\n• Arrow functions are not hoisted\n\nBest Practices:\n• Declare variables at the top of their scope\n• Use let and const to avoid hoisting confusion\n• Understand the difference between declaration and initialization",
      "explanation": "Hoisting moves variable and function declarations to the top of their scope during compilation, with var initialized to undefined, while let and const remain in the Temporal Dead Zone until their actual declaration.",
      "difficulty": "Easy",
      "code": "// Variable hoisting with var\nconsole.log(x);  // undefined (not error)\nvar x = 5;\n// Interpreted as:\n// var x;\n// console.log(x);\n// x = 5;\n\n// let/const - Temporal Dead Zone\n// console.log(y);  // ReferenceError\nlet y = 10;\n\n// Function declaration hoisting\ngreet();  // Works!\nfunction greet() {\n  console.log('Hello');\n}\n\n// Function expression - NOT hoisted\n// sayHi();  // TypeError\nvar sayHi = function() {\n  console.log('Hi');\n};"
    },
    {
      "id": 5,
      "question": "What are the different ways to create objects in JavaScript?",
      "answer": "JavaScript provides multiple approaches to create objects, each with different use cases.\n\nObject Creation Methods:\n• Object literal notation - simplest and most common\n• Object constructor - using new Object()\n• Constructor function - custom object templates\n• Object.create() - creates object with specified prototype\n• ES6 Classes - syntactic sugar over constructor functions\n• Factory functions - functions that return objects\n\nObject Literal:\n• Most common and readable\n• Direct property and method definition\n\nConstructor Functions:\n• Used before ES6 classes\n• Convention: capitalize first letter\n• Use 'this' keyword for properties\n\nES6 Classes:\n• Modern and clean syntax\n• Support inheritance with extends\n• Constructor method for initialization",
      "explanation": "Objects in JavaScript can be created using object literals, constructor functions, Object.create(), ES6 classes, or factory functions, with object literals being the simplest and ES6 classes providing the most structured approach.",
      "difficulty": "Easy",
      "code": "// 1. Object literal\nconst person1 = {\n  name: 'John',\n  greet() { console.log(`Hi, I'm ${this.name}`); }\n};\n\n// 2. Object constructor\nconst person2 = new Object();\nperson2.name = 'Jane';\n\n// 3. Constructor function\nfunction Person(name) {\n  this.name = name;\n  this.greet = function() {\n    console.log(`Hi, I'm ${this.name}`);\n  };\n}\nconst person3 = new Person('Bob');\n\n// 4. Object.create()\nconst personProto = {\n  greet() { console.log(`Hi, I'm ${this.name}`); }\n};\nconst person4 = Object.create(personProto);\nperson4.name = 'Alice';\n\n// 5. ES6 Class\nclass PersonClass {\n  constructor(name) {\n    this.name = name;\n  }\n  greet() {\n    console.log(`Hi, I'm ${this.name}`);\n  }\n}\nconst person5 = new PersonClass('Charlie');"
    },
    {
      "id": 6,
      "question": "What is the difference between == and === operators?",
      "answer": "The == and === operators are used for comparison but differ in how they handle type coercion.\n\nDouble Equals (==) - Loose Equality:\n• Compares values after type coercion\n• Converts operands to same type before comparison\n• Can lead to unexpected results\n• Less predictable behavior\n\nTriple Equals (===) - Strict Equality:\n• Compares both value and type\n• No type coercion performed\n• Returns false if types differ\n• Recommended for most comparisons\n\nCommon Pitfalls with ==:\n• 0 == false returns true\n• '' == false returns true\n• null == undefined returns true\n• '0' == 0 returns true\n\nBest Practice:\n• Always use === unless you specifically need type coercion\n• Use !== instead of !=",
      "explanation": "The == operator performs type coercion before comparison (loose equality), while === compares both value and type without coercion (strict equality), making === more predictable and preferred.",
      "difficulty": "Easy",
      "code": "// Loose equality (==) - with type coercion\nconsole.log(5 == '5');       // true (string converted to number)\nconsole.log(0 == false);     // true\nconsole.log('' == false);    // true\nconsole.log(null == undefined); // true\nconsole.log('0' == 0);       // true\n\n// Strict equality (===) - no type coercion\nconsole.log(5 === '5');      // false (different types)\nconsole.log(0 === false);    // false\nconsole.log('' === false);   // false\nconsole.log(null === undefined); // false\nconsole.log('0' === 0);      // false\n\n// Best practice: use ===\nconst value = '5';\nif (value === '5') {\n  console.log('Strict check passed');\n}"
    },
    {
      "id": 7,
      "question": "What are truthy and falsy values in JavaScript?",
      "answer": "In JavaScript, values are coerced to boolean in conditional contexts, resulting in truthy or falsy evaluation.\n\nFalsy Values (8 total):\n• false - boolean false\n• 0 - number zero\n• -0 - negative zero\n• 0n - BigInt zero\n• '' or \"\" or `` - empty string\n• null - absence of value\n• undefined - uninitialized variable\n• NaN - Not a Number\n\nTruthy Values:\n• Everything else not listed as falsy\n• Non-empty strings (including '0' and 'false')\n• Non-zero numbers (including negative numbers)\n• Objects and arrays (even empty ones)\n• Functions\n\nImportant Notes:\n• Empty objects {} and arrays [] are truthy\n• String 'false' is truthy\n• String '0' is truthy",
      "explanation": "JavaScript has 8 falsy values (false, 0, -0, 0n, empty string, null, undefined, NaN), while all other values including empty objects and arrays are truthy in boolean contexts.",
      "difficulty": "Easy",
      "code": "// Falsy values\nif (!false) console.log('false is falsy');\nif (!0) console.log('0 is falsy');\nif (!'') console.log('empty string is falsy');\nif (!null) console.log('null is falsy');\nif (!undefined) console.log('undefined is falsy');\nif (!NaN) console.log('NaN is falsy');\n\n// Truthy values (surprises)\nif ('0') console.log('\"0\" is truthy!');      // truthy\nif ('false') console.log('\"false\" is truthy!'); // truthy\nif ([]) console.log('[] is truthy!');        // truthy\nif ({}) console.log('{} is truthy!');        // truthy\nif (-1) console.log('-1 is truthy!');        // truthy\n\n// Practical usage\nconst name = '';\nif (name) {\n  console.log('Has name');\n} else {\n  console.log('No name'); // This executes\n}"
    },
    {
      "id": 8,
      "question": "What is the difference between null and undefined?",
      "answer": "Both null and undefined represent absence of value but with different semantic meanings.\n\nundefined:\n• Default value for uninitialized variables\n• Returned when accessing non-existent object properties\n• Returned by functions without explicit return\n• Represents unintentional absence of value\n• Type of undefined is 'undefined'\n\nnull:\n• Explicitly assigned to indicate intentional absence\n• Must be assigned deliberately\n• Represents intentional absence of value\n• Type of null is 'object' (JavaScript bug)\n• Used to clear object references\n\nComparison:\n• null == undefined returns true (loose equality)\n• null === undefined returns false (strict equality)\n• Both are falsy values\n\nWhen to Use:\n• Use undefined for checking if variable exists\n• Use null to explicitly indicate 'no value'",
      "explanation": "undefined indicates a variable exists but hasn't been assigned a value (unintentional absence), while null is explicitly assigned to represent intentional absence of value.",
      "difficulty": "Easy",
      "code": "// undefined - uninitialized\nlet x;\nconsole.log(x);              // undefined\nconsole.log(typeof x);       // 'undefined'\n\n// undefined - non-existent property\nconst obj = { name: 'John' };\nconsole.log(obj.age);        // undefined\n\n// undefined - no return value\nfunction noReturn() {}\nconsole.log(noReturn());     // undefined\n\n// null - intentional absence\nlet y = null;\nconsole.log(y);              // null\nconsole.log(typeof y);       // 'object' (bug)\n\n// Comparison\nconsole.log(null == undefined);   // true\nconsole.log(null === undefined);  // false\n\n// Clearing object reference\nlet user = { name: 'John' };\nuser = null;  // Clear reference for garbage collection"
    },
    {
      "id": 9,
      "question": "What are template literals and their features?",
      "answer": "Template literals (template strings) are string literals allowing embedded expressions and multi-line strings.\n\nKey Features:\n• Enclosed in backticks (``) instead of quotes\n• Support string interpolation with ${expression}\n• Allow multi-line strings without escape characters\n• Can contain expressions and function calls\n• Support tagged templates for custom string processing\n\nString Interpolation:\n• Embed variables and expressions directly\n• Automatic toString() conversion\n• Can include complex expressions and calculations\n\nMulti-line Strings:\n• No need for \\n or + concatenation\n• Preserves formatting and indentation\n• Improves readability for long text\n\nTagged Templates:\n• Custom processing of template literals\n• Used in libraries like styled-components\n• Enables advanced string manipulation",
      "explanation": "Template literals use backticks and enable string interpolation with ${}, multi-line strings without escape characters, and advanced features like tagged templates for custom string processing.",
      "difficulty": "Easy",
      "code": "// Basic string interpolation\nconst name = 'John';\nconst age = 30;\nconsole.log(`My name is ${name} and I'm ${age} years old`);\n\n// Expressions in template literals\nconst a = 5, b = 10;\nconsole.log(`Sum: ${a + b}`);  // Sum: 15\nconsole.log(`Double: ${a * 2}`);  // Double: 10\n\n// Multi-line strings\nconst multiLine = `\n  This is line 1\n  This is line 2\n  This is line 3\n`;\nconsole.log(multiLine);\n\n// Function calls\nfunction getPrice() { return 99.99; }\nconsole.log(`Price: $${getPrice()}`);\n\n// Tagged template\nfunction highlight(strings, ...values) {\n  return strings.reduce((result, str, i) => \n    `${result}${str}<strong>${values[i] || ''}</strong>`, '');\n}\nconst emphasized = highlight`Hello ${name}, you are ${age} years old`;"
    },
    {
      "id": 10,
      "question": "What are arrow functions and how do they differ from regular functions?",
      "answer": "Arrow functions are a concise syntax for writing functions introduced in ES6 with different behavior from regular functions.\n\nSyntax Features:\n• Shorter syntax using => operator\n• Implicit return for single expressions\n• Can omit parentheses for single parameter\n• Must use parentheses for multiple or no parameters\n\nKey Differences from Regular Functions:\n• Lexical 'this' binding - inherits from enclosing scope\n• No 'arguments' object available\n• Cannot be used as constructors (no 'new')\n• No prototype property\n• Cannot be used as generators\n\nLexical 'this':\n• 'this' is bound at definition time, not call time\n• Ideal for callbacks and array methods\n• Eliminates need for self = this or bind()\n\nWhen to Use:\n• Array methods (map, filter, reduce)\n• Callbacks and event handlers\n• Short, simple functions\n• When you need lexical 'this'",
      "explanation": "Arrow functions provide concise syntax with lexical 'this' binding inherited from enclosing scope, making them ideal for callbacks but unsuitable as constructors or when needing dynamic 'this'.",
      "difficulty": "Medium",
      "code": "// Regular function\nfunction add(a, b) {\n  return a + b;\n}\n\n// Arrow function - basic\nconst addArrow = (a, b) => a + b;\n\n// Arrow function variations\nconst single = x => x * 2;           // single param, no parens\nconst multi = (x, y) => x + y;       // multiple params\nconst none = () => console.log('hi'); // no params\nconst block = (x) => {                // block body\n  const result = x * 2;\n  return result;\n};\n\n// Lexical 'this'\nclass Counter {\n  constructor() {\n    this.count = 0;\n  }\n  \n  // Arrow function inherits 'this' from Counter\n  increment = () => {\n    this.count++;\n  }\n  \n  // Regular function would lose 'this' in setTimeout\n  startTimer() {\n    setTimeout(() => {\n      this.count++; // 'this' refers to Counter instance\n    }, 1000);\n  }\n}\n\n// Array methods\nconst numbers = [1, 2, 3, 4];\nconst doubled = numbers.map(n => n * 2);\nconst evens = numbers.filter(n => n % 2 === 0);"
    },
    {
      "id": 11,
      "question": "What is the 'this' keyword in JavaScript and how does it work?",
      "answer": "The 'this' keyword refers to the context in which a function is executed, and its value depends on how the function is called.\n\nContext Determination Rules:\n• Global context - refers to window (browser) or global (Node.js)\n• Object method - refers to the object owning the method\n• Constructor function - refers to newly created instance\n• Event handler - refers to the element that triggered event\n• Arrow functions - lexically bound to enclosing scope\n\nBinding Methods:\n• call() - invokes function with specified 'this' and arguments\n• apply() - like call() but takes array of arguments\n• bind() - returns new function with bound 'this'\n\nCommon Issues:\n• Lost context when passing methods as callbacks\n• Confusion between implicit and explicit binding\n• Arrow functions don't have their own 'this'\n\nBest Practices:\n• Use arrow functions for callbacks needing parent context\n• Use bind() to preserve context\n• Be explicit about 'this' in documentation",
      "explanation": "The 'this' keyword's value is determined by how a function is called: in methods it refers to the object, in constructors to the new instance, in arrow functions to the lexical scope, and can be explicitly set with call(), apply(), or bind().",
      "difficulty": "Medium",
      "code": "// Global context\nconsole.log(this); // window (browser) or global (Node.js)\n\n// Object method\nconst person = {\n  name: 'John',\n  greet: function() {\n    console.log(this.name); // 'John'\n  },\n  greetArrow: () => {\n    console.log(this.name); // undefined (lexical this)\n  }\n};\nperson.greet();\n\n// Lost context\nconst greetFunc = person.greet;\ngreetFunc(); // undefined (this is window/global)\n\n// Constructor\nfunction Person(name) {\n  this.name = name; // 'this' refers to new instance\n}\nconst john = new Person('John');\n\n// call, apply, bind\nconst obj = { value: 42 };\nfunction showValue() {\n  console.log(this.value);\n}\nshowValue.call(obj);  // 42\nshowValue.apply(obj); // 42\nconst bound = showValue.bind(obj);\nbound(); // 42\n\n// Event handler\n// button.addEventListener('click', function() {\n//   console.log(this); // button element\n// });"
    },
    {
      "id": 12,
      "question": "What are closures in JavaScript?",
      "answer": "A closure is a function that has access to variables in its outer (enclosing) lexical scope, even after the outer function has returned.\n\nHow Closures Work:\n• Inner function retains access to outer function's variables\n• Variables are preserved in memory\n• Created every time a function is created\n• Enable data privacy and encapsulation\n\nCommon Use Cases:\n• Data privacy and private variables\n• Factory functions\n• Event handlers and callbacks\n• Partial application and currying\n• Module pattern\n\nBenefits:\n• Encapsulation of private data\n• Function factories with preset values\n• Maintain state between function calls\n• Implement decorators and middleware\n\nPotential Issues:\n• Memory leaks if not managed properly\n• Can retain large objects in memory\n• Variables captured by reference in loops",
      "explanation": "Closures are functions that remember and access variables from their outer scope even after the outer function has finished executing, enabling data privacy and maintaining state across function calls.",
      "difficulty": "Medium",
      "code": "// Basic closure\nfunction outer() {\n  const message = 'Hello';\n  \n  function inner() {\n    console.log(message); // Accesses outer scope\n  }\n  \n  return inner;\n}\n\nconst myFunc = outer();\nmyFunc(); // 'Hello' - outer() finished but message accessible\n\n// Data privacy\nfunction createCounter() {\n  let count = 0; // Private variable\n  \n  return {\n    increment() { return ++count; },\n    decrement() { return --count; },\n    getCount() { return count; }\n  };\n}\n\nconst counter = createCounter();\nconsole.log(counter.increment()); // 1\nconsole.log(counter.increment()); // 2\nconsole.log(counter.getCount());  // 2\n// console.log(counter.count);    // undefined - private!\n\n// Function factory\nfunction createMultiplier(multiplier) {\n  return function(value) {\n    return value * multiplier;\n  };\n}\n\nconst double = createMultiplier(2);\nconst triple = createMultiplier(3);\nconsole.log(double(5)); // 10\nconsole.log(triple(5)); // 15"
    },
    {
      "id": 13,
      "question": "What is event bubbling and event capturing?",
      "answer": "Event bubbling and capturing are two phases of event propagation in the DOM tree.\n\nEvent Capturing (Trickling Down):\n• Event travels from root to target element\n• Outer elements receive event first\n• Rarely used in practice\n• Enabled by setting third parameter to true in addEventListener\n\nEvent Bubbling (Bubbling Up):\n• Event travels from target to root element\n• Inner elements receive event first\n• Default behavior in browsers\n• Most commonly used phase\n\nEvent Propagation Order:\n• Capturing phase (top to bottom)\n• Target phase (reached target element)\n• Bubbling phase (bottom to top)\n\nStopping Propagation:\n• stopPropagation() - stops bubbling/capturing\n• stopImmediatePropagation() - stops and prevents other listeners\n• preventDefault() - prevents default browser behavior\n\nEvent Delegation:\n• Attach single listener to parent element\n• Use bubbling to handle child events\n• More efficient for dynamic content",
      "explanation": "Event propagation has two phases: capturing (event travels from root to target) and bubbling (event travels from target back to root), with bubbling being the default and most commonly used for event delegation.",
      "difficulty": "Medium",
      "code": "// HTML structure:\n// <div id=\"parent\">\n//   <button id=\"child\">Click me</button>\n// </div>\n\n// Event Bubbling (default)\nconst parent = document.getElementById('parent');\nconst child = document.getElementById('child');\n\nparent.addEventListener('click', () => {\n  console.log('Parent clicked');\n});\n\nchild.addEventListener('click', () => {\n  console.log('Child clicked');\n});\n// Click child: 'Child clicked', then 'Parent clicked'\n\n// Event Capturing\nparent.addEventListener('click', () => {\n  console.log('Parent capturing');\n}, true); // true enables capturing\n\nchild.addEventListener('click', () => {\n  console.log('Child capturing');\n}, true);\n// Click child: 'Parent capturing', then 'Child capturing'\n\n// Stop propagation\nchild.addEventListener('click', (event) => {\n  event.stopPropagation();\n  console.log('Child clicked');\n});\n// Click child: only 'Child clicked', parent listener not called\n\n// Event delegation\nconst list = document.getElementById('list');\nlist.addEventListener('click', (event) => {\n  if (event.target.tagName === 'LI') {\n    console.log('List item clicked:', event.target.textContent);\n  }\n});"
    },
    {
      "id": 14,
      "question": "What is the difference between call(), apply(), and bind()?",
      "answer": "call(), apply(), and bind() are methods for controlling the 'this' context when invoking functions.\n\ncall():\n• Invokes function immediately\n• Takes 'this' value as first argument\n• Remaining arguments passed individually\n• Returns function result\n\napply():\n• Invokes function immediately\n• Takes 'this' value as first argument\n• Arguments passed as array (second parameter)\n• Useful for functions accepting variable arguments\n• Returns function result\n\nbind():\n• Does not invoke function immediately\n• Returns new function with bound 'this'\n• Can partially apply arguments\n• Useful for callbacks and event handlers\n• Bound function can be called multiple times\n\nCommon Use Cases:\n• call/apply: Borrowing methods from other objects\n• bind: Setting 'this' for callbacks and event handlers\n• apply: Working with Math.max/min with arrays\n• bind: Creating function factories with preset arguments",
      "explanation": "call() and apply() immediately invoke a function with specified 'this' context (call takes individual arguments, apply takes an array), while bind() returns a new function with bound 'this' without immediate execution.",
      "difficulty": "Medium",
      "code": "const person = {\n  name: 'John',\n  greet: function(greeting, punctuation) {\n    return `${greeting}, ${this.name}${punctuation}`;\n  }\n};\n\nconst anotherPerson = { name: 'Jane' };\n\n// call() - arguments individually\nconst result1 = person.greet.call(anotherPerson, 'Hello', '!');\nconsole.log(result1); // 'Hello, Jane!'\n\n// apply() - arguments as array\nconst result2 = person.greet.apply(anotherPerson, ['Hi', '?']);\nconsole.log(result2); // 'Hi, Jane?'\n\n// bind() - returns new function\nconst greetJane = person.greet.bind(anotherPerson);\nconsole.log(greetJane('Hey', '.')); // 'Hey, Jane.'\nconsole.log(greetJane('Welcome', '!!')); // 'Welcome, Jane!!'\n\n// Practical: Math.max with array\nconst numbers = [5, 6, 2, 3, 7];\nconst max = Math.max.apply(null, numbers);\nconsole.log(max); // 7\n\n// Modern alternative with spread\nconst max2 = Math.max(...numbers);\n\n// Partial application with bind\nfunction multiply(a, b) {\n  return a * b;\n}\nconst double = multiply.bind(null, 2);\nconsole.log(double(5)); // 10"
    },
    {
      "id": 15,
      "question": "What are Immediately Invoked Function Expressions (IIFE)?",
      "answer": "An IIFE is a function that is defined and executed immediately after creation.\n\nSyntax:\n• Wrap function in parentheses ()\n• Add () at end to invoke immediately\n• Can be anonymous or named\n• Creates its own scope\n\nPurposes:\n• Create private scope to avoid global namespace pollution\n• Execute initialization code\n• Create module pattern before ES6 modules\n• Avoid variable hoisting issues\n• Data privacy and encapsulation\n\nBenefits:\n• Variables inside are not accessible from outside\n• Prevents conflicts with other scripts\n• Executes immediately without manual invocation\n• Can return values or objects\n\nModern Alternatives:\n• ES6 modules provide better encapsulation\n• Block scope with let/const\n• Still useful for certain patterns\n\nCommon Patterns:\n• Module pattern\n• Singleton pattern\n• Temporary scope creation",
      "explanation": "IIFE is a function that executes immediately after definition, creating private scope to avoid polluting global namespace and providing data encapsulation, commonly used before ES6 modules.",
      "difficulty": "Medium",
      "code": "// Basic IIFE syntax\n(function() {\n  console.log('IIFE executed!');\n})();\n\n// IIFE with parameters\n(function(name) {\n  console.log(`Hello, ${name}`);\n})('John');\n\n// IIFE with return value\nconst result = (function() {\n  const privateVar = 'secret';\n  return {\n    getSecret: function() {\n      return privateVar;\n    }\n  };\n})();\n\nconsole.log(result.getSecret()); // 'secret'\n// console.log(privateVar); // Error - not accessible\n\n// Arrow function IIFE\n(() => {\n  console.log('Arrow IIFE');\n})();\n\n// Module pattern with IIFE\nconst calculator = (function() {\n  let result = 0;\n  \n  return {\n    add: function(x) { result += x; return this; },\n    subtract: function(x) { result -= x; return this; },\n    getResult: function() { return result; }\n  };\n})();\n\ncalculator.add(5).subtract(2);\nconsole.log(calculator.getResult()); // 3\n\n// Avoid global pollution\n(function() {\n  var temp = 'I am private';\n  // Do initialization work\n})();\n// temp is not accessible here"
    },
    {
      "id": 16,
      "question": "What are higher-order functions in JavaScript?",
      "answer": "A higher-order function is a function that either takes one or more functions as arguments or returns a function as its result.\n\nCharacteristics:\n• Accepts functions as parameters\n• Returns a function\n• Or both\n• Core concept of functional programming\n\nCommon Built-in Higher-Order Functions:\n• Array methods: map(), filter(), reduce(), forEach()\n• Function methods: call(), apply(), bind()\n• setTimeout(), setInterval()\n• Event handlers: addEventListener()\n\nBenefits:\n• Code reusability and modularity\n• Abstraction of common patterns\n• Function composition\n• Declarative programming style\n• Cleaner and more maintainable code\n\nUse Cases:\n• Data transformation (map, filter)\n• Function composition and chaining\n• Callback functions and async operations\n• Decorators and middleware\n• Currying and partial application",
      "explanation": "Higher-order functions accept functions as arguments or return functions, enabling functional programming patterns like map, filter, and reduce for cleaner, reusable, and more maintainable code.",
      "difficulty": "Medium",
      "code": "// Function that takes function as argument\nfunction repeat(n, action) {\n  for (let i = 0; i < n; i++) {\n    action(i);\n  }\n}\n\nrepeat(3, (i) => console.log(`Iteration ${i}`));\n\n// Function that returns function\nfunction createMultiplier(multiplier) {\n  return function(value) {\n    return value * multiplier;\n  };\n}\n\nconst double = createMultiplier(2);\nconst triple = createMultiplier(3);\nconsole.log(double(5)); // 10\nconsole.log(triple(5)); // 15\n\n// Array higher-order functions\nconst numbers = [1, 2, 3, 4, 5];\n\n// map - transform each element\nconst doubled = numbers.map(n => n * 2);\nconsole.log(doubled); // [2, 4, 6, 8, 10]\n\n// filter - select elements\nconst evens = numbers.filter(n => n % 2 === 0);\nconsole.log(evens); // [2, 4]\n\n// reduce - accumulate values\nconst sum = numbers.reduce((acc, n) => acc + n, 0);\nconsole.log(sum); // 15\n\n// Chaining higher-order functions\nconst result = numbers\n  .filter(n => n % 2 === 0)\n  .map(n => n * 2)\n  .reduce((acc, n) => acc + n, 0);\nconsole.log(result); // 12"
    },
    {
      "id": 17,
      "question": "What is the difference between map(), filter(), and reduce()?",
      "answer": "map(), filter(), and reduce() are higher-order array methods for transforming and processing data functionally.\n\nmap():\n• Transforms each element in array\n• Returns new array of same length\n• Applies function to each element\n• Does not modify original array\n• Returns array of transformed values\n\nfilter():\n• Selects elements based on condition\n• Returns new array with matching elements\n• Tests each element with predicate function\n• Length of result may be different from original\n• Does not modify original array\n\nreduce():\n• Reduces array to single value\n• Accumulates result through iteration\n• Takes accumulator and current value\n• Can return any type (number, string, object, array)\n• Most versatile of the three\n\nCommon Patterns:\n• map for transformation\n• filter for selection\n• reduce for aggregation\n• Can be chained together",
      "explanation": "map() transforms each element returning same-length array, filter() selects elements based on condition returning subset, and reduce() accumulates array into single value of any type.",
      "difficulty": "Medium",
      "code": "const numbers = [1, 2, 3, 4, 5];\n\n// map() - transform each element\nconst doubled = numbers.map(n => n * 2);\nconsole.log(doubled); // [2, 4, 6, 8, 10]\n\nconst squared = numbers.map(n => n ** 2);\nconsole.log(squared); // [1, 4, 9, 16, 25]\n\n// filter() - select elements\nconst evens = numbers.filter(n => n % 2 === 0);\nconsole.log(evens); // [2, 4]\n\nconst greaterThanTwo = numbers.filter(n => n > 2);\nconsole.log(greaterThanTwo); // [3, 4, 5]\n\n// reduce() - accumulate to single value\nconst sum = numbers.reduce((acc, n) => acc + n, 0);\nconsole.log(sum); // 15\n\nconst product = numbers.reduce((acc, n) => acc * n, 1);\nconsole.log(product); // 120\n\n// reduce to object\nconst users = ['John', 'Jane', 'Bob'];\nconst userObj = users.reduce((acc, name, index) => {\n  acc[index] = name;\n  return acc;\n}, {});\nconsole.log(userObj); // { 0: 'John', 1: 'Jane', 2: 'Bob' }\n\n// Chaining\nconst result = numbers\n  .filter(n => n % 2 === 0)  // [2, 4]\n  .map(n => n * 3)           // [6, 12]\n  .reduce((acc, n) => acc + n, 0); // 18\nconsole.log(result);"
    },
    {
      "id": 18,
      "question": "What is destructuring in JavaScript?",
      "answer": "Destructuring is a convenient way to extract values from arrays or properties from objects into distinct variables.\n\nArray Destructuring:\n• Extract values by position\n• Can skip elements\n• Can use rest operator (...)\n• Can provide default values\n• Useful for swapping variables\n\nObject Destructuring:\n• Extract properties by name\n• Can rename variables\n• Can provide default values\n• Can destructure nested objects\n• Order doesn't matter\n\nAdvanced Features:\n• Nested destructuring\n• Rest pattern to collect remaining items\n• Default values for undefined properties\n• Function parameter destructuring\n• Mixed array/object destructuring\n\nBenefits:\n• Cleaner and more readable code\n• Less repetitive variable declarations\n• Easy parameter extraction\n• Convenient data structure unpacking",
      "explanation": "Destructuring provides concise syntax to extract values from arrays by position or object properties by name into separate variables, supporting defaults, nesting, and rest patterns.",
      "difficulty": "Medium",
      "code": "// Array destructuring\nconst colors = ['red', 'green', 'blue', 'yellow'];\nconst [first, second] = colors;\nconsole.log(first, second); // 'red' 'green'\n\n// Skip elements\nconst [, , third] = colors;\nconsole.log(third); // 'blue'\n\n// Rest operator\nconst [primary, ...others] = colors;\nconsole.log(primary); // 'red'\nconsole.log(others);  // ['green', 'blue', 'yellow']\n\n// Swapping variables\nlet a = 1, b = 2;\n[a, b] = [b, a];\nconsole.log(a, b); // 2, 1\n\n// Object destructuring\nconst person = {\n  name: 'John',\n  age: 30,\n  city: 'New York'\n};\n\nconst { name, age } = person;\nconsole.log(name, age); // 'John' 30\n\n// Rename variables\nconst { name: fullName, age: years } = person;\nconsole.log(fullName, years); // 'John' 30\n\n// Default values\nconst { name, country = 'USA' } = person;\nconsole.log(country); // 'USA'\n\n// Nested destructuring\nconst user = {\n  id: 1,\n  info: { email: 'john@email.com', phone: '123' }\n};\nconst { info: { email } } = user;\nconsole.log(email); // 'john@email.com'\n\n// Function parameters\nfunction greet({ name, age }) {\n  console.log(`${name} is ${age} years old`);\n}\ngreet(person);"
    },
    {
      "id": 19,
      "question": "What is the spread operator and rest parameter?",
      "answer": "The spread operator (...) and rest parameter (...) use the same syntax but serve opposite purposes.\n\nSpread Operator:\n• Expands iterables into individual elements\n• Used in array literals, function calls, object literals\n• Spreads elements for copying or concatenation\n• Creates shallow copies\n\nCommon Spread Uses:\n• Copying arrays and objects\n• Concatenating arrays\n• Passing array elements as function arguments\n• Cloning objects with modifications\n• Converting iterables to arrays\n\nRest Parameter:\n• Collects multiple elements into array\n• Used in function parameters and destructuring\n• Must be last parameter\n• Represents indefinite number of arguments\n\nKey Differences:\n• Spread expands, rest collects\n• Spread in calls/literals, rest in definitions/destructuring\n• Both use ... syntax\n\nBenefits:\n• Cleaner syntax than traditional methods\n• Immutable operations\n• More readable code",
      "explanation": "Spread operator (...) expands arrays/objects into individual elements for copying or passing arguments, while rest parameter (...) collects multiple elements into an array in function parameters or destructuring.",
      "difficulty": "Medium",
      "code": "// Spread in arrays\nconst arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\n\n// Concatenation\nconst combined = [...arr1, ...arr2];\nconsole.log(combined); // [1, 2, 3, 4, 5, 6]\n\n// Copying\nconst copy = [...arr1];\ncopy.push(4);\nconsole.log(arr1);  // [1, 2, 3] (unchanged)\nconsole.log(copy);  // [1, 2, 3, 4]\n\n// Spread in function calls\nconst numbers = [5, 2, 8, 1, 9];\nconsole.log(Math.max(...numbers)); // 9\n\n// Spread in objects\nconst obj1 = { a: 1, b: 2 };\nconst obj2 = { c: 3, d: 4 };\nconst merged = { ...obj1, ...obj2 };\nconsole.log(merged); // { a: 1, b: 2, c: 3, d: 4 }\n\n// Override properties\nconst updated = { ...obj1, b: 20, e: 5 };\nconsole.log(updated); // { a: 1, b: 20, e: 5 }\n\n// Rest parameter in functions\nfunction sum(...numbers) {\n  return numbers.reduce((acc, n) => acc + n, 0);\n}\nconsole.log(sum(1, 2, 3, 4, 5)); // 15\n\n// Rest in destructuring\nconst [first, ...rest] = [1, 2, 3, 4, 5];\nconsole.log(first); // 1\nconsole.log(rest);  // [2, 3, 4, 5]\n\nconst { a, ...remaining } = { a: 1, b: 2, c: 3 };\nconsole.log(a);         // 1\nconsole.log(remaining); // { b: 2, c: 3 }"
    },
    {
      "id": 20,
      "question": "What are JavaScript modules (ES6 modules)?",
      "answer": "ES6 modules are JavaScript's native module system for organizing and reusing code across files.\n\nKey Features:\n• Use export to expose functions, objects, or values\n• Use import to consume exported items\n• Each module has its own scope\n• Modules are singletons (cached after first import)\n• Support static and dynamic imports\n\nExport Types:\n• Named exports - export multiple items by name\n• Default export - single default export per module\n• Can mix named and default exports\n\nImport Types:\n• Named imports - import specific exports\n• Default imports - import default export\n• Namespace imports - import all as object\n• Dynamic imports - async loading with import()\n\nBenefits:\n• Encapsulation and scope isolation\n• Explicit dependencies\n• Better code organization\n• Tree shaking for smaller bundles\n• Static analysis by build tools\n\nUsage:\n• Use type=\"module\" in script tags\n• Node.js requires .mjs extension or package.json config",
      "explanation": "ES6 modules provide native JavaScript module system with export/import syntax for code organization, supporting named and default exports, static and dynamic imports, and enabling tree shaking for optimization.",
      "difficulty": "Medium",
      "code": "// math.js - Named exports\nexport const PI = 3.14159;\nexport function add(a, b) {\n  return a + b;\n}\nexport function multiply(a, b) {\n  return a * b;\n}\n\n// Or export at end\nconst subtract = (a, b) => a - b;\nexport { subtract };\n\n// Default export\nexport default function divide(a, b) {\n  return a / b;\n}\n\n// app.js - Named imports\nimport { add, multiply, PI } from './math.js';\nconsole.log(add(5, 3));      // 8\nconsole.log(multiply(4, 2)); // 8\nconsole.log(PI);             // 3.14159\n\n// Default import\nimport divide from './math.js';\nconsole.log(divide(10, 2)); // 5\n\n// Mixed import\nimport divide, { add, PI } from './math.js';\n\n// Rename imports\nimport { add as sum } from './math.js';\nconsole.log(sum(2, 3)); // 5\n\n// Namespace import\nimport * as math from './math.js';\nconsole.log(math.add(1, 2));  // 3\nconsole.log(math.PI);         // 3.14159\n\n// Dynamic import\nasync function loadMath() {\n  const math = await import('./math.js');\n  console.log(math.add(5, 5)); // 10\n}\n\n// HTML usage\n// <script type=\"module\" src=\"app.js\"></script>"
    },
    {
      "id": 21,
      "question": "What are promises in JavaScript?",
      "answer": "A Promise is an object representing the eventual completion or failure of an asynchronous operation.\n\nPromise States:\n• Pending - initial state, neither fulfilled nor rejected\n• Fulfilled - operation completed successfully\n• Rejected - operation failed\n• Settled - either fulfilled or rejected (no longer pending)\n\nCreating Promises:\n• Use new Promise(executor)\n• Executor receives resolve and reject functions\n• Call resolve(value) on success\n• Call reject(error) on failure\n\nConsuming Promises:\n• then() - handles fulfilled state\n• catch() - handles rejected state\n• finally() - executes regardless of outcome\n• Chainable for sequential operations\n\nAdvantages Over Callbacks:\n• Better error handling\n• Avoid callback hell\n• Cleaner chaining syntax\n• Built-in error propagation\n• Composable with Promise.all(), Promise.race()",
      "explanation": "Promises represent asynchronous operations with three states (pending, fulfilled, rejected), providing cleaner syntax than callbacks through then/catch chaining and better error handling.",
      "difficulty": "Medium",
      "code": "// Creating a promise\nconst myPromise = new Promise((resolve, reject) => {\n  const success = true;\n  \n  setTimeout(() => {\n    if (success) {\n      resolve('Operation succeeded!');\n    } else {\n      reject('Operation failed!');\n    }\n  }, 1000);\n});\n\n// Consuming a promise\nmyPromise\n  .then(result => {\n    console.log(result); // 'Operation succeeded!'\n    return 'Next value';\n  })\n  .then(value => {\n    console.log(value); // 'Next value'\n  })\n  .catch(error => {\n    console.error(error);\n  })\n  .finally(() => {\n    console.log('Cleanup or final actions');\n  });\n\n// Practical example: fetch data\nfunction fetchUser(id) {\n  return new Promise((resolve, reject) => {\n    // Simulate API call\n    setTimeout(() => {\n      if (id > 0) {\n        resolve({ id, name: 'John Doe' });\n      } else {\n        reject('Invalid user ID');\n      }\n    }, 500);\n  });\n}\n\nfetchUser(1)\n  .then(user => console.log(user))\n  .catch(error => console.error(error));"
    },
    {
      "id": 22,
      "question": "What is async/await and how does it work?",
      "answer": "async/await is syntactic sugar over promises, providing cleaner syntax for asynchronous code.\n\nasync Functions:\n• Declared with async keyword\n• Always return a promise\n• Can contain await expressions\n• Make asynchronous code look synchronous\n\nawait Keyword:\n• Pauses execution until promise resolves\n• Can only be used inside async functions\n• Returns resolved value of promise\n• Throws error if promise rejects\n\nError Handling:\n• Use try/catch blocks\n• Wraps rejected promises as exceptions\n• More intuitive than promise catch chains\n• Can handle multiple awaits in single try block\n\nBenefits:\n• More readable than promise chains\n• Easier debugging (better stack traces)\n• Better error handling with try/catch\n• Looks like synchronous code\n• Avoids then() chaining\n\nBest Practices:\n• Always handle errors with try/catch\n• Use Promise.all() for parallel operations\n• Don't forget to await",
      "explanation": "async/await provides synchronous-looking syntax for asynchronous operations, with async functions returning promises and await pausing execution until promises resolve, using try/catch for error handling.",
      "difficulty": "Medium",
      "code": "// Basic async/await\nasync function fetchData() {\n  const response = await fetch('https://api.example.com/data');\n  const data = await response.json();\n  return data;\n}\n\n// Error handling with try/catch\nasync function getUserData(id) {\n  try {\n    const response = await fetch(`/api/users/${id}`);\n    \n    if (!response.ok) {\n      throw new Error('Failed to fetch user');\n    }\n    \n    const user = await response.json();\n    return user;\n  } catch (error) {\n    console.error('Error:', error.message);\n    throw error; // Re-throw if needed\n  }\n}\n\n// Sequential vs Parallel\n// Sequential - slow\nasync function sequential() {\n  const user = await fetchUser();    // Wait\n  const posts = await fetchPosts();  // Then wait\n  return { user, posts };\n}\n\n// Parallel - fast\nasync function parallel() {\n  const [user, posts] = await Promise.all([\n    fetchUser(),\n    fetchPosts()\n  ]);\n  return { user, posts };\n}\n\n// Using async/await\ngetUserData(1)\n  .then(user => console.log(user))\n  .catch(error => console.error(error));\n\n// Top-level await (modern environments)\n// const data = await fetchData();"
    },
    {
      "id": 23,
      "question": "What is the event loop in JavaScript?",
      "answer": "The event loop is the mechanism that handles asynchronous operations in JavaScript's single-threaded environment.\n\nCore Components:\n• Call Stack - executes synchronous code\n• Web APIs - handle async operations (timers, HTTP, DOM events)\n• Callback Queue (Task Queue) - holds callbacks from Web APIs\n• Microtask Queue - holds promise callbacks and mutations\n• Event Loop - coordinates between these components\n\nExecution Flow:\n• Synchronous code executes on call stack\n• Async operations sent to Web APIs\n• Completed async operations push callbacks to queues\n• Event loop checks if call stack is empty\n• Processes microtasks before macrotasks\n• Moves callbacks from queue to call stack\n\nTask Priorities:\n• Microtasks (Promises, queueMicrotask) - higher priority\n• Macrotasks (setTimeout, setInterval, I/O) - lower priority\n• All microtasks run before next macrotask\n\nWhy It Matters:\n• Understanding async behavior\n• Avoiding blocking operations\n• Optimizing performance",
      "explanation": "The event loop coordinates JavaScript's asynchronous execution by managing the call stack, callback queues (microtasks and macrotasks), and Web APIs, enabling non-blocking I/O in a single-threaded environment.",
      "difficulty": "Hard",
      "code": "// Event loop demonstration\nconsole.log('1: Synchronous');\n\nsetTimeout(() => {\n  console.log('2: Macrotask (setTimeout)');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('3: Microtask (Promise)');\n});\n\nconsole.log('4: Synchronous');\n\n// Output order:\n// 1: Synchronous\n// 4: Synchronous\n// 3: Microtask (Promise)\n// 2: Macrotask (setTimeout)\n\n// More complex example\nconsole.log('Start');\n\nsetTimeout(() => console.log('Timeout 1'), 0);\n\nPromise.resolve()\n  .then(() => console.log('Promise 1'))\n  .then(() => console.log('Promise 2'));\n\nsetTimeout(() => console.log('Timeout 2'), 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise 3');\n  setTimeout(() => console.log('Timeout 3'), 0);\n});\n\nconsole.log('End');\n\n// Output:\n// Start\n// End\n// Promise 1\n// Promise 2\n// Promise 3\n// Timeout 1\n// Timeout 2\n// Timeout 3"
    },
    {
      "id": 24,
      "question": "What is prototypal inheritance in JavaScript?",
      "answer": "Prototypal inheritance is JavaScript's mechanism for objects to inherit properties and methods from other objects.\n\nHow It Works:\n• Every object has an internal [[Prototype]] property\n• Points to another object (the prototype)\n• Properties lookup travels up prototype chain\n• Object.prototype is at the top of chain\n\nAccessing Prototype:\n• __proto__ - deprecated but widely supported\n• Object.getPrototypeOf() - recommended way\n• Object.setPrototypeOf() - set prototype\n• Constructor.prototype - function's prototype object\n\nPrototype Chain:\n• Property lookup checks object first\n• If not found, checks prototype\n• Continues up chain until found or reaches null\n• Methods can be shared across instances\n\nConstructor Functions:\n• Functions have prototype property\n• Instances inherit from constructor.prototype\n• Add methods to prototype for efficiency\n\nBenefits:\n• Memory efficiency - methods shared\n• Dynamic inheritance\n• Simple and flexible",
      "explanation": "Prototypal inheritance enables objects to inherit properties from other objects through a prototype chain, with property lookup traversing the chain until found, allowing method sharing for memory efficiency.",
      "difficulty": "Medium",
      "code": "// Basic prototype chain\nconst animal = {\n  eat() {\n    console.log(`${this.name} is eating`);\n  }\n};\n\nconst dog = Object.create(animal);\ndog.name = 'Rex';\ndog.bark = function() {\n  console.log('Woof!');\n};\n\ndog.eat();  // 'Rex is eating' (from prototype)\ndog.bark(); // 'Woof!' (own property)\n\n// Constructor function\nfunction Person(name) {\n  this.name = name;\n}\n\n// Add method to prototype\nPerson.prototype.greet = function() {\n  console.log(`Hello, I'm ${this.name}`);\n};\n\nconst john = new Person('John');\nconst jane = new Person('Jane');\n\njohn.greet(); // 'Hello, I'm John'\njane.greet(); // 'Hello, I'm Jane'\n\n// Both instances share the same greet method\nconsole.log(john.greet === jane.greet); // true\n\n// Checking prototype\nconsole.log(Object.getPrototypeOf(john) === Person.prototype); // true\n\n// Prototype chain\nconsole.log(john.hasOwnProperty('name'));  // true\nconsole.log(john.hasOwnProperty('greet')); // false\nconsole.log('greet' in john);              // true\n\n// Adding to instance vs prototype\njohn.age = 30; // Instance property\nPerson.prototype.species = 'Human'; // Prototype property\nconsole.log(john.age);     // 30\nconsole.log(jane.age);     // undefined\nconsole.log(john.species); // 'Human'\nconsole.log(jane.species); // 'Human'"
    },
    {
      "id": 25,
      "question": "What are ES6 classes and how do they relate to prototypes?",
      "answer": "ES6 classes are syntactic sugar over JavaScript's prototypal inheritance, providing cleaner object-oriented syntax.\n\nClass Features:\n• constructor() method for initialization\n• Method definitions without function keyword\n• static methods for class-level functions\n• Inheritance with extends keyword\n• super keyword to call parent methods\n• Getter and setter methods\n\nKey Points:\n• Classes are functions under the hood\n• Methods added to prototype automatically\n• Class declarations are not hoisted\n• Classes always use strict mode\n• Constructor is optional\n\nInheritance:\n• extends creates prototype chain\n• super() calls parent constructor (required if using constructor)\n• Can override parent methods\n• Can call parent methods with super.method()\n\nAdvantages Over Constructor Functions:\n• Cleaner, more intuitive syntax\n• Built-in inheritance mechanism\n• Better tooling support\n• Familiar to developers from other languages\n\nLimitations:\n• No private properties (before ES2022)\n• All methods public\n• Still prototype-based underneath",
      "explanation": "ES6 classes provide object-oriented syntax sugar over prototypal inheritance, offering cleaner syntax with constructor, methods, static members, and extends for inheritance, but are still prototype-based underneath.",
      "difficulty": "Medium",
      "code": "// Basic class\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  \n  greet() {\n    return `Hello, I'm ${this.name}`;\n  }\n  \n  // Getter\n  get info() {\n    return `${this.name}, ${this.age} years old`;\n  }\n  \n  // Setter\n  set updateAge(newAge) {\n    this.age = newAge;\n  }\n  \n  // Static method\n  static species() {\n    return 'Homo sapiens';\n  }\n}\n\nconst john = new Person('John', 30);\nconsole.log(john.greet());  // 'Hello, I'm John'\nconsole.log(john.info);     // 'John, 30 years old'\njohn.updateAge = 31;\nconsole.log(Person.species()); // 'Homo sapiens'\n\n// Inheritance\nclass Employee extends Person {\n  constructor(name, age, job) {\n    super(name, age); // Call parent constructor\n    this.job = job;\n  }\n  \n  // Override parent method\n  greet() {\n    return `${super.greet()}, I work as a ${this.job}`;\n  }\n  \n  work() {\n    return `${this.name} is working`;\n  }\n}\n\nconst emp = new Employee('Jane', 28, 'Developer');\nconsole.log(emp.greet()); // 'Hello, I'm Jane, I work as a Developer'\nconsole.log(emp.work());  // 'Jane is working'\n\n// Still prototype-based\nconsole.log(typeof Person); // 'function'\nconsole.log(john instanceof Person); // true\nconsole.log(Object.getPrototypeOf(john) === Person.prototype); // true"
    },
    {
      "id": 26,
      "question": "What is the difference between synchronous and asynchronous code?",
      "answer": "Synchronous and asynchronous code represent different execution models in JavaScript.\n\nSynchronous Code:\n• Executes line by line in order\n• Blocks execution until operation completes\n• Next line waits for previous to finish\n• Simpler to understand and debug\n• Can cause performance issues with slow operations\n\nAsynchronous Code:\n• Executes without blocking main thread\n• Operations run in background\n• Uses callbacks, promises, or async/await\n• Continues to next line without waiting\n• Better performance for I/O operations\n\nCommon Async Operations:\n• API calls (fetch, XMLHttpRequest)\n• File system operations\n• Timers (setTimeout, setInterval)\n• Database queries\n• Event handlers\n\nWhy Async Is Important:\n• Prevents UI freezing\n• Better user experience\n• Efficient resource utilization\n• Non-blocking I/O\n• JavaScript is single-threaded",
      "explanation": "Synchronous code executes line by line blocking until complete, while asynchronous code runs operations in background without blocking, using callbacks, promises, or async/await for better performance.",
      "difficulty": "Easy",
      "code": "// Synchronous - blocks execution\nconsole.log('Start');\nconst result = 5 + 5;  // Executes immediately\nconsole.log(result);   // Waits for previous line\nconsole.log('End');\n// Output: Start, 10, End\n\n// Asynchronous - non-blocking\nconsole.log('Start');\n\nsetTimeout(() => {\n  console.log('Async operation');\n}, 2000);\n\nconsole.log('End');\n// Output: Start, End, Async operation (after 2s)\n\n// Problem with synchronous\nfunction slowOperation() {\n  // Simulating slow operation\n  const end = Date.now() + 3000;\n  while (Date.now() < end) {} // Blocks for 3 seconds\n  return 'Done';\n}\n\nconsole.log('Before slow operation');\nconst data = slowOperation(); // Everything stops here!\nconsole.log('After slow operation');\n\n// Solution with async\nfunction asyncOperation() {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve('Done');\n    }, 3000);\n  });\n}\n\nconsole.log('Before async operation');\nasyncOperation().then(data => console.log(data));\nconsole.log('After async operation started');\n// Code continues without blocking"
    },
    {
      "id": 27,
      "question": "What are callbacks and callback hell?",
      "answer": "A callback is a function passed as an argument to another function to be executed later.\n\nCallback Characteristics:\n• Executed after async operation completes\n• Common pattern before promises\n• Used in event handlers and timers\n• Enable asynchronous programming\n\nCallback Hell (Pyramid of Doom):\n• Nested callbacks creating deep indentation\n• Occurs with multiple sequential async operations\n• Hard to read and maintain\n• Difficult error handling\n• Complex control flow\n\nProblems with Callback Hell:\n• Poor readability\n• Difficult debugging\n• Error handling complexity\n• Hard to reason about execution order\n• Tightly coupled code\n\nSolutions:\n• Use promises instead\n• Use async/await\n• Named functions instead of anonymous\n• Modularize code\n• Use control flow libraries\n\nModern Alternatives:\n• Promises with then() chaining\n• async/await syntax\n• Promise combinators (Promise.all, Promise.race)",
      "explanation": "Callbacks are functions passed to execute after async operations, but nesting multiple callbacks creates callback hell with poor readability, which promises and async/await solve elegantly.",
      "difficulty": "Medium",
      "code": "// Simple callback\nfunction fetchData(callback) {\n  setTimeout(() => {\n    callback('Data received');\n  }, 1000);\n}\n\nfetchData((data) => {\n  console.log(data);\n});\n\n// Callback Hell - nested callbacks\ngetUser(userId, (user) => {\n  getOrders(user.id, (orders) => {\n    getOrderDetails(orders[0].id, (details) => {\n      getPayment(details.paymentId, (payment) => {\n        console.log(payment);\n        // More nesting...\n      });\n    });\n  });\n});\n\n// Solution 1: Named functions\nfunction handlePayment(payment) {\n  console.log(payment);\n}\n\nfunction handleDetails(details) {\n  getPayment(details.paymentId, handlePayment);\n}\n\nfunction handleOrders(orders) {\n  getOrderDetails(orders[0].id, handleDetails);\n}\n\nfunction handleUser(user) {\n  getOrders(user.id, handleOrders);\n}\n\ngetUser(userId, handleUser);\n\n// Solution 2: Promises\ngetUser(userId)\n  .then(user => getOrders(user.id))\n  .then(orders => getOrderDetails(orders[0].id))\n  .then(details => getPayment(details.paymentId))\n  .then(payment => console.log(payment))\n  .catch(error => console.error(error));\n\n// Solution 3: async/await\nasync function getUserPayment(userId) {\n  try {\n    const user = await getUser(userId);\n    const orders = await getOrders(user.id);\n    const details = await getOrderDetails(orders[0].id);\n    const payment = await getPayment(details.paymentId);\n    console.log(payment);\n  } catch (error) {\n    console.error(error);\n  }\n}"
    },
    {
      "id": 28,
      "question": "What are Promise methods: Promise.all(), Promise.race(), Promise.allSettled(), and Promise.any()?",
      "answer": "These static methods handle multiple promises with different behaviors.\n\nPromise.all():\n• Waits for all promises to resolve\n• Returns array of all results\n• Rejects immediately if any promise rejects\n• Use for parallel operations that all must succeed\n\nPromise.race():\n• Returns first settled promise (resolved or rejected)\n• Ignores other promises once one settles\n• Use for timeout implementations or fastest response\n\nPromise.allSettled():\n• Waits for all promises to settle (resolve or reject)\n• Returns array of objects with status and value/reason\n• Never rejects\n• Use when you need results of all operations regardless of success\n\nPromise.any():\n• Returns first successful promise\n• Ignores rejected promises\n• Rejects only if all promises reject (AggregateError)\n• Use when you need any successful result\n\nWhen to Use:\n• all() - all must succeed\n• race() - first result matters\n• allSettled() - need all results\n• any() - need any success",
      "explanation": "Promise.all() waits for all to succeed, Promise.race() returns first settled, Promise.allSettled() waits for all regardless of outcome, and Promise.any() returns first success, each serving different parallel operation needs.",
      "difficulty": "Medium",
      "code": "// Promise.all() - all must succeed\nconst p1 = Promise.resolve(1);\nconst p2 = Promise.resolve(2);\nconst p3 = Promise.resolve(3);\n\nPromise.all([p1, p2, p3])\n  .then(results => console.log(results)) // [1, 2, 3]\n  .catch(error => console.error(error));\n\n// If one fails, all fails\nPromise.all([p1, Promise.reject('Error'), p3])\n  .then(results => console.log(results))\n  .catch(error => console.error(error)); // 'Error'\n\n// Promise.race() - first to settle\nconst slow = new Promise(resolve => setTimeout(() => resolve('slow'), 2000));\nconst fast = new Promise(resolve => setTimeout(() => resolve('fast'), 500));\n\nPromise.race([slow, fast])\n  .then(result => console.log(result)); // 'fast'\n\n// Promise.allSettled() - all results\nconst promises = [\n  Promise.resolve(1),\n  Promise.reject('Error'),\n  Promise.resolve(3)\n];\n\nPromise.allSettled(promises)\n  .then(results => console.log(results));\n// [\n//   { status: 'fulfilled', value: 1 },\n//   { status: 'rejected', reason: 'Error' },\n//   { status: 'fulfilled', value: 3 }\n// ]\n\n// Promise.any() - first success\nPromise.any([\n  Promise.reject('Error 1'),\n  Promise.resolve('Success'),\n  Promise.reject('Error 2')\n])\n  .then(result => console.log(result)); // 'Success'\n\n// Practical: parallel API calls\nasync function fetchMultiple() {\n  const [users, posts, comments] = await Promise.all([\n    fetch('/api/users').then(r => r.json()),\n    fetch('/api/posts').then(r => r.json()),\n    fetch('/api/comments').then(r => r.json())\n  ]);\n  return { users, posts, comments };\n}"
    },
    {
      "id": 29,
      "question": "What is debouncing and throttling?",
      "answer": "Debouncing and throttling are techniques to control function execution frequency, improving performance.\n\nDebouncing:\n• Delays function execution until after delay period\n• Resets timer if called again before delay ends\n• Function executes only after user stops action\n• Use for search inputs, resize events, form validation\n\nHow Debouncing Works:\n• User triggers event\n• Start timer\n• If event triggers again, cancel and restart timer\n• Execute function only when timer completes\n\nThrottling:\n• Ensures function executes at most once per interval\n• Ignores calls during interval\n• Guarantees execution happens regularly\n• Use for scroll events, mouse movement, animation\n\nHow Throttling Works:\n• Function executes immediately\n• Subsequent calls ignored until interval passes\n• After interval, next call executes\n\nKey Differences:\n• Debouncing waits for pause, throttling executes regularly\n• Debouncing may never execute if events continuous\n• Throttling guarantees execution at intervals",
      "explanation": "Debouncing delays function execution until after a pause in events (like search input), while throttling ensures function executes at most once per time interval (like scroll events).",
      "difficulty": "Medium",
      "code": "// Debounce implementation\nfunction debounce(func, delay) {\n  let timeoutId;\n  \n  return function(...args) {\n    clearTimeout(timeoutId);\n    \n    timeoutId = setTimeout(() => {\n      func.apply(this, args);\n    }, delay);\n  };\n}\n\n// Usage: Search input\nconst searchAPI = (query) => {\n  console.log('Searching for:', query);\n  // API call\n};\n\nconst debouncedSearch = debounce(searchAPI, 500);\n\n// User types: 'hello'\n// Only calls API once, 500ms after they stop typing\ninput.addEventListener('input', (e) => {\n  debouncedSearch(e.target.value);\n});\n\n// Throttle implementation\nfunction throttle(func, limit) {\n  let inThrottle;\n  \n  return function(...args) {\n    if (!inThrottle) {\n      func.apply(this, args);\n      inThrottle = true;\n      \n      setTimeout(() => {\n        inThrottle = false;\n      }, limit);\n    }\n  };\n}\n\n// Usage: Scroll event\nconst handleScroll = () => {\n  console.log('Scrolling...');\n  // Update UI\n};\n\nconst throttledScroll = throttle(handleScroll, 200);\n\nwindow.addEventListener('scroll', throttledScroll);\n// Executes at most once every 200ms while scrolling\n\n// Comparison\n// Debounce: --------wait---------EXECUTE (after quiet period)\n// Throttle: EXECUTE-wait-EXECUTE-wait-EXECUTE (regular intervals)"
    },
    {
      "id": 30,
      "question": "What is the difference between deep copy and shallow copy?",
      "answer": "Deep and shallow copies differ in how they handle nested objects and references.\n\nShallow Copy:\n• Copies only first level of properties\n• Nested objects copied by reference\n• Changes to nested objects affect original\n• Faster and uses less memory\n• Methods: Object.assign(), spread operator, Array.slice()\n\nDeep Copy:\n• Copies all levels recursively\n• Creates completely independent copy\n• Nested objects also cloned\n• Changes don't affect original\n• Methods: JSON.parse(JSON.stringify()), structuredClone(), libraries\n\nShallow Copy Problems:\n• Modifying nested objects affects original\n• Shared references between copies\n• Unexpected mutations\n\nDeep Copy Limitations:\n• JSON methods lose functions, undefined, symbols\n• Cannot handle circular references\n• Performance overhead\n• More memory usage\n\nBest Practices:\n• Use shallow copy when no nested objects\n• Use deep copy for complex nested structures\n• Consider immutability libraries (Immer, Immutable.js)",
      "explanation": "Shallow copy duplicates only the first level with nested objects shared by reference, while deep copy recursively clones all levels creating independent copies, with different trade-offs in performance and completeness.",
      "difficulty": "Medium",
      "code": "// Shallow copy examples\nconst original = {\n  name: 'John',\n  address: { city: 'New York', zip: '10001' }\n};\n\n// Method 1: Spread operator\nconst copy1 = { ...original };\ncopy1.name = 'Jane'; // OK\ncopy1.address.city = 'Boston'; // Affects original!\nconsole.log(original.address.city); // 'Boston'\n\n// Method 2: Object.assign()\nconst copy2 = Object.assign({}, original);\n\n// Method 3: Array shallow copy\nconst arr = [1, 2, [3, 4]];\nconst arrCopy = [...arr];\narrCopy[2][0] = 99;\nconsole.log(arr[2][0]); // 99 (affected!)\n\n// Deep copy examples\nconst obj = {\n  name: 'John',\n  age: 30,\n  address: { city: 'New York', zip: '10001' },\n  hobbies: ['reading', 'coding']\n};\n\n// Method 1: JSON (limitations)\nconst deepCopy1 = JSON.parse(JSON.stringify(obj));\ndeepCopy1.address.city = 'Boston';\nconsole.log(obj.address.city); // 'New York' (not affected)\n\n// JSON limitations\nconst objWithFunc = {\n  name: 'John',\n  greet: function() { console.log('Hi'); },\n  undef: undefined\n};\nconst jsonCopy = JSON.parse(JSON.stringify(objWithFunc));\n// greet and undef are lost!\n\n// Method 2: structuredClone() (modern browsers)\nconst deepCopy2 = structuredClone(obj);\n\n// Manual deep copy function\nfunction deepClone(obj) {\n  if (obj === null || typeof obj !== 'object') return obj;\n  \n  if (obj instanceof Date) return new Date(obj);\n  if (obj instanceof Array) return obj.map(item => deepClone(item));\n  \n  const cloned = {};\n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      cloned[key] = deepClone(obj[key]);\n    }\n  }\n  return cloned;\n}"
    },
    {
      "id": 31,
      "question": "What are generator functions and iterators?",
      "answer": "Generator functions are special functions that can pause execution and resume later, producing sequence of values.\n\nGenerator Characteristics:\n• Defined with function* syntax\n• Use yield keyword to pause and return values\n• Return iterator object\n• Maintain state between yields\n• Can be resumed with next()\n\nIterator Protocol:\n• Objects with next() method\n• next() returns { value, done } object\n• done is true when iteration complete\n• Generators implement iterator protocol automatically\n\nkey Features:\n• Lazy evaluation - values generated on demand\n• Memory efficient for large sequences\n• Can represent infinite sequences\n• Control execution flow\n• Can accept values via next(value)\n\nUse Cases:\n• Implementing custom iterators\n• Lazy data processing\n• Async operations (with async generators)\n• State machines\n• Infinite sequences\n\nAdvanced:\n• yield* delegates to another generator\n• return() method to end generator\n• throw() method to throw error",
      "explanation": "Generator functions use function* and yield to create iterators that can pause and resume execution, enabling lazy evaluation, memory-efficient sequences, and powerful control flow patterns.",
      "difficulty": "Hard",
      "code": "// Basic generator\nfunction* numberGenerator() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nconst gen = numberGenerator();\nconsole.log(gen.next()); // { value: 1, done: false }\nconsole.log(gen.next()); // { value: 2, done: false }\nconsole.log(gen.next()); // { value: 3, done: false }\nconsole.log(gen.next()); // { value: undefined, done: true }\n\n// Using for...of\nfor (const num of numberGenerator()) {\n  console.log(num); // 1, 2, 3\n}\n\n// Infinite sequence\nfunction* infiniteNumbers() {\n  let n = 0;\n  while (true) {\n    yield n++;\n  }\n}\n\nconst infinite = infiniteNumbers();\nconsole.log(infinite.next().value); // 0\nconsole.log(infinite.next().value); // 1\n\n// Range generator\nfunction* range(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n}\n\nconst numbers = [...range(1, 5)];\nconsole.log(numbers); // [1, 2, 3, 4, 5]\n\n// Generator with input\nfunction* echo() {\n  while (true) {\n    const value = yield;\n    console.log('Received:', value);\n  }\n}\n\nconst echoGen = echo();\nechoGen.next();        // Start generator\nechoGen.next('Hello'); // Received: Hello\nechoGen.next('World'); // Received: World\n\n// Practical: ID generator\nfunction* idGenerator() {\n  let id = 1;\n  while (true) {\n    yield id++;\n  }\n}\n\nconst ids = idGenerator();\nconsole.log(ids.next().value); // 1\nconsole.log(ids.next().value); // 2"
    },
    {
      "id": 32,
      "question": "What is currying in JavaScript?",
      "answer": "Currying is transforming a function with multiple arguments into a sequence of functions each taking a single argument.\n\nHow Currying Works:\n• Original function takes multiple arguments\n• Curried version returns series of functions\n• Each function takes one argument\n• Returns next function until all arguments provided\n• Final function returns result\n\nBenefits:\n• Partial application of arguments\n• Function reusability\n• Function composition\n• Creating specialized functions\n• Better code organization\n\nUse Cases:\n• Event handler factories\n• Configuration functions\n• Functional programming\n• Creating utility functions\n• Dependency injection\n\nImplementation Approaches:\n• Manual currying with nested functions\n• Generic curry function\n• Using bind() for partial application\n• Arrow functions for concise syntax\n\nRelated Concepts:\n• Partial application - fixing some arguments\n• Function composition - combining functions\n• Higher-order functions",
      "explanation": "Currying transforms a multi-argument function into nested single-argument functions, enabling partial application, function reusability, and creation of specialized functions from general ones.",
      "difficulty": "Hard",
      "code": "// Non-curried function\nfunction add(a, b, c) {\n  return a + b + c;\n}\nconsole.log(add(1, 2, 3)); // 6\n\n// Manually curried\nfunction curriedAdd(a) {\n  return function(b) {\n    return function(c) {\n      return a + b + c;\n    };\n  };\n}\n\nconsole.log(curriedAdd(1)(2)(3)); // 6\n\n// Arrow function syntax\nconst curriedAddArrow = a => b => c => a + b + c;\nconsole.log(curriedAddArrow(1)(2)(3)); // 6\n\n// Partial application\nconst add1 = curriedAdd(1);\nconst add1And2 = add1(2);\nconsole.log(add1And2(3)); // 6\n\n// Generic curry function\nfunction curry(fn) {\n  return function curried(...args) {\n    if (args.length >= fn.length) {\n      return fn.apply(this, args);\n    } else {\n      return function(...nextArgs) {\n        return curried.apply(this, args.concat(nextArgs));\n      };\n    }\n  };\n}\n\nconst multiply = (a, b, c) => a * b * c;\nconst curriedMultiply = curry(multiply);\n\nconsole.log(curriedMultiply(2)(3)(4));    // 24\nconsole.log(curriedMultiply(2, 3)(4));    // 24\nconsole.log(curriedMultiply(2)(3, 4));    // 24\n\n// Practical example: logging\nconst log = level => message => timestamp => {\n  console.log(`[${timestamp}] ${level}: ${message}`);\n};\n\nconst errorLog = log('ERROR');\nconst infoLog = log('INFO');\n\nerrorLog('Connection failed')(new Date().toISOString());\ninfoLog('User logged in')(new Date().toISOString());\n\n// Using bind for partial application\nconst greet = (greeting, name) => `${greeting}, ${name}!`;\nconst sayHello = greet.bind(null, 'Hello');\nconsole.log(sayHello('John')); // 'Hello, John!'"
    },
    {
      "id": 33,
      "question": "What is memoization and how do you implement it?",
      "answer": "Memoization is an optimization technique that caches function results based on input arguments.\n\nHow It Works:\n• Cache stores results keyed by arguments\n• On function call, check cache first\n• Return cached result if exists\n• Otherwise compute, cache, and return result\n• Trades memory for speed\n\nWhen to Use:\n• Expensive computations\n• Pure functions (same input always produces same output)\n• Recursive algorithms (Fibonacci, factorial)\n• Repeated calculations with same inputs\n• API calls with same parameters\n\nBenefits:\n• Significant performance improvement\n• Reduces redundant calculations\n• Especially effective for recursive functions\n• Improves response time\n\nConsiderations:\n• Only for pure functions\n• Memory overhead from cache\n• Cache invalidation strategy\n• Not suitable for functions with side effects\n• May need cache size limits\n\nImplementation Approaches:\n• Simple object cache\n• WeakMap for object keys\n• LRU (Least Recently Used) cache\n• Library solutions (lodash.memoize)",
      "explanation": "Memoization caches function results based on arguments to avoid redundant calculations, significantly improving performance for expensive pure functions by trading memory for speed.",
      "difficulty": "Medium",
      "code": "// Basic memoization\nfunction memoize(fn) {\n  const cache = {};\n  \n  return function(...args) {\n    const key = JSON.stringify(args);\n    \n    if (key in cache) {\n      console.log('Returning cached result');\n      return cache[key];\n    }\n    \n    console.log('Computing result');\n    const result = fn.apply(this, args);\n    cache[key] = result;\n    return result;\n  };\n}\n\n// Example: Expensive function\nfunction expensiveCalculation(n) {\n  // Simulate expensive operation\n  let sum = 0;\n  for (let i = 0; i < n * 1000000; i++) {\n    sum += i;\n  }\n  return sum;\n}\n\nconst memoizedCalc = memoize(expensiveCalculation);\n\nconsole.log(memoizedCalc(100)); // Computing result (slow)\nconsole.log(memoizedCalc(100)); // Returning cached result (fast)\n\n// Fibonacci without memoization - exponential time\nfunction fibonacci(n) {\n  if (n <= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n// Fibonacci with memoization - linear time\nconst memoizedFib = memoize(function fibonacci(n) {\n  if (n <= 1) return n;\n  return memoizedFib(n - 1) + memoizedFib(n - 2);\n});\n\nconsole.log(fibonacci(40));     // Very slow\nconsole.log(memoizedFib(40));   // Much faster\n\n// Advanced: With WeakMap for object keys\nfunction memoizeWithWeakMap(fn) {\n  const cache = new WeakMap();\n  \n  return function(obj) {\n    if (cache.has(obj)) {\n      return cache.get(obj);\n    }\n    \n    const result = fn.call(this, obj);\n    cache.set(obj, result);\n    return result;\n  };\n}\n\n// Practical: API call memoization\nconst fetchUser = memoize(async function(userId) {\n  const response = await fetch(`/api/users/${userId}`);\n  return response.json();\n});"
    },
    {
      "id": 34,
      "question": "What is the difference between localStorage, sessionStorage, and cookies?",
      "answer": "These are client-side storage mechanisms with different characteristics and use cases.\n\nlocalStorage:\n• Stores data persistently (no expiration)\n• Data survives browser close/restart\n• Storage limit: ~5-10MB\n• Accessible only from same origin\n• Not sent to server with requests\n• Synchronous API\n\nsessionStorage:\n• Stores data for session duration\n• Data cleared when tab/window closed\n• Storage limit: ~5-10MB\n• Isolated per tab/window\n• Not sent to server with requests\n• Synchronous API\n\nCookies:\n• Can set expiration date\n• Storage limit: ~4KB per cookie\n• Sent to server with every HTTP request\n• Can be made HTTP-only (no JavaScript access)\n• Can be secured (HTTPS only)\n• Accessible across tabs\n• Supports domain and path attributes\n\nWhen to Use:\n• localStorage - user preferences, cached data\n• sessionStorage - temporary session data\n• cookies - authentication tokens, server-side data",
      "explanation": "localStorage persists indefinitely, sessionStorage lasts for the session, and cookies are limited to 4KB but can be sent to servers and have fine-grained control over expiration and security.",
      "difficulty": "Medium",
      "code": "// localStorage - persistent storage\nlocalStorage.setItem('username', 'John');\nlocalStorage.setItem('theme', 'dark');\n\nconst username = localStorage.getItem('username');\nconsole.log(username); // 'John'\n\nlocalStorage.removeItem('username');\nlocalStorage.clear(); // Remove all\n\n// Store objects (must stringify)\nconst user = { name: 'John', age: 30 };\nlocalStorage.setItem('user', JSON.stringify(user));\nconst storedUser = JSON.parse(localStorage.getItem('user'));\n\n// sessionStorage - session-only storage\nsessionStorage.setItem('tempData', 'temporary');\nconst temp = sessionStorage.getItem('tempData');\nsessionStorage.removeItem('tempData');\n\n// Cookies - with expiration\nfunction setCookie(name, value, days) {\n  const expires = new Date();\n  expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);\n  document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;\n}\n\nfunction getCookie(name) {\n  const cookies = document.cookie.split(';');\n  for (let cookie of cookies) {\n    const [key, value] = cookie.trim().split('=');\n    if (key === name) return value;\n  }\n  return null;\n}\n\nfunction deleteCookie(name) {\n  document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 UTC;path=/`;\n}\n\nsetCookie('token', 'abc123', 7); // Expires in 7 days\nconst token = getCookie('token');\ndeleteCookie('token');\n\n// Comparison\n// Feature          | localStorage | sessionStorage | cookies\n// ----------------|--------------|----------------|----------\n// Expiration      | Never        | On tab close   | Custom\n// Size            | ~5-10MB      | ~5-10MB        | ~4KB\n// Server access   | No           | No             | Yes\n// Scope           | Origin       | Tab/Window     | Origin\n// API             | Sync         | Sync           | String"
    },
    {
      "id": 35,
      "question": "What is event delegation and why is it useful?",
      "answer": "Event delegation is a pattern where a single event listener on a parent element handles events for multiple child elements.\n\nHow It Works:\n• Attach listener to parent element\n• Child events bubble up to parent\n• Use event.target to identify actual element clicked\n• Parent listener handles events for all children\n• Leverages event bubbling mechanism\n\nBenefits:\n• Better performance - fewer event listeners\n• Memory efficient\n• Handles dynamically added elements automatically\n• Simpler code maintenance\n• Reduced memory consumption\n\nWhen to Use:\n• Large lists of similar elements\n• Dynamically generated content\n• Tables with many rows\n• Navigation menus\n• Any scenario with many similar child elements\n\nImplementation:\n• Add listener to parent\n• Check event.target in handler\n• Filter by tag name, class, or data attributes\n• Perform appropriate action\n\nConsiderations:\n• Not all events bubble (focus, blur, load)\n• Check event.target carefully\n• May need event.target.closest() for nested elements",
      "explanation": "Event delegation attaches a single listener to a parent element to handle events for multiple children using event bubbling, improving performance and automatically handling dynamically added elements.",
      "difficulty": "Medium",
      "code": "// Without delegation - inefficient\nconst buttons = document.querySelectorAll('.button');\nbuttons.forEach(button => {\n  button.addEventListener('click', (e) => {\n    console.log('Button clicked:', e.target.textContent);\n  });\n});\n// Problem: New buttons added later won't have listeners!\n\n// With delegation - efficient\nconst container = document.getElementById('container');\ncontainer.addEventListener('click', (e) => {\n  if (e.target.classList.contains('button')) {\n    console.log('Button clicked:', e.target.textContent);\n  }\n});\n// Works for existing and future buttons!\n\n// Practical example: Todo list\nconst todoList = document.getElementById('todo-list');\n\ntodoList.addEventListener('click', (e) => {\n  // Delete button\n  if (e.target.classList.contains('delete-btn')) {\n    e.target.parentElement.remove();\n  }\n  \n  // Complete checkbox\n  if (e.target.classList.contains('complete-checkbox')) {\n    e.target.parentElement.classList.toggle('completed');\n  }\n  \n  // Edit button\n  if (e.target.classList.contains('edit-btn')) {\n    const todo = e.target.parentElement;\n    const text = todo.querySelector('.todo-text');\n    text.contentEditable = true;\n    text.focus();\n  }\n});\n\n// Using closest() for nested elements\nconst table = document.getElementById('data-table');\n\ntable.addEventListener('click', (e) => {\n  const row = e.target.closest('tr');\n  \n  if (row && row.dataset.id) {\n    console.log('Row clicked:', row.dataset.id);\n  }\n});\n\n// Filtering multiple element types\nconst parent = document.getElementById('parent');\n\nparent.addEventListener('click', (e) => {\n  const target = e.target;\n  \n  if (target.matches('.button')) {\n    console.log('Button clicked');\n  } else if (target.matches('.link')) {\n    console.log('Link clicked');\n  } else if (target.matches('.item')) {\n    console.log('Item clicked');\n  }\n});"
    },
    {
      "id": 36,
      "question": "What are JavaScript design patterns and name some common ones?",
      "answer": "Design patterns are reusable solutions to common software design problems.\n\nCommon Patterns:\n\nModule Pattern:\n• Encapsulation using closures\n• Public and private members\n• IIFE for immediate execution\n• Pre-ES6 module system\n\nSingleton Pattern:\n• Ensures only one instance exists\n• Global access point\n• Lazy initialization\n• Used for configuration, logging\n\nObserver Pattern:\n• Subject notifies observers of changes\n• Loose coupling between components\n• Event systems, data binding\n• Used in frameworks like React, Vue\n\nFactory Pattern:\n• Creates objects without specifying exact class\n• Centralized object creation\n• Abstraction layer\n• Flexible and extensible\n\nPrototype Pattern:\n• Clone existing objects\n• JavaScript's native inheritance model\n• Object.create() implementation\n\nDecorator Pattern:\n• Add functionality to objects dynamically\n• Wrapper around existing code\n• Higher-order functions\n\nStrategy Pattern:\n• Define family of algorithms\n• Make them interchangeable\n• Encapsulate each one",
      "explanation": "JavaScript design patterns provide proven solutions to common problems, including Module (encapsulation), Singleton (single instance), Observer (event notification), Factory (object creation), and others for better code organization.",
      "difficulty": "Hard",
      "code": "// 1. Module Pattern\nconst Calculator = (function() {\n  // Private\n  let result = 0;\n  \n  // Public API\n  return {\n    add(x) { result += x; return this; },\n    subtract(x) { result -= x; return this; },\n    getResult() { return result; }\n  };\n})();\n\nCalculator.add(5).subtract(2);\nconsole.log(Calculator.getResult()); // 3\n\n// 2. Singleton Pattern\nconst Singleton = (function() {\n  let instance;\n  \n  function createInstance() {\n    return { name: 'Singleton Instance' };\n  }\n  \n  return {\n    getInstance() {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return instance;\n    }\n  };\n})();\n\nconst s1 = Singleton.getInstance();\nconst s2 = Singleton.getInstance();\nconsole.log(s1 === s2); // true\n\n// 3. Observer Pattern\nclass Subject {\n  constructor() {\n    this.observers = [];\n  }\n  \n  subscribe(observer) {\n    this.observers.push(observer);\n  }\n  \n  unsubscribe(observer) {\n    this.observers = this.observers.filter(obs => obs !== observer);\n  }\n  \n  notify(data) {\n    this.observers.forEach(observer => observer.update(data));\n  }\n}\n\nclass Observer {\n  update(data) {\n    console.log('Received:', data);\n  }\n}\n\nconst subject = new Subject();\nconst obs1 = new Observer();\nsubject.subscribe(obs1);\nsubject.notify('Hello'); // Observer receives 'Hello'\n\n// 4. Factory Pattern\nclass Car { drive() { console.log('Driving car'); } }\nclass Bike { ride() { console.log('Riding bike'); } }\n\nclass VehicleFactory {\n  createVehicle(type) {\n    switch(type) {\n      case 'car': return new Car();\n      case 'bike': return new Bike();\n      default: throw new Error('Unknown vehicle');\n    }\n  }\n}\n\nconst factory = new VehicleFactory();\nconst car = factory.createVehicle('car');\ncar.drive();"
    },
    {
      "id": 37,
      "question": "What is the difference between function declaration and function expression?",
      "answer": "Function declarations and expressions are two ways to define functions with key differences.\n\nFunction Declaration:\n• Uses function keyword followed by name\n• Hoisted completely (can call before definition)\n• Creates named function in current scope\n• Cannot be anonymous\n• Statement, not expression\n\nFunction Expression:\n• Function assigned to variable\n• Not hoisted (only variable declaration hoisted)\n• Can be anonymous or named\n• Can be used as IIFE\n• Expression, can be used inline\n\nNamed Function Expression:\n• Function expression with name\n• Name only available inside function\n• Useful for recursion and debugging\n• Stack traces show function name\n\nArrow Function Expression:\n• Concise syntax\n• Lexical this binding\n• Cannot be used as constructor\n• No arguments object\n\nWhen to Use:\n• Declarations for top-level functions\n• Expressions for callbacks, conditionals\n• Arrow functions for short callbacks",
      "explanation": "Function declarations are hoisted and can be called before definition, while function expressions are assigned to variables, not hoisted, and can be anonymous or used inline.",
      "difficulty": "Easy",
      "code": "// Function Declaration - hoisted\ngreet(); // Works!\n\nfunction greet() {\n  console.log('Hello');\n}\n\n// Function Expression - not hoisted\n// sayHi(); // Error: sayHi is not a function\n\nconst sayHi = function() {\n  console.log('Hi');\n};\n\nsayHi(); // Works now\n\n// Named Function Expression\nconst factorial = function fact(n) {\n  if (n <= 1) return 1;\n  return n * fact(n - 1); // Can use 'fact' inside\n};\n\nconsole.log(factorial(5)); // 120\n// console.log(fact(5)); // Error: fact not defined outside\n\n// Arrow Function Expression\nconst multiply = (a, b) => a * b;\n\n// Function expressions in objects\nconst calculator = {\n  add: function(a, b) { return a + b; },\n  subtract(a, b) { return a - b; }, // Shorthand\n  multiply: (a, b) => a * b // Arrow function\n};\n\n// Conditional function assignment\nconst operation = isAddition ? \n  function(a, b) { return a + b; } :\n  function(a, b) { return a - b; };\n\n// IIFE with function expression\n(function() {\n  console.log('Immediately invoked');\n})();\n\n// Hoisting comparison\nconsole.log(typeof declared);  // 'function'\nconsole.log(typeof expressed); // 'undefined'\n\nfunction declared() {}\nvar expressed = function() {};"
    },
    {
      "id": 38,
      "question": "What is the Temporal Dead Zone (TDZ)?",
      "answer": "The Temporal Dead Zone is the period between entering scope and variable declaration where let/const variables cannot be accessed.\n\nHow It Works:\n• Variables declared with let/const are hoisted\n• Unlike var, they're not initialized with undefined\n• Accessing before declaration throws ReferenceError\n• TDZ exists from scope start to declaration line\n• Ends when variable is declared\n\nVariables Affected:\n• let variables\n• const variables\n• class declarations\n• Function parameters with default values\n\nNot Affected:\n• var variables (initialized to undefined)\n• function declarations (fully hoisted)\n\nWhy TDZ Exists:\n• Catches potential bugs early\n• Prevents using variables before initialization\n• Makes const behavior consistent\n• Encourages better coding practices\n\nBest Practices:\n• Declare variables at top of scope\n• Initialize variables when declaring\n• Use const by default, let when needed\n• Avoid accessing variables before declaration",
      "explanation": "The Temporal Dead Zone is the period from scope entry to variable declaration where let/const variables are hoisted but uninitialized, throwing ReferenceError if accessed, preventing unintended undefined usage.",
      "difficulty": "Medium",
      "code": "// TDZ with let\nconsole.log(x); // ReferenceError: Cannot access 'x' before initialization\nlet x = 5;\n\n// TDZ with const\nconsole.log(y); // ReferenceError\nconst y = 10;\n\n// Compare with var - no TDZ\nconsole.log(z); // undefined (no error)\nvar z = 15;\n\n// TDZ in block scope\n{\n  // TDZ starts\n  // console.log(temp); // Error\n  \n  let temp = 'value'; // TDZ ends\n  console.log(temp);  // Works\n}\n\n// TDZ with function parameters\nfunction test(a = b, b = 2) {\n  return [a, b];\n}\n\n// test(); // ReferenceError: b is in TDZ when evaluating a's default\n\n// Working version\nfunction testWorking(a = 1, b = a) {\n  return [a, b];\n}\n\nconsole.log(testWorking()); // [1, 1]\n\n// TDZ in loops\nfor (let i = 0; i < 3; i++) {\n  // Each iteration has its own 'i' with TDZ\n  console.log(i);\n}\n\n// Practical example showing TDZ benefit\nfunction getValue() {\n  // Catches typo/error early\n  // console.log(result); // ReferenceError - good!\n  \n  let result = complexCalculation();\n  return result;\n}\n\n// Without TDZ (with var)\nfunction getValueVar() {\n  console.log(result); // undefined - silent bug!\n  var result = complexCalculation();\n  return result;\n}\n\nfunction complexCalculation() {\n  return 42;\n}"
    },
    {
      "id": 39,
      "question": "What is the difference between for...in and for...of loops?",
      "answer": "for...in and for...of are iteration statements with different purposes and behaviors.\n\nfor...in:\n• Iterates over enumerable property keys\n• Works with objects and arrays\n• Returns property names (strings)\n• Includes inherited enumerable properties\n• Order not guaranteed\n• Should avoid with arrays\n\nfor...of:\n• Iterates over iterable values\n• Works with arrays, strings, Maps, Sets, NodeLists\n• Returns values, not indices/keys\n• Does not work with plain objects\n• Follows insertion order\n• Modern and preferred for arrays\n\nIterable Protocol:\n• for...of requires Symbol.iterator\n• Arrays, strings, Maps, Sets are iterable\n• Plain objects are not iterable\n• Can make objects iterable\n\nWhen to Use:\n• for...in for object properties\n• for...of for array/iterable values\n• forEach() for array methods\n• Object.keys/values/entries for objects\n\nBest Practices:\n• Use for...of for arrays\n• Use Object.keys/entries for objects\n• Avoid for...in with arrays",
      "explanation": "for...in iterates over enumerable property keys (mainly for objects), while for...of iterates over values of iterables like arrays and strings, with for...of being preferred for arrays.",
      "difficulty": "Medium",
      "code": "// for...in - iterates over keys\nconst obj = { a: 1, b: 2, c: 3 };\n\nfor (const key in obj) {\n  console.log(key, obj[key]);\n}\n// Output: 'a' 1, 'b' 2, 'c' 3\n\n// for...in with arrays (not recommended)\nconst arr = ['x', 'y', 'z'];\n\nfor (const index in arr) {\n  console.log(index, arr[index]); // '0' 'x', '1' 'y', '2' 'z'\n}\n// Problem: index is string, includes inherited properties\n\n// for...of - iterates over values\nfor (const value of arr) {\n  console.log(value); // 'x', 'y', 'z'\n}\n\n// for...of with strings\nconst str = 'Hello';\nfor (const char of str) {\n  console.log(char); // 'H', 'e', 'l', 'l', 'o'\n}\n\n// for...of with Sets\nconst set = new Set([1, 2, 3]);\nfor (const value of set) {\n  console.log(value); // 1, 2, 3\n}\n\n// for...of with Maps\nconst map = new Map([['a', 1], ['b', 2]]);\nfor (const [key, value] of map) {\n  console.log(key, value); // 'a' 1, 'b' 2\n}\n\n// for...of doesn't work with plain objects\nconst person = { name: 'John', age: 30 };\n// for (const value of person) {} // Error: not iterable\n\n// Use Object methods instead\nfor (const key of Object.keys(person)) {\n  console.log(key, person[key]);\n}\n\nfor (const [key, value] of Object.entries(person)) {\n  console.log(key, value);\n}\n\n// Custom iterable\nconst range = {\n  from: 1,\n  to: 5,\n  [Symbol.iterator]() {\n    let current = this.from;\n    const last = this.to;\n    return {\n      next() {\n        if (current <= last) {\n          return { value: current++, done: false };\n        }\n        return { done: true };\n      }\n    };\n  }\n};\n\nfor (const num of range) {\n  console.log(num); // 1, 2, 3, 4, 5\n}"
    },
    {
      "id": 40,
      "question": "What are symbols in JavaScript and what are they used for?",
      "answer": "Symbols are primitive data types introduced in ES6 that create unique, immutable identifiers.\n\nKey Characteristics:\n• Every symbol is unique\n• Immutable primitive value\n• Can have optional description\n• Not enumerable in for...in\n• Not included in Object.keys()\n• Cannot be auto-converted to string\n\nCreating Symbols:\n• Symbol() - creates unique symbol\n• Symbol.for() - global symbol registry\n• Symbol.keyFor() - retrieve key from registry\n• Description parameter for debugging\n\nCommon Use Cases:\n• Private object properties (pre-ES2022)\n• Unique property keys\n• Avoiding property name collisions\n• Well-known symbols (Symbol.iterator, etc.)\n• Meta-programming\n\nWell-Known Symbols:\n• Symbol.iterator - make object iterable\n• Symbol.toStringTag - customize Object.prototype.toString\n• Symbol.hasInstance - customize instanceof\n• Symbol.toPrimitive - customize type conversion\n\nBenefits:\n• Property name uniqueness\n• Hidden from standard iteration\n• Framework internal properties",
      "explanation": "Symbols are unique, immutable primitive identifiers used for creating private-like properties, avoiding name collisions, and implementing well-known symbols like Symbol.iterator for meta-programming.",
      "difficulty": "Medium",
      "code": "// Creating symbols\nconst sym1 = Symbol();\nconst sym2 = Symbol();\nconsole.log(sym1 === sym2); // false - each is unique\n\n// Symbol with description\nconst id = Symbol('id');\nconsole.log(id.toString()); // 'Symbol(id)'\nconsole.log(id.description); // 'id'\n\n// Using symbols as object keys\nconst user = {\n  name: 'John',\n  [id]: 123 // Symbol as property key\n};\n\nconsole.log(user[id]); // 123\nconsole.log(user.id);  // undefined\n\n// Symbols are hidden from enumeration\nfor (const key in user) {\n  console.log(key); // Only 'name', not symbol\n}\n\nconsole.log(Object.keys(user)); // ['name']\nconsole.log(Object.getOwnPropertySymbols(user)); // [Symbol(id)]\n\n// Global symbol registry\nconst globalSym1 = Symbol.for('app.id');\nconst globalSym2 = Symbol.for('app.id');\nconsole.log(globalSym1 === globalSym2); // true - same symbol\n\nconst key = Symbol.keyFor(globalSym1);\nconsole.log(key); // 'app.id'\n\n// Well-known symbol: Symbol.iterator\nconst iterable = {\n  from: 1,\n  to: 3,\n  [Symbol.iterator]() {\n    let current = this.from;\n    return {\n      next: () => {\n        if (current <= this.to) {\n          return { value: current++, done: false };\n        }\n        return { done: true };\n      }\n    };\n  }\n};\n\nfor (const num of iterable) {\n  console.log(num); // 1, 2, 3\n}\n\n// Symbol.toStringTag\nclass MyClass {\n  get [Symbol.toStringTag]() {\n    return 'MyClass';\n  }\n}\n\nconst obj = new MyClass();\nconsole.log(Object.prototype.toString.call(obj)); // '[object MyClass]'\n\n// Private-like properties with symbols\nconst _password = Symbol('password');\n\nclass User {\n  constructor(name, password) {\n    this.name = name;\n    this[_password] = password; // Hidden from normal access\n  }\n  \n  checkPassword(pwd) {\n    return this[_password] === pwd;\n  }\n}\n\nconst john = new User('John', 'secret123');\nconsole.log(john.name); // 'John'\nconsole.log(john.password); // undefined\nconsole.log(john[_password]); // Still accessible if you have the symbol"
    },
    {
      "id": 41,
      "question": "What is the difference between Map and Object?",
      "answer": "Map and Object are both key-value data structures but with important differences.\n\nMap:\n• Keys can be any type (objects, functions, primitives)\n• Maintains insertion order\n• Has size property\n• Directly iterable with for...of\n• Better performance for frequent additions/deletions\n• No default keys\n• Methods: set, get, has, delete, clear\n\nObject:\n• Keys must be strings or symbols\n• No guaranteed order (mostly insertion order in modern engines)\n• No built-in size property\n• Need Object.keys/values/entries to iterate\n• Inherits from Object.prototype\n• Property access with dot or bracket notation\n• JSON serialization support\n\nPerformance:\n• Map faster for frequent add/remove operations\n• Map better for large datasets\n• Object slightly faster for small fixed structures\n\nWhen to Use:\n• Map: dynamic key-value pairs, non-string keys, frequent updates\n• Object: fixed structure, string keys, JSON compatibility\n• WeakMap: object keys with garbage collection",
      "explanation": "Map allows any type as keys with guaranteed insertion order and better performance for frequent changes, while Object requires string/symbol keys and is better for fixed structures and JSON serialization.",
      "difficulty": "Medium",
      "code": "// Object - traditional way\nconst objMap = {\n  name: 'John',\n  age: 30\n};\n\nobjMap.city = 'New York';\nconsole.log(objMap.name); // 'John'\nconsole.log(objMap['age']); // 30\n\n// Map - modern way\nconst map = new Map();\nmap.set('name', 'John');\nmap.set('age', 30);\nmap.set('city', 'New York');\n\nconsole.log(map.get('name')); // 'John'\nconsole.log(map.size); // 3\nconsole.log(map.has('age')); // true\nmap.delete('city');\nmap.clear(); // Remove all\n\n// Map with non-string keys\nconst objKey = { id: 1 };\nconst funcKey = function() {};\n\nconst advancedMap = new Map();\nadvancedMap.set(objKey, 'object value');\nadvancedMap.set(funcKey, 'function value');\nadvancedMap.set(1, 'number value');\n\nconsole.log(advancedMap.get(objKey)); // 'object value'\nconsole.log(advancedMap.get(funcKey)); // 'function value'\n\n// Iterating Map\nconst users = new Map([\n  ['john', { age: 30 }],\n  ['jane', { age: 25 }]\n]);\n\n// for...of directly\nfor (const [key, value] of users) {\n  console.log(key, value);\n}\n\n// forEach\nusers.forEach((value, key) => {\n  console.log(key, value);\n});\n\n// Keys, values, entries\nfor (const key of users.keys()) {\n  console.log(key);\n}\n\nfor (const value of users.values()) {\n  console.log(value);\n}\n\n// Converting between Map and Object\nconst obj = { a: 1, b: 2 };\nconst mapFromObj = new Map(Object.entries(obj));\n\nconst objFromMap = Object.fromEntries(map);\n\n// WeakMap - garbage collectable keys\nconst weakMap = new WeakMap();\nlet keyObj = { id: 1 };\nweakMap.set(keyObj, 'value');\n// When keyObj is no longer referenced, entry is garbage collected"
    },
    {
      "id": 42,
      "question": "What is the difference between Set and Array?",
      "answer": "Set and Array are both collections but with different characteristics and use cases.\n\nSet:\n• Stores unique values only\n• No duplicate elements\n• No index-based access\n• Maintains insertion order\n• Faster for checking existence (has())\n• Methods: add, delete, has, clear\n• Iterable with for...of\n\nArray:\n• Can contain duplicate values\n• Index-based access (arr[0])\n• Maintains insertion order\n• Rich set of methods (map, filter, reduce)\n• Push/pop/shift/unshift operations\n• Can be sorted and reversed\n• JSON serialization support\n\nPerformance:\n• Set.has() faster than array.includes() for large datasets\n• Array better for ordered operations\n• Set better for uniqueness checks\n\nCommon Operations:\n• Union, intersection, difference easier with Set\n• Removing duplicates: new Set(array)\n• Conversion: [...set] or Array.from(set)\n\nWhen to Use:\n• Set: unique values, membership testing\n• Array: ordered list, indexed access, transformations\n• WeakSet: object uniqueness with garbage collection",
      "explanation": "Set stores unique values without duplicates and offers fast existence checks, while Array allows duplicates with index-based access and rich transformation methods, each suited to different use cases.",
      "difficulty": "Medium",
      "code": "// Array - can have duplicates\nconst arr = [1, 2, 2, 3, 3, 4];\nconsole.log(arr); // [1, 2, 2, 3, 3, 4]\nconsole.log(arr[0]); // 1 (index access)\nconsole.log(arr.includes(2)); // true (slower for large arrays)\n\n// Set - only unique values\nconst set = new Set([1, 2, 2, 3, 3, 4]);\nconsole.log(set); // Set { 1, 2, 3, 4 }\nconsole.log(set.size); // 4\nconsole.log(set.has(2)); // true (faster than includes)\n\n// Set operations\nconst numbers = new Set();\nnumbers.add(1);\nnumbers.add(2);\nnumbers.add(2); // Ignored - already exists\nnumbers.add(3);\n\nconsole.log(numbers.size); // 3\nnumbers.delete(2);\nnumbers.clear(); // Remove all\n\n// Remove duplicates from array\nconst duplicates = [1, 1, 2, 2, 3, 3, 4, 4];\nconst unique = [...new Set(duplicates)];\nconsole.log(unique); // [1, 2, 3, 4]\n\n// Set to Array\nconst mySet = new Set([1, 2, 3]);\nconst myArray = Array.from(mySet);\nconst myArray2 = [...mySet];\n\n// Iterating Set\nfor (const value of numbers) {\n  console.log(value);\n}\n\nnumbers.forEach(value => console.log(value));\n\n// Set operations: union, intersection, difference\nconst setA = new Set([1, 2, 3]);\nconst setB = new Set([2, 3, 4]);\n\n// Union\nconst union = new Set([...setA, ...setB]);\nconsole.log(union); // Set { 1, 2, 3, 4 }\n\n// Intersection\nconst intersection = new Set(\n  [...setA].filter(x => setB.has(x))\n);\nconsole.log(intersection); // Set { 2, 3 }\n\n// Difference\nconst difference = new Set(\n  [...setA].filter(x => !setB.has(x))\n);\nconsole.log(difference); // Set { 1 }\n\n// Performance comparison\nconst largeArray = Array.from({ length: 100000 }, (_, i) => i);\nconst largeSet = new Set(largeArray);\n\nconsole.time('Array includes');\nlargeArray.includes(99999);\nconsole.timeEnd('Array includes'); // Slower\n\nconsole.time('Set has');\nlargeSet.has(99999);\nconsole.timeEnd('Set has'); // Faster"
    },
    {
      "id": 43,
      "question": "What is the fetch API and how do you use it?",
      "answer": "The Fetch API provides a modern interface for making HTTP requests in JavaScript.\n\nKey Features:\n• Promise-based (cleaner than XMLHttpRequest)\n• Returns Response object\n• Supports async/await\n• Works with streams\n• Modern and standardized\n• Not supported in older browsers\n\nBasic Usage:\n• fetch(url, options) returns Promise\n• Response object has methods: json(), text(), blob()\n• Need to check response.ok for errors\n• Does not reject on HTTP errors (4xx, 5xx)\n\nRequest Options:\n• method: GET, POST, PUT, DELETE, etc.\n• headers: request headers\n• body: request payload (JSON, FormData, etc.)\n• mode: cors, no-cors, same-origin\n• credentials: include, same-origin, omit\n\nError Handling:\n• Network errors reject promise\n• HTTP errors don't reject (check response.ok)\n• Use try/catch with async/await\n• Check status codes\n\nCommon Patterns:\n• GET requests for data\n• POST requests with JSON body\n• File uploads with FormData\n• Setting authorization headers",
      "explanation": "Fetch API provides promise-based HTTP requests with cleaner syntax than XMLHttpRequest, returning Response objects that require explicit error checking since HTTP errors don't reject the promise.",
      "difficulty": "Medium",
      "code": "// Basic GET request\nfetch('https://api.example.com/users')\n  .then(response => {\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    return response.json();\n  })\n  .then(data => console.log(data))\n  .catch(error => console.error('Error:', error));\n\n// With async/await\nasync function fetchUsers() {\n  try {\n    const response = await fetch('https://api.example.com/users');\n    \n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    console.log(data);\n  } catch (error) {\n    console.error('Error:', error);\n  }\n}\n\n// POST request with JSON\nasync function createUser(userData) {\n  const response = await fetch('https://api.example.com/users', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': 'Bearer token123'\n    },\n    body: JSON.stringify(userData)\n  });\n  \n  return response.json();\n}\n\ncreateUser({ name: 'John', email: 'john@example.com' });\n\n// PUT request\nasync function updateUser(id, updates) {\n  const response = await fetch(`https://api.example.com/users/${id}`, {\n    method: 'PUT',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(updates)\n  });\n  \n  return response.json();\n}\n\n// DELETE request\nasync function deleteUser(id) {\n  const response = await fetch(`https://api.example.com/users/${id}`, {\n    method: 'DELETE'\n  });\n  \n  return response.ok;\n}\n\n// File upload with FormData\nasync function uploadFile(file) {\n  const formData = new FormData();\n  formData.append('file', file);\n  formData.append('description', 'My file');\n  \n  const response = await fetch('https://api.example.com/upload', {\n    method: 'POST',\n    body: formData // Don't set Content-Type, browser will set it\n  });\n  \n  return response.json();\n}\n\n// Timeout implementation\nfunction fetchWithTimeout(url, timeout = 5000) {\n  return Promise.race([\n    fetch(url),\n    new Promise((_, reject) =>\n      setTimeout(() => reject(new Error('Timeout')), timeout)\n    )\n  ]);\n}\n\n// Retry logic\nasync function fetchWithRetry(url, retries = 3) {\n  for (let i = 0; i < retries; i++) {\n    try {\n      const response = await fetch(url);\n      if (response.ok) return response;\n    } catch (error) {\n      if (i === retries - 1) throw error;\n    }\n  }\n}"
    },
    {
      "id": 44,
      "question": "What are default parameters in JavaScript?",
      "answer": "Default parameters allow function parameters to have default values if no value or undefined is passed.\n\nKey Features:\n• Set default values in parameter list\n• Evaluated at call time, not definition time\n• Can use previous parameters in defaults\n• undefined triggers default, null doesn't\n• Cleaner than manual checks\n\nSyntax:\n• parameter = defaultValue\n• Can use expressions\n• Can reference earlier parameters\n• Can call functions\n\nBehavior:\n• Only undefined triggers default\n• null, 0, false, empty string don't trigger\n• Evaluated left to right\n• Can have default for any parameter position\n\nAdvanced Usage:\n• Destructured parameters with defaults\n• Required parameter pattern\n• Function calls as defaults\n• Complex expressions\n\nBenefits:\n• More readable code\n• Fewer manual checks\n• Self-documenting function signatures\n• Reduces boilerplate\n\nBest Practices:\n• Put optional parameters last\n• Use meaningful defaults\n• Document when null is valid",
      "explanation": "Default parameters provide fallback values when arguments are undefined (not null or other falsy values), simplifying function definitions by eliminating manual default value checks.",
      "difficulty": "Easy",
      "code": "// Basic default parameters\nfunction greet(name = 'Guest', greeting = 'Hello') {\n  return `${greeting}, ${name}!`;\n}\n\nconsole.log(greet());              // 'Hello, Guest!'\nconsole.log(greet('John'));        // 'Hello, John!'\nconsole.log(greet('John', 'Hi'));  // 'Hi, John!'\n\n// undefined triggers default, null doesn't\nconsole.log(greet(undefined, undefined)); // 'Hello, Guest!'\nconsole.log(greet(null));                 // 'Hello, null!'\n\n// Using previous parameters\nfunction createUrl(domain, path = '/', protocol = 'https') {\n  return `${protocol}://${domain}${path}`;\n}\n\nconsole.log(createUrl('example.com')); // 'https://example.com/'\n\n// Expression as default\nfunction add(a, b = a * 2) {\n  return a + b;\n}\n\nconsole.log(add(5));    // 15 (5 + 10)\nconsole.log(add(5, 3)); // 8 (5 + 3)\n\n// Function call as default\nfunction getDefaultName() {\n  console.log('Getting default name...');\n  return 'Anonymous';\n}\n\nfunction register(name = getDefaultName()) {\n  console.log(`Registering ${name}`);\n}\n\nregister('John');  // No call to getDefaultName()\nregister();        // Calls getDefaultName()\n\n// Destructuring with defaults\nfunction createUser({ name = 'Anonymous', age = 18, role = 'user' } = {}) {\n  return { name, age, role };\n}\n\nconsole.log(createUser()); // { name: 'Anonymous', age: 18, role: 'user' }\nconsole.log(createUser({ name: 'John' })); // { name: 'John', age: 18, role: 'user' }\n\n// Array destructuring with defaults\nfunction getCoordinates([x = 0, y = 0, z = 0] = []) {\n  return { x, y, z };\n}\n\nconsole.log(getCoordinates([1, 2]));    // { x: 1, y: 2, z: 0 }\nconsole.log(getCoordinates());          // { x: 0, y: 0, z: 0 }\n\n// Required parameter pattern\nfunction required() {\n  throw new Error('Missing required parameter');\n}\n\nfunction multiply(a = required(), b = required()) {\n  return a * b;\n}\n\n// multiply(); // Error: Missing required parameter\nmultiply(2, 3); // 6"
    },
    {
      "id": 45,
      "question": "What is the nullish coalescing operator (??) and optional chaining (?.)?",
      "answer": "These ES2020 operators provide safer ways to handle null/undefined values and property access.\n\nNullish Coalescing (??):\n• Returns right operand if left is null or undefined\n• Unlike ||, doesn't treat 0, false, empty string as falsy\n• Only null and undefined trigger fallback\n• More precise than logical OR\n\nOptional Chaining (?.):\n• Safe navigation through nested properties\n• Returns undefined if property doesn't exist\n• Stops evaluation at first null/undefined\n• Works with properties, methods, and array indices\n• Short-circuits entire chain\n\nSyntax Variants:\n• obj?.prop - property access\n• obj?.[expr] - computed property\n• func?.() - function call\n• arr?.[0] - array element\n\nBenefits:\n• Prevents TypeError on null/undefined\n• Cleaner code, less defensive checks\n• Safer deeply nested access\n• More readable than && chains\n\nCommon Use Cases:\n• API response handling\n• Configuration objects\n• Deeply nested data structures\n• Default values",
      "explanation": "Nullish coalescing (??) provides defaults only for null/undefined (not other falsy values), while optional chaining (?.) safely accesses nested properties without throwing errors on null/undefined.",
      "difficulty": "Medium",
      "code": "// Nullish Coalescing (??) vs Logical OR (||)\nconst value1 = 0;\nconst value2 = '';\nconst value3 = false;\nconst value4 = null;\n\n// Using ||\nconsole.log(value1 || 'default');  // 'default' (0 is falsy)\nconsole.log(value2 || 'default');  // 'default' ('' is falsy)\nconsole.log(value3 || 'default');  // 'default' (false is falsy)\n\n// Using ??\nconsole.log(value1 ?? 'default');  // 0 (not null/undefined)\nconsole.log(value2 ?? 'default');  // '' (not null/undefined)\nconsole.log(value3 ?? 'default');  // false (not null/undefined)\nconsole.log(value4 ?? 'default');  // 'default' (null)\n\n// Practical example\nfunction getConfig(config) {\n  const timeout = config.timeout ?? 3000; // 0 is valid timeout\n  const retries = config.retries ?? 3;\n  const enabled = config.enabled ?? true;\n  \n  return { timeout, retries, enabled };\n}\n\nconsole.log(getConfig({ timeout: 0 })); // { timeout: 0, ... }\n\n// Optional Chaining (?.)\nconst user = {\n  name: 'John',\n  address: {\n    street: '123 Main St',\n    city: 'Boston'\n  }\n};\n\n// Without optional chaining\n// const zip = user.address.zip; // undefined (ok)\n// const zip = user.contact.email; // TypeError!\n\n// With optional chaining\nconsole.log(user?.address?.zip);      // undefined (no error)\nconsole.log(user?.contact?.email);    // undefined (no error)\nconsole.log(user?.unknownProp?.value); // undefined\n\n// Method call\nconst obj = {\n  method() { return 'called'; }\n};\n\nconsole.log(obj.method?.());        // 'called'\nconsole.log(obj.nonExistent?.());   // undefined\n\n// Array access\nconst arr = [1, 2, 3];\nconst emptyArr = null;\n\nconsole.log(arr?.[0]);       // 1\nconsole.log(emptyArr?.[0]);  // undefined\n\n// Combining both operators\nconst userData = {\n  user: {\n    profile: {\n      settings: {\n        theme: null\n      }\n    }\n  }\n};\n\nconst theme = userData?.user?.profile?.settings?.theme ?? 'light';\nconsole.log(theme); // 'light'\n\n// API response handling\nasync function fetchUserData(userId) {\n  const response = await fetch(`/api/users/${userId}`);\n  const data = await response.json();\n  \n  const email = data?.user?.contact?.email ?? 'No email';\n  const phone = data?.user?.contact?.phone ?? 'No phone';\n  \n  return { email, phone };\n}\n\n// Delete with optional chaining\ndelete user?.address?.tempField; // Safe even if address is undefined"
    },
    {
      "id": 46,
      "question": "What is the difference between shallow and deep equality comparison?",
      "answer": "Equality comparison can be shallow (reference/first level) or deep (recursive value comparison).\n\nShallow Equality:\n• Compares primitive values directly\n• Compares object/array references\n• Doesn't check nested properties\n• Fast and efficient\n• Used by ===, Object.is()\n\nDeep Equality:\n• Recursively compares all nested values\n• Compares structure and content\n• Slower than shallow comparison\n• No native JavaScript method\n• Libraries provide implementations\n\nComparison Methods:\n• === - strict equality (shallow)\n• Object.is() - same as === but handles NaN, -0\n• JSON.stringify() - simple deep comparison (limited)\n• Libraries: lodash isEqual, deep-equal\n\nUse Cases:\n• Shallow: primitive comparisons, reference checks\n• Deep: complex object comparison, testing\n• React: shallow comparison in shouldComponentUpdate\n\nImplementation Considerations:\n• Handle circular references\n• Compare arrays and objects differently\n• Handle special types (Date, RegExp, etc.)\n• Performance implications",
      "explanation": "Shallow equality compares references for objects and direct values for primitives, while deep equality recursively compares all nested properties and values, with trade-offs between performance and thoroughness.",
      "difficulty": "Medium",
      "code": "// Shallow equality\nconst obj1 = { a: 1, b: 2 };\nconst obj2 = { a: 1, b: 2 };\nconst obj3 = obj1;\n\nconsole.log(obj1 === obj2); // false (different references)\nconsole.log(obj1 === obj3); // true (same reference)\n\n// Shallow comparison function\nfunction shallowEqual(obj1, obj2) {\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  \n  if (keys1.length !== keys2.length) return false;\n  \n  for (let key of keys1) {\n    if (obj1[key] !== obj2[key]) return false;\n  }\n  \n  return true;\n}\n\nconst a = { x: 1, y: 2 };\nconst b = { x: 1, y: 2 };\nconsole.log(shallowEqual(a, b)); // true\n\n// But fails with nested objects\nconst c = { x: 1, nested: { z: 3 } };\nconst d = { x: 1, nested: { z: 3 } };\nconsole.log(shallowEqual(c, d)); // false (nested objects are different references)\n\n// Deep equality function (basic)\nfunction deepEqual(obj1, obj2) {\n  // Check if same reference\n  if (obj1 === obj2) return true;\n  \n  // Check if both are objects\n  if (typeof obj1 !== 'object' || typeof obj2 !== 'object' || \n      obj1 === null || obj2 === null) {\n    return false;\n  }\n  \n  // Check array types\n  const isArray1 = Array.isArray(obj1);\n  const isArray2 = Array.isArray(obj2);\n  if (isArray1 !== isArray2) return false;\n  \n  // Compare keys\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  \n  if (keys1.length !== keys2.length) return false;\n  \n  // Recursively compare values\n  for (let key of keys1) {\n    if (!keys2.includes(key)) return false;\n    if (!deepEqual(obj1[key], obj2[key])) return false;\n  }\n  \n  return true;\n}\n\nconsole.log(deepEqual(c, d)); // true (deep comparison)\n\n// Arrays\nconst arr1 = [1, 2, [3, 4]];\nconst arr2 = [1, 2, [3, 4]];\nconsole.log(arr1 === arr2);       // false (shallow)\nconsole.log(deepEqual(arr1, arr2)); // true (deep)\n\n// JSON.stringify for simple cases (limitations)\nconst json1 = { a: 1, b: 2 };\nconst json2 = { b: 2, a: 1 };\n\n// May fail due to property order\nconsole.log(JSON.stringify(json1) === JSON.stringify(json2)); // false\n\n// Can't handle:\n// - Functions\n// - undefined values\n// - Circular references\n// - Date objects\n// - RegExp\n\n// Using Object.is() - handles edge cases\nconsole.log(Object.is(NaN, NaN));   // true (=== returns false)\nconsole.log(Object.is(+0, -0));     // false (=== returns true)\nconsole.log(Object.is(0, -0));      // false"
    },
    {
      "id": 47,
      "question": "What are WeakMap and WeakSet?",
      "answer": "WeakMap and WeakSet are collections that hold weak references to objects, allowing garbage collection.\n\nWeakMap:\n• Keys must be objects (not primitives)\n• Weak references to keys\n• Keys can be garbage collected\n• No iteration methods\n• No size property\n• Methods: get, set, has, delete\n\nWeakSet:\n• Values must be objects\n• Weak references to values\n• Values can be garbage collected\n• No iteration methods\n• No size property\n• Methods: add, has, delete\n\nWeak References:\n• Don't prevent garbage collection\n• Objects removed when no other references exist\n• Non-enumerable by design\n• Memory efficient\n\nUse Cases:\n• Private data storage\n• Object metadata\n• Cache with automatic cleanup\n• DOM node associations\n• Preventing memory leaks\n\nLimitations:\n• Cannot iterate\n• Cannot get size\n• Keys/values must be objects\n• Not serializable",
      "explanation": "WeakMap and WeakSet hold weak references to objects allowing garbage collection when no other references exist, useful for metadata and caching without preventing memory cleanup.",
      "difficulty": "Hard",
      "code": "// WeakMap - object keys only\nconst weakMap = new WeakMap();\n\nlet user = { name: 'John' };\nlet metadata = { lastAccess: Date.now() };\n\nweakMap.set(user, metadata);\nconsole.log(weakMap.get(user)); // { lastAccess: ... }\nconsole.log(weakMap.has(user)); // true\n\n// When user is garbage collected, entry is removed\nuser = null; // No more references\n// weakMap entry for original user is automatically removed\n\n// WeakSet - object values only\nconst weakSet = new WeakSet();\n\nlet obj1 = { id: 1 };\nlet obj2 = { id: 2 };\n\nweakSet.add(obj1);\nweakSet.add(obj2);\n\nconsole.log(weakSet.has(obj1)); // true\nweakSet.delete(obj2);\n\n// Practical: Private data\nconst privateData = new WeakMap();\n\nclass User {\n  constructor(name, password) {\n    this.name = name;\n    privateData.set(this, { password });\n  }\n  \n  checkPassword(pwd) {\n    return privateData.get(this).password === pwd;\n  }\n}\n\nconst john = new User('John', 'secret123');\nconsole.log(john.name);           // 'John'\nconsole.log(john.password);       // undefined\nconsole.log(john.checkPassword('secret123')); // true\n\n// Practical: DOM node metadata\nconst nodeMetadata = new WeakMap();\n\nfunction trackElement(element) {\n  nodeMetadata.set(element, {\n    clicks: 0,\n    created: Date.now()\n  });\n  \n  element.addEventListener('click', () => {\n    const data = nodeMetadata.get(element);\n    data.clicks++;\n  });\n}\n\n// When element is removed from DOM and dereferenced,\n// metadata is automatically garbage collected\n\n// Practical: Object tagging without modification\nconst processedObjects = new WeakSet();\n\nfunction processObject(obj) {\n  if (processedObjects.has(obj)) {\n    console.log('Already processed');\n    return;\n  }\n  \n  // Process object\n  console.log('Processing...');\n  processedObjects.add(obj);\n}\n\nconst data = { value: 42 };\nprocessObject(data); // Processing...\nprocessObject(data); // Already processed\n\n// Comparison with regular Map\nconst regularMap = new Map();\nlet key = { id: 1 };\n\nregularMap.set(key, 'value');\n// key cannot be garbage collected while in map\n// Even if we set key = null, original object stays in map\n\n// With WeakMap\nconst weakMapExample = new WeakMap();\nlet weakKey = { id: 1 };\n\nweakMapExample.set(weakKey, 'value');\n// If we set weakKey = null and no other references exist,\n// the entry is automatically removed from WeakMap"
    },
    {
      "id": 48,
      "question": "What is the difference between synchronous and asynchronous iteration?",
      "answer": "Synchronous and asynchronous iteration handle different types of data sources and execution models.\n\nSynchronous Iteration:\n• for...of loop with regular iterables\n• Symbol.iterator protocol\n• Returns values immediately\n• Blocks until iteration completes\n• Works with arrays, strings, Sets, Maps\n\nAsynchronous Iteration:\n• for await...of loop with async iterables\n• Symbol.asyncIterator protocol\n• Returns promises of values\n• Non-blocking iteration\n• Works with async generators, streams\n\nAsync Iterator Protocol:\n• next() returns Promise<{value, done}>\n• Allows awaiting each value\n• Handles async data sources\n• Streams, API pagination, file reading\n\nAsync Generators:\n• async function* syntax\n• yield awaitable values\n• Produces async iterable\n• Cleaner than manual implementation\n\nUse Cases:\n• Sync: in-memory collections\n• Async: API pagination, file streams, database cursors\n• Async: real-time data, web sockets\n\nBenefits:\n• Clean syntax for async sequences\n• Backpressure handling\n• Memory efficient",
      "explanation": "Synchronous iteration processes collections immediately with for...of and Symbol.iterator, while asynchronous iteration handles async data sources with for await...of and Symbol.asyncIterator for streams and paginated APIs.",
      "difficulty": "Hard",
      "code": "// Synchronous iteration\nconst numbers = [1, 2, 3, 4, 5];\n\nfor (const num of numbers) {\n  console.log(num); // Immediate\n}\n\n// Custom sync iterator\nconst range = {\n  from: 1,\n  to: 5,\n  [Symbol.iterator]() {\n    let current = this.from;\n    return {\n      next: () => {\n        if (current <= this.to) {\n          return { value: current++, done: false };\n        }\n        return { done: true };\n      }\n    };\n  }\n};\n\nfor (const num of range) {\n  console.log(num); // 1, 2, 3, 4, 5\n}\n\n// Asynchronous iteration with for await...of\nasync function processAsyncData() {\n  const asyncIterable = {\n    [Symbol.asyncIterator]() {\n      let i = 0;\n      return {\n        async next() {\n          if (i < 3) {\n            // Simulate async operation\n            await new Promise(resolve => setTimeout(resolve, 100));\n            return { value: i++, done: false };\n          }\n          return { done: true };\n        }\n      };\n    }\n  };\n  \n  for await (const value of asyncIterable) {\n    console.log(value); // 0, 1, 2 (with delays)\n  }\n}\n\nprocessAsyncData();\n\n// Async generator function\nasync function* asyncGenerator() {\n  yield await Promise.resolve(1);\n  yield await Promise.resolve(2);\n  yield await Promise.resolve(3);\n}\n\nasync function consumeAsyncGenerator() {\n  for await (const value of asyncGenerator()) {\n    console.log(value); // 1, 2, 3\n  }\n}\n\n// Practical: API pagination\nasync function* fetchPages(url) {\n  let page = 1;\n  let hasMore = true;\n  \n  while (hasMore) {\n    const response = await fetch(`${url}?page=${page}`);\n    const data = await response.json();\n    \n    yield data.items;\n    \n    hasMore = data.hasMore;\n    page++;\n  }\n}\n\nasync function processAllPages() {\n  for await (const items of fetchPages('/api/users')) {\n    console.log('Processing page:', items);\n    // Process each page as it arrives\n  }\n}\n\n// Practical: Reading file stream\nasync function* readFileByLines(filename) {\n  const fileStream = await getFileStream(filename);\n  let buffer = '';\n  \n  for await (const chunk of fileStream) {\n    buffer += chunk;\n    const lines = buffer.split('\\n');\n    buffer = lines.pop(); // Keep incomplete line\n    \n    for (const line of lines) {\n      yield line;\n    }\n  }\n  \n  if (buffer) yield buffer;\n}\n\nasync function processFile() {\n  for await (const line of readFileByLines('data.txt')) {\n    console.log('Line:', line);\n  }\n}\n\n// Error handling\nasync function* errorProneGenerator() {\n  yield 1;\n  yield 2;\n  throw new Error('Something went wrong');\n  yield 3; // Never reached\n}\n\nasync function handleErrors() {\n  try {\n    for await (const value of errorProneGenerator()) {\n      console.log(value);\n    }\n  } catch (error) {\n    console.error('Error:', error.message);\n  }\n}"
    },
    {
      "id": 49,
      "question": "What is function composition and how do you implement it?",
      "answer": "Function composition is combining multiple functions to create a new function where output of one becomes input of next.\n\nCore Concept:\n• Mathematical: (f ∘ g)(x) = f(g(x))\n• Right-to-left execution order\n• Create complex operations from simple functions\n• Functional programming paradigm\n• Pure functions ideal for composition\n\nImplementation Approaches:\n• Manual nesting\n• compose() utility function\n• pipe() utility (left-to-right)\n• reduce() for dynamic composition\n• Libraries: Ramda, Lodash/fp\n\nBenefits:\n• Code reusability\n• Better testability\n• Declarative style\n• Point-free programming\n• Easy to reason about\n\nCompose vs Pipe:\n• compose: right-to-left (mathematical)\n• pipe: left-to-right (readable)\n• Same functionality, different order\n\nUse Cases:\n• Data transformation pipelines\n• Middleware chains\n• Form validation\n• String processing\n• Array transformations",
      "explanation": "Function composition combines multiple functions where each function's output becomes the next function's input, enabling reusable, testable code through compose (right-to-left) or pipe (left-to-right) utilities.",
      "difficulty": "Hard",
      "code": "// Manual composition\nconst add5 = x => x + 5;\nconst multiply3 = x => x * 3;\nconst subtract2 = x => x - 2;\n\n// Nested calls - hard to read\nconst result1 = subtract2(multiply3(add5(10)));\nconsole.log(result1); // (10 + 5) * 3 - 2 = 43\n\n// Compose utility - right to left\nfunction compose(...fns) {\n  return function(value) {\n    return fns.reduceRight((acc, fn) => fn(acc), value);\n  };\n}\n\nconst composed = compose(subtract2, multiply3, add5);\nconsole.log(composed(10)); // 43\n\n// Pipe utility - left to right (more readable)\nfunction pipe(...fns) {\n  return function(value) {\n    return fns.reduce((acc, fn) => fn(acc), value);\n  };\n}\n\nconst piped = pipe(add5, multiply3, subtract2);\nconsole.log(piped(10)); // 43\n\n// Practical example: Data transformation\nconst users = [\n  { name: 'john doe', age: 25, active: true },\n  { name: 'jane smith', age: 30, active: false },\n  { name: 'bob jones', age: 35, active: true }\n];\n\n// Individual functions\nconst filterActive = users => users.filter(u => u.active);\nconst mapNames = users => users.map(u => u.name);\nconst capitalize = name => name.split(' ').map(w => \n  w.charAt(0).toUpperCase() + w.slice(1)\n).join(' ');\nconst capitalizeAll = names => names.map(capitalize);\n\n// Compose the pipeline\nconst getActiveUserNames = pipe(\n  filterActive,\n  mapNames,\n  capitalizeAll\n);\n\nconsole.log(getActiveUserNames(users));\n// ['John Doe', 'Bob Jones']\n\n// String processing pipeline\nconst trim = str => str.trim();\nconst toLowerCase = str => str.toLowerCase();\nconst removeSpaces = str => str.replace(/\\s+/g, '-');\n\nconst slugify = pipe(\n  trim,\n  toLowerCase,\n  removeSpaces\n);\n\nconsole.log(slugify('  Hello World  ')); // 'hello-world'\n\n// Curried functions for composition\nconst map = fn => arr => arr.map(fn);\nconst filter = fn => arr => arr.filter(fn);\nconst reduce = (fn, init) => arr => arr.reduce(fn, init);\n\nconst sumOfSquaresOfEvens = pipe(\n  filter(x => x % 2 === 0),\n  map(x => x * x),\n  reduce((sum, x) => sum + x, 0)\n);\n\nconsole.log(sumOfSquaresOfEvens([1, 2, 3, 4, 5, 6]));\n// 2^2 + 4^2 + 6^2 = 4 + 16 + 36 = 56\n\n// Async composition\nconst asyncPipe = (...fns) => value => \n  fns.reduce(async (acc, fn) => fn(await acc), value);\n\nconst fetchUser = async id => ({ id, name: 'John' });\nconst addTimestamp = async user => ({ ...user, timestamp: Date.now() });\nconst logUser = async user => { console.log(user); return user; };\n\nconst processUser = asyncPipe(\n  fetchUser,\n  addTimestamp,\n  logUser\n);\n\nprocessUser(1);"
    },
    {
      "id": 50,
      "question": "What is tail call optimization and does JavaScript support it?",
      "answer": "Tail call optimization (TCO) is a technique where tail recursive calls don't create new stack frames.\n\nTail Call:\n• Last operation in function is returning another function call\n• No additional work after recursive call\n• Return statement directly returns recursive call\n• No pending operations\n\nTail Call Optimization:\n• Reuses current stack frame\n• Prevents stack overflow\n• Enables deep recursion\n• Performance improvement\n• Memory efficient\n\nJavaScript Support:\n• ES6 specification includes TCO (proper tail calls)\n• Limited implementation in engines\n• Only Safari/WebKit implements it\n• Strict mode required\n• Most engines don't optimize\n\nProper Tail Call (PTC):\n• Return only the call result\n• No expressions around call\n• No closure capturing\n• Strict mode only\n\nAlternatives:\n• Trampolining\n• Iteration instead of recursion\n• Manual stack management\n• Reduce recursion depth",
      "explanation": "Tail call optimization reuses stack frames for tail recursive calls preventing stack overflow, but JavaScript has limited support despite ES6 specification, requiring alternatives like trampolining or iteration.",
      "difficulty": "Hard",
      "code": "// Non-tail recursive (not optimized)\nfunction factorial(n) {\n  if (n <= 1) return 1;\n  return n * factorial(n - 1); // Multiplication after recursive call\n}\n\n// Stack grows: factorial(5) * factorial(4) * factorial(3) * ...\n// Can cause stack overflow with large n\n\n// Tail recursive (can be optimized)\nfunction factorialTail(n, acc = 1) {\n  'use strict'; // Required for TCO\n  if (n <= 1) return acc;\n  return factorialTail(n - 1, n * acc); // Direct return of recursive call\n}\n\n// Stack doesn't grow if optimized\n// factorialTail(5, 1) -> factorialTail(4, 5) -> factorialTail(3, 20) -> ...\n\n// Testing (likely will still overflow in most browsers)\ntry {\n  console.log(factorial(10000)); // Stack overflow\n} catch (e) {\n  console.error('Stack overflow:', e.message);\n}\n\ntry {\n  console.log(factorialTail(10000)); // May still overflow (no TCO)\n} catch (e) {\n  console.error('Stack overflow:', e.message);\n}\n\n// Trampoline - alternative to TCO\nfunction trampoline(fn) {\n  return function(...args) {\n    let result = fn(...args);\n    while (typeof result === 'function') {\n      result = result();\n    }\n    return result;\n  };\n}\n\nfunction factorialTrampoline(n, acc = 1) {\n  if (n <= 1) return acc;\n  return () => factorialTrampoline(n - 1, n * acc);\n}\n\nconst factorial10000 = trampoline(factorialTrampoline);\nconsole.log(factorial10000(100)); // Works without stack overflow\n\n// Sum array - non-tail recursive\nfunction sumArray(arr) {\n  if (arr.length === 0) return 0;\n  return arr[0] + sumArray(arr.slice(1)); // Addition after call\n}\n\n// Sum array - tail recursive\nfunction sumArrayTail(arr, acc = 0) {\n  if (arr.length === 0) return acc;\n  return sumArrayTail(arr.slice(1), acc + arr[0]);\n}\n\n// Iterative alternative (best for most cases)\nfunction sumArrayIterative(arr) {\n  let sum = 0;\n  for (const num of arr) {\n    sum += num;\n  }\n  return sum;\n}\n\n// Proper tail call requirements\nfunction properTailCall(n) {\n  'use strict'; // Required\n  if (n <= 0) return 'done';\n  return properTailCall(n - 1); // Direct return, no wrapping\n}\n\nfunction notProperTailCall(n) {\n  if (n <= 0) return 'done';\n  const result = notProperTailCall(n - 1); // Not direct return\n  return result; // Work after recursive call\n}\n\n// Also not proper tail call\nfunction alsoNotProper(n) {\n  if (n <= 0) return 'done';\n  return notProperTailCall(n - 1) + ''; // Expression around call\n}\n\nconsole.log(properTailCall(1000));\n\n// Best practice: Use iteration\nfunction factorialIterative(n) {\n  let result = 1;\n  for (let i = 2; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorialIterative(100));"
    },
    {
      "id": 51,
      "question": "What are JavaScript decorators and how do they work?",
      "answer": "Decorators are a proposal (Stage 3) for adding annotations and metadata to classes and class members.\n\nKey Concepts:\n• Special syntax using @ symbol\n• Functions that modify classes or class members\n• Applied at design time, not runtime\n• Enable aspect-oriented programming\n• Composition of functionality\n\nTypes of Decorators:\n• Class decorators - modify class constructor\n• Method decorators - wrap or modify methods\n• Property decorators - control property behavior\n• Parameter decorators - annotate parameters\n• Accessor decorators - modify getters/setters\n\nHow They Work:\n• Decorators are functions\n• Receive target, name, descriptor\n• Return modified descriptor or undefined\n• Applied bottom-to-top, right-to-left\n• Can be stacked\n\nCommon Use Cases:\n• Logging and debugging\n• Validation\n• Memoization\n• Access control\n• Deprecation warnings\n• Dependency injection\n\nStatus:\n• Not yet in ECMAScript standard\n• Requires transpiler (Babel, TypeScript)\n• TypeScript has experimental support\n• Syntax may change",
      "explanation": "Decorators are a Stage 3 proposal using @ syntax to annotate and modify classes and members at design time, enabling cross-cutting concerns like logging, validation, and memoization through function composition.",
      "difficulty": "Hard",
      "code": "// Note: Requires Babel or TypeScript with decorator support\n\n// Method decorator example\nfunction log(target, name, descriptor) {\n  const original = descriptor.value;\n  \n  descriptor.value = function(...args) {\n    console.log(`Calling ${name} with`, args);\n    const result = original.apply(this, args);\n    console.log(`${name} returned`, result);\n    return result;\n  };\n  \n  return descriptor;\n}\n\nclass Calculator {\n  @log\n  add(a, b) {\n    return a + b;\n  }\n}\n\n// Usage\nconst calc = new Calculator();\ncalc.add(2, 3);\n// Logs: Calling add with [2, 3]\n// Logs: add returned 5\n\n// Class decorator\nfunction sealed(constructor) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n  return constructor;\n}\n\n@sealed\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\n// Readonly decorator\nfunction readonly(target, name, descriptor) {\n  descriptor.writable = false;\n  return descriptor;\n}\n\nclass User {\n  @readonly\n  getId() {\n    return this.id;\n  }\n}\n\n// Memoization decorator\nfunction memoize(target, name, descriptor) {\n  const original = descriptor.value;\n  const cache = new Map();\n  \n  descriptor.value = function(...args) {\n    const key = JSON.stringify(args);\n    \n    if (cache.has(key)) {\n      console.log('Returning cached result');\n      return cache.get(key);\n    }\n    \n    const result = original.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n  \n  return descriptor;\n}\n\nclass Fibonacci {\n  @memoize\n  calculate(n) {\n    if (n <= 1) return n;\n    return this.calculate(n - 1) + this.calculate(n - 2);\n  }\n}\n\n// Debounce decorator\nfunction debounce(delay) {\n  return function(target, name, descriptor) {\n    const original = descriptor.value;\n    let timeoutId;\n    \n    descriptor.value = function(...args) {\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => {\n        original.apply(this, args);\n      }, delay);\n    };\n    \n    return descriptor;\n  };\n}\n\nclass SearchComponent {\n  @debounce(500)\n  search(query) {\n    console.log('Searching for:', query);\n    // API call\n  }\n}\n\n// Validation decorator\nfunction validate(...validators) {\n  return function(target, name, descriptor) {\n    const original = descriptor.value;\n    \n    descriptor.value = function(...args) {\n      for (const validator of validators) {\n        if (!validator(...args)) {\n          throw new Error(`Validation failed for ${name}`);\n        }\n      }\n      return original.apply(this, args);\n    };\n    \n    return descriptor;\n  };\n}\n\nconst isPositive = (n) => n > 0;\nconst isNumber = (n) => typeof n === 'number';\n\nclass Math {\n  @validate(isNumber, isPositive)\n  sqrt(n) {\n    return Math.sqrt(n);\n  }\n}\n\n// Stacking decorators\nclass Example {\n  @log\n  @memoize\n  @validate(isNumber)\n  compute(n) {\n    return n * 2;\n  }\n}\n// Applied bottom to top: validate -> memoize -> log"
    },
    {
      "id": 52,
      "question": "What is the Proxy object and what can you do with it?",
      "answer": "Proxy is a built-in object that creates a wrapper around another object, intercepting and customizing operations.\n\nKey Features:\n• Intercepts fundamental operations\n• Creates virtual properties\n• Validation and type checking\n• Meta-programming capabilities\n• Observable objects\n• Function call trapping\n\nProxy Traps (Handlers):\n• get - property access\n• set - property assignment\n• has - in operator\n• deleteProperty - delete operator\n• apply - function call\n• construct - new operator\n• getPrototypeOf - prototype retrieval\n• 13 total traps available\n\nCommon Use Cases:\n• Data validation\n• Property access logging\n• Default values\n• Negative array indices\n• Private properties\n• Observable/reactive data\n• API mocking\n\nReflect API:\n• Companion to Proxy\n• Provides default behaviors\n• Forward operations properly\n• Makes code cleaner\n\nLimitations:\n• Performance overhead\n• Cannot proxy primitives\n• Some internal slots not trappable",
      "explanation": "Proxy wraps objects to intercept and customize fundamental operations like property access, assignment, and function calls through trap handlers, enabling meta-programming patterns like validation, observation, and default values.",
      "difficulty": "Hard",
      "code": "// Basic proxy\nconst target = {\n  name: 'John',\n  age: 30\n};\n\nconst handler = {\n  get(target, prop) {\n    console.log(`Getting ${prop}`);\n    return prop in target ? target[prop] : 'Property not found';\n  },\n  \n  set(target, prop, value) {\n    console.log(`Setting ${prop} to ${value}`);\n    target[prop] = value;\n    return true; // Indicates success\n  }\n};\n\nconst proxy = new Proxy(target, handler);\n\nconsole.log(proxy.name);  // Getting name -> 'John'\nproxy.age = 31;           // Setting age to 31\nconsole.log(proxy.city);  // Getting city -> 'Property not found'\n\n// Validation proxy\nfunction createValidatedUser(user) {\n  return new Proxy(user, {\n    set(target, prop, value) {\n      if (prop === 'age') {\n        if (typeof value !== 'number' || value < 0) {\n          throw new TypeError('Age must be a positive number');\n        }\n      }\n      \n      if (prop === 'email') {\n        if (!value.includes('@')) {\n          throw new TypeError('Invalid email');\n        }\n      }\n      \n      target[prop] = value;\n      return true;\n    }\n  });\n}\n\nconst user = createValidatedUser({ name: 'John' });\nuser.age = 30;           // OK\n// user.age = -5;        // TypeError: Age must be positive\n// user.age = 'thirty';  // TypeError: Age must be number\n\n// Negative array indices\nfunction createArray(arr) {\n  return new Proxy(arr, {\n    get(target, prop) {\n      const index = Number(prop);\n      if (index < 0) {\n        prop = target.length + index;\n      }\n      return Reflect.get(target, prop);\n    }\n  });\n}\n\nconst arr = createArray([1, 2, 3, 4, 5]);\nconsole.log(arr[-1]); // 5 (last element)\nconsole.log(arr[-2]); // 4 (second to last)\n\n// Observable object\nfunction createObservable(target, callback) {\n  return new Proxy(target, {\n    set(target, prop, value) {\n      const oldValue = target[prop];\n      target[prop] = value;\n      callback(prop, oldValue, value);\n      return true;\n    }\n  });\n}\n\nconst state = createObservable({ count: 0 }, (prop, oldVal, newVal) => {\n  console.log(`${prop} changed from ${oldVal} to ${newVal}`);\n});\n\nstate.count = 1; // count changed from 0 to 1\nstate.count = 2; // count changed from 1 to 2\n\n// Private properties (using proxy)\nfunction createPrivate(target) {\n  const privateProps = new WeakMap();\n  \n  return new Proxy(target, {\n    get(target, prop) {\n      if (prop.startsWith('_')) {\n        return privateProps.get(target)?.[prop];\n      }\n      return Reflect.get(target, prop);\n    },\n    \n    set(target, prop, value) {\n      if (prop.startsWith('_')) {\n        const privates = privateProps.get(target) || {};\n        privates[prop] = value;\n        privateProps.set(target, privates);\n        return true;\n      }\n      return Reflect.set(target, prop, value);\n    }\n  });\n}\n\nconst obj = createPrivate({});\nobj._secret = 'hidden';\nobj.public = 'visible';\nconsole.log(obj._secret);  // 'hidden'\nconsole.log(obj.public);   // 'visible'\n\n// Function proxy\nfunction createLogger(fn) {\n  return new Proxy(fn, {\n    apply(target, thisArg, args) {\n      console.log(`Calling function with args:`, args);\n      const result = Reflect.apply(target, thisArg, args);\n      console.log(`Function returned:`, result);\n      return result;\n    }\n  });\n}\n\nconst add = createLogger((a, b) => a + b);\nadd(2, 3);\n// Logs: Calling function with args: [2, 3]\n// Logs: Function returned: 5\n\n// Revocable proxy\nconst { proxy: revocableProxy, revoke } = Proxy.revocable(target, handler);\n\nconsole.log(revocableProxy.name); // Works\nrevoke(); // Revoke access\n// console.log(revocableProxy.name); // TypeError: proxy revoked"
    },
    {
      "id": 53,
      "question": "What is the Reflect API and why use it?",
      "answer": "Reflect is a built-in object providing methods for interceptable JavaScript operations.\n\nKey Characteristics:\n• Namespace for reflection methods\n• Not a constructor (cannot use new)\n• Static methods only\n• Mirrors Proxy trap methods\n• Returns boolean for success/failure\n\nMain Methods:\n• Reflect.get() - get property value\n• Reflect.set() - set property value\n• Reflect.has() - check property existence\n• Reflect.deleteProperty() - delete property\n• Reflect.apply() - call function\n• Reflect.construct() - call constructor\n• Reflect.defineProperty() - define property\n• Reflect.getPrototypeOf() - get prototype\n• And more...\n\nWhy Use Reflect:\n• More reliable return values (boolean vs throw)\n• Functional approach to operations\n• Default behavior in Proxy handlers\n• Better error handling\n• Consistent API\n• Method calls instead of operators\n\nReflect vs Traditional:\n• Reflect.has(obj, 'prop') vs 'prop' in obj\n• Reflect.deleteProperty(obj, 'prop') vs delete obj.prop\n• Cleaner and more functional",
      "explanation": "Reflect provides static methods mirroring Proxy traps for performing JavaScript operations programmatically, offering more reliable return values, better error handling, and default behaviors for Proxy handlers.",
      "difficulty": "Hard",
      "code": "// Basic Reflect usage\nconst obj = { name: 'John', age: 30 };\n\n// Get property\nconsole.log(Reflect.get(obj, 'name'));     // 'John'\nconsole.log(obj.name);                      // Same as above\n\n// Set property\nReflect.set(obj, 'city', 'New York');       // Returns true\nobj.city = 'Boston';                        // Same as above\n\n// Has property\nconsole.log(Reflect.has(obj, 'name'));     // true\nconsole.log('name' in obj);                // Same as above\n\n// Delete property\nReflect.deleteProperty(obj, 'age');        // Returns true\ndelete obj.age;                            // Same as above\n\n// Why Reflect is better\nconst frozen = Object.freeze({ x: 1 });\n\n// Traditional way - throws in strict mode\ntry {\n  frozen.x = 2;\n  console.log('Success');\n} catch (e) {\n  console.log('Failed');\n}\n\n// Reflect way - returns false\nconst success = Reflect.set(frozen, 'x', 2);\nif (!success) {\n  console.log('Set failed, handle gracefully');\n}\n\n// Using Reflect with Proxy\nconst target = {\n  message: 'Hello'\n};\n\nconst handler = {\n  get(target, prop, receiver) {\n    console.log(`Getting ${prop}`);\n    // Use Reflect to forward operation\n    return Reflect.get(target, prop, receiver);\n  },\n  \n  set(target, prop, value, receiver) {\n    console.log(`Setting ${prop} to ${value}`);\n    // Use Reflect for default behavior\n    return Reflect.set(target, prop, value, receiver);\n  }\n};\n\nconst proxy = new Proxy(target, handler);\nproxy.message = 'Hi';\nconsole.log(proxy.message);\n\n// Reflect.apply - function invocation\nfunction greet(name, greeting = 'Hello') {\n  return `${greeting}, ${name}!`;\n}\n\nconst result = Reflect.apply(greet, null, ['John', 'Hi']);\nconsole.log(result); // 'Hi, John!'\n\n// Traditional way\nconst result2 = greet.apply(null, ['Jane', 'Hey']);\n\n// Reflect.construct - create instance\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nconst person = Reflect.construct(Person, ['John']);\nconsole.log(person.name); // 'John'\n\n// Same as:\nconst person2 = new Person('Jane');\n\n// Reflect.defineProperty\nReflect.defineProperty(obj, 'id', {\n  value: 123,\n  writable: false,\n  enumerable: true\n});\n\n// Better than Object.defineProperty because:\n// - Returns boolean instead of object\n// - Clearer success/failure\n\n// Reflect.getPrototypeOf\nconst proto = Reflect.getPrototypeOf(person);\nconsole.log(proto === Person.prototype); // true\n\n// Reflect.setPrototypeOf\nconst animal = { speak() { return 'sound'; } };\nReflect.setPrototypeOf(person, animal);\n\n// Practical: Safe property access\nfunction safeGet(obj, path) {\n  const keys = path.split('.');\n  let current = obj;\n  \n  for (const key of keys) {\n    if (!Reflect.has(current, key)) {\n      return undefined;\n    }\n    current = Reflect.get(current, key);\n  }\n  \n  return current;\n}\n\nconst data = {\n  user: {\n    profile: {\n      name: 'John'\n    }\n  }\n};\n\nconsole.log(safeGet(data, 'user.profile.name')); // 'John'\nconsole.log(safeGet(data, 'user.address.city')); // undefined\n\n// Reflect.ownKeys - get all keys\nconst mixed = {\n  [Symbol('id')]: 1,\n  name: 'John',\n  age: 30\n};\n\nconsole.log(Reflect.ownKeys(mixed));\n// ['name', 'age', Symbol(id)]\n// Gets both string and symbol keys"
    },
    {
      "id": 54,
      "question": "What are BigInt and when should you use it?",
      "answer": "BigInt is a primitive type for representing integers larger than Number.MAX_SAFE_INTEGER.\n\nKey Features:\n• Arbitrary precision integers\n• No precision loss for large numbers\n• Created with n suffix or BigInt()\n• Separate type from Number\n• Cannot mix with regular numbers in operations\n\nNumber Limitations:\n• MAX_SAFE_INTEGER = 2^53 - 1 (9007199254740991)\n• Beyond this, precision is lost\n• Floating point representation issues\n• Not suitable for cryptography or precise calculations\n\nBigInt Characteristics:\n• Unlimited size (memory permitting)\n• Always exact integer\n• No fractional part\n• Cannot use with Math methods\n• JSON.stringify doesn't support (needs custom)\n\nOperations:\n• Arithmetic: +, -, *, /, %, **\n• Comparison: <, >, <=, >=, ==, ===\n• Bitwise: &, |, ^, ~, <<, >>\n• Cannot mix BigInt and Number\n\nWhen to Use:\n• Working with large integers\n• Cryptographic operations\n• Precise calculations\n• Financial calculations\n• Timestamps in microseconds\n• Large database IDs",
      "explanation": "BigInt handles arbitrarily large integers beyond Number.MAX_SAFE_INTEGER without precision loss, created with n suffix or BigInt() constructor, essential for cryptography, financial calculations, and large precise integers.",
      "difficulty": "Medium",
      "code": "// Number limitations\nconsole.log(Number.MAX_SAFE_INTEGER);       // 9007199254740991\nconsole.log(Number.MAX_SAFE_INTEGER + 1);   // 9007199254740992\nconsole.log(Number.MAX_SAFE_INTEGER + 2);   // 9007199254740992 (wrong!)\n// Precision loss beyond MAX_SAFE_INTEGER\n\n// Creating BigInt\nconst big1 = 9007199254740991n;             // Literal with n suffix\nconst big2 = BigInt('9007199254740991');    // BigInt constructor\nconst big3 = BigInt(9007199254740991);      // From number\n\nconsole.log(typeof big1);  // 'bigint'\n\n// Arithmetic operations\nconst a = 10n;\nconst b = 20n;\n\nconsole.log(a + b);   // 30n\nconsole.log(a - b);   // -10n\nconsole.log(a * b);   // 200n\nconsole.log(b / a);   // 2n (integer division)\nconsole.log(b % a);   // 0n\nconsole.log(a ** b);  // 100000000000000000000n\n\n// Cannot mix BigInt and Number\n// console.log(10n + 5); // TypeError!\n\n// Need to convert\nconsole.log(10n + BigInt(5));  // 15n\nconsole.log(Number(10n) + 5);  // 15 (loses precision if big)\n\n// Comparisons\nconsole.log(10n < 20);     // true (works!)\nconsole.log(10n == 10);    // true (loose equality)\nconsole.log(10n === 10);   // false (different types)\n\n// Large number calculations\nconst huge1 = 9007199254740991n;\nconst huge2 = 9007199254740992n;\n\nconsole.log(huge1 + 1n);  // 9007199254740992n (exact!)\nconsole.log(huge1 + 2n);  // 9007199254740993n (exact!)\n\n// Factorial of large numbers\nfunction factorial(n) {\n  let result = 1n;\n  for (let i = 2n; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorial(20n));\n// 2432902008176640000n (exact result)\n\n// With regular numbers:\nfunction factorialNumber(n) {\n  let result = 1;\n  for (let i = 2; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorialNumber(20));\n// 2432902008176640000 (may lose precision)\n\n// Bitwise operations\nconst x = 5n;  // 101 in binary\nconst y = 3n;  // 011 in binary\n\nconsole.log(x & y);  // 1n (001)\nconsole.log(x | y);  // 7n (111)\nconsole.log(x ^ y);  // 6n (110)\nconsole.log(~x);     // -6n\nconsole.log(x << 1n); // 10n (1010)\n\n// Converting to/from strings\nconst bigNum = BigInt('12345678901234567890');\nconsole.log(bigNum.toString()); // '12345678901234567890'\n\n// JSON serialization (requires custom handling)\nconst obj = { id: 12345678901234567890n };\n\n// JSON.stringify(obj); // TypeError!\n\n// Custom serialization\nBigInt.prototype.toJSON = function() {\n  return this.toString();\n};\n\nconsole.log(JSON.stringify(obj)); // '{\"id\":\"12345678901234567890\"}'\n\n// Practical: Timestamp in nanoseconds\nconst nanoTimestamp = BigInt(Date.now()) * 1000000n;\nconsole.log(nanoTimestamp);\n\n// Financial calculations\nfunction calculateInterest(principal, rate, time) {\n  // Work in cents to avoid floating point\n  const p = BigInt(Math.round(principal * 100));\n  const r = BigInt(Math.round(rate * 10000));  // rate * 100 * 100\n  const t = BigInt(time);\n  \n  const interest = (p * r * t) / 10000n;\n  return Number(interest) / 100; // Convert back to dollars\n}\n\nconsole.log(calculateInterest(1000, 0.05, 2)); // Precise"
    },
    {
      "id": 55,
      "question": "What are JavaScript modules patterns (CommonJS vs ES6 modules)?",
      "answer": "CommonJS and ES6 modules are two different module systems for organizing JavaScript code.\n\nCommonJS (Node.js):\n• Used in Node.js historically\n• Synchronous loading\n• require() to import\n• module.exports to export\n• Dynamic imports possible\n• Runtime evaluation\n• Single object export\n\nES6 Modules (ESM):\n• Standard JavaScript modules\n• Asynchronous loading\n• import/export keywords\n• Static structure (analyzable)\n• Tree shaking support\n• Compile-time evaluation\n• Named and default exports\n\nKey Differences:\n• CommonJS runs synchronously, ESM asynchronously\n• CommonJS evaluated at runtime, ESM at compile time\n• ESM allows static analysis and tree shaking\n• ESM has named exports, CommonJS exports object\n• ESM is now standard, CommonJS legacy\n\nNode.js Support:\n• .mjs extension for ESM\n• type: module in package.json\n• Modern Node supports both\n• Can import CommonJS from ESM",
      "explanation": "CommonJS uses require/module.exports with synchronous runtime loading (Node.js legacy), while ES6 modules use import/export with static compile-time evaluation enabling tree shaking and are now the JavaScript standard.",
      "difficulty": "Medium",
      "code": "// CommonJS (Node.js) - math.js\nfunction add(a, b) {\n  return a + b;\n}\n\nfunction subtract(a, b) {\n  return a - b;\n}\n\n// Export\nmodule.exports = {\n  add,\n  subtract\n};\n\n// Or export individually\nmodule.exports.multiply = function(a, b) {\n  return a * b;\n};\n\n// Import in app.js\nconst math = require('./math');\nconsole.log(math.add(5, 3));      // 8\n\n// Destructure\nconst { add, subtract } = require('./math');\nconsole.log(add(5, 3));           // 8\n\n// Dynamic require\nconst moduleName = './math';\nconst dynamicMath = require(moduleName); // Works!\n\n// ES6 Modules - math.mjs\nexport function add(a, b) {\n  return a + b;\n}\n\nexport function subtract(a, b) {\n  return a - b;\n}\n\n// Default export\nexport default function multiply(a, b) {\n  return a * b;\n}\n\n// Import in app.mjs\nimport multiply, { add, subtract } from './math.mjs';\nconsole.log(add(5, 3));           // 8\nconsole.log(multiply(4, 2));      // 8\n\n// Import all\nimport * as math from './math.mjs';\nconsole.log(math.add(5, 3));      // 8\n\n// Dynamic import (ESM)\nasync function loadModule() {\n  const math = await import('./math.mjs');\n  console.log(math.add(2, 3));\n}\n\n// Conditional import\nif (condition) {\n  import('./math.mjs').then(math => {\n    console.log(math.add(1, 2));\n  });\n}\n\n// Node.js package.json for ESM\n// {\n//   \"type\": \"module\",\n//   \"main\": \"index.js\"\n// }\n\n// Mixed: Import CommonJS in ESM\n// CommonJS module: utils.js\n// module.exports = { helper: () => 'help' };\n\n// ESM can import it\nimport utils from './utils.js';\nconsole.log(utils.helper());\n\n// But CommonJS cannot use import!\n// const { add } = import('./math.mjs'); // ERROR in CommonJS\n\n// Comparison\n// Feature          | CommonJS | ES6 Modules\n// -----------------|----------|--------------\n// Syntax           | require  | import/export\n// Loading          | Sync     | Async\n// Evaluation       | Runtime  | Compile-time\n// Tree shaking     | No       | Yes\n// Top-level await  | No       | Yes\n// Circular deps    | Better   | Can be tricky\n// Browser support  | No       | Yes (native)\n// Node.js          | Default  | Needs .mjs or config"
    },
    {
      "id": 56,
      "question": "What is strict mode in JavaScript?",
      "answer": "Strict mode is a way to opt into a restricted variant of JavaScript with different semantics.\n\nEnabling Strict Mode:\n• Add 'use strict' at file or function start\n• Entire script or per-function\n• ES6 modules are automatically strict\n• Cannot be undone once enabled\n\nMain Changes:\n• Silent errors become throw errors\n• Prevents accidental globals\n• Disallows duplicate parameter names\n• Makes eval() safer\n• Prohibits octal syntax\n• this is undefined in functions (not global)\n• Cannot delete undeletable properties\n\nProhibited Features:\n• with statement\n• Assignment to undeclared variables\n• Delete variables, functions, arguments\n• Duplicate property names (ES5)\n• Octal literals (0123)\n• Setting properties on primitives\n\nBenefits:\n• Catches common coding errors\n• Prevents unsafe actions\n• Easier optimization by engines\n• Better error messages\n• Prepares for future ECMAScript\n\nBest Practices:\n• Always use strict mode\n• ES6 modules are strict by default\n• Helps catch bugs early",
      "explanation": "Strict mode opts into restricted JavaScript that throws errors for silent failures, prevents accidental globals, disallows unsafe features, and enables better optimization by catching common mistakes early.",
      "difficulty": "Easy",
      "code": "// Enable strict mode for entire script\n'use strict';\n\n// This will throw errors in strict mode\n\n// 1. Prevents accidental globals\nfunction nonStrict() {\n  // Without strict mode\n  name = 'John';  // Creates global variable\n}\n\nfunction strict() {\n  'use strict';\n  // name = 'John';  // ReferenceError: name is not defined\n  let name = 'John'; // Must declare\n}\n\n// 2. Duplicate parameters not allowed\n// function sum(a, a, b) {  // SyntaxError in strict mode\n//   return a + a + b;\n// }\n\nfunction sumStrict(a, b, c) {\n  'use strict';\n  return a + b + c; // OK\n}\n\n// 3. Octal literals not allowed\n'use strict';\n// const octal = 0123;  // SyntaxError\nconst octal = 0o123;   // OK - ES6 octal\nconst decimal = 123;   // OK\n\n// 4. this is undefined in functions\nfunction nonStrictThis() {\n  console.log(this); // window or global\n}\n\nfunction strictThis() {\n  'use strict';\n  console.log(this); // undefined\n}\n\nnonStrictThis();\nstrictThis();\n\n// 5. Cannot delete undeletable properties\n'use strict';\n// delete Object.prototype;  // TypeError\n\nconst obj = { x: 1 };\ndelete obj.x;  // OK\n\n// 6. with statement not allowed\n// with (obj) {  // SyntaxError in strict mode\n//   console.log(x);\n// }\n\n// 7. Setting properties on primitives throws\n'use strict';\nconst num = 5;\n// num.prop = 'value';  // TypeError\n\n// 8. eval doesn't create variables in scope\nfunction testEval() {\n  eval('var x = 10');\n  console.log(x); // 10 (non-strict)\n}\n\nfunction testEvalStrict() {\n  'use strict';\n  eval('var x = 10');\n  // console.log(x); // ReferenceError (strict)\n}\n\n// 9. Arguments object differences\nfunction nonStrictArgs(a) {\n  a = 5;\n  console.log(arguments[0]); // 5 (synced)\n}\n\nfunction strictArgs(a) {\n  'use strict';\n  a = 5;\n  console.log(arguments[0]); // Original value (not synced)\n}\n\nnonStrictArgs(1);  // 5\nstrictArgs(1);     // 1\n\n// 10. Reserved words\n'use strict';\n// const let = 5;      // SyntaxError\n// const static = 10;  // SyntaxError\n// const interface = 'test'; // SyntaxError\n\n// ES6 modules are automatically strict\n// No need for 'use strict' in modules\nexport function moduleFunction() {\n  // Already in strict mode\n  // name = 'test'; // Error\n}\n\n// Class bodies are also strict\nclass MyClass {\n  constructor() {\n    // Already in strict mode\n    // x = 5; // Error\n    this.x = 5; // OK\n  }\n}\n\n// Benefits demonstration\n'use strict';\n\n// Catches typos\nconst user = { name: 'John', age: 30 };\n// user.naem = 'Jane';  // In non-strict, creates new property\n                        // In strict, caught earlier with proper checking\n\n// Safer delete\nconst obj2 = Object.freeze({ x: 1 });\n// delete obj2.x;  // TypeError in strict (silently fails in non-strict)"
    },
    {
      "id": 57,
      "question": "What are the different ways to create objects and their prototypes?",
      "answer": "JavaScript offers multiple approaches to create objects with different prototype relationships.\n\nObject Creation Methods:\n\n1. Object Literal:\n• Simplest method\n• Inherits from Object.prototype\n• Direct property definition\n\n2. Constructor Function:\n• Pre-ES6 pattern\n• Uses 'new' keyword\n• prototype property for methods\n• this binding\n\n3. Object.create():\n• Explicit prototype specification\n• Can create with null prototype\n• Most flexible\n\n4. ES6 Classes:\n• Syntactic sugar over prototypes\n• constructor method\n• Clean inheritance syntax\n\n5. Factory Functions:\n• Return new objects\n• No 'new' keyword needed\n• Private variables via closures\n\nPrototype Setting:\n• Object.setPrototypeOf() - change prototype\n• Object.getPrototypeOf() - get prototype\n• __proto__ - deprecated but widely supported\n• prototype property on functions",
      "explanation": "Objects can be created via literals (Object.prototype), constructor functions with prototype, Object.create() with custom prototype, ES6 classes (syntax sugar), or factory functions, each offering different prototype chain configurations.",
      "difficulty": "Medium",
      "code": "// 1. Object Literal\nconst person1 = {\n  name: 'John',\n  greet() {\n    return `Hello, I'm ${this.name}`;\n  }\n};\n\nconsole.log(person1.greet());\nconsole.log(Object.getPrototypeOf(person1) === Object.prototype); // true\n\n// 2. Constructor Function\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\n// Add methods to prototype\nPerson.prototype.greet = function() {\n  return `Hello, I'm ${this.name}`;\n};\n\nPerson.prototype.getAge = function() {\n  return this.age;\n};\n\nconst person2 = new Person('Jane', 25);\nconst person3 = new Person('Bob', 30);\n\nconsole.log(person2.greet());\nconsole.log(person2.greet === person3.greet); // true (shared method)\n\n// 3. Object.create()\nconst personProto = {\n  greet() {\n    return `Hello, I'm ${this.name}`;\n  }\n};\n\nconst person4 = Object.create(personProto);\nperson4.name = 'Alice';\nperson4.age = 28;\n\nconsole.log(person4.greet());\nconsole.log(Object.getPrototypeOf(person4) === personProto); // true\n\n// Object with null prototype\nconst noProto = Object.create(null);\nnoProto.name = 'Test';\nconsole.log(noProto.toString); // undefined (no Object.prototype)\n\n// 4. ES6 Class\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  speak() {\n    return `${this.name} makes a sound`;\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name, breed) {\n    super(name);\n    this.breed = breed;\n  }\n  \n  speak() {\n    return `${this.name} barks`;\n  }\n}\n\nconst dog = new Dog('Rex', 'Labrador');\nconsole.log(dog.speak());\nconsole.log(dog instanceof Dog);    // true\nconsole.log(dog instanceof Animal); // true\n\n// 5. Factory Function\nfunction createUser(name, email) {\n  // Private variable\n  let password = '';\n  \n  return {\n    name,\n    email,\n    setPassword(pwd) {\n      password = pwd;\n    },\n    checkPassword(pwd) {\n      return password === pwd;\n    }\n  };\n}\n\nconst user = createUser('John', 'john@email.com');\nuser.setPassword('secret123');\nconsole.log(user.checkPassword('secret123')); // true\nconsole.log(user.password); // undefined (private)\n\n// Prototype chain demonstration\nfunction Parent() {\n  this.parentProp = 'parent';\n}\n\nParent.prototype.parentMethod = function() {\n  return 'from parent';\n};\n\nfunction Child() {\n  Parent.call(this); // Call parent constructor\n  this.childProp = 'child';\n}\n\n// Set up inheritance\nChild.prototype = Object.create(Parent.prototype);\nChild.prototype.constructor = Child;\n\nChild.prototype.childMethod = function() {\n  return 'from child';\n};\n\nconst child = new Child();\nconsole.log(child.parentProp);    // 'parent'\nconsole.log(child.childProp);     // 'child'\nconsole.log(child.parentMethod());// 'from parent'\nconsole.log(child.childMethod()); // 'from child'\n\n// Prototype manipulation\nconst obj1 = { x: 1 };\nconst obj2 = Object.create(obj1);\nobj2.y = 2;\n\nconsole.log(obj2.x); // 1 (from prototype)\nconsole.log(obj2.y); // 2 (own property)\n\n// Change prototype (not recommended in production)\nconst newProto = { z: 3 };\nObject.setPrototypeOf(obj2, newProto);\nconsole.log(obj2.z); // 3\nconsole.log(obj2.x); // undefined (old prototype gone)\n\n// Check prototype chain\nconsole.log(Object.getPrototypeOf(obj2) === newProto); // true"
    },
    {
      "id": 58,
      "question": "What is event loop's microtask and macrotask queue?",
      "answer": "The event loop processes two types of task queues with different priorities.\n\nMacrotask Queue (Task Queue):\n• setTimeout callbacks\n• setInterval callbacks\n• setImmediate (Node.js)\n• I/O operations\n• UI rendering\n• requestAnimationFrame\n\nMicrotask Queue (Job Queue):\n• Promise callbacks (then, catch, finally)\n• queueMicrotask()\n• MutationObserver callbacks\n• process.nextTick (Node.js - special case)\n\nExecution Order:\n• Execute all synchronous code\n• Process ALL microtasks in queue\n• Execute ONE macrotask\n• Process ALL new microtasks\n• Render if needed\n• Repeat\n\nKey Rules:\n• Microtasks have higher priority\n• All microtasks run before next macrotask\n• Microtasks can queue more microtasks\n• Can cause microtask queue starvation\n\nWhy It Matters:\n• Understanding async timing\n• Predicting execution order\n• Optimizing performance\n• Avoiding blocking",
      "explanation": "Event loop has two queues: microtasks (Promises, queueMicrotask) processed completely before each macrotask (setTimeout, I/O), with microtasks having higher priority and all executing before the next macrotask runs.",
      "difficulty": "Hard",
      "code": "// Basic execution order\nconsole.log('1: Sync');\n\nsetTimeout(() => {\n  console.log('2: Macrotask (setTimeout)');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('3: Microtask (Promise)');\n});\n\nconsole.log('4: Sync');\n\n// Output:\n// 1: Sync\n// 4: Sync\n// 3: Microtask (Promise)\n// 2: Macrotask (setTimeout)\n\n// Complex example\nconsole.log('Start');\n\nsetTimeout(() => {\n  console.log('Timeout 1');\n  Promise.resolve().then(() => console.log('Promise in Timeout 1'));\n}, 0);\n\nsetTimeout(() => {\n  console.log('Timeout 2');\n}, 0);\n\nPromise.resolve()\n  .then(() => {\n    console.log('Promise 1');\n    return Promise.resolve();\n  })\n  .then(() => {\n    console.log('Promise 2');\n  });\n\nPromise.resolve().then(() => {\n  console.log('Promise 3');\n  setTimeout(() => {\n    console.log('Timeout in Promise');\n  }, 0);\n});\n\nconsole.log('End');\n\n// Output:\n// Start\n// End\n// Promise 1\n// Promise 3\n// Promise 2\n// Timeout 1\n// Promise in Timeout 1\n// Timeout 2\n// Timeout in Promise\n\n// Microtask starvation example\nfunction recursiveMicrotask() {\n  Promise.resolve().then(() => {\n    console.log('Microtask');\n    recursiveMicrotask(); // Queues another microtask\n  });\n}\n\n// This will block macrotasks!\n// recursiveMicrotask();\n// setTimeout(() => console.log('Never runs!'), 0);\n\n// queueMicrotask API\nconsole.log('A');\n\nqueueMicrotask(() => {\n  console.log('Microtask 1');\n});\n\nPromise.resolve().then(() => {\n  console.log('Microtask 2');\n});\n\nsetTimeout(() => {\n  console.log('Macrotask');\n}, 0);\n\nconsole.log('B');\n\n// Output:\n// A\n// B\n// Microtask 1\n// Microtask 2\n// Macrotask\n\n// Practical: Batching updates\nconst updates = [];\n\nfunction scheduleUpdate(update) {\n  updates.push(update);\n  \n  // Use microtask to batch updates\n  queueMicrotask(() => {\n    if (updates.length > 0) {\n      console.log('Applying updates:', updates);\n      updates.length = 0; // Clear\n    }\n  });\n}\n\nscheduleUpdate('update1');\nscheduleUpdate('update2');\nscheduleUpdate('update3');\n// All three updates applied together\n\n// Async/await with event loop\nasync function example() {\n  console.log('1');\n  \n  await Promise.resolve();\n  console.log('2'); // Microtask\n  \n  await Promise.resolve();\n  console.log('3'); // Microtask\n}\n\nconsole.log('Start');\nexample();\nconsole.log('End');\n\n// Output:\n// Start\n// 1\n// End\n// 2\n// 3\n\n// Node.js specific: process.nextTick\n// Even higher priority than microtasks!\nif (typeof process !== 'undefined') {\n  console.log('A');\n  \n  setTimeout(() => console.log('Timeout'), 0);\n  Promise.resolve().then(() => console.log('Promise'));\n  process.nextTick(() => console.log('nextTick'));\n  \n  console.log('B');\n  \n  // Output:\n  // A\n  // B\n  // nextTick\n  // Promise\n  // Timeout\n}"
    },
    {
      "id": 59,
      "question": "What is the difference between slice(), splice(), and split()?",
      "answer": "These three methods have different purposes and work with arrays or strings differently.\n\nslice():\n• Extracts portion of array or string\n• Returns new array/string (immutable)\n• Does not modify original\n• Takes start and end indices\n• Negative indices count from end\n• Works on arrays and strings\n\nsplice():\n• Modifies array in place (mutable)\n• Can remove, add, or replace elements\n• Returns removed elements\n• Takes index, deleteCount, items to add\n• Only works on arrays\n• Changes original array\n\nsplit():\n• Converts string to array\n• Only works on strings\n• Takes separator and limit\n• Returns array of substrings\n• Does not modify original string\n• Immutable operation\n\nKey Differences:\n• slice immutable, splice mutable\n• slice preserves original, splice changes it\n• split is string-only, others are primarily array\n• Different parameters and return values",
      "explanation": "slice() extracts portions immutably from arrays/strings, splice() mutates arrays by adding/removing elements, and split() converts strings to arrays using a separator, each serving distinct purposes.",
      "difficulty": "Easy",
      "code": "// slice() - arrays\nconst arr = [1, 2, 3, 4, 5];\n\nconst sliced1 = arr.slice(1, 3);  // [2, 3] (index 1 to 2)\nconst sliced2 = arr.slice(2);     // [3, 4, 5] (from index 2)\nconst sliced3 = arr.slice(-2);    // [4, 5] (last 2 elements)\nconst sliced4 = arr.slice();      // [1, 2, 3, 4, 5] (shallow copy)\n\nconsole.log(arr); // [1, 2, 3, 4, 5] (unchanged)\n\n// slice() - strings\nconst str = 'Hello World';\n\nconst substr1 = str.slice(0, 5);  // 'Hello'\nconst substr2 = str.slice(6);     // 'World'\nconst substr3 = str.slice(-5);    // 'World'\n\nconsole.log(str); // 'Hello World' (unchanged)\n\n// splice() - arrays only\nconst arr2 = [1, 2, 3, 4, 5];\n\n// Remove elements\nconst removed1 = arr2.splice(1, 2);  // Removes 2 elements at index 1\nconsole.log(removed1); // [2, 3] (removed elements)\nconsole.log(arr2);     // [1, 4, 5] (modified!)\n\n// Add elements\nconst arr3 = [1, 2, 3, 4, 5];\narr3.splice(2, 0, 'a', 'b');  // Add at index 2, remove 0\nconsole.log(arr3); // [1, 2, 'a', 'b', 3, 4, 5]\n\n// Replace elements\nconst arr4 = [1, 2, 3, 4, 5];\narr4.splice(1, 2, 'x', 'y');  // Remove 2, add 2\nconsole.log(arr4); // [1, 'x', 'y', 4, 5]\n\n// Remove from end\nconst arr5 = [1, 2, 3, 4, 5];\narr5.splice(-2);  // Remove last 2\nconsole.log(arr5); // [1, 2, 3]\n\n// split() - strings only\nconst sentence = 'Hello World JavaScript';\n\nconst words1 = sentence.split(' ');  // Split by space\nconsole.log(words1); // ['Hello', 'World', 'JavaScript']\n\nconst chars = sentence.split('');    // Split into characters\nconsole.log(chars);  // ['H', 'e', 'l', 'l', 'o', ' ', ...]\n\nconst limited = sentence.split(' ', 2);  // Limit to 2 parts\nconsole.log(limited); // ['Hello', 'World']\n\nconst csv = 'apple,banana,orange';\nconst fruits = csv.split(',');\nconsole.log(fruits); // ['apple', 'banana', 'orange']\n\n// Edge cases\nconst empty = ''.split('');     // []\nconst noMatch = 'hello'.split('x'); // ['hello']\n\nconsole.log(sentence); // 'Hello World JavaScript' (unchanged)\n\n// Comparison\nconst original = [1, 2, 3, 4, 5];\n\n// slice - returns new array\nconst a = original.slice(1, 3);\nconsole.log(a);        // [2, 3]\nconsole.log(original); // [1, 2, 3, 4, 5] (unchanged)\n\n// splice - modifies original\nconst b = original.splice(1, 2);\nconsole.log(b);        // [2, 3]\nconsole.log(original); // [1, 4, 5] (modified!)\n\n// Practical examples\n\n// Remove duplicates using slice\nfunction removeDuplicates(arr) {\n  return arr.filter((item, index) => \n    arr.slice(0, index).indexOf(item) === -1\n  );\n}\n\n// Insert at position using splice\nfunction insertAt(arr, index, item) {\n  arr.splice(index, 0, item);\n  return arr;\n}\n\n// Parse CSV\nfunction parseCSV(csv) {\n  return csv.split('\\n').map(line => line.split(','));\n}\n\nconst csvData = 'name,age\\nJohn,30\\nJane,25';\nconsole.log(parseCSV(csvData));\n// [['name', 'age'], ['John', '30'], ['Jane', '25']]"
    },
    {
      "id": 60,
      "question": "What are private class fields and methods?",
      "answer": "Private class fields and methods are ES2022 features for true encapsulation in JavaScript classes.\n\nPrivate Fields:\n• Prefixed with # symbol\n• Only accessible within class\n• Cannot be accessed from outside\n• Not inherited by subclasses\n• Truly private (not just convention)\n\nPrivate Methods:\n• Also prefixed with #\n• Internal class methods\n• Cannot be called from outside\n• Can be instance or static\n• Better encapsulation\n\nPrivate Static:\n• Static fields and methods can be private\n• Shared across all instances\n• Class-level privacy\n• Access only through class methods\n\nBenefits:\n• True encapsulation\n• No name collisions\n• Clear public API\n• Cannot be accessed via bracket notation\n• Better security\n\nBefore ES2022:\n• Used _property convention\n• WeakMaps for privacy\n• Closures in constructors\n• Symbols (partially private)\n\nBrowser Support:\n• Modern browsers support\n• Node.js 12+\n• May need transpilation for older environments",
      "explanation": "Private class fields and methods use # prefix for true encapsulation, accessible only within the class, providing genuine privacy unlike underscore convention, introduced in ES2022 for better API design.",
      "difficulty": "Medium",
      "code": "// Private fields and methods (ES2022)\nclass BankAccount {\n  // Private fields\n  #balance = 0;\n  #accountNumber;\n  \n  // Public field\n  owner;\n  \n  constructor(owner, initialBalance, accountNumber) {\n    this.owner = owner;\n    this.#balance = initialBalance;\n    this.#accountNumber = accountNumber;\n  }\n  \n  // Private method\n  #validateAmount(amount) {\n    return amount > 0 && amount <= this.#balance;\n  }\n  \n  // Public methods\n  deposit(amount) {\n    if (amount > 0) {\n      this.#balance += amount;\n      this.#logTransaction('deposit', amount);\n      return true;\n    }\n    return false;\n  }\n  \n  withdraw(amount) {\n    if (this.#validateAmount(amount)) {\n      this.#balance -= amount;\n      this.#logTransaction('withdraw', amount);\n      return true;\n    }\n    return false;\n  }\n  \n  // Private method\n  #logTransaction(type, amount) {\n    console.log(`${type}: $${amount}`);\n  }\n  \n  // Getter for private field\n  getBalance() {\n    return this.#balance;\n  }\n  \n  // Private getter\n  get #maskedAccount() {\n    return '****' + this.#accountNumber.slice(-4);\n  }\n  \n  getAccountInfo() {\n    return `Account: ${this.#maskedAccount}, Balance: $${this.#balance}`;\n  }\n}\n\nconst account = new BankAccount('John', 1000, '1234567890');\n\nconsole.log(account.owner);       // 'John' (public)\nconsole.log(account.getBalance()); // 1000\n// console.log(account.#balance);  // SyntaxError\n// account.#validateAmount(50);    // SyntaxError\n\naccount.deposit(500);\naccount.withdraw(200);\nconsole.log(account.getBalance()); // 1300\n\n// Private static members\nclass Counter {\n  // Private static field\n  static #count = 0;\n  \n  // Private static method\n  static #increment() {\n    this.#count++;\n  }\n  \n  // Public static method\n  static createInstance() {\n    this.#increment();\n    return new Counter();\n  }\n  \n  static getCount() {\n    return this.#count;\n  }\n}\n\nconst c1 = Counter.createInstance();\nconst c2 = Counter.createInstance();\nconsole.log(Counter.getCount()); // 2\n// console.log(Counter.#count);  // SyntaxError\n\n// Inheritance with private fields\nclass Parent {\n  #privateField = 'parent private';\n  \n  getPrivate() {\n    return this.#privateField;\n  }\n}\n\nclass Child extends Parent {\n  // #privateField here would be different from parent's\n  #childPrivate = 'child private';\n  \n  getChildPrivate() {\n    return this.#childPrivate;\n  }\n}\n\nconst child = new Child();\nconsole.log(child.getPrivate());      // 'parent private'\nconsole.log(child.getChildPrivate()); // 'child private'\n\n// Before ES2022: Convention with underscore (not truly private)\nclass OldWay {\n  constructor(value) {\n    this._private = value; // Convention, not enforced\n  }\n  \n  getValue() {\n    return this._private;\n  }\n}\n\nconst old = new OldWay(42);\nconsole.log(old._private); // 42 (accessible!)\nconsole.log(old['_private']); // 42 (still accessible)\n\n// With private fields\nclass NewWay {\n  #private;\n  \n  constructor(value) {\n    this.#private = value; // Truly private\n  }\n  \n  getValue() {\n    return this.#private;\n  }\n}\n\nconst newObj = new NewWay(42);\nconsole.log(newObj.getValue()); // 42\n// console.log(newObj.#private);     // SyntaxError\n// console.log(newObj['#private']);  // undefined\n\n// Practical example: Form validation\nclass FormValidator {\n  #rules = new Map();\n  #errors = [];\n  \n  addRule(field, validator) {\n    this.#rules.set(field, validator);\n  }\n  \n  #validateField(field, value) {\n    const validator = this.#rules.get(field);\n    if (validator && !validator(value)) {\n      this.#errors.push(`${field} is invalid`);\n      return false;\n    }\n    return true;\n  }\n  \n  validate(formData) {\n    this.#errors = [];\n    for (const [field, value] of Object.entries(formData)) {\n      this.#validateField(field, value);\n    }\n    return this.#errors.length === 0;\n  }\n  \n  getErrors() {\n    return [...this.#errors]; // Return copy\n  }\n}\n\nconst validator = new FormValidator();\nvalidator.addRule('email', (v) => v.includes('@'));\nvalidator.addRule('age', (v) => v >= 18);\n\nconst isValid = validator.validate({ email: 'test', age: 15 });\nconsole.log(isValid); // false\nconsole.log(validator.getErrors());\n// ['email is invalid', 'age is invalid']"
    },
    {
      "id": 61,
      "question": "What is the difference between function() and () => {} syntax for methods?",
      "answer": "Regular functions and arrow functions behave differently as object methods, especially regarding 'this' binding.\n\nRegular Function Methods:\n• 'this' bound to calling object\n• Dynamic 'this' based on call site\n• Can use call(), apply(), bind()\n• Have arguments object\n• Can be used as constructors\n\nArrow Function Methods:\n• Lexical 'this' from enclosing scope\n• Cannot rebind 'this'\n• No arguments object\n• Cannot be used as constructors\n• Shorter syntax\n\nWhen to Use:\n• Regular functions for object methods\n• Arrow functions for callbacks\n• Regular functions when needing dynamic 'this'\n• Arrow functions when preserving outer 'this'\n\nCommon Pitfalls:\n• Arrow functions in objects get wrong 'this'\n• Event handlers need regular functions for element reference\n• Prototype methods should use regular functions\n\nBest Practices:\n• Use regular functions for methods\n• Use arrow functions for array operations\n• Use arrow functions in class properties",
      "explanation": "Regular function methods have dynamic 'this' bound to calling object, while arrow function methods use lexical 'this' from surrounding scope, making regular functions better for object methods and arrow functions better for callbacks.",
      "difficulty": "Medium",
      "code": "// Regular function method - correct\nconst obj1 = {\n  name: 'John',\n  greet: function() {\n    console.log(`Hello, ${this.name}`);\n  }\n};\n\nobj1.greet(); // 'Hello, John' (this = obj1)\n\n// Arrow function method - wrong!\nconst obj2 = {\n  name: 'Jane',\n  greet: () => {\n    console.log(`Hello, ${this.name}`);\n  }\n};\n\nobj2.greet(); // 'Hello, undefined' (this = global/window)\n\n// Method shorthand (ES6) - recommended\nconst obj3 = {\n  name: 'Bob',\n  greet() {\n    console.log(`Hello, ${this.name}`);\n  }\n};\n\nobj3.greet(); // 'Hello, Bob'\n\n// Arrow function in method (useful for callbacks)\nconst obj4 = {\n  name: 'Alice',\n  numbers: [1, 2, 3],\n  \n  // Regular method\n  processNumbers: function() {\n    // Arrow function preserves 'this'\n    return this.numbers.map(n => `${this.name}: ${n}`);\n  },\n  \n  // This would fail:\n  processNumbersBad: function() {\n    return this.numbers.map(function(n) {\n      return `${this.name}: ${n}`; // 'this' is undefined!\n    });\n  },\n  \n  // Old solution (before arrow functions):\n  processNumbersOld: function() {\n    const self = this;\n    return this.numbers.map(function(n) {\n      return `${self.name}: ${n}`;\n    });\n  }\n};\n\nconsole.log(obj4.processNumbers());\n// ['Alice: 1', 'Alice: 2', 'Alice: 3']\n\n// Class example\nclass Counter {\n  constructor() {\n    this.count = 0;\n  }\n  \n  // Regular method\n  increment() {\n    this.count++;\n  }\n  \n  // Arrow function as class property (preserves this)\n  incrementArrow = () => {\n    this.count++;\n  }\n  \n  // Event handler issue\n  attachHandlers() {\n    const button = document.getElementById('btn');\n    \n    // Regular function loses 'this'\n    button.addEventListener('click', this.increment);\n    // 'this' will be button element!\n    \n    // Solutions:\n    // 1. Arrow function\n    button.addEventListener('click', () => this.increment());\n    \n    // 2. bind\n    button.addEventListener('click', this.increment.bind(this));\n    \n    // 3. Arrow property\n    button.addEventListener('click', this.incrementArrow);\n  }\n}\n\n// Prototype methods - use regular functions\nfunction Person(name) {\n  this.name = name;\n}\n\n// Good\nPerson.prototype.greet = function() {\n  return `Hello, ${this.name}`;\n};\n\n// Bad - arrow function has wrong 'this'\nPerson.prototype.greetBad = () => {\n  return `Hello, ${this.name}`; // this is not Person instance!\n};\n\nconst person = new Person('John');\nconsole.log(person.greet());    // 'Hello, John'\nconsole.log(person.greetBad()); // 'Hello, undefined'\n\n// Arguments object\nconst obj5 = {\n  regular: function() {\n    console.log(arguments); // Available\n  },\n  arrow: () => {\n    // console.log(arguments); // ReferenceError\n  }\n};\n\nobj5.regular(1, 2, 3); // [1, 2, 3]\n\n// Dynamic 'this' with call/apply\nconst obj6 = {\n  value: 42,\n  regular: function() {\n    return this.value;\n  },\n  arrow: () => {\n    return this.value;\n  }\n};\n\nconst newContext = { value: 99 };\n\nconsole.log(obj6.regular.call(newContext)); // 99 (rebindable)\nconsole.log(obj6.arrow.call(newContext));   // undefined (not rebindable)"
    },
    {
      "id": 62,
      "question": "What is the JavaScript execution context and call stack?",
      "answer": "Execution context and call stack are fundamental to understanding how JavaScript code runs.\n\nExecution Context:\n• Environment where code is evaluated and executed\n• Contains variable environment, this binding, scope chain\n• Three types: Global, Function, Eval\n• Created in two phases: Creation and Execution\n\nTypes of Context:\n• Global - default, one per program\n• Function - created when function called\n• Eval - code inside eval() (avoid using)\n\nCreation Phase:\n• Creates variable object\n• Establishes scope chain\n• Determines 'this' value\n• Hoisting occurs\n\nExecution Phase:\n• Assigns values to variables\n• Executes code line by line\n• Function calls create new contexts\n\nCall Stack:\n• LIFO (Last In, First Out) structure\n• Tracks execution contexts\n• Pushes context when function called\n• Pops context when function returns\n• Stack overflow when too deep\n\nWhy It Matters:\n• Understanding scope and closures\n• Debugging stack traces\n• Avoiding stack overflow\n• Optimizing recursion",
      "explanation": "Execution context is the environment for code execution with variables, 'this', and scope, stacked in a call stack (LIFO) that tracks function calls, pushing on invocation and popping on return.",
      "difficulty": "Hard",
      "code": "// Example demonstrating execution context and call stack\n\nfunction first() {\n  console.log('First function');\n  second();\n  console.log('First function end');\n}\n\nfunction second() {\n  console.log('Second function');\n  third();\n  console.log('Second function end');\n}\n\nfunction third() {\n  console.log('Third function');\n}\n\nconsole.log('Global context start');\nfirst();\nconsole.log('Global context end');\n\n// Call Stack visualization:\n// 1. Global context\n// 2. Push first() - [Global, first]\n// 3. Push second() - [Global, first, second]\n// 4. Push third() - [Global, first, second, third]\n// 5. Pop third() - [Global, first, second]\n// 6. Pop second() - [Global, first]\n// 7. Pop first() - [Global]\n\n// Output:\n// Global context start\n// First function\n// Second function\n// Third function\n// Second function end\n// First function end\n// Global context end\n\n// Execution Context creation phases\nfunction example() {\n  console.log(x); // undefined (hoisted)\n  var x = 5;\n  console.log(x); // 5\n  \n  // Creation phase:\n  // - Variable 'x' created and set to undefined\n  // - Function declarations hoisted\n  // Execution phase:\n  // - x assigned value 5\n}\n\n// Scope chain example\nconst globalVar = 'global';\n\nfunction outer() {\n  const outerVar = 'outer';\n  \n  function inner() {\n    const innerVar = 'inner';\n    \n    // Has access to all three scopes\n    console.log(innerVar);  // 'inner' (local)\n    console.log(outerVar);  // 'outer' (outer function)\n    console.log(globalVar); // 'global' (global)\n  }\n  \n  inner();\n}\n\nouter();\n\n// Stack overflow example\nfunction recursiveFunction() {\n  recursiveFunction(); // No base case!\n}\n\n// recursiveFunction(); // RangeError: Maximum call stack size exceeded\n\n// Proper recursion with base case\nfunction countdown(n) {\n  if (n <= 0) {\n    console.log('Done!');\n    return;\n  }\n  console.log(n);\n  countdown(n - 1);\n}\n\ncountdown(5);\n\n// Call stack trace example\nfunction a() {\n  b();\n}\n\nfunction b() {\n  c();\n}\n\nfunction c() {\n  console.trace('Stack trace'); // Shows call stack\n}\n\na();\n// Stack trace will show:\n// c @ ...\n// b @ ...\n// a @ ...\n// (anonymous) @ ...\n\n// this binding in different contexts\nconst obj = {\n  value: 42,\n  method: function() {\n    console.log(this.value); // 42\n    \n    function inner() {\n      console.log(this.value); // undefined (new context)\n    }\n    inner();\n    \n    const arrow = () => {\n      console.log(this.value); // 42 (lexical this)\n    };\n    arrow();\n  }\n};\n\nobj.method();\n\n// Simulating call stack\nclass CallStack {\n  constructor() {\n    this.stack = [];\n  }\n  \n  push(context) {\n    this.stack.push(context);\n    console.log(`Pushed: ${context}`);\n    this.display();\n  }\n  \n  pop() {\n    const context = this.stack.pop();\n    console.log(`Popped: ${context}`);\n    this.display();\n    return context;\n  }\n  \n  display() {\n    console.log('Stack:', this.stack.join(' > '));\n  }\n}\n\nconst stack = new CallStack();\n\nfunction simulate() {\n  stack.push('global');\n  \n  function funcA() {\n    stack.push('funcA');\n    funcB();\n    stack.pop();\n  }\n  \n  function funcB() {\n    stack.push('funcB');\n    funcC();\n    stack.pop();\n  }\n  \n  function funcC() {\n    stack.push('funcC');\n    // Do work\n    stack.pop();\n  }\n  \n  funcA();\n  stack.pop();\n}\n\n// simulate();\n\n// Memory and context\nfunction createClosures() {\n  const closures = [];\n  \n  for (var i = 0; i < 3; i++) {\n    closures.push(function() {\n      console.log(i); // All reference same 'i'\n    });\n  }\n  \n  return closures;\n}\n\nconst badClosures = createClosures();\nbadClosures[0](); // 3\nbadClosures[1](); // 3\nbadClosures[2](); // 3\n\n// Fixed with let (block scope)\nfunction createClosuresFixed() {\n  const closures = [];\n  \n  for (let i = 0; i < 3; i++) {\n    closures.push(function() {\n      console.log(i); // Each has own 'i'\n    });\n  }\n  \n  return closures;\n}\n\nconst goodClosures = createClosuresFixed();\ngoodClosures[0](); // 0\ngoodClosures[1](); // 1\ngoodClosures[2](); // 2"
    },
    {
      "id": 63,
      "question": "What is coercion in JavaScript and what are its types?",
      "answer": "Type coercion is automatic or implicit conversion of values from one data type to another.\n\nTypes of Coercion:\n\n1. Implicit Coercion:\n• Automatic conversion by JavaScript\n• Happens in operations with mixed types\n• Can be unpredictable\n• Silent conversions\n\n2. Explicit Coercion:\n• Manual conversion by programmer\n• Using Number(), String(), Boolean()\n• Clear and intentional\n• Preferred approach\n\nString Coercion:\n• + operator with string\n• String() function\n• toString() method\n• Template literals\n\nNumber Coercion:\n• Arithmetic operators (-, *, /, %)\n• Unary + operator\n• Number() function\n• parseInt(), parseFloat()\n\nBoolean Coercion:\n• if statements, logical operators\n• Boolean() function\n• Double negation (!!)\n• Falsy values: false, 0, '', null, undefined, NaN\n\nCommon Pitfalls:\n• '5' + 3 = '53' (string concat)\n• '5' - 3 = 2 (number subtraction)\n• [] + [] = '' (empty string)\n• {} + [] = 0 (confusing!)",
      "explanation": "Coercion converts values between types either implicitly (automatic by JavaScript) or explicitly (manual with Number(), String(), Boolean()), with implicit coercion often causing unexpected results in mixed-type operations.",
      "difficulty": "Medium",
      "code": "// String coercion\nconsole.log('5' + 3);        // '53' (number to string)\nconsole.log('5' + true);     // '5true'\nconsole.log('5' + null);     // '5null'\nconsole.log('5' + undefined);// '5undefined'\n\n// Explicit string coercion\nconsole.log(String(123));    // '123'\nconsole.log(String(true));   // 'true'\nconsole.log(String(null));   // 'null'\nconsole.log((123).toString());// '123'\n\n// Number coercion\nconsole.log('5' - 3);        // 2 (string to number)\nconsole.log('5' * 2);        // 10\nconsole.log('5' / 2);        // 2.5\nconsole.log('10' % 3);       // 1\n\n// Unary + operator\nconsole.log(+'5');           // 5\nconsole.log(+'5.5');         // 5.5\nconsole.log(+'abc');         // NaN\nconsole.log(+true);          // 1\nconsole.log(+false);         // 0\nconsole.log(+null);          // 0\nconsole.log(+undefined);     // NaN\n\n// Explicit number coercion\nconsole.log(Number('123'));  // 123\nconsole.log(Number(''));     // 0\nconsole.log(Number(' '));    // 0\nconsole.log(Number('abc'));  // NaN\nconsole.log(Number(true));   // 1\nconsole.log(Number(false));  // 0\n\n// parseInt and parseFloat\nconsole.log(parseInt('123px'));    // 123\nconsole.log(parseInt('12.5'));     // 12\nconsole.log(parseFloat('12.5'));   // 12.5\nconsole.log(parseFloat('12.5px')); // 12.5\n\n// Boolean coercion\nif ('hello') console.log('truthy'); // Executes\nif (0) console.log('won\\'t execute');\nif ('') console.log('won\\'t execute');\n\n// Explicit boolean coercion\nconsole.log(Boolean(1));       // true\nconsole.log(Boolean(0));       // false\nconsole.log(Boolean('hi'));    // true\nconsole.log(Boolean(''));      // false\nconsole.log(Boolean(null));    // false\nconsole.log(Boolean(undefined));// false\nconsole.log(Boolean(NaN));     // false\n\n// Double negation\nconsole.log(!!'hello');  // true\nconsole.log(!!0);        // false\nconsole.log(!!'');       // false\nconsole.log(!!null);     // false\n\n// Tricky coercions\nconsole.log([] + []);      // '' (empty string)\nconsole.log([] + {});      // '[object Object]'\nconsole.log({} + []);      // '[object Object]' or 0 (depends on context)\nconsole.log([1, 2] + [3, 4]); // '1,23,4'\n\n// Equality coercion\nconsole.log(5 == '5');     // true (coercion)\nconsole.log(5 === '5');    // false (no coercion)\nconsole.log(null == undefined); // true\nconsole.log(null === undefined); // false\n\n// Object to primitive\nconst obj = {\n  valueOf() {\n    return 42;\n  },\n  toString() {\n    return 'object';\n  }\n};\n\nconsole.log(obj + 1);      // 43 (valueOf used)\nconsole.log(`${obj}`);     // 'object' (toString used)\n\n// Array coercion\nconst arr = [1, 2, 3];\nconsole.log(arr + 1);      // '1,2,31' (toString then concat)\nconsole.log(String(arr));  // '1,2,3'\nconsole.log(Number(arr));  // NaN\nconsole.log(Number([5]));  // 5 (single element)\nconsole.log(Number([]));   // 0 (empty array)\n\n// Common mistakes\nconsole.log('5' + 2 + 1);  // '521' (left to right)\nconsole.log(5 + 2 + '1');  // '71' (5+2=7, then '7'+'1')\n\n// Comparing with coercion\nconsole.log(0 == false);   // true\nconsole.log('' == false);  // true\nconsole.log([] == false);  // true\nconsole.log('' == 0);      // true\n\n// Avoid coercion with ===\nconsole.log(0 === false);  // false\nconsole.log('' === false); // false\n\n// Safe practices\nfunction add(a, b) {\n  // Explicit coercion\n  return Number(a) + Number(b);\n}\n\nconsole.log(add('5', '3')); // 8\nconsole.log(add(5, 3));     // 8\n\n// Type checking before coercion\nfunction safeAdd(a, b) {\n  if (typeof a !== 'number' || typeof b !== 'number') {\n    throw new TypeError('Arguments must be numbers');\n  }\n  return a + b;\n}"
    },
    {
      "id": 64,
      "question": "What are JavaScript's built-in error types?",
      "answer": "JavaScript has several built-in error types for different error scenarios.\n\nError Types:\n\n1. Error:\n• Base error class\n• Generic errors\n• Can be extended for custom errors\n\n2. SyntaxError:\n• Invalid JavaScript syntax\n• Parsing errors\n• Cannot be caught in same scope\n\n3. ReferenceError:\n• Reference to undefined variable\n• Variable not in scope\n• Accessing before declaration\n\n4. TypeError:\n• Value not of expected type\n• Calling non-function\n• Accessing properties of null/undefined\n\n5. RangeError:\n• Value not in allowed range\n• Stack overflow\n• Invalid array length\n\n6. URIError:\n• Invalid URI encoding/decoding\n• encodeURI(), decodeURI() errors\n\n7. EvalError:\n• Errors in eval() (deprecated)\n• Rarely used\n\nError Properties:\n• name - error type\n• message - error description\n• stack - stack trace\n\nCreating Custom Errors:\n• Extend Error class\n• Add custom properties\n• Better error handling",
      "explanation": "JavaScript has seven built-in error types (Error, SyntaxError, ReferenceError, TypeError, RangeError, URIError, EvalError) each representing specific error scenarios, with Error being the base class extensible for custom errors.",
      "difficulty": "Medium",
      "code": "// 1. Error - base class\ntry {\n  throw new Error('Something went wrong');\n} catch (e) {\n  console.log(e.name);    // 'Error'\n  console.log(e.message); // 'Something went wrong'\n  console.log(e.stack);   // Stack trace\n}\n\n// 2. SyntaxError - parsing errors\ntry {\n  eval('const x = ;'); // Invalid syntax\n} catch (e) {\n  console.log(e instanceof SyntaxError); // true\n  console.log(e.message);\n}\n\n// Cannot catch SyntaxError in same scope\n// const y = ; // This would stop execution immediately\n\n// 3. ReferenceError - undefined variables\ntry {\n  console.log(undefinedVariable);\n} catch (e) {\n  console.log(e instanceof ReferenceError); // true\n  console.log(e.message); // 'undefinedVariable is not defined'\n}\n\n// Temporal Dead Zone\ntry {\n  console.log(x);\n  let x = 5;\n} catch (e) {\n  console.log(e instanceof ReferenceError); // true\n}\n\n// 4. TypeError - type mismatches\ntry {\n  const num = 5;\n  num.toUpperCase(); // Number doesn't have toUpperCase\n} catch (e) {\n  console.log(e instanceof TypeError); // true\n}\n\ntry {\n  null.property; // Cannot access property of null\n} catch (e) {\n  console.log(e instanceof TypeError); // true\n}\n\ntry {\n  const obj = {};\n  obj.method(); // method is not a function\n} catch (e) {\n  console.log(e instanceof TypeError); // true\n}\n\n// 5. RangeError - out of range values\ntry {\n  const arr = new Array(-1); // Invalid length\n} catch (e) {\n  console.log(e instanceof RangeError); // true\n}\n\ntry {\n  function recursiveOverflow() {\n    recursiveOverflow();\n  }\n  recursiveOverflow(); // Stack overflow\n} catch (e) {\n  console.log(e instanceof RangeError); // true\n  console.log(e.message); // Maximum call stack size exceeded\n}\n\ntry {\n  (123.456).toFixed(500); // Precision out of range\n} catch (e) {\n  console.log(e instanceof RangeError); // true\n}\n\n// 6. URIError - URI encoding/decoding\ntry {\n  decodeURIComponent('%'); // Invalid URI\n} catch (e) {\n  console.log(e instanceof URIError); // true\n}\n\n// 7. EvalError - eval errors (rarely thrown in modern JS)\n// Mostly deprecated, included for completeness\n\n// Custom Error classes\nclass ValidationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\n\nclass DatabaseError extends Error {\n  constructor(message, code) {\n    super(message);\n    this.name = 'DatabaseError';\n    this.code = code;\n  }\n}\n\n// Using custom errors\nfunction validateUser(user) {\n  if (!user.name) {\n    throw new ValidationError('Name is required');\n  }\n  if (!user.email) {\n    throw new ValidationError('Email is required');\n  }\n}\n\ntry {\n  validateUser({ name: 'John' });\n} catch (e) {\n  if (e instanceof ValidationError) {\n    console.log('Validation failed:', e.message);\n  } else {\n    console.log('Unknown error:', e);\n  }\n}\n\n// Error factory\nclass AppError extends Error {\n  constructor(message, statusCode) {\n    super(message);\n    this.statusCode = statusCode;\n    this.isOperational = true;\n    \n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nclass NotFoundError extends AppError {\n  constructor(message = 'Resource not found') {\n    super(message, 404);\n    this.name = 'NotFoundError';\n  }\n}\n\nclass UnauthorizedError extends AppError {\n  constructor(message = 'Unauthorized access') {\n    super(message, 401);\n    this.name = 'UnauthorizedError';\n  }\n}\n\n// Using in application\ntry {\n  throw new NotFoundError('User not found');\n} catch (e) {\n  console.log(e.name);       // 'NotFoundError'\n  console.log(e.message);    // 'User not found'\n  console.log(e.statusCode); // 404\n}\n\n// Error handling helper\nfunction handleError(error) {\n  if (error instanceof ValidationError) {\n    return { status: 400, message: error.message };\n  } else if (error instanceof NotFoundError) {\n    return { status: 404, message: error.message };\n  } else if (error instanceof UnauthorizedError) {\n    return { status: 401, message: error.message };\n  } else {\n    return { status: 500, message: 'Internal server error' };\n  }\n}\n\n// Async error handling\nasync function fetchData() {\n  try {\n    const response = await fetch('/api/data');\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    return await response.json();\n  } catch (e) {\n    if (e instanceof TypeError) {\n      console.log('Network error');\n    } else {\n      console.log('Other error:', e.message);\n    }\n    throw e;\n  }\n}"
    },
    {
      "id": 65,
      "question": "What is the difference between throw and return in error handling?",
      "answer": "throw and return are fundamentally different in how they handle error conditions and control flow.\n\nthrow Statement:\n• Throws an exception\n• Stops normal execution\n• Jumps to nearest catch block\n• Unwinds call stack\n• Used for exceptional conditions\n• Can throw any value (Error objects recommended)\n\nreturn Statement:\n• Returns value normally\n• Continues normal flow\n• Caller must check return value\n• No automatic error propagation\n• Used for normal operation results\n• Can return error objects or codes\n\nWhen to throw:\n• Exceptional, unexpected errors\n• Cannot handle error locally\n• Want automatic error propagation\n• Breaking contract/preconditions\n\nWhen to return:\n• Expected alternative outcomes\n• Error can be handled locally\n• Functional error handling style\n• Performance-critical code\n\nError Propagation:\n• throw propagates automatically\n• return requires manual checking\n• throw can cross multiple function boundaries\n• return stops at immediate caller\n\nBest Practices:\n• Use throw for unexpected errors\n• Use return for expected alternatives\n• Don't throw for control flow\n• Consistent error handling strategy",
      "explanation": "throw creates an exception that automatically propagates up the call stack to the nearest catch block, while return provides normal value that requires manual checking, with throw for exceptional errors and return for expected outcomes.",
      "difficulty": "Medium",
      "code": "// Using throw - automatic propagation\nfunction divideThrow(a, b) {\n  if (b === 0) {\n    throw new Error('Division by zero');\n  }\n  return a / b;\n}\n\ntry {\n  const result = divideThrow(10, 0);\n  console.log(result); // Never executes\n} catch (e) {\n  console.log('Error:', e.message); // 'Division by zero'\n}\n\n// Using return - manual checking\nfunction divideReturn(a, b) {\n  if (b === 0) {\n    return { success: false, error: 'Division by zero' };\n  }\n  return { success: true, value: a / b };\n}\n\nconst result = divideReturn(10, 0);\nif (!result.success) {\n  console.log('Error:', result.error); // Manual check required\n} else {\n  console.log('Result:', result.value);\n}\n\n// Throw propagates automatically\nfunction level3() {\n  throw new Error('Error at level 3');\n}\n\nfunction level2() {\n  level3(); // Error propagates through\n}\n\nfunction level1() {\n  try {\n    level2();\n  } catch (e) {\n    console.log('Caught at level 1:', e.message);\n  }\n}\n\nlevel1(); // 'Caught at level 1: Error at level 3'\n\n// Return requires checking at each level\nfunction level3Return() {\n  return { error: 'Error at level 3' };\n}\n\nfunction level2Return() {\n  const result = level3Return();\n  if (result.error) {\n    return result; // Must manually propagate\n  }\n  return { success: true };\n}\n\nfunction level1Return() {\n  const result = level2Return();\n  if (result.error) {\n    console.log('Error:', result.error);\n  }\n}\n\nlevel1Return();\n\n// throw stops execution\nfunction processWithThrow(data) {\n  if (!data) {\n    throw new Error('No data');\n  }\n  console.log('Processing data'); // Skipped if throw\n  return 'done';\n}\n\ntry {\n  processWithThrow(null);\n  console.log('Continuing'); // Never executes\n} catch (e) {\n  console.log('Error:', e.message);\n}\n\n// return allows continued execution\nfunction processWithReturn(data) {\n  if (!data) {\n    return { error: 'No data' };\n  }\n  console.log('Processing data');\n  return { success: true, result: 'done' };\n}\n\nconst res = processWithReturn(null);\nconsole.log('Continuing'); // Executes\nif (res.error) {\n  console.log('Error:', res.error);\n}\n\n// Practical: Validation\nfunction validateUserThrow(user) {\n  if (!user.name) throw new Error('Name required');\n  if (!user.email) throw new Error('Email required');\n  if (!user.email.includes('@')) throw new Error('Invalid email');\n  return true;\n}\n\ntry {\n  validateUserThrow({ name: 'John' });\n  console.log('User valid');\n} catch (e) {\n  console.log('Validation failed:', e.message);\n}\n\n// Alternative: Return errors\nfunction validateUserReturn(user) {\n  const errors = [];\n  if (!user.name) errors.push('Name required');\n  if (!user.email) errors.push('Email required');\n  else if (!user.email.includes('@')) errors.push('Invalid email');\n  \n  return errors.length > 0 ? { valid: false, errors } : { valid: true };\n}\n\nconst validation = validateUserReturn({ name: 'John' });\nif (!validation.valid) {\n  console.log('Validation errors:', validation.errors);\n}\n\n// Result type pattern (functional approach)\nclass Result {\n  constructor(success, value, error) {\n    this.success = success;\n    this.value = value;\n    this.error = error;\n  }\n  \n  static ok(value) {\n    return new Result(true, value, null);\n  }\n  \n  static err(error) {\n    return new Result(false, null, error);\n  }\n  \n  map(fn) {\n    return this.success ? Result.ok(fn(this.value)) : this;\n  }\n  \n  orElse(defaultValue) {\n    return this.success ? this.value : defaultValue;\n  }\n}\n\nfunction divideResult(a, b) {\n  if (b === 0) {\n    return Result.err('Division by zero');\n  }\n  return Result.ok(a / b);\n}\n\nconst r1 = divideResult(10, 2);\nif (r1.success) {\n  console.log('Result:', r1.value); // 5\n}\n\nconst r2 = divideResult(10, 0);\nconsole.log('Result:', r2.orElse(0)); // 0\n\n// When to use each\n// throw for: unexpected errors, programmer errors, violations\n// return for: expected alternatives, recoverable errors, multiple outcomes"
    },
    {
      "id": 66,
      "question": "What is lazy evaluation and how can you implement it in JavaScript?",
      "answer": "Lazy evaluation delays computation until the value is actually needed, improving performance and enabling infinite sequences.\n\nKey Concepts:\n• Deferred computation\n• Compute on demand\n• Avoid unnecessary calculations\n• Memory efficient\n• Enable infinite data structures\n\nImplementation Techniques:\n• Generator functions\n• Closures with cached values\n• Proxy objects\n• Thunks (functions returning values)\n• Iterator protocol\n\nBenefits:\n• Performance optimization\n• Work with infinite sequences\n• Reduced memory usage\n• Short-circuit evaluation\n• Composability\n\nUse Cases:\n• Large datasets\n• Infinite sequences\n• Expensive computations\n• Streams and pipelines\n• Conditional execution\n\nJavaScript Support:\n• Generators for lazy iteration\n• && and || for short-circuit\n• Conditional operators\n• Array methods can be chained lazily\n\nLimitations:\n• More complex code\n• Debugging challenges\n• State management\n• Not always needed",
      "explanation": "Lazy evaluation postpones computation until values are needed, implemented via generators, closures, or thunks, enabling efficient handling of large datasets and infinite sequences by avoiding unnecessary calculations.",
      "difficulty": "Hard",
      "code": "// Eager evaluation (immediate)\nfunction eagerRange(start, end) {\n  const result = [];\n  for (let i = start; i <= end; i++) {\n    result.push(i);\n  }\n  return result; // All values computed immediately\n}\n\nconst eager = eagerRange(1, 1000000); // Memory intensive\n\n// Lazy evaluation with generator\nfunction* lazyRange(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i; // Computed on demand\n  }\n}\n\nconst lazy = lazyRange(1, 1000000); // No computation yet\nconsole.log(lazy.next().value); // 1 (computed now)\nconsole.log(lazy.next().value); // 2\n\n// Infinite sequence (only possible with lazy evaluation)\nfunction* infiniteNumbers() {\n  let n = 0;\n  while (true) {\n    yield n++;\n  }\n}\n\nconst infinite = infiniteNumbers();\nconsole.log(infinite.next().value); // 0\nconsole.log(infinite.next().value); // 1\n// Can continue indefinitely\n\n// Lazy evaluation with closures\nfunction lazyValue(fn) {\n  let cached;\n  let computed = false;\n  \n  return function() {\n    if (!computed) {\n      cached = fn();\n      computed = true;\n    }\n    return cached;\n  };\n}\n\nconst expensiveCalc = lazyValue(() => {\n  console.log('Computing...');\n  return 42 * 42;\n});\n\nconsole.log('Before access');\nconst result1 = expensiveCalc(); // 'Computing...' then 1764\nconst result2 = expensiveCalc(); // 1764 (cached, no computation)\n\n// Lazy array operations\nclass LazyArray {\n  constructor(iterable) {\n    this.iterable = iterable;\n  }\n  \n  *[Symbol.iterator]() {\n    yield* this.iterable;\n  }\n  \n  map(fn) {\n    const iterable = this.iterable;\n    return new LazyArray(function*() {\n      for (const item of iterable) {\n        yield fn(item);\n      }\n    }());\n  }\n  \n  filter(fn) {\n    const iterable = this.iterable;\n    return new LazyArray(function*() {\n      for (const item of iterable) {\n        if (fn(item)) {\n          yield item;\n        }\n      }\n    }());\n  }\n  \n  take(n) {\n    const iterable = this.iterable;\n    return new LazyArray(function*() {\n      let count = 0;\n      for (const item of iterable) {\n        if (count >= n) break;\n        yield item;\n        count++;\n      }\n    }());\n  }\n  \n  toArray() {\n    return [...this.iterable];\n  }\n}\n\n// Usage: only processes first 5 items\nconst lazyResult = new LazyArray([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  .map(x => {\n    console.log('Mapping', x);\n    return x * 2;\n  })\n  .filter(x => {\n    console.log('Filtering', x);\n    return x > 5;\n  })\n  .take(3)\n  .toArray();\n\nconsole.log(lazyResult); // [6, 8, 10]\n\n// Compare with eager (processes all)\nconst eagerResult = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  .map(x => {\n    console.log('Eager mapping', x);\n    return x * 2;\n  })\n  .filter(x => {\n    console.log('Eager filtering', x);\n    return x > 5;\n  })\n  .slice(0, 3);\n\n// Short-circuit evaluation (built-in lazy)\nconst result = false && expensiveFunction(); // expensiveFunction never called\nconst value = null || getDefaultValue(); // getDefaultValue called only if null\n\n// Lazy property with Proxy\nfunction lazyObject(obj) {\n  const computed = {};\n  \n  return new Proxy(obj, {\n    get(target, prop) {\n      if (prop in computed) {\n        return computed[prop];\n      }\n      \n      if (typeof target[prop] === 'function') {\n        console.log(`Computing ${prop}...`);\n        computed[prop] = target[prop]();\n        return computed[prop];\n      }\n      \n      return target[prop];\n    }\n  });\n}\n\nconst user = lazyObject({\n  name: 'John',\n  age: 30,\n  fullName() {\n    console.log('Generating full name...');\n    return `${this.name} Doe`;\n  },\n  email() {\n    console.log('Generating email...');\n    return `${this.name.toLowerCase()}@example.com`;\n  }\n});\n\nconsole.log(user.name);     // 'John' (direct access)\nconsole.log(user.fullName); // 'Generating full name...' then 'John Doe'\nconsole.log(user.fullName); // 'John Doe' (cached)\n\n// Thunk pattern\nfunction thunk(fn) {\n  return () => fn();\n}\n\nconst lazyComputation = thunk(() => {\n  console.log('Doing work...');\n  return 100 + 200;\n});\n\nconsole.log('Created thunk');\nconst value2 = lazyComputation(); // Work happens here\n\n// Practical: Fibonacci with memoization\nfunction* fibonacci() {\n  let [a, b] = [0, 1];\n  while (true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}\n\nconst fib = fibonacci();\nconst first10 = [];\nfor (let i = 0; i < 10; i++) {\n  first10.push(fib.next().value);\n}\nconsole.log(first10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]"
    },
    {
      "id": 67,
      "question": "What is tree shaking and how does it work in JavaScript?",
      "answer": "Tree shaking is dead code elimination during bundling, removing unused code to reduce bundle size.\n\nHow It Works:\n• Static analysis of ES6 modules\n• Identifies unused exports\n• Removes dead code during build\n• Works with import/export statements\n• Requires static module structure\n\nRequirements:\n• ES6 modules (import/export)\n• Static imports (not dynamic)\n• Module bundler (Webpack, Rollup)\n• Production mode build\n• Side-effect free code\n\nWhy ES6 Modules:\n• Statically analyzable\n• Imports/exports known at build time\n• No runtime evaluation\n• CommonJS is dynamic (harder to shake)\n\nSide Effects:\n• Code that affects global state\n• Module-level mutations\n• Prevents tree shaking\n• Mark side-effect-free in package.json\n\nOptimization Tips:\n• Use named exports\n• Avoid default exports for libraries\n• Import only what you need\n• Mark packages as side-effect-free\n• Use ESLint to detect unused imports\n\nBenefits:\n• Smaller bundle sizes\n• Faster load times\n• Better performance\n• Remove unnecessary dependencies",
      "explanation": "Tree shaking removes unused code during bundling by statically analyzing ES6 module imports/exports, requiring static structure and side-effect-free code to eliminate dead code and reduce bundle size.",
      "difficulty": "Hard",
      "code": "// utils.js - Library with multiple exports\nexport function add(a, b) {\n  return a + b;\n}\n\nexport function subtract(a, b) {\n  return a - b;\n}\n\nexport function multiply(a, b) {\n  return a * b;\n}\n\nexport function divide(a, b) {\n  return a / b;\n}\n\n// app.js - Only imports what's needed\nimport { add, multiply } from './utils.js';\n\nconsole.log(add(5, 3));\nconsole.log(multiply(4, 2));\n\n// After tree shaking:\n// subtract and divide are removed from final bundle\n\n// Won't tree shake - default export\n// utils-bad.js\nexport default {\n  add: (a, b) => a + b,\n  subtract: (a, b) => a - b,\n  multiply: (a, b) => a * b,\n  divide: (a, b) => a / b\n};\n\n// app-bad.js\nimport utils from './utils-bad.js';\nconsole.log(utils.add(5, 3));\n// Entire object included in bundle (no tree shaking!)\n\n// Good: Named imports\nimport { add } from './utils.js'; // Only 'add' bundled\n\n// Bad: Import everything\nimport * as utils from './utils.js'; // All functions bundled\n\n// Side effects prevent tree shaking\n// config.js\nexport const API_URL = 'https://api.example.com';\n\n// This has side effect (modifies global)\nconsole.log('Module loaded');\nwindow.config = { apiUrl: API_URL };\n\n// Even if API_URL isn't used, whole module included\n\n// Mark as side-effect free in package.json\n// {\n//   \"name\": \"my-library\",\n//   \"sideEffects\": false\n// }\n\n// Or specify which files have side effects\n// {\n//   \"sideEffects\": [\"*.css\", \"*.scss\", \"polyfills.js\"]\n// }\n\n// Pure functions (tree-shakeable)\nexport function pure(x) {\n  return x * 2; // No side effects\n}\n\n// Impure (may prevent tree shaking)\nlet cache = {};\nexport function impure(x) {\n  cache[x] = x * 2; // Side effect\n  return cache[x];\n}\n\n// Lodash example\n// Bad: Imports entire library\nimport _ from 'lodash';\nconst result = _.map([1, 2, 3], x => x * 2);\n\n// Good: Import specific functions\nimport map from 'lodash/map';\n// Or with lodash-es\nimport { map } from 'lodash-es';\n\n// Webpack configuration for tree shaking\n// webpack.config.js\nmodule.exports = {\n  mode: 'production', // Enables tree shaking\n  optimization: {\n    usedExports: true, // Mark used exports\n    sideEffects: true  // Remove side-effect-free modules\n  }\n};\n\n// Example: Icon library\n// icons.js\nexport const HomeIcon = '🏠';\nexport const UserIcon = '👤';\nexport const SettingsIcon = '⚙️';\nexport const SearchIcon = '🔍';\nexport const NotificationIcon = '🔔';\n\n// app.js\nimport { HomeIcon, UserIcon } from './icons.js';\n\n// Only HomeIcon and UserIcon in final bundle\n// Other icons tree-shaken away\n\n// Class methods tree shaking\nclass MathUtils {\n  static add(a, b) {\n    return a + b;\n  }\n  \n  static subtract(a, b) {\n    return a - b;\n  }\n  \n  static multiply(a, b) {\n    return a * b;\n  }\n}\n\nexport { MathUtils };\n\n// Usage\nimport { MathUtils } from './math.js';\nMathUtils.add(5, 3);\n// Problem: Entire class included even if only using 'add'\n\n// Better: Separate functions\nexport const add = (a, b) => a + b;\nexport const subtract = (a, b) => a - b;\nexport const multiply = (a, b) => a * b;\n\n// Now only 'add' bundled\nimport { add } from './math.js';\n\n// Checking if tree shaking works\n// 1. Build for production\n// 2. Check bundle size\n// 3. Search bundle for unused code\n// 4. Use webpack-bundle-analyzer\n\n// Common pitfalls\n// 1. Using CommonJS (require/module.exports)\nconst utils = require('./utils'); // Can't tree shake\n\n// 2. Babel transpiling ES6 to CommonJS\n// Configure Babel to preserve modules:\n// {\n//   \"presets\": [\n//     [\"@babel/preset-env\", { \"modules\": false }]\n//   ]\n// }\n\n// 3. Dynamic imports\nimport('./utils.js').then(utils => {\n  // Dynamic, harder to tree shake\n});\n\n// 4. Re-exporting everything\nexport * from './utils.js'; // Includes everything\n\n// Better: selective re-export\nexport { add, multiply } from './utils.js';"
    },
    {
      "id": 68,
      "question": "What are JavaScript memory leaks and how to prevent them?",
      "answer": "Memory leaks occur when JavaScript retains references to objects that are no longer needed, preventing garbage collection.\n\nCommon Causes:\n\n1. Global Variables:\n• Accidental globals\n• Variables not cleaned up\n• Persistent references\n\n2. Forgotten Timers:\n• setInterval not cleared\n• setTimeout references\n• Animation frames\n\n3. Event Listeners:\n• Not removed when element destroyed\n• Multiple listeners added\n• Closure capturing large objects\n\n4. Closures:\n• Retaining unnecessary references\n• Large object captures\n• Long-lived closures\n\n5. DOM References:\n• Detached DOM nodes\n• Cached element references\n• Circular references\n\n6. Caches:\n• Unbounded caches\n• No eviction policy\n• WeakMap not used\n\nPrevention:\n• Remove event listeners\n• Clear timers\n• Use WeakMap/WeakSet\n• Set references to null\n• Proper cleanup in lifecycle\n• Monitor memory usage\n\nDetection:\n• Browser DevTools memory profiler\n• Heap snapshots\n• Memory timeline\n• Performance monitoring",
      "explanation": "Memory leaks occur when unused objects remain referenced preventing garbage collection, commonly caused by forgotten timers, event listeners, closures, and DOM references, preventable through proper cleanup and using WeakMap/WeakSet.",
      "difficulty": "Hard",
      "code": "// 1. Global variable leak\nfunction createLeak() {\n  // Accidental global (forgot 'let'/'const')\n  leakedVar = 'I am global!'; // Persists forever\n}\n\n// Fixed\nfunction noLeak() {\n  const properVar = 'I will be collected';\n}\n\n// 2. Forgotten timer leak\nclass LeakyComponent {\n  constructor() {\n    this.data = new Array(1000000).fill('data');\n    \n    // Leaks: timer keeps running even if component destroyed\n    setInterval(() => {\n      console.log(this.data.length);\n    }, 1000);\n  }\n}\n\n// Fixed\nclass ProperComponent {\n  constructor() {\n    this.data = new Array(1000000).fill('data');\n    \n    this.timerId = setInterval(() => {\n      console.log(this.data.length);\n    }, 1000);\n  }\n  \n  destroy() {\n    clearInterval(this.timerId); // Cleanup!\n  }\n}\n\n// 3. Event listener leak\nclass LeakyElement {\n  constructor(elementId) {\n    this.element = document.getElementById(elementId);\n    this.data = new Array(1000000).fill('data');\n    \n    // Leaks: listener not removed\n    this.element.addEventListener('click', () => {\n      console.log(this.data);\n    });\n  }\n}\n\n// Fixed\nclass ProperElement {\n  constructor(elementId) {\n    this.element = document.getElementById(elementId);\n    this.data = new Array(1000000).fill('data');\n    \n    this.handleClick = () => {\n      console.log(this.data);\n    };\n    \n    this.element.addEventListener('click', this.handleClick);\n  }\n  \n  destroy() {\n    this.element.removeEventListener('click', this.handleClick);\n    this.element = null; // Clear reference\n  }\n}\n\n// 4. Closure leak\nfunction createClosure() {\n  const largeData = new Array(1000000).fill('data');\n  \n  return function() {\n    // Closure captures largeData even if not used\n    console.log('Hello');\n    // largeData kept in memory!\n  };\n}\n\n// Fixed: Only capture what's needed\nfunction createProperClosure() {\n  const largeData = new Array(1000000).fill('data');\n  const needed = largeData[0]; // Extract only what's needed\n  \n  return function() {\n    console.log(needed); // Only small value captured\n  };\n}\n\n// 5. DOM reference leak\nconst elements = [];\n\nfunction addElement() {\n  const div = document.createElement('div');\n  document.body.appendChild(div);\n  elements.push(div); // Reference kept\n}\n\nfunction removeElement() {\n  const div = elements.pop();\n  div.remove(); // Removed from DOM but still in array!\n  // Memory leak!\n}\n\n// Fixed\nfunction removeElementProperly() {\n  const div = elements.pop();\n  div.remove();\n  // Element can be garbage collected\n}\n\n// Or use WeakMap\nconst elementData = new WeakMap();\n\nfunction addElementWeak() {\n  const div = document.createElement('div');\n  document.body.appendChild(div);\n  elementData.set(div, { info: 'data' });\n  // When div is removed, WeakMap entry auto-removed\n}\n\n// 6. Unbounded cache leak\nclass LeakyCache {\n  constructor() {\n    this.cache = {};\n  }\n  \n  set(key, value) {\n    this.cache[key] = value; // Grows forever!\n  }\n  \n  get(key) {\n    return this.cache[key];\n  }\n}\n\n// Fixed: LRU cache\nclass ProperCache {\n  constructor(maxSize = 100) {\n    this.cache = new Map();\n    this.maxSize = maxSize;\n  }\n  \n  set(key, value) {\n    if (this.cache.size >= this.maxSize) {\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey); // Evict oldest\n    }\n    this.cache.set(key, value);\n  }\n  \n  get(key) {\n    return this.cache.get(key);\n  }\n}\n\n// Or use WeakMap for object keys\nconst objectCache = new WeakMap();\n\nfunction cacheResult(obj, result) {\n  objectCache.set(obj, result);\n  // When obj is garbage collected, cache entry removed automatically\n}\n\n// 7. Circular reference (old issue, mostly fixed in modern JS)\nfunction createCircular() {\n  const obj1 = {};\n  const obj2 = {};\n  \n  obj1.ref = obj2;\n  obj2.ref = obj1; // Circular\n  \n  // Modern GC handles this, but good to avoid\n}\n\n// 8. Detached DOM nodes\nconst button = document.getElementById('myButton');\nconst parent = document.getElementById('container');\n\nparent.removeChild(button);\n// button still referenced in variable\n// Set to null to allow GC\nbutton = null;\n\n// Practical: React component cleanup\nclass DataComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { data: null };\n  }\n  \n  componentDidMount() {\n    // Set up subscriptions\n    this.timerId = setInterval(this.fetchData, 1000);\n    this.subscription = dataSource.subscribe(this.handleData);\n    \n    window.addEventListener('resize', this.handleResize);\n  }\n  \n  componentWillUnmount() {\n    // Clean up to prevent leaks\n    clearInterval(this.timerId);\n    this.subscription.unsubscribe();\n    window.removeEventListener('resize', this.handleResize);\n  }\n  \n  fetchData = () => {\n    // Fetch data\n  }\n  \n  handleData = (data) => {\n    this.setState({ data });\n  }\n  \n  handleResize = () => {\n    // Handle resize\n  }\n  \n  render() {\n    return <div>{this.state.data}</div>;\n  }\n}\n\n// Memory leak detection\nif (typeof performance !== 'undefined') {\n  const memory = performance.memory;\n  console.log(`Used: ${memory.usedJSHeapSize}`);\n  console.log(`Total: ${memory.totalJSHeapSize}`);\n  console.log(`Limit: ${memory.jsHeapSizeLimit}`);\n}"
    },
    {
      "id": 69,
      "question": "What is the difference between Object.freeze(), Object.seal(), and Object.preventExtensions()?",
      "answer": "These methods restrict object modifications at different levels of strictness.\n\nObject.preventExtensions():\n• Cannot add new properties\n• Can delete existing properties\n• Can modify existing properties\n• Least restrictive\n• Use Object.isExtensible() to check\n\nObject.seal():\n• Cannot add new properties\n• Cannot delete existing properties\n• Can modify existing properties\n• Makes all properties non-configurable\n• Use Object.isSealed() to check\n\nObject.freeze():\n• Cannot add new properties\n• Cannot delete existing properties\n• Cannot modify existing properties\n• Most restrictive (immutable)\n• Shallow freeze only\n• Use Object.isFrozen() to check\n\nComparison:\n• preventExtensions < seal < freeze (increasing strictness)\n• All are shallow (nested objects not affected)\n• Violations silent in non-strict, throw in strict mode\n\nDeep Freeze:\n• Manual recursion needed\n• Freeze nested objects\n• Libraries available\n\nUse Cases:\n• freeze: configuration, constants\n• seal: fixed structure objects\n• preventExtensions: semi-mutable objects",
      "explanation": "Object.preventExtensions() prevents adding properties, Object.seal() additionally prevents deletion, and Object.freeze() makes object completely immutable (no add, delete, or modify), with increasing strictness levels and all being shallow.",
      "difficulty": "Medium",
      "code": "// Object.preventExtensions() - can modify and delete\nconst obj1 = { x: 1, y: 2 };\nObject.preventExtensions(obj1);\n\nobj1.x = 10;      // OK - can modify\nconsole.log(obj1.x); // 10\n\ndelete obj1.y;    // OK - can delete\nconsole.log(obj1); // { x: 10 }\n\nobj1.z = 3;       // Silently fails (throws in strict mode)\nconsole.log(obj1.z); // undefined\n\nconsole.log(Object.isExtensible(obj1)); // false\n\n// Object.seal() - can modify, cannot delete\nconst obj2 = { x: 1, y: 2 };\nObject.seal(obj2);\n\nobj2.x = 10;      // OK - can modify\nconsole.log(obj2.x); // 10\n\ndelete obj2.y;    // Silently fails (throws in strict mode)\nconsole.log(obj2); // { x: 10, y: 2 }\n\nobj2.z = 3;       // Silently fails\nconsole.log(obj2.z); // undefined\n\nconsole.log(Object.isSealed(obj2)); // true\nconsole.log(Object.isExtensible(obj2)); // false (seal implies non-extensible)\n\n// Object.freeze() - cannot modify, delete, or add\nconst obj3 = { x: 1, y: 2 };\nObject.freeze(obj3);\n\nobj3.x = 10;      // Silently fails (throws in strict mode)\nconsole.log(obj3.x); // 1 (unchanged)\n\ndelete obj3.y;    // Silently fails\nconsole.log(obj3); // { x: 1, y: 2 }\n\nobj3.z = 3;       // Silently fails\nconsole.log(obj3.z); // undefined\n\nconsole.log(Object.isFrozen(obj3)); // true\nconsole.log(Object.isSealed(obj3)); // true\nconsole.log(Object.isExtensible(obj3)); // false\n\n// Strict mode behavior\n'use strict';\n\nconst strict = Object.freeze({ x: 1 });\n// strict.x = 2; // TypeError: Cannot assign to read only property\n// delete strict.x; // TypeError: Cannot delete property\n// strict.y = 3; // TypeError: Cannot add property\n\n// Shallow nature - nested objects not frozen\nconst nested = {\n  x: 1,\n  inner: { y: 2 }\n};\n\nObject.freeze(nested);\n\nnested.x = 10;         // Fails\nnested.inner.y = 20;   // Works! Inner object not frozen\nconsole.log(nested.inner.y); // 20\n\n// Deep freeze implementation\nfunction deepFreeze(obj) {\n  // Freeze object\n  Object.freeze(obj);\n  \n  // Recursively freeze nested objects\n  Object.getOwnPropertyNames(obj).forEach(prop => {\n    if (obj[prop] !== null &&\n        (typeof obj[prop] === 'object' || typeof obj[prop] === 'function') &&\n        !Object.isFrozen(obj[prop])) {\n      deepFreeze(obj[prop]);\n    }\n  });\n  \n  return obj;\n}\n\nconst deepNested = {\n  x: 1,\n  inner: { y: 2, deeper: { z: 3 } }\n};\n\ndeepFreeze(deepNested);\n\ndeepNested.inner.deeper.z = 30; // Fails now\nconsole.log(deepNested.inner.deeper.z); // 3 (unchanged)\n\n// Practical examples\n\n// Configuration object\nconst config = Object.freeze({\n  API_URL: 'https://api.example.com',\n  TIMEOUT: 5000,\n  MAX_RETRIES: 3\n});\n\n// config.API_URL = 'hacked'; // Fails\n\n// Enum-like object\nconst Status = Object.freeze({\n  PENDING: 'pending',\n  APPROVED: 'approved',\n  REJECTED: 'rejected'\n});\n\n// Status.PENDING = 'modified'; // Fails\n\n// Sealed object with fixed structure\nconst user = Object.seal({\n  name: 'John',\n  age: 30,\n  email: 'john@example.com'\n});\n\nuser.name = 'Jane';  // OK - can modify\nuser.phone = '123';  // Fails - cannot add\ndelete user.email;   // Fails - cannot delete\n\n// Comparison table\nconst comparison = {\n  'Add properties': {\n    'preventExtensions': '❌',\n    'seal': '❌',\n    'freeze': '❌'\n  },\n  'Delete properties': {\n    'preventExtensions': '✅',\n    'seal': '❌',\n    'freeze': '❌'\n  },\n  'Modify properties': {\n    'preventExtensions': '✅',\n    'seal': '✅',\n    'freeze': '❌'\n  }\n};\n\n// Checking methods\nconst testObj = { x: 1 };\n\nconsole.log(Object.isExtensible(testObj)); // true\nconsole.log(Object.isSealed(testObj));     // false\nconsole.log(Object.isFrozen(testObj));     // false\n\nObject.freeze(testObj);\n\nconsole.log(Object.isExtensible(testObj)); // false\nconsole.log(Object.isSealed(testObj));     // true\nconsole.log(Object.isFrozen(testObj));     // true\n\n// Note: frozen implies sealed, sealed implies non-extensible\n\n// Performance consideration\nconst large = {};\nfor (let i = 0; i < 10000; i++) {\n  large[`prop${i}`] = i;\n}\n\n// Freezing large objects can impact performance\nObject.freeze(large);\n\n// Alternative: use const for immutability where possible\nconst immutable = { x: 1 };\n// immutable = {}; // Error: Assignment to constant\nimmutable.x = 2;   // But can modify properties\n\n// Combine const with freeze for true immutability\nconst trulyImmutable = Object.freeze({ x: 1 });\n// trulyImmutable = {};    // Error\n// trulyImmutable.x = 2;   // Fails"
    },
    {
      "id": 70,
      "question": "What are the different ways to clone an object in JavaScript?",
      "answer": "JavaScript provides multiple methods to clone objects, each with different characteristics and use cases.\n\nShallow Clone Methods:\n\n1. Spread Operator (...):\n• Simple and readable\n• Copies enumerable properties\n• Shallow copy only\n• ES6+ feature\n\n2. Object.assign():\n• Copies enumerable properties\n• Shallow copy\n• Can merge multiple objects\n• ES6+ feature\n\n3. Object.create():\n• Creates object with same prototype\n• Manual property copying needed\n• Preserves prototype chain\n\nDeep Clone Methods:\n\n1. JSON.parse(JSON.stringify()):\n• Simple for plain objects\n• Loses functions, undefined, symbols\n• Cannot handle circular references\n• Cannot handle Date, RegExp properly\n\n2. structuredClone():\n• Native deep cloning (modern browsers)\n• Handles most types correctly\n• Handles circular references\n• No function cloning\n\n3. Recursive Function:\n• Custom implementation\n• Full control over cloning\n• Can handle special cases\n• More complex\n\n4. Libraries:\n• Lodash cloneDeep\n• jQuery extend\n• Robust implementations",
      "explanation": "Object cloning includes shallow methods (spread operator, Object.assign()) that copy only first level, and deep methods (JSON methods, structuredClone(), libraries) that recursively copy all levels, each with different capabilities and limitations.",
      "difficulty": "Medium",
      "code": "// 1. Spread operator - shallow clone\nconst original = {\n  name: 'John',\n  age: 30,\n  address: { city: 'New York' }\n};\n\nconst clone1 = { ...original };\nclone1.name = 'Jane';           // OK - different value\nclone1.address.city = 'Boston'; // Affects original!\n\nconsole.log(original.address.city); // 'Boston' (shallow!)\n\n// 2. Object.assign() - shallow clone\nconst clone2 = Object.assign({}, original);\n// Same behavior as spread operator\n\n// Merge multiple objects\nconst merged = Object.assign({}, obj1, obj2, obj3);\n\n// 3. JSON methods - deep clone (with limitations)\nconst original2 = {\n  name: 'John',\n  age: 30,\n  address: { city: 'New York' },\n  hobbies: ['reading', 'coding']\n};\n\nconst deepClone1 = JSON.parse(JSON.stringify(original2));\ndeepClone1.address.city = 'Boston';\n\nconsole.log(original2.address.city); // 'New York' (deep clone!)\n\n// JSON limitations\nconst withFunctions = {\n  name: 'John',\n  greet: function() { console.log('Hi'); },\n  date: new Date(),\n  undef: undefined,\n  sym: Symbol('test'),\n  regex: /test/i\n};\n\nconst jsonClone = JSON.parse(JSON.stringify(withFunctions));\n// Lost: greet (function), undef, sym\n// Changed: date becomes string, regex becomes {}\n\nconsole.log(jsonClone);\n// { name: 'John', date: '2024-...', regex: {} }\n\n// Circular reference fails\nconst circular = { a: 1 };\ncircular.self = circular;\n// JSON.stringify(circular); // TypeError: circular reference\n\n// 4. structuredClone() - modern deep clone\nconst original3 = {\n  name: 'John',\n  age: 30,\n  address: { city: 'New York' },\n  date: new Date(),\n  regex: /test/i,\n  map: new Map([['key', 'value']]),\n  set: new Set([1, 2, 3])\n};\n\nconst deepClone2 = structuredClone(original3);\ndeepClone2.address.city = 'Boston';\n\nconsole.log(original3.address.city); // 'New York'\nconsole.log(deepClone2.date instanceof Date); // true\nconsole.log(deepClone2.regex instanceof RegExp); // true\n\n// Handles circular references\nconst withCircular = { a: 1 };\nwithCircular.self = withCircular;\nconst clonedCircular = structuredClone(withCircular); // Works!\n\n// But cannot clone functions\nconst withFunc = {\n  name: 'John',\n  greet() { console.log('Hi'); }\n};\n// structuredClone(withFunc); // Error: functions cannot be cloned\n\n// 5. Custom deep clone function\nfunction deepClone(obj, hash = new WeakMap()) {\n  // Handle primitives and null\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n  \n  // Handle circular references\n  if (hash.has(obj)) {\n    return hash.get(obj);\n  }\n  \n  // Handle Date\n  if (obj instanceof Date) {\n    return new Date(obj);\n  }\n  \n  // Handle RegExp\n  if (obj instanceof RegExp) {\n    return new RegExp(obj.source, obj.flags);\n  }\n  \n  // Handle Array\n  if (Array.isArray(obj)) {\n    const arrCopy = [];\n    hash.set(obj, arrCopy);\n    obj.forEach((item, index) => {\n      arrCopy[index] = deepClone(item, hash);\n    });\n    return arrCopy;\n  }\n  \n  // Handle Map\n  if (obj instanceof Map) {\n    const mapCopy = new Map();\n    hash.set(obj, mapCopy);\n    obj.forEach((value, key) => {\n      mapCopy.set(key, deepClone(value, hash));\n    });\n    return mapCopy;\n  }\n  \n  // Handle Set\n  if (obj instanceof Set) {\n    const setCopy = new Set();\n    hash.set(obj, setCopy);\n    obj.forEach(value => {\n      setCopy.add(deepClone(value, hash));\n    });\n    return setCopy;\n  }\n  \n  // Handle Object\n  const objCopy = {};\n  hash.set(obj, objCopy);\n  \n  Object.keys(obj).forEach(key => {\n    objCopy[key] = deepClone(obj[key], hash);\n  });\n  \n  return objCopy;\n}\n\n// Test custom deep clone\nconst complex = {\n  name: 'John',\n  age: 30,\n  address: { city: 'New York', zip: '10001' },\n  hobbies: ['reading', { type: 'coding', languages: ['JS', 'Python'] }],\n  date: new Date(),\n  regex: /test/i,\n  map: new Map([['key', 'value']]),\n  set: new Set([1, 2, 3])\n};\n\ncomplex.self = complex; // Circular reference\n\nconst customClone = deepClone(complex);\ncustomClone.address.city = 'Boston';\ncustomClone.hobbies[1].languages.push('Java');\n\nconsole.log(original.address.city); // 'New York'\nconsole.log(original.hobbies[1].languages); // ['JS', 'Python']\n\n// 6. Using lodash\nconst _ = require('lodash');\n\nconst original4 = {\n  name: 'John',\n  nested: { deep: { value: 42 } },\n  fn: function() { console.log('test'); }\n};\n\nconst lodashClone = _.cloneDeep(original4);\nlodashClone.nested.deep.value = 100;\n\nconsole.log(original4.nested.deep.value); // 42\n\n// Comparison\n// Method               | Shallow | Deep | Functions | Circular | Types\n// ---------------------|---------|------|-----------|----------|-------\n// Spread (...)         | ✅      | ❌   | ✅        | ❌       | Basic\n// Object.assign()      | ✅      | ❌   | ✅        | ❌       | Basic\n// JSON methods         | ❌      | ✅   | ❌        | ❌       | Limited\n// structuredClone()    | ❌      | ✅   | ❌        | ✅       | Most\n// Custom function      | ❌      | ✅   | Custom    | ✅       | Custom\n// Lodash cloneDeep     | ❌      | ✅   | ✅        | ✅       | All\n\n// Array cloning\nconst arr = [1, 2, [3, 4]];\n\nconst arrClone1 = [...arr];              // Shallow\nconst arrClone2 = arr.slice();           // Shallow\nconst arrClone3 = Array.from(arr);       // Shallow\nconst arrClone4 = structuredClone(arr);  // Deep\n\narrClone1[2][0] = 99;\nconsole.log(arr[2][0]); // 99 (shallow)\n\narrClone4[2][0] = 88;\nconsole.log(arr[2][0]); // 99 (deep clone preserved)"
    },
    {
      "id": 71,
      "question": "What is the difference between synchronous and asynchronous error handling?",
      "answer": "Synchronous and asynchronous errors require different handling approaches.\n\nSynchronous Error Handling:\n• try/catch blocks\n• Immediate error detection\n• Stack trace preserved\n• Errors propagate up call stack\n• Simple and straightforward\n\nAsynchronous Error Handling:\n\nCallbacks:\n• Error-first callback pattern\n• Manual error checking\n• Error passed as first parameter\n• No automatic propagation\n\nPromises:\n• .catch() method\n• Rejection handling\n• Error propagates through chain\n• Unhandled rejection warnings\n\nAsync/Await:\n• try/catch works with async\n• Synchronous-looking error handling\n• Can catch promise rejections\n• Cleaner syntax\n\nCommon Pitfalls:\n• Unhandled promise rejections\n• try/catch doesn't catch async errors in callbacks\n• Mixing error handling styles\n• Missing error handlers\n\nBest Practices:\n• Always handle errors\n• Use async/await with try/catch\n• Log unhandled rejections\n• Consistent error handling strategy\n• Proper error propagation",
      "explanation": "Synchronous errors use try/catch immediately, while asynchronous errors use error-first callbacks, promise .catch(), or try/catch with async/await, with async/await providing the cleanest syntax for async error handling.",
      "difficulty": "Medium",
      "code": "// 1. Synchronous error handling\ntry {\n  const result = JSON.parse('invalid json');\n  console.log(result);\n} catch (error) {\n  console.error('Sync error:', error.message);\n}\n\n// 2. Async error - try/catch DOESN'T work\ntry {\n  setTimeout(() => {\n    throw new Error('Async error');\n  }, 1000);\n} catch (error) {\n  // This never catches the error!\n  console.error('Caught:', error);\n}\n// Error is uncaught!\n\n// 3. Error-first callback pattern\nfunction readFile(path, callback) {\n  setTimeout(() => {\n    if (!path) {\n      callback(new Error('Path required'), null);\n      return;\n    }\n    callback(null, 'file contents');\n  }, 100);\n}\n\n// Usage\nreadFile('file.txt', (error, data) => {\n  if (error) {\n    console.error('Error:', error.message);\n    return;\n  }\n  console.log('Data:', data);\n});\n\n// 4. Promise error handling\nfunction fetchData(url) {\n  return new Promise((resolve, reject) => {\n    if (!url) {\n      reject(new Error('URL required'));\n      return;\n    }\n    setTimeout(() => resolve('data'), 100);\n  });\n}\n\n// With .catch()\nfetchData('')\n  .then(data => console.log(data))\n  .catch(error => console.error('Promise error:', error.message));\n\n// Chaining with error handling\nfetchData('api/users')\n  .then(users => {\n    console.log(users);\n    return fetchData('api/posts');\n  })\n  .then(posts => {\n    console.log(posts);\n    return fetchData('api/comments');\n  })\n  .then(comments => {\n    console.log(comments);\n  })\n  .catch(error => {\n    // Catches errors from any promise in chain\n    console.error('Chain error:', error.message);\n  });\n\n// 5. Async/await with try/catch\nasync function loadData() {\n  try {\n    const users = await fetchData('api/users');\n    console.log(users);\n    \n    const posts = await fetchData('api/posts');\n    console.log(posts);\n    \n    const comments = await fetchData('api/comments');\n    console.log(comments);\n    \n    return { users, posts, comments };\n  } catch (error) {\n    console.error('Async error:', error.message);\n    throw error; // Re-throw if needed\n  }\n}\n\n// Multiple try/catch blocks\nasync function loadDataWithMultipleCatch() {\n  let users, posts, comments;\n  \n  try {\n    users = await fetchData('api/users');\n  } catch (error) {\n    console.error('Users error:', error);\n    users = []; // Default value\n  }\n  \n  try {\n    posts = await fetchData('api/posts');\n  } catch (error) {\n    console.error('Posts error:', error);\n    posts = [];\n  }\n  \n  return { users, posts };\n}\n\n// 6. Finally block\nasync function fetchWithFinally() {\n  try {\n    const data = await fetchData('api/data');\n    return data;\n  } catch (error) {\n    console.error('Error:', error);\n    throw error;\n  } finally {\n    console.log('Cleanup'); // Always runs\n  }\n}\n\n// 7. Promise.allSettled for multiple promises\nasync function loadMultiple() {\n  const results = await Promise.allSettled([\n    fetchData('api/users'),\n    fetchData(''),          // Will reject\n    fetchData('api/posts')\n  ]);\n  \n  results.forEach((result, index) => {\n    if (result.status === 'fulfilled') {\n      console.log(`Promise ${index} succeeded:`, result.value);\n    } else {\n      console.log(`Promise ${index} failed:`, result.reason.message);\n    }\n  });\n}\n\n// 8. Global error handlers\n\n// Unhandled promise rejections\nwindow.addEventListener('unhandledrejection', event => {\n  console.error('Unhandled rejection:', event.reason);\n  event.preventDefault(); // Prevent default error\n});\n\n// In Node.js\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('Unhandled Rejection at:', promise, 'reason:', reason);\n});\n\n// Unhandled exceptions\nwindow.addEventListener('error', event => {\n  console.error('Global error:', event.error);\n});\n\n// Node.js\nprocess.on('uncaughtException', error => {\n  console.error('Uncaught Exception:', error);\n  process.exit(1); // Exit with error\n});\n\n// 9. Custom error wrapper\nasync function safeAsyncCall(fn, fallback) {\n  try {\n    return await fn();\n  } catch (error) {\n    console.error('Error in async call:', error);\n    return fallback;\n  }\n}\n\n// Usage\nconst data = await safeAsyncCall(\n  () => fetchData('api/data'),\n  { default: 'data' }\n);\n\n// 10. Error boundary pattern\nclass AsyncErrorBoundary {\n  constructor() {\n    this.errors = [];\n  }\n  \n  async execute(fn) {\n    try {\n      return await fn();\n    } catch (error) {\n      this.errors.push(error);\n      throw error;\n    }\n  }\n  \n  async executeMany(fns) {\n    const results = [];\n    \n    for (const fn of fns) {\n      try {\n        results.push(await fn());\n      } catch (error) {\n        this.errors.push(error);\n        results.push(null);\n      }\n    }\n    \n    return results;\n  }\n  \n  getErrors() {\n    return this.errors;\n  }\n  \n  clearErrors() {\n    this.errors = [];\n  }\n}\n\nconst boundary = new AsyncErrorBoundary();\n\nconst results = await boundary.executeMany([\n  () => fetchData('api/users'),\n  () => fetchData(''),  // Will fail\n  () => fetchData('api/posts')\n]);\n\nconsole.log('Results:', results);\nconsole.log('Errors:', boundary.getErrors());\n\n// 11. Retry logic with error handling\nasync function fetchWithRetry(url, retries = 3) {\n  for (let i = 0; i < retries; i++) {\n    try {\n      const data = await fetchData(url);\n      return data;\n    } catch (error) {\n      console.log(`Attempt ${i + 1} failed:`, error.message);\n      \n      if (i === retries - 1) {\n        throw error; // Last attempt failed\n      }\n      \n      // Wait before retry\n      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));\n    }\n  }\n}\n\n// 12. Practical: API error handling\nclass APIError extends Error {\n  constructor(message, statusCode, body) {\n    super(message);\n    this.name = 'APIError';\n    this.statusCode = statusCode;\n    this.body = body;\n  }\n}\n\nasync function apiCall(url) {\n  try {\n    const response = await fetch(url);\n    \n    if (!response.ok) {\n      const body = await response.json().catch(() => ({}));\n      throw new APIError(\n        `HTTP ${response.status}: ${response.statusText}`,\n        response.status,\n        body\n      );\n    }\n    \n    return await response.json();\n  } catch (error) {\n    if (error instanceof APIError) {\n      console.error('API Error:', error.message);\n      console.error('Status:', error.statusCode);\n      console.error('Body:', error.body);\n    } else if (error instanceof TypeError) {\n      console.error('Network Error:', error.message);\n    } else {\n      console.error('Unknown Error:', error);\n    }\n    throw error;\n  }\n}"
    },
    {
      "id": 72,
      "question": "What are JavaScript performance optimization techniques?",
      "answer": "JavaScript performance can be optimized through various techniques targeting different aspects of execution.\n\nCode Optimization:\n• Minimize DOM manipulation\n• Avoid global variables\n• Use efficient algorithms\n• Avoid memory leaks\n• Cache calculations and lookups\n• Use appropriate data structures\n\nLoop Optimization:\n• Cache length in loops\n• Use for loops over forEach for performance\n• Break early when possible\n• Avoid creating functions in loops\n\nDOM Optimization:\n• Batch DOM updates\n• Use DocumentFragment\n• Minimize reflows and repaints\n• Use event delegation\n• Virtual scrolling for large lists\n\nAsynchronous Optimization:\n• Debouncing and throttling\n• Use Web Workers for heavy computations\n• Lazy loading\n• Code splitting\n• Prioritize critical resources\n\nMemory Optimization:\n• Remove event listeners\n• Clear intervals and timeouts\n• Avoid circular references\n• Use WeakMap/WeakSet\n• Limit cache size\n\nNetwork Optimization:\n• Minimize bundle size\n• Tree shaking\n• Compress resources\n• Use CDN\n• HTTP/2 and caching",
      "explanation": "JavaScript performance optimization includes efficient code patterns, minimizing DOM manipulation, debouncing events, using Web Workers, lazy loading, proper memory management, and reducing bundle sizes through tree shaking and code splitting.",
      "difficulty": "Hard",
      "code": "// 1. Loop optimization\n// Bad - recalculates length\nconst arr = [1, 2, 3, 4, 5];\nfor (let i = 0; i < arr.length; i++) {\n  console.log(arr[i]);\n}\n\n// Good - cache length\nfor (let i = 0, len = arr.length; i < len; i++) {\n  console.log(arr[i]);\n}\n\n// Best for performance (native)\nfor (let value of arr) {\n  console.log(value);\n}\n\n// 2. DOM manipulation optimization\n// Bad - multiple reflows\nconst list = document.getElementById('list');\nfor (let i = 0; i < 100; i++) {\n  const li = document.createElement('li');\n  li.textContent = `Item ${i}`;\n  list.appendChild(li); // Reflow for each append!\n}\n\n// Good - batch with DocumentFragment\nconst fragment = document.createDocumentFragment();\nfor (let i = 0; i < 100; i++) {\n  const li = document.createElement('li');\n  li.textContent = `Item ${i}`;\n  fragment.appendChild(li);\n}\nlist.appendChild(fragment); // Single reflow!\n\n// 3. Memoization for expensive calculations\nfunction memoize(fn) {\n  const cache = new Map();\n  return function(...args) {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\nconst fibonacci = memoize(function(n) {\n  if (n <= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n});\n\nconsole.log(fibonacci(40)); // Fast with memoization\n\n// 4. Debouncing for performance\nfunction debounce(func, delay) {\n  let timeoutId;\n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => func.apply(this, args), delay);\n  };\n}\n\n// Debounced search\nconst searchInput = document.getElementById('search');\nconst debouncedSearch = debounce(query => {\n  console.log('Searching:', query);\n  // API call here\n}, 300);\n\nsearchInput.addEventListener('input', e => {\n  debouncedSearch(e.target.value);\n});\n\n// 5. Throttling for scroll/resize\nfunction throttle(func, limit) {\n  let inThrottle;\n  return function(...args) {\n    if (!inThrottle) {\n      func.apply(this, args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  };\n}\n\nconst handleScroll = throttle(() => {\n  console.log('Scrolling...');\n}, 200);\n\nwindow.addEventListener('scroll', handleScroll);\n\n// 6. Event delegation\n// Bad - many listeners\nconst buttons = document.querySelectorAll('.button');\nbuttons.forEach(btn => {\n  btn.addEventListener('click', handleClick);\n});\n\n// Good - single listener\nconst container = document.getElementById('container');\ncontainer.addEventListener('click', e => {\n  if (e.target.classList.contains('button')) {\n    handleClick(e);\n  }\n});\n\n// 7. Virtual scrolling for large lists\nclass VirtualList {\n  constructor(container, items, rowHeight) {\n    this.container = container;\n    this.items = items;\n    this.rowHeight = rowHeight;\n    this.visibleRows = Math.ceil(container.clientHeight / rowHeight);\n    this.render();\n  }\n  \n  render() {\n    const scrollTop = this.container.scrollTop;\n    const startIndex = Math.floor(scrollTop / this.rowHeight);\n    const endIndex = startIndex + this.visibleRows;\n    \n    const visibleItems = this.items.slice(startIndex, endIndex);\n    \n    this.container.innerHTML = '';\n    const fragment = document.createDocumentFragment();\n    \n    visibleItems.forEach((item, index) => {\n      const div = document.createElement('div');\n      div.style.height = `${this.rowHeight}px`;\n      div.style.transform = `translateY(${(startIndex + index) * this.rowHeight}px)`;\n      div.textContent = item;\n      fragment.appendChild(div);\n    });\n    \n    this.container.appendChild(fragment);\n  }\n}\n\n// 8. Lazy loading\nfunction lazyLoadImages() {\n  const images = document.querySelectorAll('img[data-src]');\n  const observer = new IntersectionObserver(entries => {\n    entries.forEach(entry => {\n      if (entry.isIntersecting) {\n        const img = entry.target;\n        img.src = img.dataset.src;\n        img.removeAttribute('data-src');\n        observer.unobserve(img);\n      }\n    });\n  });\n  \n  images.forEach(img => observer.observe(img));\n}\n\n// 9. Web Worker for heavy computation\n// main.js\nconst worker = new Worker('worker.js');\n\nworker.postMessage({ numbers: [1, 2, 3, 4, 5] });\n\nworker.onmessage = function(e) {\n  console.log('Result from worker:', e.data);\n};\n\n// worker.js\nself.onmessage = function(e) {\n  const numbers = e.data.numbers;\n  const result = numbers.reduce((sum, n) => sum + n, 0);\n  self.postMessage(result);\n};\n\n// 10. Object pooling\nclass ObjectPool {\n  constructor(createFn, resetFn, size = 10) {\n    this.createFn = createFn;\n    this.resetFn = resetFn;\n    this.pool = [];\n    \n    for (let i = 0; i < size; i++) {\n      this.pool.push(createFn());\n    }\n  }\n  \n  acquire() {\n    return this.pool.length > 0 \n      ? this.pool.pop()\n      : this.createFn();\n  }\n  \n  release(obj) {\n    this.resetFn(obj);\n    this.pool.push(obj);\n  }\n}\n\n// Usage\nconst particlePool = new ObjectPool(\n  () => ({ x: 0, y: 0, vx: 0, vy: 0 }),\n  (p) => { p.x = 0; p.y = 0; p.vx = 0; p.vy = 0; }\n);\n\nconst particle = particlePool.acquire();\n// Use particle\nparticlePool.release(particle);\n\n// 11. RequestAnimationFrame for animations\n// Bad - setTimeout\nfunction badAnimation() {\n  setTimeout(() => {\n    // Update animation\n    badAnimation();\n  }, 16); // Trying to hit 60fps\n}\n\n// Good - requestAnimationFrame\nfunction goodAnimation() {\n  // Update animation\n  requestAnimationFrame(goodAnimation);\n}\n\n// 12. Efficient array operations\n// Use map, filter, reduce instead of loops when appropriate\nconst numbers = [1, 2, 3, 4, 5];\n\n// Chaining (multiple iterations)\nconst result1 = numbers\n  .filter(n => n % 2 === 0)\n  .map(n => n * 2);\n\n// Single iteration (more efficient)\nconst result2 = numbers.reduce((acc, n) => {\n  if (n % 2 === 0) {\n    acc.push(n * 2);\n  }\n  return acc;\n}, []);\n\n// 13. Measuring performance\nconsole.time('operation');\n// Code to measure\nconsole.timeEnd('operation');\n\n// Performance API\nconst start = performance.now();\n// Code to measure\nconst end = performance.now();\nconsole.log(`Took ${end - start}ms`);\n\n// Memory usage\nif (performance.memory) {\n  console.log('Used heap:', performance.memory.usedJSHeapSize);\n  console.log('Total heap:', performance.memory.totalJSHeapSize);\n}"
    },
    {
      "id": 73,
      "question": "What are JavaScript modules and their import/export patterns?",
      "answer": "ES6 modules provide native JavaScript module system with various import/export patterns.\n\nExport Patterns:\n\nNamed Exports:\n• Export multiple values\n• Must import with same name\n• Can rename with 'as'\n• Preferred for libraries\n\nDefault Exports:\n• One per module\n• Import with any name\n• Simpler for single exports\n• Common for components\n\nMixed Exports:\n• Combine named and default\n• Flexibility in consumption\n• Common in utilities\n\nImport Patterns:\n\nNamed Imports:\n• Import specific exports\n• Destructuring syntax\n• Tree-shakeable\n• Clear dependencies\n\nDefault Imports:\n• Import default export\n• Any name allowed\n• Simple syntax\n\nNamespace Imports:\n• Import all as object\n• Access via dot notation\n• Less tree-shakeable\n\nDynamic Imports:\n• Runtime loading\n• Returns promise\n• Code splitting\n• Conditional loading\n\nBest Practices:\n• Use named exports\n• Consistent naming\n• Avoid circular dependencies\n• One module per file",
      "explanation": "ES6 modules use export (named, default, mixed) and import (named, default, namespace, dynamic) patterns, with named exports preferred for tree shaking and clear dependencies, and dynamic imports enabling code splitting.",
      "difficulty": "Medium",
      "code": "// ========== EXPORTS ==========\n\n// math.js - Named exports\nexport const PI = 3.14159;\n\nexport function add(a, b) {\n  return a + b;\n}\n\nexport function subtract(a, b) {\n  return a - b;\n}\n\n// Or export at end\nconst multiply = (a, b) => a * b;\nconst divide = (a, b) => a / b;\n\nexport { multiply, divide };\n\n// Rename on export\nconst secret = 42;\nexport { secret as answer };\n\n// default-export.js - Default export\nexport default function greet(name) {\n  return `Hello, ${name}!`;\n}\n\n// Or\nfunction greet(name) {\n  return `Hello, ${name}!`;\n}\nexport default greet;\n\n// Default with expression\nexport default class User {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\n// mixed-exports.js - Mixed exports\nexport default function main() {\n  console.log('Main function');\n}\n\nexport const VERSION = '1.0.0';\nexport const API_URL = 'https://api.example.com';\n\n// ========== IMPORTS ==========\n\n// Named imports\nimport { add, subtract } from './math.js';\nconsole.log(add(5, 3));      // 8\nconsole.log(subtract(5, 3)); // 2\n\n// Import and rename\nimport { add as sum, subtract as diff } from './math.js';\nconsole.log(sum(5, 3));  // 8\nconsole.log(diff(5, 3)); // 2\n\n// Import multiple\nimport { add, subtract, multiply, divide } from './math.js';\n\n// Import all as namespace\nimport * as math from './math.js';\nconsole.log(math.add(5, 3));      // 8\nconsole.log(math.PI);             // 3.14159\nconsole.log(math.multiply(4, 2)); // 8\n\n// Default import\nimport greet from './default-export.js';\nconsole.log(greet('John')); // 'Hello, John!'\n\n// Can use any name\nimport sayHello from './default-export.js';\nconsole.log(sayHello('Jane')); // 'Hello, Jane!'\n\n// Mixed imports\nimport main, { VERSION, API_URL } from './mixed-exports.js';\nmain(); // Calls default export\nconsole.log(VERSION);  // '1.0.0'\nconsole.log(API_URL);  // 'https://api.example.com'\n\n// Import with side effects only\nimport './polyfills.js'; // Runs code, no imports\n\n// Dynamic imports\nasync function loadModule() {\n  const module = await import('./math.js');\n  console.log(module.add(2, 3)); // 5\n}\n\n// Dynamic import with destructuring\nimport('./math.js').then(({ add, subtract }) => {\n  console.log(add(10, 5));      // 15\n  console.log(subtract(10, 5)); // 5\n});\n\n// Conditional dynamic import\nif (condition) {\n  import('./feature.js').then(module => {\n    module.initialize();\n  });\n}\n\n// Code splitting with dynamic imports\nbutton.addEventListener('click', async () => {\n  const { default: Component } = await import('./Component.js');\n  const component = new Component();\n  component.render();\n});\n\n// ========== PATTERNS ==========\n\n// 1. Barrel exports (index.js)\n// components/index.js\nexport { default as Button } from './Button.js';\nexport { default as Input } from './Input.js';\nexport { default as Modal } from './Modal.js';\n\n// Usage\nimport { Button, Input, Modal } from './components';\n\n// 2. Re-exporting\n// utils/index.js\nexport { add, subtract } from './math.js';\nexport { parseDate, formatDate } from './date.js';\nexport * from './string.js'; // Export all\n\n// 3. Module pattern with IIFE (pre-ES6)\nconst MyModule = (function() {\n  // Private\n  let privateVar = 'secret';\n  \n  function privateMethod() {\n    return privateVar;\n  }\n  \n  // Public API\n  return {\n    publicMethod() {\n      return privateMethod();\n    }\n  };\n})();\n\n// 4. Singleton pattern\n// database.js\nclass Database {\n  constructor() {\n    this.connection = null;\n  }\n  \n  connect() {\n    if (!this.connection) {\n      this.connection = {}; // Create connection\n    }\n    return this.connection;\n  }\n}\n\nexport default new Database(); // Export instance\n\n// Usage\nimport db from './database.js';\ndb.connect(); // Same instance everywhere\n\n// 5. Factory pattern\n// factory.js\nexport function createUser(name, email) {\n  return {\n    name,\n    email,\n    createdAt: new Date()\n  };\n}\n\nexport function createAdmin(name, email) {\n  return {\n    ...createUser(name, email),\n    role: 'admin'\n  };\n}\n\n// 6. Config module\n// config.js\nconst config = {\n  development: {\n    apiUrl: 'http://localhost:3000',\n    debug: true\n  },\n  production: {\n    apiUrl: 'https://api.example.com',\n    debug: false\n  }\n};\n\nconst env = process.env.NODE_ENV || 'development';\n\nexport default config[env];\n\n// Usage\nimport config from './config.js';\nconsole.log(config.apiUrl);\n\n// 7. Lazy loading routes\nconst routes = [\n  {\n    path: '/home',\n    component: () => import('./pages/Home.js')\n  },\n  {\n    path: '/about',\n    component: () => import('./pages/About.js')\n  }\n];\n\n// 8. Tree shaking example\n// utils.js\nexport const utility1 = () => {};\nexport const utility2 = () => {};\nexport const utility3 = () => {};\n\n// app.js\nimport { utility1 } from './utils.js';\n// Only utility1 bundled, others tree-shaken\n\n// 9. Circular dependencies (avoid)\n// a.js\nimport { b } from './b.js';\nexport const a = () => b();\n\n// b.js\nimport { a } from './a.js';\nexport const b = () => a(); // Circular!\n\n// Solution: restructure or use dynamic import\n\n// 10. Module aliases (webpack config)\n// resolve: {\n//   alias: {\n//     '@components': path.resolve(__dirname, 'src/components'),\n//     '@utils': path.resolve(__dirname, 'src/utils')\n//   }\n// }\n\n// Usage\nimport Button from '@components/Button';\nimport { add } from '@utils/math';"
    },
    {
      "id": 74,
      "question": "What are JavaScript design patterns for async code?",
      "answer": "Async design patterns help manage asynchronous operations effectively.\n\nCallback Patterns:\n• Error-first callbacks\n• Callback hell (avoid)\n• Continuation passing style\n• Node.js convention\n\nPromise Patterns:\n• Promise chains\n• Promise combinators\n• Promise wrapping\n• Deferred pattern\n\nAsync/Await Patterns:\n• Sequential execution\n• Parallel execution\n• Race conditions\n• Error handling\n\nAdvanced Patterns:\n\n1. Queue Pattern:\n• Process tasks sequentially\n• Task prioritization\n• Concurrency control\n\n2. Circuit Breaker:\n• Fail fast mechanism\n• Retry with backoff\n• Fallback strategies\n\n3. Pub/Sub:\n• Event-driven architecture\n• Loose coupling\n• Async messaging\n\n4. Promise Pool:\n• Limited concurrency\n• Resource management\n• Batch processing\n\n5. Saga Pattern:\n• Long-running transactions\n• Compensation logic\n• Distributed systems\n\nBest Practices:\n• Avoid callback hell\n• Use async/await\n• Handle errors properly\n• Control concurrency\n• Timeout long operations",
      "explanation": "Async patterns include callbacks (error-first), promises (chains and combinators), async/await (sequential/parallel), and advanced patterns like queue, circuit breaker, pub/sub, promise pool for managing complex async operations.",
      "difficulty": "Hard",
      "code": "// 1. Promise chain pattern\nfunction fetchUserData(userId) {\n  return fetch(`/api/users/${userId}`)\n    .then(response => response.json())\n    .then(user => fetch(`/api/posts?userId=${user.id}`))\n    .then(response => response.json())\n    .then(posts => ({ user, posts }))\n    .catch(error => console.error(error));\n}\n\n// 2. Parallel execution with Promise.all\nasync function loadAllData() {\n  const [users, posts, comments] = await Promise.all([\n    fetch('/api/users').then(r => r.json()),\n    fetch('/api/posts').then(r => r.json()),\n    fetch('/api/comments').then(r => r.json())\n  ]);\n  \n  return { users, posts, comments };\n}\n\n// 3. Race pattern - timeout\nfunction fetchWithTimeout(url, timeout = 5000) {\n  return Promise.race([\n    fetch(url),\n    new Promise((_, reject) =>\n      setTimeout(() => reject(new Error('Timeout')), timeout)\n    )\n  ]);\n}\n\n// 4. Queue pattern\nclass AsyncQueue {\n  constructor() {\n    this.queue = [];\n    this.processing = false;\n  }\n  \n  async enqueue(task) {\n    this.queue.push(task);\n    if (!this.processing) {\n      await this.process();\n    }\n  }\n  \n  async process() {\n    this.processing = true;\n    \n    while (this.queue.length > 0) {\n      const task = this.queue.shift();\n      try {\n        await task();\n      } catch (error) {\n        console.error('Task failed:', error);\n      }\n    }\n    \n    this.processing = false;\n  }\n}\n\n// Usage\nconst queue = new AsyncQueue();\nqueue.enqueue(async () => await fetch('/api/data1'));\nqueue.enqueue(async () => await fetch('/api/data2'));\n\n// 5. Promise pool - limited concurrency\nclass PromisePool {\n  constructor(concurrency) {\n    this.concurrency = concurrency;\n    this.running = 0;\n    this.queue = [];\n  }\n  \n  async add(promiseFn) {\n    while (this.running >= this.concurrency) {\n      await this.queue.shift();\n    }\n    \n    this.running++;\n    \n    const promise = promiseFn().finally(() => {\n      this.running--;\n    });\n    \n    this.queue.push(promise);\n    \n    return promise;\n  }\n  \n  async all(promiseFns) {\n    return Promise.all(\n      promiseFns.map(fn => this.add(fn))\n    );\n  }\n}\n\n// Usage\nconst pool = new PromisePool(3); // Max 3 concurrent\n\nconst tasks = Array.from({ length: 10 }, (_, i) =>\n  () => fetch(`/api/data${i}`).then(r => r.json())\n);\n\npool.all(tasks).then(results => {\n  console.log('All done:', results);\n});\n\n// 6. Retry pattern with exponential backoff\nasync function retry(fn, maxRetries = 3, delay = 1000) {\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      return await fn();\n    } catch (error) {\n      if (i === maxRetries - 1) throw error;\n      \n      const backoff = delay * Math.pow(2, i);\n      console.log(`Retry ${i + 1} after ${backoff}ms`);\n      await new Promise(resolve => setTimeout(resolve, backoff));\n    }\n  }\n}\n\n// Usage\nconst data = await retry(() => fetch('/api/unstable'), 5, 500);\n\n// 7. Circuit breaker pattern\nclass CircuitBreaker {\n  constructor(fn, options = {}) {\n    this.fn = fn;\n    this.failureThreshold = options.failureThreshold || 5;\n    this.cooldownPeriod = options.cooldownPeriod || 60000;\n    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN\n    this.failures = 0;\n    this.nextAttempt = Date.now();\n  }\n  \n  async call(...args) {\n    if (this.state === 'OPEN') {\n      if (Date.now() < this.nextAttempt) {\n        throw new Error('Circuit breaker is OPEN');\n      }\n      this.state = 'HALF_OPEN';\n    }\n    \n    try {\n      const result = await this.fn(...args);\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure();\n      throw error;\n    }\n  }\n  \n  onSuccess() {\n    this.failures = 0;\n    this.state = 'CLOSED';\n  }\n  \n  onFailure() {\n    this.failures++;\n    if (this.failures >= this.failureThreshold) {\n      this.state = 'OPEN';\n      this.nextAttempt = Date.now() + this.cooldownPeriod;\n    }\n  }\n}\n\n// Usage\nconst breaker = new CircuitBreaker(\n  userId => fetch(`/api/users/${userId}`).then(r => r.json()),\n  { failureThreshold: 3, cooldownPeriod: 30000 }\n);\n\ntry {\n  const user = await breaker.call(123);\n} catch (error) {\n  console.error('Service unavailable');\n}\n\n// 8. Pub/Sub pattern\nclass EventEmitter {\n  constructor() {\n    this.events = {};\n  }\n  \n  on(event, callback) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    this.events[event].push(callback);\n  }\n  \n  emit(event, data) {\n    if (this.events[event]) {\n      this.events[event].forEach(callback => callback(data));\n    }\n  }\n  \n  off(event, callback) {\n    if (this.events[event]) {\n      this.events[event] = this.events[event]\n        .filter(cb => cb !== callback);\n    }\n  }\n}\n\n// Usage\nconst emitter = new EventEmitter();\n\nemitter.on('dataLoaded', data => {\n  console.log('Data received:', data);\n});\n\nfetch('/api/data')\n  .then(r => r.json())\n  .then(data => emitter.emit('dataLoaded', data));\n\n// 9. Deferred pattern\nclass Deferred {\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n}\n\n// Usage\nconst deferred = new Deferred();\n\nsetTimeout(() => {\n  deferred.resolve('Done!');\n}, 1000);\n\nawait deferred.promise; // 'Done!'\n\n// 10. Saga pattern (simplified)\nclass Saga {\n  constructor() {\n    this.steps = [];\n    this.compensations = [];\n  }\n  \n  addStep(execute, compensate) {\n    this.steps.push(execute);\n    this.compensations.push(compensate);\n  }\n  \n  async run() {\n    const results = [];\n    \n    try {\n      for (const step of this.steps) {\n        results.push(await step());\n      }\n      return results;\n    } catch (error) {\n      console.error('Saga failed, compensating...');\n      \n      // Run compensations in reverse\n      for (let i = results.length - 1; i >= 0; i--) {\n        try {\n          await this.compensations[i](results[i]);\n        } catch (e) {\n          console.error('Compensation failed:', e);\n        }\n      }\n      \n      throw error;\n    }\n  }\n}\n\n// Usage\nconst saga = new Saga();\n\nsaga.addStep(\n  () => createOrder(),\n  orderId => cancelOrder(orderId)\n);\n\nsaga.addStep(\n  () => chargePayment(),\n  paymentId => refundPayment(paymentId)\n);\n\nsaga.addStep(\n  () => sendEmail(),\n  () => {} // No compensation for email\n);\n\nawait saga.run();"
    },
    {
      "id": 75,
      "question": "What are JavaScript testing patterns and best practices?",
      "answer": "Testing patterns ensure code quality and maintainability through various strategies.\n\nTesting Types:\n\n1. Unit Testing:\n• Test individual functions\n• Isolated and fast\n• Mock dependencies\n• High coverage\n\n2. Integration Testing:\n• Test module interactions\n• Real dependencies\n• Database and API calls\n• More realistic scenarios\n\n3. End-to-End Testing:\n• Test complete workflows\n• User perspective\n• Browser automation\n• Slower but comprehensive\n\nTesting Patterns:\n\n1. AAA Pattern:\n• Arrange - setup\n• Act - execute\n• Assert - verify\n\n2. Given-When-Then:\n• BDD style\n• Readable specifications\n• User story format\n\n3. Test Doubles:\n• Mocks - verify behavior\n• Stubs - return fixed data\n• Spies - record calls\n• Fakes - working implementations\n\n4. Test Fixtures:\n• Setup and teardown\n• Shared test data\n• Database seeding\n\nBest Practices:\n• One assertion per test\n• Descriptive test names\n• Independent tests\n• Fast execution\n• Avoid test interdependence\n• Mock external services\n• Test edge cases",
      "explanation": "Testing patterns include unit (isolated functions), integration (module interactions), and E2E (workflows) testing, using AAA pattern, test doubles (mocks, stubs, spies), fixtures for setup, and best practices for maintainable tests.",
      "difficulty": "Hard",
      "code": "// 1. AAA Pattern (Arrange, Act, Assert)\nfunction add(a, b) {\n  return a + b;\n}\n\n// Test with Jest\ndescribe('add function', () => {\n  test('should add two positive numbers', () => {\n    // Arrange\n    const a = 5;\n    const b = 3;\n    const expected = 8;\n    \n    // Act\n    const result = add(a, b);\n    \n    // Assert\n    expect(result).toBe(expected);\n  });\n});\n\n// 2. Given-When-Then (BDD style)\ndescribe('Calculator', () => {\n  it('should calculate sum when adding positive numbers', () => {\n    // Given\n    const calculator = new Calculator();\n    \n    // When\n    const result = calculator.add(5, 3);\n    \n    // Then\n    expect(result).toBe(8);\n  });\n});\n\n// 3. Mocking dependencies\nclass UserService {\n  constructor(database) {\n    this.database = database;\n  }\n  \n  async getUser(id) {\n    const user = await this.database.findById(id);\n    return user;\n  }\n}\n\n// Test with mock\ndescribe('UserService', () => {\n  test('should fetch user from database', async () => {\n    // Mock database\n    const mockDatabase = {\n      findById: jest.fn().mockResolvedValue({\n        id: 1,\n        name: 'John'\n      })\n    };\n    \n    const service = new UserService(mockDatabase);\n    const user = await service.getUser(1);\n    \n    expect(mockDatabase.findById).toHaveBeenCalledWith(1);\n    expect(user.name).toBe('John');\n  });\n});\n\n// 4. Spy pattern\nclass Logger {\n  log(message) {\n    console.log(message);\n  }\n}\n\nclass App {\n  constructor(logger) {\n    this.logger = logger;\n  }\n  \n  doSomething() {\n    this.logger.log('Doing something');\n    return 'done';\n  }\n}\n\n// Test with spy\ndescribe('App', () => {\n  test('should log when doing something', () => {\n    const logger = new Logger();\n    const logSpy = jest.spyOn(logger, 'log');\n    \n    const app = new App(logger);\n    app.doSomething();\n    \n    expect(logSpy).toHaveBeenCalledWith('Doing something');\n  });\n});\n\n// 5. Test fixtures\nclass TestFixture {\n  constructor() {\n    this.users = [];\n    this.posts = [];\n  }\n  \n  async setup() {\n    this.users = await createTestUsers();\n    this.posts = await createTestPosts(this.users[0].id);\n  }\n  \n  async teardown() {\n    await deleteTestData();\n  }\n}\n\n// Usage with Jest\nlet fixture;\n\nbeforeEach(async () => {\n  fixture = new TestFixture();\n  await fixture.setup();\n});\n\nafterEach(async () => {\n  await fixture.teardown();\n});\n\ntest('should work with test data', () => {\n  expect(fixture.users).toHaveLength(3);\n  expect(fixture.posts).toHaveLength(5);\n});\n\n// 6. Async testing\nfunction fetchUser(id) {\n  return fetch(`/api/users/${id}`).then(r => r.json());\n}\n\n// Test with async/await\ntest('should fetch user', async () => {\n  const user = await fetchUser(1);\n  expect(user.id).toBe(1);\n});\n\n// Test with return promise\ntest('should fetch user', () => {\n  return fetchUser(1).then(user => {\n    expect(user.id).toBe(1);\n  });\n});\n\n// 7. Error testing\nfunction divide(a, b) {\n  if (b === 0) {\n    throw new Error('Division by zero');\n  }\n  return a / b;\n}\n\ntest('should throw error for division by zero', () => {\n  expect(() => divide(10, 0)).toThrow('Division by zero');\n});\n\n// Async error\nasync function failingAsync() {\n  throw new Error('Async error');\n}\n\ntest('should handle async errors', async () => {\n  await expect(failingAsync()).rejects.toThrow('Async error');\n});\n\n// 8. Parameterized tests\ntest.each([\n  [1, 2, 3],\n  [5, 3, 8],\n  [10, 20, 30]\n])('add(%i, %i) should equal %i', (a, b, expected) => {\n  expect(add(a, b)).toBe(expected);\n});\n\n// 9. Snapshot testing\nfunction render(props) {\n  return `<div class=\"${props.className}\">${props.text}</div>`;\n}\n\ntest('should match snapshot', () => {\n  const output = render({ className: 'test', text: 'Hello' });\n  expect(output).toMatchSnapshot();\n});\n\n// 10. Integration test example\ndescribe('User API Integration', () => {\n  let server;\n  let database;\n  \n  beforeAll(async () => {\n    database = await setupDatabase();\n    server = await startServer(database);\n  });\n  \n  afterAll(async () => {\n    await server.close();\n    await database.close();\n  });\n  \n  test('should create and retrieve user', async () => {\n    // Create user\n    const createResponse = await fetch('http://localhost:3000/users', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ name: 'John', email: 'john@example.com' })\n    });\n    const created = await createResponse.json();\n    \n    // Retrieve user\n    const getResponse = await fetch(`http://localhost:3000/users/${created.id}`);\n    const retrieved = await getResponse.json();\n    \n    expect(retrieved.name).toBe('John');\n    expect(retrieved.email).toBe('john@example.com');\n  });\n});\n\n// 11. Test coverage\n// Run with: jest --coverage\n\n// 12. Custom matchers\nexpect.extend({\n  toBeWithinRange(received, floor, ceiling) {\n    const pass = received >= floor && received <= ceiling;\n    return {\n      pass,\n      message: () =>\n        `expected ${received} ${pass ? 'not ' : ''}to be within range ${floor} - ${ceiling}`\n    };\n  }\n});\n\ntest('should be within range', () => {\n  expect(5).toBeWithinRange(1, 10);\n});\n\n// 13. Testing React components (example)\nimport { render, screen, fireEvent } from '@testing-library/react';\n\nfunction Button({ onClick, children }) {\n  return <button onClick={onClick}>{children}</button>;\n}\n\ntest('should call onClick when clicked', () => {\n  const handleClick = jest.fn();\n  render(<Button onClick={handleClick}>Click me</Button>);\n  \n  fireEvent.click(screen.getByText('Click me'));\n  \n  expect(handleClick).toHaveBeenCalledTimes(1);\n});\n\n// 14. Test organization\ndescribe('User Management', () => {\n  describe('User Creation', () => {\n    test('should create user with valid data', () => {});\n    test('should reject invalid email', () => {});\n  });\n  \n  describe('User Deletion', () => {\n    test('should delete existing user', () => {});\n    test('should handle non-existent user', () => {});\n  });\n});"
    },
    {
      "id": 76,
      "question": "What are JavaScript security best practices and common vulnerabilities?",
      "answer": "JavaScript security involves protecting applications from various attack vectors and vulnerabilities.\n\nCommon Vulnerabilities:\n\n1. Cross-Site Scripting (XSS):\n• Injecting malicious scripts\n• Stealing cookies and tokens\n• DOM manipulation\n• Prevention: sanitize input, escape output\n\n2. Cross-Site Request Forgery (CSRF):\n• Unauthorized actions on behalf of user\n• Prevention: CSRF tokens, SameSite cookies\n\n3. Injection Attacks:\n• SQL injection\n• Command injection\n• Prevention: parameterized queries, validation\n\n4. Insecure Dependencies:\n• Vulnerable npm packages\n• Prevention: audit regularly, update dependencies\n\n5. Prototype Pollution:\n• Modifying Object.prototype\n• Prevention: Object.create(null), freeze prototypes\n\n6. ReDoS (Regular Expression Denial of Service):\n• Catastrophic backtracking\n• Prevention: safe regex patterns, timeout\n\nBest Practices:\n• Input validation\n• Output encoding\n• Content Security Policy\n• HTTPS only\n• Secure cookies\n• Avoid eval()\n• Use security headers\n• Regular security audits",
      "explanation": "JavaScript security focuses on preventing XSS (sanitize input), CSRF (tokens), injection attacks (validation), insecure dependencies (audits), prototype pollution (freeze), and ReDoS (safe regex) through input validation, output encoding, CSP, and security headers.",
      "difficulty": "Hard"
    },
    {
      "id": 77,
      "question": "What are JavaScript performance monitoring and profiling techniques?",
      "answer": "Performance monitoring and profiling help identify and fix performance bottlenecks.\n\nBrowser DevTools:\n\n1. Performance Tab:\n• Record and analyze runtime performance\n• Identify long tasks\n• Memory usage\n• FPS and rendering metrics\n\n2. Memory Profiler:\n• Heap snapshots\n• Memory leaks detection\n• Allocation timeline\n• Object retention\n\n3. Network Tab:\n• Request waterfall\n• Resource timing\n• Bandwidth usage\n• Caching efficiency\n\nPerformance APIs:\n\n1. Performance.now():\n• High-resolution timestamps\n• Measure execution time\n• More accurate than Date\n\n2. Performance Observer:\n• Monitor various metrics\n• Navigation timing\n• Resource timing\n• User timing marks\n\n3. console.time/timeEnd:\n• Simple timing measurements\n• Named timers\n• Console output\n\nMetrics to Monitor:\n• First Contentful Paint (FCP)\n• Largest Contentful Paint (LCP)\n• Time to Interactive (TTI)\n• Total Blocking Time (TBT)\n• Cumulative Layout Shift (CLS)\n\nProfiling Tools:\n• Chrome DevTools\n• Firefox Profiler\n• Lighthouse\n• WebPageTest\n• Real User Monitoring (RUM)",
      "explanation": "Performance monitoring uses browser DevTools (Performance, Memory, Network tabs), Performance APIs (performance.now(), Observer), and metrics (FCP, LCP, TTI, TBT, CLS) to identify bottlenecks and optimize JavaScript applications.",
      "difficulty": "Hard"
    },
    {
      "id": 78,
      "question": "What are JavaScript build tools and bundlers?",
      "answer": "Build tools and bundlers optimize JavaScript applications for production deployment.\n\nBundlers:\n\n1. Webpack:\n• Module bundler\n• Code splitting\n• Loaders for assets\n• Extensive plugin system\n• Configuration complex\n\n2. Rollup:\n• ES6 module bundler\n• Tree shaking focus\n• Better for libraries\n• Simpler config\n\n3. Parcel:\n• Zero configuration\n• Fast build times\n• Auto code splitting\n• Built-in features\n\n4. Vite:\n• Native ESM dev server\n• Fast HMR\n• Production bundling\n• Modern and fast\n\n5. esbuild:\n• Extremely fast (Go-based)\n• Minimal config\n• Limited plugins\n\nBuild Tools:\n\n1. Babel:\n• JavaScript compiler\n• Transpile modern to legacy\n• Polyfills\n• Plugin system\n\n2. TypeScript:\n• Type checking\n• Compilation to JavaScript\n• Better tooling\n• Compile-time errors\n\nTask Runners:\n• Gulp - streaming builds\n• Grunt - configuration-based\n• npm scripts - simple tasks\n\nOptimizations:\n• Minification\n• Tree shaking\n• Code splitting\n• Lazy loading\n• Compression",
      "explanation": "Build tools include bundlers (Webpack, Rollup, Parcel, Vite, esbuild) for module bundling and code splitting, compilers (Babel, TypeScript) for transpilation, and task runners (Gulp, npm scripts) for automation and optimization.",
      "difficulty": "Medium"
    },
    {
      "id": 79,
      "question": "What are JavaScript runtime environments and their differences?",
      "answer": "JavaScript runs in different environments with distinct characteristics and APIs.\n\nBrowser Environment:\n• Window object as global\n• DOM API\n• Web APIs (fetch, localStorage, etc.)\n• Browser security restrictions\n• Same-origin policy\n• User interface events\n\nNode.js Environment:\n• Global object as global\n• File system access\n• Operating system APIs\n• Network programming\n• Package management (npm)\n• Server-side execution\n• No DOM\n\nDeno:\n• Secure by default\n• TypeScript support\n• No package.json\n• URL imports\n• Standard library\n• Permission system\n\nBun:\n• Fast JavaScript runtime\n• Built-in bundler\n• npm-compatible\n• Native TypeScript\n• Performance focus\n\nKey Differences:\n\nAPIs:\n• Browser has DOM, Bun has no DOM\n• Node has fs, crypto modules\n• Different global objects\n\nSecurity:\n• Browser sandboxed\n• Node/Deno need permissions\n• Bun security model\n\nModules:\n• Browser supports ESM natively\n• Node supports CommonJS and ESM\n• Deno only ESM\n\nPerformance:\n• Browser optimized for UI\n• Node for I/O\n• Bun for speed",
      "explanation": "JavaScript runs in browsers (DOM, Web APIs), Node.js (file system, server), Deno (secure, TypeScript), and Bun (fast runtime), each with different global objects, APIs, security models, and module systems.",
      "difficulty": "Medium"
    },
    {
      "id": 80,
      "question": "What are JavaScript frameworks and when to use them?",
      "answer": "JavaScript frameworks provide structure and tools for building applications efficiently.\n\nFront-End Frameworks:\n\n1. React:\n• Component-based\n• Virtual DOM\n• Large ecosystem\n• JSX syntax\n• Flexible (library)\n• Use for: SPAs, mobile apps\n\n2. Vue:\n• Progressive framework\n• Template syntax\n• Reactive data binding\n• Easy learning curve\n• Use for: all sizes of apps\n\n3. Angular:\n• Full framework\n• TypeScript-first\n• Dependency injection\n• Two-way binding\n• Opinionated\n• Use for: enterprise apps\n\n4. Svelte:\n• Compile-time framework\n• No virtual DOM\n• Reactive by default\n• Small bundle size\n• Use for: performance-critical apps\n\nBack-End Frameworks:\n\n1. Express (Node.js):\n• Minimal framework\n• Middleware system\n• Routing\n• REST APIs\n\n2. NestJS:\n• Angular-inspired\n• TypeScript\n• Dependency injection\n• Enterprise-ready\n\n3. Fastify:\n• Performance focus\n• Schema validation\n• Plugin system\n\nWhen to Use Frameworks:\n• Complex applications\n• Team collaboration\n• Rapid development\n• Standard patterns needed\n• Large-scale projects\n\nWhen Not to Use:\n• Simple static sites\n• Learning JavaScript\n• Performance critical\n• Minimal requirements",
      "explanation": "Frameworks include React (component-based SPA), Vue (progressive), Angular (enterprise), Svelte (compile-time), Express (Node.js API), and NestJS (TypeScript backend), chosen based on project size, complexity, team, and requirements.",
      "difficulty": "Medium"
    },
    {
      "id": 81,
      "question": "What are advanced array methods in JavaScript?",
      "answer": "JavaScript provides powerful array methods for data manipulation and transformation.\n\nIteration Methods:\n\n1. forEach():\n• Iterate without return value\n• Cannot break early\n• Side effects\n\n2. map():\n• Transform each element\n• Returns new array\n• Same length as original\n\n3. filter():\n• Select elements by condition\n• Returns new array\n• Length may differ\n\n4. reduce():\n• Accumulate to single value\n• Most versatile\n• Can implement other methods\n\n5. find/findIndex():\n• Find first matching element\n• Returns element or index\n• Stops at first match\n\n6. some/every():\n• Test conditions\n• Returns boolean\n• Short-circuits\n\nArray Manipulation:\n\n1. flat/flatMap():\n• Flatten nested arrays\n• Map and flatten\n• Specify depth\n\n2. sort():\n• Mutates original\n• Custom comparator\n• In-place sorting\n\n3. reverse():\n• Reverses in-place\n• Mutates original\n\nModern Methods:\n\n1. at():\n• Negative indexing\n• More readable\n\n2. toSorted/toReversed():\n• Non-mutating versions\n• Returns new array\n\n3. with():\n• Immutable update\n• Copy with change",
      "explanation": "Advanced array methods include iteration (forEach, map, filter, reduce, find), testing (some, every), manipulation (flat, flatMap, sort), and modern methods (at, toSorted, with) for functional data transformation.",
      "difficulty": "Medium",
      "code": "// 1. map - transform elements\nconst numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map(n => n * 2);\nconsole.log(doubled); // [2, 4, 6, 8, 10]\n\n// 2. filter - select elements\nconst evens = numbers.filter(n => n % 2 === 0);\nconsole.log(evens); // [2, 4]\n\n// 3. reduce - accumulate\nconst sum = numbers.reduce((acc, n) => acc + n, 0);\nconsole.log(sum); // 15\n\nconst product = numbers.reduce((acc, n) => acc * n, 1);\nconsole.log(product); // 120\n\n// Group by\nconst people = [\n  { name: 'John', age: 30 },\n  { name: 'Jane', age: 25 },\n  { name: 'Bob', age: 30 }\n];\n\nconst grouped = people.reduce((acc, person) => {\n  (acc[person.age] = acc[person.age] || []).push(person);\n  return acc;\n}, {});\nconsole.log(grouped);\n// { 25: [{ name: 'Jane', age: 25 }], 30: [{ name: 'John', age: 30 }, { name: 'Bob', age: 30 }] }\n\n// 4. find/findIndex\nconst first = numbers.find(n => n > 3);\nconsole.log(first); // 4\n\nconst index = numbers.findIndex(n => n > 3);\nconsole.log(index); // 3\n\n// 5. some/every\nconst hasEven = numbers.some(n => n % 2 === 0);\nconsole.log(hasEven); // true\n\nconst allEven = numbers.every(n => n % 2 === 0);\nconsole.log(allEven); // false\n\n// 6. flat/flatMap\nconst nested = [1, [2, 3], [4, [5, 6]]];\nconst flat1 = nested.flat();      // [1, 2, 3, 4, [5, 6]]\nconst flat2 = nested.flat(2);     // [1, 2, 3, 4, 5, 6]\nconst flatAll = nested.flat(Infinity); // [1, 2, 3, 4, 5, 6]\n\nconst words = ['hello world', 'foo bar'];\nconst letters = words.flatMap(s => s.split(' '));\nconsole.log(letters); // ['hello', 'world', 'foo', 'bar']\n\n// 7. at - negative indexing\nconst arr = [1, 2, 3, 4, 5];\nconsole.log(arr.at(-1));  // 5 (last element)\nconsole.log(arr.at(-2));  // 4\n\n// 8. toSorted (non-mutating)\nconst original = [3, 1, 4, 1, 5];\nconst sorted = original.toSorted();\nconsole.log(original); // [3, 1, 4, 1, 5] (unchanged)\nconsole.log(sorted);   // [1, 1, 3, 4, 5]\n\n// Custom comparator\nconst desc = original.toSorted((a, b) => b - a);\nconsole.log(desc); // [5, 4, 3, 1, 1]\n\n// 9. with - immutable update\nconst arr2 = [1, 2, 3, 4, 5];\nconst updated = arr2.with(2, 10);\nconsole.log(arr2);    // [1, 2, 3, 4, 5] (unchanged)\nconsole.log(updated); // [1, 2, 10, 4, 5]\n\n// 10. Chaining methods\nconst result = numbers\n  .filter(n => n % 2 === 0)\n  .map(n => n * 2)\n  .reduce((acc, n) => acc + n, 0);\nconsole.log(result); // 12 (2*2 + 4*2 = 4 + 8 = 12)"
    },
    {
      "id": 82,
      "question": "What are JavaScript regex patterns and common use cases?",
      "answer": "Regular expressions (regex) are patterns for matching and manipulating text.\n\nBasic Syntax:\n• /pattern/flags\n• Flags: g (global), i (ignore case), m (multiline), s (dotAll)\n• Methods: test(), exec(), match(), replace(), search(), split()\n\nCommon Patterns:\n\n1. Character Classes:\n• \\d - digit [0-9]\n• \\w - word character [a-zA-Z0-9_]\n• \\s - whitespace\n• \\D, \\W, \\S - negations\n• . - any character\n\n2. Quantifiers:\n• * - 0 or more\n• + - 1 or more\n• ? - 0 or 1\n• {n} - exactly n\n• {n,m} - n to m times\n\n3. Anchors:\n• ^ - start of string\n• $ - end of string\n• \\b - word boundary\n\n4. Groups:\n• (pattern) - capturing group\n• (?:pattern) - non-capturing\n• (a|b) - alternation\n\nCommon Use Cases:\n• Email validation\n• Phone number formatting\n• URL parsing\n• Input sanitization\n• Text extraction\n• String replacement\n\nPerformance:\n• Avoid catastrophic backtracking\n• Use specific patterns\n• Limit quantifier ranges\n• Test with long strings\n\nBest Practices:\n• Document complex regex\n• Test thoroughly\n• Use online testers\n• Consider readability",
      "explanation": "Regex provides patterns for text matching using character classes (\\d, \\w, \\s), quantifiers (*, +, ?), anchors (^, $), and groups for validation, formatting, extraction, and replacement with careful attention to performance.",
      "difficulty": "Medium",
      "code": "// 1. Email validation\nconst emailRegex = /^[\\w.-]+@[\\w.-]+\\.\\w+$/;\n\nconsole.log(emailRegex.test('user@example.com')); // true\nconsole.log(emailRegex.test('invalid.email'));    // false\n\n// 2. Phone number formatting\nconst phone = '1234567890';\nconst formatted = phone.replace(/(\\d{3})(\\d{3})(\\d{4})/, '($1) $2-$3');\nconsole.log(formatted); // '(123) 456-7890'\n\n// 3. Password validation (8+ chars, uppercase, lowercase, number)\nconst passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{8,}$/;\n\nconsole.log(passwordRegex.test('Pass123'));   // false (< 8 chars)\nconsole.log(passwordRegex.test('Password1')); // true\n\n// 4. URL extraction\nconst text = 'Visit https://example.com and http://test.org';\nconst urlRegex = /https?:\\/\\/[^\\s]+/g;\nconst urls = text.match(urlRegex);\nconsole.log(urls); // ['https://example.com', 'http://test.org']\n\n// 5. Removing HTML tags\nconst html = '<p>Hello <strong>world</strong>!</p>';\nconst plain = html.replace(/<[^>]*>/g, '');\nconsole.log(plain); // 'Hello world!'\n\n// 6. Extracting numbers\nconst str = 'Price: $123.45, Tax: $12.34';\nconst prices = str.match(/\\d+\\.\\d+/g);\nconsole.log(prices); // ['123.45', '12.34']\n\n// 7. Camel case to kebab case\nfunction toKebab(str) {\n  return str.replace(/([A-Z])/g, '-$1').toLowerCase();\n}\n\nconsole.log(toKebab('backgroundColor')); // 'background-color'\n\n// 8. Validating dates (MM/DD/YYYY)\nconst dateRegex = /^(0[1-9]|1[0-2])\\/(0[1-9]|[12]\\d|3[01])\\/(19|20)\\d{2}$/;\n\nconsole.log(dateRegex.test('12/25/2024')); // true\nconsole.log(dateRegex.test('13/01/2024')); // false\n\n// 9. Named capture groups\nconst nameRegex = /(?<first>\\w+)\\s+(?<last>\\w+)/;\nconst match = 'John Doe'.match(nameRegex);\nconsole.log(match.groups.first); // 'John'\nconsole.log(match.groups.last);  // 'Doe'\n\n// 10. Replacing with function\nconst text2 = 'Hello world';\nconst result = text2.replace(/\\b\\w/g, match => match.toUpperCase());\nconsole.log(result); // 'Hello World'\n\n// 11. Finding duplicates\nconst duplicateRegex = /\\b(\\w+)\\s+\\1\\b/gi;\nconst text3 = 'This is is a test test';\nconsole.log(text3.match(duplicateRegex)); // ['is is', 'test test']\n\n// 12. Escaping special characters\nfunction escapeRegex(str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nconst escaped = escapeRegex('Hello (world)');\nconsole.log(escaped); // 'Hello \\\\(world\\\\)'\n\n// 13. Split by multiple delimiters\nconst data = 'a,b;c|d';\nconst parts = data.split(/[,;|]/);\nconsole.log(parts); // ['a', 'b', 'c', 'd']\n\n// 14. Lookahead/lookbehind\n// Positive lookahead: match 'foo' followed by 'bar'\nconst lookahead = /foo(?=bar)/;\nconsole.log(lookahead.test('foobar')); // true\nconsole.log(lookahead.test('foobaz')); // false\n\n// Negative lookahead: match 'foo' NOT followed by 'bar'\nconst negLookahead = /foo(?!bar)/;\nconsole.log(negLookahead.test('foobaz')); // true\n\n// 15. Performance - avoid catastrophic backtracking\n// Bad: can cause ReDoS\nconst bad = /(a+)+b/;\n// Good: more specific\nconst good = /a+b/;"
    },
    {
      "id": 83,
      "question": "What are JavaScript functional programming concepts?",
      "answer": "Functional programming is a paradigm emphasizing pure functions and immutability.\n\nCore Concepts:\n\n1. Pure Functions:\n• No side effects\n• Same input, same output\n• Predictable and testable\n• No external state mutation\n\n2. Immutability:\n• Data never changes\n• Create new copies\n• Prevent bugs\n• Easier reasoning\n\n3. First-Class Functions:\n• Functions as values\n• Pass as arguments\n• Return from functions\n• Assign to variables\n\n4. Higher-Order Functions:\n• Accept functions as arguments\n• Return functions\n• Map, filter, reduce\n• Function composition\n\n5. Declarative Style:\n• What, not how\n• Readable code\n• Less imperative\n\n6. Function Composition:\n• Combine simple functions\n• Build complex behavior\n• Reusability\n• Pipe and compose\n\n7. Currying:\n• Partial application\n• Transform multi-arg to single-arg\n• Reusable functions\n\n8. Recursion:\n• Self-calling functions\n• Replace loops\n• Base case needed\n\nBenefits:\n• Easier testing\n• Better parallelization\n• Fewer bugs\n• Reusable code\n• Predictable behavior\n\nLibraries:\n• Lodash/fp\n• Ramda\n• Immutable.js",
      "explanation": "Functional programming uses pure functions (no side effects), immutability (no mutations), higher-order functions (map, filter, reduce), composition (combine functions), and currying (partial application) for predictable, testable code.",
      "difficulty": "Hard",
      "code": "// 1. Pure functions\n// Impure - modifies external state\nlet total = 0;\nfunction addImpure(value) {\n  total += value; // Side effect!\n  return total;\n}\n\n// Pure - no side effects\nfunction addPure(a, b) {\n  return a + b; // Always same output for same input\n}\n\nconsole.log(addPure(5, 3)); // 8\nconsole.log(addPure(5, 3)); // 8 (predictable)\n\n// 2. Immutability\n// Mutating (bad)\nconst arr = [1, 2, 3];\narr.push(4); // Mutates!\n\n// Immutable (good)\nconst arr2 = [1, 2, 3];\nconst newArr = [...arr2, 4]; // New array\nconsole.log(arr2);   // [1, 2, 3] (unchanged)\nconsole.log(newArr); // [1, 2, 3, 4]\n\n// Object immutability\nconst person = { name: 'John', age: 30 };\nconst updated = { ...person, age: 31 }; // New object\n\n// 3. First-class functions\nconst greet = function(name) {\n  return `Hello, ${name}!`;\n};\n\n// Pass as argument\nfunction execute(fn, value) {\n  return fn(value);\n}\n\nconsole.log(execute(greet, 'World')); // 'Hello, World!'\n\n// Return from function\nfunction createMultiplier(factor) {\n  return function(x) {\n    return x * factor;\n  };\n}\n\nconst double = createMultiplier(2);\nconsole.log(double(5)); // 10\n\n// 4. Higher-order functions\nconst numbers = [1, 2, 3, 4, 5];\n\n// map\nconst squared = numbers.map(n => n ** 2);\nconsole.log(squared); // [1, 4, 9, 16, 25]\n\n// filter\nconst evens = numbers.filter(n => n % 2 === 0);\nconsole.log(evens); // [2, 4]\n\n// reduce\nconst sum = numbers.reduce((acc, n) => acc + n, 0);\nconsole.log(sum); // 15\n\n// 5. Function composition\nconst compose = (...fns) => x =>\n  fns.reduceRight((acc, fn) => fn(acc), x);\n\nconst pipe = (...fns) => x =>\n  fns.reduce((acc, fn) => fn(acc), x);\n\nconst add5 = x => x + 5;\nconst multiply3 = x => x * 3;\nconst subtract2 = x => x - 2;\n\n// Compose: right to left\nconst composed = compose(subtract2, multiply3, add5);\nconsole.log(composed(10)); // (10 + 5) * 3 - 2 = 43\n\n// Pipe: left to right\nconst piped = pipe(add5, multiply3, subtract2);\nconsole.log(piped(10)); // (10 + 5) * 3 - 2 = 43\n\n// 6. Currying\n// Non-curried\nfunction add(a, b, c) {\n  return a + b + c;\n}\n\n// Curried\nconst addCurried = a => b => c => a + b + c;\n\nconsole.log(addCurried(1)(2)(3)); // 6\n\n// Partial application\nconst add1 = addCurried(1);\nconst add1and2 = add1(2);\nconsole.log(add1and2(3)); // 6\n\n// Auto-curry function\nfunction curry(fn) {\n  return function curried(...args) {\n    if (args.length >= fn.length) {\n      return fn.apply(this, args);\n    }\n    return function(...nextArgs) {\n      return curried.apply(this, args.concat(nextArgs));\n    };\n  };\n}\n\nconst curriedAdd = curry(add);\nconsole.log(curriedAdd(1)(2)(3));    // 6\nconsole.log(curriedAdd(1, 2)(3));    // 6\nconsole.log(curriedAdd(1)(2, 3));    // 6\n\n// 7. Recursion\n// Factorial\nfunction factorial(n) {\n  if (n <= 1) return 1;\n  return n * factorial(n - 1);\n}\n\nconsole.log(factorial(5)); // 120\n\n// Tail recursion\nfunction factorialTail(n, acc = 1) {\n  if (n <= 1) return acc;\n  return factorialTail(n - 1, n * acc);\n}\n\n// Array recursion\nfunction sumArray(arr) {\n  if (arr.length === 0) return 0;\n  return arr[0] + sumArray(arr.slice(1));\n}\n\nconsole.log(sumArray([1, 2, 3, 4, 5])); // 15\n\n// 8. Declarative vs Imperative\n// Imperative (how)\nconst nums = [1, 2, 3, 4, 5];\nconst doubled = [];\nfor (let i = 0; i < nums.length; i++) {\n  doubled.push(nums[i] * 2);\n}\n\n// Declarative (what)\nconst doubled2 = nums.map(n => n * 2);\n\n// 9. Point-free style\n// Not point-free\nconst increment = x => x + 1;\nconst numbers2 = [1, 2, 3];\nconst incremented = numbers2.map(x => increment(x));\n\n// Point-free\nconst incremented2 = numbers2.map(increment);\n\n// 10. Practical example: data pipeline\nconst users = [\n  { name: 'john', age: 30, active: true },\n  { name: 'jane', age: 25, active: false },\n  { name: 'bob', age: 35, active: true }\n];\n\n// Imperative\nconst result1 = [];\nfor (const user of users) {\n  if (user.active) {\n    const transformed = {\n      name: user.name.toUpperCase(),\n      age: user.age\n    };\n    result1.push(transformed);\n  }\n}\n\n// Functional\nconst result2 = users\n  .filter(u => u.active)\n  .map(u => ({\n    name: u.name.toUpperCase(),\n    age: u.age\n  }));\n\nconsole.log(result2);\n// [{ name: 'JOHN', age: 30 }, { name: 'BOB', age: 35 }]"
    },
    {
      "id": 84,
      "question": "What are JavaScript data structures beyond arrays and objects?",
      "answer": "JavaScript provides built-in data structures beyond basic arrays and objects.\n\nMap:\n• Key-value pairs\n• Any type as key\n• Maintains insertion order\n• size property\n• Better for frequent additions/deletions\n\nSet:\n• Unique values\n• Any type\n• Maintains insertion order\n• Fast membership testing\n• No duplicates automatically\n\nWeakMap:\n• Object keys only\n• Garbage collectable\n• No enumeration\n• Private data storage\n\nWeakSet:\n• Object values only\n• Garbage collectable\n• No enumeration\n• Uniqueness checking\n\nTypedArray:\n• Fixed-length arrays\n• Specific numeric types\n• Better performance\n• Binary data handling\n• ArrayBuffer backed\n\nCustom Structures:\n\n1. Stack:\n• LIFO (Last In, First Out)\n• push/pop operations\n• Function call stack\n\n2. Queue:\n• FIFO (First In, First Out)\n• enqueue/dequeue\n• Task scheduling\n\n3. Linked List:\n• Node-based\n• Dynamic size\n• Efficient insertions\n\n4. Tree:\n• Hierarchical\n• Parent-child relationships\n• DOM is a tree\n\n5. Graph:\n• Nodes and edges\n• Relationships\n• Social networks",
      "explanation": "Beyond arrays/objects, JavaScript has Map (any-key pairs), Set (unique values), WeakMap/WeakSet (garbage collectable), TypedArray (binary data), and custom structures like Stack (LIFO), Queue (FIFO), Linked List, Tree, Graph.",
      "difficulty": "Hard",
      "code": "// 1. Map - key-value with any type keys\nconst map = new Map();\n\nmap.set('string', 'value');\nmap.set(42, 'number key');\nmap.set({ id: 1 }, 'object key');\n\nconsole.log(map.get('string')); // 'value'\nconsole.log(map.size); // 3\nconsole.log(map.has(42)); // true\n\nmap.delete('string');\nmap.clear(); // Remove all\n\n// Iteration\nconst map2 = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3]\n]);\n\nfor (const [key, value] of map2) {\n  console.log(key, value);\n}\n\n// 2. Set - unique values\nconst set = new Set([1, 2, 3, 2, 1]);\nconsole.log(set); // Set { 1, 2, 3 }\n\nset.add(4);\nset.add(2); // Ignored (already exists)\nconsole.log(set.has(3)); // true\nset.delete(2);\n\n// Remove duplicates from array\nconst arr = [1, 2, 2, 3, 3, 4];\nconst unique = [...new Set(arr)];\nconsole.log(unique); // [1, 2, 3, 4]\n\n// Set operations\nconst setA = new Set([1, 2, 3]);\nconst setB = new Set([2, 3, 4]);\n\n// Union\nconst union = new Set([...setA, ...setB]);\nconsole.log(union); // Set { 1, 2, 3, 4 }\n\n// Intersection\nconst intersection = new Set(\n  [...setA].filter(x => setB.has(x))\n);\nconsole.log(intersection); // Set { 2, 3 }\n\n// Difference\nconst difference = new Set(\n  [...setA].filter(x => !setB.has(x))\n);\nconsole.log(difference); // Set { 1 }\n\n// 3. WeakMap - garbage collectable\nconst weakMap = new WeakMap();\nlet obj = { id: 1 };\n\nweakMap.set(obj, 'metadata');\nconsole.log(weakMap.get(obj)); // 'metadata'\n\nobj = null; // Object can be garbage collected\n\n// 4. TypedArray - binary data\nconst buffer = new ArrayBuffer(16); // 16 bytes\nconst view = new Uint8Array(buffer);\n\nview[0] = 255;\nview[1] = 128;\nconsole.log(view); // Uint8Array [255, 128, 0, ...]\n\n// Different views of same buffer\nconst view16 = new Uint16Array(buffer);\nconst view32 = new Uint32Array(buffer);\n\n// 5. Stack implementation\nclass Stack {\n  constructor() {\n    this.items = [];\n  }\n  \n  push(item) {\n    this.items.push(item);\n  }\n  \n  pop() {\n    return this.items.pop();\n  }\n  \n  peek() {\n    return this.items[this.items.length - 1];\n  }\n  \n  isEmpty() {\n    return this.items.length === 0;\n  }\n}\n\nconst stack = new Stack();\nstack.push(1);\nstack.push(2);\nconsole.log(stack.pop()); // 2 (LIFO)\n\n// 6. Queue implementation\nclass Queue {\n  constructor() {\n    this.items = [];\n  }\n  \n  enqueue(item) {\n    this.items.push(item);\n  }\n  \n  dequeue() {\n    return this.items.shift();\n  }\n  \n  front() {\n    return this.items[0];\n  }\n  \n  isEmpty() {\n    return this.items.length === 0;\n  }\n}\n\nconst queue = new Queue();\nqueue.enqueue(1);\nqueue.enqueue(2);\nconsole.log(queue.dequeue()); // 1 (FIFO)\n\n// 7. Linked List\nclass Node {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nclass LinkedList {\n  constructor() {\n    this.head = null;\n  }\n  \n  append(value) {\n    const node = new Node(value);\n    \n    if (!this.head) {\n      this.head = node;\n      return;\n    }\n    \n    let current = this.head;\n    while (current.next) {\n      current = current.next;\n    }\n    current.next = node;\n  }\n  \n  toArray() {\n    const result = [];\n    let current = this.head;\n    \n    while (current) {\n      result.push(current.value);\n      current = current.next;\n    }\n    \n    return result;\n  }\n}\n\nconst list = new LinkedList();\nlist.append(1);\nlist.append(2);\nlist.append(3);\nconsole.log(list.toArray()); // [1, 2, 3]\n\n// 8. Binary Tree\nclass TreeNode {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nclass BinaryTree {\n  constructor() {\n    this.root = null;\n  }\n  \n  insert(value) {\n    const node = new TreeNode(value);\n    \n    if (!this.root) {\n      this.root = node;\n      return;\n    }\n    \n    this.insertNode(this.root, node);\n  }\n  \n  insertNode(root, node) {\n    if (node.value < root.value) {\n      if (!root.left) {\n        root.left = node;\n      } else {\n        this.insertNode(root.left, node);\n      }\n    } else {\n      if (!root.right) {\n        root.right = node;\n      } else {\n        this.insertNode(root.right, node);\n      }\n    }\n  }\n  \n  inOrder(node = this.root, result = []) {\n    if (node) {\n      this.inOrder(node.left, result);\n      result.push(node.value);\n      this.inOrder(node.right, result);\n    }\n    return result;\n  }\n}\n\nconst tree = new BinaryTree();\ntree.insert(5);\ntree.insert(3);\ntree.insert(7);\ntree.insert(1);\nconsole.log(tree.inOrder()); // [1, 3, 5, 7]\n\n// 9. Graph\nclass Graph {\n  constructor() {\n    this.adjacencyList = new Map();\n  }\n  \n  addVertex(vertex) {\n    if (!this.adjacencyList.has(vertex)) {\n      this.adjacencyList.set(vertex, []);\n    }\n  }\n  \n  addEdge(v1, v2) {\n    this.adjacencyList.get(v1).push(v2);\n    this.adjacencyList.get(v2).push(v1); // Undirected\n  }\n  \n  bfs(start) {\n    const queue = [start];\n    const result = [];\n    const visited = new Set();\n    visited.add(start);\n    \n    while (queue.length) {\n      const vertex = queue.shift();\n      result.push(vertex);\n      \n      this.adjacencyList.get(vertex).forEach(neighbor => {\n        if (!visited.has(neighbor)) {\n          visited.add(neighbor);\n          queue.push(neighbor);\n        }\n      });\n    }\n    \n    return result;\n  }\n}\n\nconst graph = new Graph();\ngraph.addVertex('A');\ngraph.addVertex('B');\ngraph.addVertex('C');\ngraph.addEdge('A', 'B');\ngraph.addEdge('A', 'C');\nconsole.log(graph.bfs('A')); // ['A', 'B', 'C']"
    },
    {
      "id": 85,
      "question": "What are JavaScript metaprogramming techniques?",
      "answer": "Metaprogramming involves code that can inspect, modify, or generate other code at runtime.\n\nKey Techniques:\n\n1. Reflection:\n• Inspect code structure\n• typeof, instanceof\n• Object methods\n• Reflect API\n\n2. Proxies:\n• Intercept operations\n• Custom behavior\n• Validation\n• Observable objects\n\n3. Property Descriptors:\n• Control property behavior\n• Getters and setters\n• Enumerable, writable\n• defineProperty\n\n4. Symbols:\n• Unique identifiers\n• Well-known symbols\n• Custom behavior\n• Symbol.iterator, etc.\n\n5. eval and Function:\n• Dynamic code execution\n• Security risks\n• Rarely recommended\n• Limited use cases\n\n6. Decorators:\n• Modify class/method behavior\n• Stage 3 proposal\n• Transpiler needed\n• Aspect-oriented programming\n\n7. Mixins:\n• Share functionality\n• Multiple inheritance\n• Composition\n• Object.assign\n\nUse Cases:\n• Framework development\n• ORM libraries\n• Testing frameworks\n• Validation systems\n• Logging and profiling\n• Reactive systems\n\nCautions:\n• Performance overhead\n• Complexity\n• Debugging difficulty\n• Use sparingly",
      "explanation": "Metaprogramming includes reflection (inspect code), proxies (intercept operations), property descriptors (control behavior), symbols (unique identifiers), decorators (modify classes), and mixins (composition) for advanced runtime code manipulation.",
      "difficulty": "Hard",
      "code": "// 1. Reflection with typeof and instanceof\nfunction inspect(value) {\n  console.log('Type:', typeof value);\n  console.log('Constructor:', value.constructor?.name);\n  \n  if (typeof value === 'object' && value !== null) {\n    console.log('Keys:', Object.keys(value));\n    console.log('Prototype:', Object.getPrototypeOf(value));\n  }\n}\n\ninspect({ x: 1, y: 2 });\n\n// 2. Reflect API\nconst obj = { x: 1, y: 2 };\n\nconsole.log(Reflect.has(obj, 'x'));        // true\nReflect.set(obj, 'z', 3);\nReflect.deleteProperty(obj, 'y');\nconsole.log(Reflect.ownKeys(obj));         // ['x', 'z']\n\n// 3. Property descriptors\nconst person = {};\n\nObject.defineProperty(person, 'name', {\n  value: 'John',\n  writable: false,     // Cannot reassign\n  enumerable: true,    // Shows in for...in\n  configurable: false  // Cannot delete\n});\n\nperson.name = 'Jane'; // Silently fails (throws in strict)\nconsole.log(person.name); // 'John'\n\n// Getters and setters\nObject.defineProperty(person, 'age', {\n  get() {\n    return this._age || 0;\n  },\n  set(value) {\n    if (value < 0) {\n      throw new Error('Age must be positive');\n    }\n    this._age = value;\n  },\n  enumerable: true\n});\n\nperson.age = 30;\nconsole.log(person.age); // 30\n\n// 4. Proxy for validation\nconst validator = {\n  set(target, prop, value) {\n    if (prop === 'age') {\n      if (typeof value !== 'number') {\n        throw new TypeError('Age must be a number');\n      }\n      if (value < 0 || value > 150) {\n        throw new RangeError('Age must be 0-150');\n      }\n    }\n    target[prop] = value;\n    return true;\n  }\n};\n\nconst validatedPerson = new Proxy({}, validator);\nvalidatedPerson.age = 30;  // OK\n// validatedPerson.age = -5;  // Error\n// validatedPerson.age = 'thirty'; // Error\n\n// 5. Observable with Proxy\nfunction createObservable(target, onChange) {\n  return new Proxy(target, {\n    set(obj, prop, value) {\n      const oldValue = obj[prop];\n      obj[prop] = value;\n      onChange(prop, oldValue, value);\n      return true;\n    }\n  });\n}\n\nconst state = createObservable({}, (prop, oldVal, newVal) => {\n  console.log(`${prop} changed from ${oldVal} to ${newVal}`);\n});\n\nstate.count = 0;  // count changed from undefined to 0\nstate.count = 1;  // count changed from 0 to 1\n\n// 6. Symbols for custom behavior\nclass Collection {\n  constructor(...items) {\n    this.items = items;\n  }\n  \n  // Custom iterator\n  [Symbol.iterator]() {\n    let index = 0;\n    return {\n      next: () => {\n        if (index < this.items.length) {\n          return { value: this.items[index++], done: false };\n        }\n        return { done: true };\n      }\n    };\n  }\n  \n  // Custom toString\n  [Symbol.toStringTag]() {\n    return 'Collection';\n  }\n}\n\nconst collection = new Collection(1, 2, 3);\n\nfor (const item of collection) {\n  console.log(item); // 1, 2, 3\n}\n\n// 7. Mixins\nconst canEat = {\n  eat(food) {\n    console.log(`${this.name} is eating ${food}`);\n  }\n};\n\nconst canWalk = {\n  walk() {\n    console.log(`${this.name} is walking`);\n  }\n};\n\nfunction mixin(target, ...sources) {\n  Object.assign(target, ...sources);\n}\n\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nmixin(Animal.prototype, canEat, canWalk);\n\nconst dog = new Animal('Rex');\ndog.eat('food');  // Rex is eating food\ndog.walk();       // Rex is walking\n\n// 8. Dynamic method creation\nclass DynamicClass {\n  constructor(methods) {\n    methods.forEach(method => {\n      this[method.name] = method.fn;\n    });\n  }\n}\n\nconst dynamic = new DynamicClass([\n  { name: 'greet', fn: function() { console.log('Hello'); } },\n  { name: 'farewell', fn: function() { console.log('Goodbye'); } }\n]);\n\ndynamic.greet();     // Hello\ndynamic.farewell();  // Goodbye\n\n// 9. Method chaining with Proxy\nfunction createChainable(obj) {\n  const calls = [];\n  \n  return new Proxy(obj, {\n    get(target, prop) {\n      if (prop === 'execute') {\n        return () => {\n          calls.forEach(([method, args]) => {\n            target[method](...args);\n          });\n        };\n      }\n      \n      return (...args) => {\n        calls.push([prop, args]);\n        return this;\n      };\n    }\n  });\n}\n\nconst calculator = {\n  value: 0,\n  add(n) { this.value += n; },\n  multiply(n) { this.value *= n; },\n  log() { console.log(this.value); }\n};\n\nconst chainable = createChainable(calculator);\nchainable.add(5).multiply(2).log().execute();\n// Logs: 10\n\n// 10. Type checking at runtime\nfunction typed(types) {\n  return function(target, name, descriptor) {\n    const original = descriptor.value;\n    \n    descriptor.value = function(...args) {\n      args.forEach((arg, i) => {\n        if (typeof arg !== types[i]) {\n          throw new TypeError(\n            `Argument ${i} must be ${types[i]}, got ${typeof arg}`\n          );\n        }\n      });\n      \n      return original.apply(this, args);\n    };\n    \n    return descriptor;\n  };\n}\n\n// Usage (requires decorator support)\nclass Math {\n  @typed(['number', 'number'])\n  add(a, b) {\n    return a + b;\n  }\n}"
    },
    {
      "id": 86,
      "question": "What are JavaScript Web APIs and browser APIs?",
      "answer": "Web APIs provide interfaces for interacting with the browser and web platform.\n\nDocument Object Model (DOM):\n• Access and manipulate HTML\n• querySelector, getElementById\n• createElement, appendChild\n• Event listeners\n• Style manipulation\n\nFetch API:\n• HTTP requests\n• Promise-based\n• Replaces XMLHttpRequest\n• Modern and cleaner\n• Request/Response objects\n\nStorage APIs:\n• localStorage - persistent\n• sessionStorage - session only\n• IndexedDB - database\n• Cookies - small data with server\n\nCanvas and WebGL:\n• 2D drawing (Canvas)\n• 3D graphics (WebGL)\n• Animations\n• Game development\n• Data visualization\n\nGeolocation API:\n• Get user location\n• GPS coordinates\n• Permission required\n• getCurrentPosition\n\nNotification API:\n• Desktop notifications\n• Permission-based\n• User engagement\n• Service worker integration\n\nWebSocket API:\n• Real-time communication\n• Bidirectional\n• Persistent connection\n• Low latency\n\nWeb Workers:\n• Background threads\n• CPU-intensive tasks\n• No DOM access\n• postMessage communication\n\nIntersection Observer:\n• Track element visibility\n• Lazy loading\n• Infinite scroll\n• Performance friendly\n\nMutation Observer:\n• Watch DOM changes\n• React to modifications\n• Efficient monitoring",
      "explanation": "Web APIs include DOM (HTML manipulation), Fetch (HTTP requests), Storage (localStorage, IndexedDB), Canvas/WebGL (graphics), Geolocation (location), WebSocket (real-time), Workers (background threads), and Observers (visibility, mutations).",
      "difficulty": "Medium",
      "code": "// 1. DOM Manipulation\nconst div = document.createElement('div');\ndiv.id = 'myDiv';\ndiv.className = 'container';\ndiv.textContent = 'Hello World';\ndiv.style.color = 'blue';\n\ndocument.body.appendChild(div);\n\n// Query selectors\nconst element = document.querySelector('.container');\nconst elements = document.querySelectorAll('div');\n\n// Event listeners\nelement.addEventListener('click', (e) => {\n  console.log('Clicked!', e.target);\n});\n\n// 2. Fetch API\nasync function getData() {\n  try {\n    const response = await fetch('https://api.example.com/data');\n    \n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('Fetch error:', error);\n  }\n}\n\n// POST request\nasync function postData(data) {\n  const response = await fetch('https://api.example.com/data', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(data)\n  });\n  \n  return response.json();\n}\n\n// 3. LocalStorage\n// Save\nlocalStorage.setItem('user', JSON.stringify({ name: 'John', age: 30 }));\n\n// Retrieve\nconst user = JSON.parse(localStorage.getItem('user'));\n\n// Remove\nlocalStorage.removeItem('user');\n\n// Clear all\nlocalStorage.clear();\n\n// 4. Geolocation\nif ('geolocation' in navigator) {\n  navigator.geolocation.getCurrentPosition(\n    (position) => {\n      const { latitude, longitude } = position.coords;\n      console.log(`Lat: ${latitude}, Lon: ${longitude}`);\n    },\n    (error) => {\n      console.error('Geolocation error:', error.message);\n    },\n    {\n      enableHighAccuracy: true,\n      timeout: 5000,\n      maximumAge: 0\n    }\n  );\n}\n\n// Watch position\nconst watchId = navigator.geolocation.watchPosition(\n  (position) => {\n    console.log('Position updated:', position.coords);\n  }\n);\n\n// Stop watching\nnavigator.geolocation.clearWatch(watchId);\n\n// 5. Notifications\nasync function showNotification() {\n  // Request permission\n  const permission = await Notification.requestPermission();\n  \n  if (permission === 'granted') {\n    new Notification('Hello!', {\n      body: 'This is a notification',\n      icon: '/icon.png',\n      tag: 'unique-tag',\n      requireInteraction: true\n    });\n  }\n}\n\n// 6. WebSocket\nconst socket = new WebSocket('wss://example.com/socket');\n\nsocket.addEventListener('open', (event) => {\n  console.log('Connected');\n  socket.send('Hello Server!');\n});\n\nsocket.addEventListener('message', (event) => {\n  console.log('Message from server:', event.data);\n});\n\nsocket.addEventListener('error', (event) => {\n  console.error('WebSocket error:', event);\n});\n\nsocket.addEventListener('close', (event) => {\n  console.log('Disconnected');\n});\n\n// Close connection\nsocket.close();\n\n// 7. Web Workers\n// main.js\nconst worker = new Worker('worker.js');\n\nworker.postMessage({ type: 'start', data: [1, 2, 3, 4, 5] });\n\nworker.onmessage = (e) => {\n  console.log('Result from worker:', e.data);\n};\n\nworker.onerror = (e) => {\n  console.error('Worker error:', e.message);\n};\n\n// worker.js\n/* \nself.onmessage = (e) => {\n  const { type, data } = e.data;\n  \n  if (type === 'start') {\n    // CPU-intensive task\n    const result = data.reduce((acc, n) => acc + n, 0);\n    self.postMessage(result);\n  }\n};\n*/\n\n// 8. Intersection Observer - Lazy loading\nconst observer = new IntersectionObserver(\n  (entries) => {\n    entries.forEach(entry => {\n      if (entry.isIntersecting) {\n        const img = entry.target;\n        img.src = img.dataset.src;\n        observer.unobserve(img);\n      }\n    });\n  },\n  {\n    root: null,        // viewport\n    rootMargin: '0px',\n    threshold: 0.1     // 10% visible\n  }\n);\n\n// Observe images\ndocument.querySelectorAll('img[data-src]').forEach(img => {\n  observer.observe(img);\n});\n\n// 9. Mutation Observer - Watch DOM changes\nconst mutationObserver = new MutationObserver((mutations) => {\n  mutations.forEach(mutation => {\n    if (mutation.type === 'childList') {\n      console.log('Child nodes changed:', mutation);\n    } else if (mutation.type === 'attributes') {\n      console.log('Attribute changed:', mutation.attributeName);\n    }\n  });\n});\n\nconst targetNode = document.getElementById('myDiv');\nmutationObserver.observe(targetNode, {\n  childList: true,\n  attributes: true,\n  subtree: true,\n  attributeOldValue: true\n});\n\n// Stop observing\nmutationObserver.disconnect();\n\n// 10. Canvas API\nconst canvas = document.createElement('canvas');\ncanvas.width = 400;\ncanvas.height = 400;\ndocument.body.appendChild(canvas);\n\nconst ctx = canvas.getContext('2d');\n\n// Draw rectangle\nctx.fillStyle = 'blue';\nctx.fillRect(50, 50, 100, 100);\n\n// Draw circle\nctx.beginPath();\nctx.arc(200, 200, 50, 0, Math.PI * 2);\nctx.fillStyle = 'red';\nctx.fill();\n\n// Draw text\nctx.font = '30px Arial';\nctx.fillStyle = 'black';\nctx.fillText('Hello Canvas', 50, 300);\n\n// Animation\nfunction animate() {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  // Draw frame\n  requestAnimationFrame(animate);\n}\nanimate();\n\n// 11. History API\n// Navigate without page reload\nhistory.pushState({ page: 1 }, 'Page 1', '/page1');\nhistory.replaceState({ page: 2 }, 'Page 2', '/page2');\nhistory.back();\nhistory.forward();\nhistory.go(-2);\n\nwindow.addEventListener('popstate', (event) => {\n  console.log('State:', event.state);\n});\n\n// 12. Performance API\nconst start = performance.now();\n\n// Some operation\nfor (let i = 0; i < 1000000; i++) {}\n\nconst end = performance.now();\nconsole.log(`Operation took ${end - start}ms`);\n\n// Performance marks\nperformance.mark('start-task');\n// Do task\nperformance.mark('end-task');\nperformance.measure('task-duration', 'start-task', 'end-task');\n\nconst measures = performance.getEntriesByType('measure');\nconsole.log(measures);"
    },
    {
      "id": 87,
      "question": "What are JavaScript design patterns for modern applications?",
      "answer": "Design patterns provide reusable solutions to common programming problems.\n\nCreational Patterns:\n\n1. Module Pattern:\n• Encapsulation\n• Private/public members\n• IIFE-based\n• ES6 modules\n\n2. Singleton:\n• Single instance\n• Global access\n• Lazy initialization\n• State management\n\n3. Factory:\n• Object creation\n• Abstraction\n• Flexibility\n• Polymorphism\n\n4. Builder:\n• Step-by-step construction\n• Complex objects\n• Method chaining\n• Readability\n\nStructural Patterns:\n\n1. Decorator:\n• Add functionality\n• Wrapper pattern\n• Open/closed principle\n• Composition over inheritance\n\n2. Adapter:\n• Interface conversion\n• Legacy code integration\n• Third-party libraries\n\n3. Facade:\n• Simplified interface\n• Complex subsystem\n• Hide complexity\n\n4. Proxy:\n• Access control\n• Lazy loading\n• Caching\n• Logging\n\nBehavioral Patterns:\n\n1. Observer:\n• Event system\n• Publisher-subscriber\n• Loose coupling\n• React state\n\n2. Strategy:\n• Algorithm selection\n• Runtime behavior\n• Avoid conditionals\n\n3. Command:\n• Action encapsulation\n• Undo/redo\n• Queue operations\n\n4. Iterator:\n• Sequential access\n• Custom iteration\n• Generator functions",
      "explanation": "Design patterns include creational (Module, Singleton, Factory, Builder), structural (Decorator, Adapter, Facade, Proxy), and behavioral (Observer, Strategy, Command, Iterator) patterns for organized, maintainable code.",
      "difficulty": "Hard",
      "code": "// 1. Module Pattern (ES6)\nconst UserModule = (() => {\n  // Private\n  let users = [];\n  \n  function validate(user) {\n    return user.name && user.email;\n  }\n  \n  // Public API\n  return {\n    addUser(user) {\n      if (validate(user)) {\n        users.push(user);\n        return true;\n      }\n      return false;\n    },\n    \n    getUsers() {\n      return [...users]; // Copy\n    }\n  };\n})();\n\nUserModule.addUser({ name: 'John', email: 'john@example.com' });\nconsole.log(UserModule.getUsers());\n\n// 2. Singleton\nclass Database {\n  constructor() {\n    if (Database.instance) {\n      return Database.instance;\n    }\n    \n    this.connection = null;\n    Database.instance = this;\n  }\n  \n  connect() {\n    if (!this.connection) {\n      this.connection = 'Connected';\n      console.log('Database connected');\n    }\n    return this.connection;\n  }\n}\n\nconst db1 = new Database();\nconst db2 = new Database();\nconsole.log(db1 === db2); // true (same instance)\n\n// 3. Factory Pattern\nclass Car {\n  constructor(model) {\n    this.model = model;\n    this.type = 'car';\n  }\n}\n\nclass Truck {\n  constructor(model) {\n    this.model = model;\n    this.type = 'truck';\n  }\n}\n\nclass VehicleFactory {\n  createVehicle(type, model) {\n    switch (type) {\n      case 'car':\n        return new Car(model);\n      case 'truck':\n        return new Truck(model);\n      default:\n        throw new Error('Unknown vehicle type');\n    }\n  }\n}\n\nconst factory = new VehicleFactory();\nconst car = factory.createVehicle('car', 'Sedan');\nconst truck = factory.createVehicle('truck', 'Pickup');\n\n// 4. Builder Pattern\nclass HttpRequestBuilder {\n  constructor() {\n    this.url = '';\n    this.method = 'GET';\n    this.headers = {};\n    this.body = null;\n  }\n  \n  setUrl(url) {\n    this.url = url;\n    return this;\n  }\n  \n  setMethod(method) {\n    this.method = method;\n    return this;\n  }\n  \n  setHeader(key, value) {\n    this.headers[key] = value;\n    return this;\n  }\n  \n  setBody(body) {\n    this.body = body;\n    return this;\n  }\n  \n  build() {\n    return {\n      url: this.url,\n      method: this.method,\n      headers: this.headers,\n      body: this.body\n    };\n  }\n}\n\nconst request = new HttpRequestBuilder()\n  .setUrl('https://api.example.com')\n  .setMethod('POST')\n  .setHeader('Content-Type', 'application/json')\n  .setBody({ data: 'value' })\n  .build();\n\n// 5. Observer Pattern\nclass EventEmitter {\n  constructor() {\n    this.events = {};\n  }\n  \n  on(event, listener) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    this.events[event].push(listener);\n  }\n  \n  emit(event, ...args) {\n    if (this.events[event]) {\n      this.events[event].forEach(listener => {\n        listener(...args);\n      });\n    }\n  }\n  \n  off(event, listenerToRemove) {\n    if (this.events[event]) {\n      this.events[event] = this.events[event].filter(\n        listener => listener !== listenerToRemove\n      );\n    }\n  }\n}\n\nconst emitter = new EventEmitter();\n\nemitter.on('data', (data) => {\n  console.log('Received:', data);\n});\n\nemitter.emit('data', { value: 123 });\n\n// 6. Strategy Pattern\nclass PaymentContext {\n  constructor(strategy) {\n    this.strategy = strategy;\n  }\n  \n  setStrategy(strategy) {\n    this.strategy = strategy;\n  }\n  \n  pay(amount) {\n    return this.strategy.pay(amount);\n  }\n}\n\nclass CreditCardPayment {\n  pay(amount) {\n    console.log(`Paid $${amount} with credit card`);\n  }\n}\n\nclass PayPalPayment {\n  pay(amount) {\n    console.log(`Paid $${amount} with PayPal`);\n  }\n}\n\nconst payment = new PaymentContext(new CreditCardPayment());\npayment.pay(100);\n\npayment.setStrategy(new PayPalPayment());\npayment.pay(50);\n\n// 7. Decorator Pattern\nclass Coffee {\n  cost() {\n    return 5;\n  }\n}\n\nclass MilkDecorator {\n  constructor(coffee) {\n    this.coffee = coffee;\n  }\n  \n  cost() {\n    return this.coffee.cost() + 2;\n  }\n}\n\nclass SugarDecorator {\n  constructor(coffee) {\n    this.coffee = coffee;\n  }\n  \n  cost() {\n    return this.coffee.cost() + 1;\n  }\n}\n\nlet coffee = new Coffee();\nconsole.log(coffee.cost()); // 5\n\ncoffee = new MilkDecorator(coffee);\nconsole.log(coffee.cost()); // 7\n\ncoffee = new SugarDecorator(coffee);\nconsole.log(coffee.cost()); // 8\n\n// 8. Proxy Pattern - Caching\nclass ExpensiveOperation {\n  process(data) {\n    console.log('Processing:', data);\n    // Expensive operation\n    return data.toUpperCase();\n  }\n}\n\nclass CachedProxy {\n  constructor(target) {\n    this.target = target;\n    this.cache = new Map();\n  }\n  \n  process(data) {\n    if (this.cache.has(data)) {\n      console.log('From cache');\n      return this.cache.get(data);\n    }\n    \n    const result = this.target.process(data);\n    this.cache.set(data, result);\n    return result;\n  }\n}\n\nconst operation = new ExpensiveOperation();\nconst proxy = new CachedProxy(operation);\n\nconsole.log(proxy.process('hello')); // Processing: hello -> HELLO\nconsole.log(proxy.process('hello')); // From cache -> HELLO\n\n// 9. Command Pattern - Undo/Redo\nclass Command {\n  execute() {}\n  undo() {}\n}\n\nclass AddCommand extends Command {\n  constructor(receiver, value) {\n    super();\n    this.receiver = receiver;\n    this.value = value;\n  }\n  \n  execute() {\n    this.receiver.value += this.value;\n  }\n  \n  undo() {\n    this.receiver.value -= this.value;\n  }\n}\n\nclass Calculator {\n  constructor() {\n    this.value = 0;\n    this.history = [];\n    this.undone = [];\n  }\n  \n  execute(command) {\n    command.execute();\n    this.history.push(command);\n    this.undone = [];\n  }\n  \n  undo() {\n    const command = this.history.pop();\n    if (command) {\n      command.undo();\n      this.undone.push(command);\n    }\n  }\n  \n  redo() {\n    const command = this.undone.pop();\n    if (command) {\n      command.execute();\n      this.history.push(command);\n    }\n  }\n}\n\nconst calc = new Calculator();\ncalc.execute(new AddCommand(calc, 10));\nconsole.log(calc.value); // 10\ncalc.execute(new AddCommand(calc, 5));\nconsole.log(calc.value); // 15\ncalc.undo();\nconsole.log(calc.value); // 10\ncalc.redo();\nconsole.log(calc.value); // 15\n\n// 10. Iterator Pattern\nclass Range {\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n  \n  [Symbol.iterator]() {\n    let current = this.start;\n    const end = this.end;\n    \n    return {\n      next() {\n        if (current <= end) {\n          return { value: current++, done: false };\n        }\n        return { done: true };\n      }\n    };\n  }\n}\n\nconst range = new Range(1, 5);\nfor (const num of range) {\n  console.log(num); // 1, 2, 3, 4, 5\n}"
    },
    {
      "id": 88,
      "question": "What are JavaScript testing frameworks and methodologies?",
      "answer": "Testing ensures code quality and reliability through various frameworks and approaches.\n\nTesting Frameworks:\n\n1. Jest:\n• Facebook-developed\n• Zero configuration\n• Snapshot testing\n• Code coverage\n• Mocking built-in\n• React friendly\n\n2. Mocha:\n• Flexible\n• Requires assertion library\n• Async testing\n• Browser and Node\n\n3. Jasmine:\n• Behavior-driven\n• No dependencies\n• Built-in assertions\n• Spies and mocks\n\n4. Cypress:\n• End-to-end testing\n• Real browser\n• Time travel\n• Automatic waiting\n\n5. Vitest:\n• Vite-powered\n• Jest compatible\n• Fast execution\n• ESM support\n\nTesting Types:\n\n1. Unit Testing:\n• Individual functions\n• Isolated components\n• Fast execution\n• High coverage\n\n2. Integration Testing:\n• Module interaction\n• API calls\n• Database connections\n• Component integration\n\n3. E2E Testing:\n• User workflows\n• Full application\n• Browser automation\n• Real scenarios\n\n4. Snapshot Testing:\n• UI component output\n• Detect changes\n• Visual regression\n\nBest Practices:\n• Arrange-Act-Assert\n• Test isolation\n• Meaningful names\n• Mock external dependencies\n• Fast execution\n• CI/CD integration",
      "explanation": "Testing frameworks include Jest (zero-config, snapshots), Mocha (flexible), Cypress (E2E), Vitest (fast) for unit testing (isolated), integration (interaction), E2E (workflows), and snapshot testing (UI) with AAA pattern and mocking.",
      "difficulty": "Medium",
      "code": "// 1. Jest - Unit Testing\n// sum.js\nfunction sum(a, b) {\n  return a + b;\n}\n\nmodule.exports = sum;\n\n// sum.test.js\nconst sum = require('./sum');\n\ntest('adds 1 + 2 to equal 3', () => {\n  expect(sum(1, 2)).toBe(3);\n});\n\ntest('adds negative numbers', () => {\n  expect(sum(-1, -2)).toBe(-3);\n});\n\n// 2. Describe blocks for organization\ndescribe('Math operations', () => {\n  describe('Addition', () => {\n    test('positive numbers', () => {\n      expect(sum(1, 2)).toBe(3);\n    });\n    \n    test('negative numbers', () => {\n      expect(sum(-1, -2)).toBe(-3);\n    });\n  });\n});\n\n// 3. Setup and teardown\nlet database;\n\nbeforeAll(() => {\n  // Runs once before all tests\n  database = connectToDatabase();\n});\n\nafterAll(() => {\n  // Runs once after all tests\n  database.disconnect();\n});\n\nbeforeEach(() => {\n  // Runs before each test\n  database.clear();\n});\n\nafterEach(() => {\n  // Runs after each test\n  database.cleanup();\n});\n\n// 4. Async testing\ntest('async function', async () => {\n  const data = await fetchData();\n  expect(data).toBe('peanut butter');\n});\n\ntest('promise', () => {\n  return fetchData().then(data => {\n    expect(data).toBe('peanut butter');\n  });\n});\n\n// 5. Mocking\n// userService.js\nconst axios = require('axios');\n\nasync function getUser(id) {\n  const response = await axios.get(`/users/${id}`);\n  return response.data;\n}\n\nmodule.exports = { getUser };\n\n// userService.test.js\nconst axios = require('axios');\nconst { getUser } = require('./userService');\n\njest.mock('axios');\n\ntest('fetches user data', async () => {\n  const user = { id: 1, name: 'John' };\n  axios.get.mockResolvedValue({ data: user });\n  \n  const result = await getUser(1);\n  \n  expect(axios.get).toHaveBeenCalledWith('/users/1');\n  expect(result).toEqual(user);\n});\n\n// 6. Spy functions\nconst mockCallback = jest.fn(x => x + 1);\n\n[1, 2, 3].forEach(mockCallback);\n\nexpect(mockCallback).toHaveBeenCalledTimes(3);\nexpect(mockCallback).toHaveBeenCalledWith(1);\nexpect(mockCallback).toHaveBeenLastCalledWith(3);\nexpect(mockCallback.mock.results[0].value).toBe(2);\n\n// 7. Snapshot testing\n// component.test.js\nconst React = require('react');\nconst renderer = require('react-test-renderer');\nconst Button = require('./Button');\n\ntest('renders correctly', () => {\n  const tree = renderer\n    .create(<Button label=\"Click me\" />)\n    .toJSON();\n  \n  expect(tree).toMatchSnapshot();\n});\n\n// 8. Matchers\ntest('various matchers', () => {\n  // Equality\n  expect(2 + 2).toBe(4);\n  expect({ a: 1 }).toEqual({ a: 1 });\n  \n  // Truthiness\n  expect(true).toBeTruthy();\n  expect(false).toBeFalsy();\n  expect(null).toBeNull();\n  expect(undefined).toBeUndefined();\n  \n  // Numbers\n  expect(5).toBeGreaterThan(3);\n  expect(5).toBeLessThanOrEqual(5);\n  expect(0.1 + 0.2).toBeCloseTo(0.3);\n  \n  // Strings\n  expect('team').toMatch(/tea/);\n  expect('hello').toContain('ell');\n  \n  // Arrays\n  expect([1, 2, 3]).toContain(2);\n  expect([1, 2, 3]).toHaveLength(3);\n  \n  // Objects\n  expect({ a: 1, b: 2 }).toHaveProperty('a');\n  expect({ a: 1, b: 2 }).toMatchObject({ a: 1 });\n  \n  // Exceptions\n  expect(() => {\n    throw new Error('error');\n  }).toThrow();\n  \n  expect(() => {\n    throw new Error('error');\n  }).toThrow('error');\n});\n\n// 9. Testing React components\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport Counter from './Counter';\n\ntest('increments counter', () => {\n  render(<Counter />);\n  \n  const button = screen.getByText('Increment');\n  const count = screen.getByText('Count: 0');\n  \n  expect(count).toBeInTheDocument();\n  \n  fireEvent.click(button);\n  \n  expect(screen.getByText('Count: 1')).toBeInTheDocument();\n});\n\n// 10. Integration testing\ndescribe('User registration flow', () => {\n  test('registers new user', async () => {\n    // Arrange\n    const userData = {\n      username: 'testuser',\n      email: 'test@example.com',\n      password: 'password123'\n    };\n    \n    // Act\n    const response = await registerUser(userData);\n    const user = await getUser(response.id);\n    \n    // Assert\n    expect(response.success).toBe(true);\n    expect(user.username).toBe(userData.username);\n    expect(user.email).toBe(userData.email);\n    expect(user.password).not.toBe(userData.password); // Hashed\n  });\n});\n\n// 11. Cypress - E2E Testing\n// cypress/integration/login.spec.js\ndescribe('Login Flow', () => {\n  beforeEach(() => {\n    cy.visit('/login');\n  });\n  \n  it('logs in successfully', () => {\n    cy.get('[data-testid=\"username\"]').type('testuser');\n    cy.get('[data-testid=\"password\"]').type('password123');\n    cy.get('[data-testid=\"submit\"]').click();\n    \n    cy.url().should('include', '/dashboard');\n    cy.get('[data-testid=\"welcome\"]')\n      .should('contain', 'Welcome, testuser');\n  });\n  \n  it('shows error on invalid credentials', () => {\n    cy.get('[data-testid=\"username\"]').type('invalid');\n    cy.get('[data-testid=\"password\"]').type('wrong');\n    cy.get('[data-testid=\"submit\"]').click();\n    \n    cy.get('[data-testid=\"error\"]')\n      .should('be.visible')\n      .and('contain', 'Invalid credentials');\n  });\n});\n\n// 12. Code coverage\n// package.json\n{\n  \"scripts\": {\n    \"test\": \"jest\",\n    \"test:coverage\": \"jest --coverage\"\n  },\n  \"jest\": {\n    \"coverageThreshold\": {\n      \"global\": {\n        \"branches\": 80,\n        \"functions\": 80,\n        \"lines\": 80,\n        \"statements\": 80\n      }\n    }\n  }\n}"
    },
    {
      "id": 89,
      "question": "What are JavaScript memory management and garbage collection?",
      "answer": "Memory management involves allocating and freeing memory for variables and objects.\n\nMemory Lifecycle:\n\n1. Allocation:\n• Primitive values on stack\n• Objects on heap\n• Automatic for most types\n• Manual for buffers\n\n2. Usage:\n• Read and write values\n• Object manipulation\n• Function execution\n\n3. Deallocation:\n• Garbage collection\n• Automatic process\n• Mark-and-sweep algorithm\n• Generational collection\n\nGarbage Collection:\n\nMark-and-Sweep:\n• Mark reachable objects\n• Sweep unreachable\n• Root objects (global, stack)\n• Reference counting avoided\n\nGenerational Collection:\n• Young generation (new objects)\n• Old generation (survived)\n• Most objects die young\n• Optimize for common case\n\nMemory Leaks:\n\n1. Global Variables:\n• Never collected\n• Accidental globals\n• Use 'use strict'\n\n2. Forgotten Timers:\n• setInterval not cleared\n• Event listeners not removed\n• clearInterval/removeEventListener\n\n3. Closures:\n• Retain outer scope\n• Large objects captured\n• Be mindful of references\n\n4. DOM References:\n• Detached nodes\n• Event listeners\n• Clear references\n\nBest Practices:\n• Minimize global scope\n• Clear timers and listeners\n• Use WeakMap/WeakSet\n• Avoid circular references\n• Profile memory usage",
      "explanation": "Memory management uses mark-and-sweep garbage collection for automatic deallocation, with generational optimization. Common leaks include globals, forgotten timers, closures, and DOM references, prevented through proper cleanup and WeakMap/WeakSet usage.",
      "difficulty": "Hard",
      "code": "// 1. Stack vs Heap allocation\n// Primitives on stack\nlet num = 42;\nlet str = 'hello';\nlet bool = true;\n\n// Objects on heap\nlet obj = { x: 1, y: 2 };\nlet arr = [1, 2, 3];\n\n// 2. Reference vs Value\nlet a = { x: 1 };\nlet b = a; // Same reference\nb.x = 2;\nconsole.log(a.x); // 2 (both point to same object)\n\nlet c = 5;\nlet d = c; // Copy value\nd = 10;\nconsole.log(c); // 5 (independent)\n\n// 3. Memory leak - Global variables\nfunction createLeak() {\n  // Bad: accidental global\n  leakedVar = 'This is global!';\n  \n  // Good: use strict mode\n  'use strict';\n  // leakedVar = 'This throws error';\n}\n\n// 4. Memory leak - Forgotten timers\nclass Component {\n  constructor() {\n    // Bad: timer not cleared\n    this.timer = setInterval(() => {\n      console.log(this.data);\n    }, 1000);\n  }\n  \n  destroy() {\n    // Good: clear timer\n    clearInterval(this.timer);\n  }\n}\n\n// 5. Memory leak - Event listeners\nconst element = document.getElementById('button');\n\n// Bad: listener not removed\nfunction onClick() {\n  console.log('Clicked');\n}\nelement.addEventListener('click', onClick);\n\n// When element removed:\n// element.remove(); // Listener still in memory!\n\n// Good: remove listener\nelement.removeEventListener('click', onClick);\nelement.remove();\n\n// 6. Memory leak - Closures\nfunction createClosure() {\n  const largeData = new Array(1000000).fill('data');\n  \n  return function() {\n    // This closure keeps largeData in memory!\n    console.log(largeData[0]);\n  };\n}\n\nconst fn = createClosure();\n// largeData remains in memory as long as fn exists\n\n// Better: only capture what you need\nfunction createBetterClosure() {\n  const largeData = new Array(1000000).fill('data');\n  const firstItem = largeData[0];\n  \n  return function() {\n    console.log(firstItem);\n  }; // largeData can be collected\n}\n\n// 7. WeakMap for memory management\n// Regular Map prevents garbage collection\nconst map = new Map();\nlet obj1 = { id: 1 };\nmap.set(obj1, 'metadata');\nobj1 = null; // Object still in Map, not collected!\n\n// WeakMap allows garbage collection\nconst weakMap = new WeakMap();\nlet obj2 = { id: 2 };\nweakMap.set(obj2, 'metadata');\nobj2 = null; // Object can be collected!\n\n// 8. WeakSet\nconst weakSet = new WeakSet();\nlet obj3 = { id: 3 };\nweakSet.add(obj3);\nobj3 = null; // Can be collected\n\n// 9. Circular references (handled by modern GC)\nfunction createCircular() {\n  const objA = {};\n  const objB = {};\n  \n  objA.ref = objB;\n  objB.ref = objA;\n  \n  // Modern GC handles this\n  return objA;\n}\n\nlet circular = createCircular();\ncircular = null; // Both objects collected\n\n// 10. DOM references\nconst elements = [];\n\nfunction addElement() {\n  const div = document.createElement('div');\n  document.body.appendChild(div);\n  \n  // Bad: keeps reference even after removal\n  elements.push(div);\n}\n\nfunction removeElement() {\n  const div = elements.pop();\n  div.remove(); // Element removed from DOM but still in array!\n}\n\n// Better: clear references\nfunction removeElementProperly() {\n  const div = elements.pop();\n  div.remove();\n  // div reference goes out of scope\n}\n\n// 11. Profiling memory\nif (performance.memory) {\n  console.log('Used JS Heap:', performance.memory.usedJSHeapSize);\n  console.log('Total JS Heap:', performance.memory.totalJSHeapSize);\n  console.log('Heap Limit:', performance.memory.jsHeapSizeLimit);\n}\n\n// 12. Force garbage collection (Chrome DevTools only)\n// Not available in production\nif (global.gc) {\n  global.gc(); // Trigger garbage collection\n}\n\n// 13. Memory-efficient array operations\n// Bad: creates many intermediate arrays\nconst result1 = [1, 2, 3, 4, 5]\n  .map(x => x * 2)\n  .filter(x => x > 5)\n  .map(x => x + 1);\n\n// Better: single iteration\nconst result2 = [1, 2, 3, 4, 5].reduce((acc, x) => {\n  const doubled = x * 2;\n  if (doubled > 5) {\n    acc.push(doubled + 1);\n  }\n  return acc;\n}, []);\n\n// 14. Reusing objects (object pooling)\nclass ObjectPool {\n  constructor(createFn, resetFn) {\n    this.createFn = createFn;\n    this.resetFn = resetFn;\n    this.pool = [];\n  }\n  \n  acquire() {\n    return this.pool.length > 0\n      ? this.pool.pop()\n      : this.createFn();\n  }\n  \n  release(obj) {\n    this.resetFn(obj);\n    this.pool.push(obj);\n  }\n}\n\nconst particlePool = new ObjectPool(\n  () => ({ x: 0, y: 0, vx: 0, vy: 0 }),\n  (p) => { p.x = 0; p.y = 0; p.vx = 0; p.vy = 0; }\n);\n\nconst particle = particlePool.acquire();\nparticle.x = 100;\n// Use particle...\nparticlePool.release(particle); // Reuse instead of GC\n\n// 15. Avoiding memory leaks in SPA\nclass Component {\n  constructor() {\n    this.listeners = [];\n    this.timers = [];\n    this.subscriptions = [];\n  }\n  \n  addEventListener(element, event, handler) {\n    element.addEventListener(event, handler);\n    this.listeners.push({ element, event, handler });\n  }\n  \n  setTimeout(fn, delay) {\n    const id = setTimeout(fn, delay);\n    this.timers.push(id);\n    return id;\n  }\n  \n  subscribe(observable, handler) {\n    const subscription = observable.subscribe(handler);\n    this.subscriptions.push(subscription);\n    return subscription;\n  }\n  \n  destroy() {\n    // Clean up all listeners\n    this.listeners.forEach(({ element, event, handler }) => {\n      element.removeEventListener(event, handler);\n    });\n    \n    // Clear all timers\n    this.timers.forEach(id => clearTimeout(id));\n    \n    // Unsubscribe all\n    this.subscriptions.forEach(sub => sub.unsubscribe());\n    \n    // Clear references\n    this.listeners = [];\n    this.timers = [];\n    this.subscriptions = [];\n  }\n}"
    },
    {
      "id": 90,
      "question": "What are JavaScript ES2015+ modern features and syntax?",
      "answer": "Modern JavaScript (ES2015+) introduced many features improving code quality and developer experience.\n\nES2015 (ES6) Features:\n\n1. let and const:\n• Block scoping\n• const prevents reassignment\n• Replace var\n\n2. Arrow Functions:\n• Concise syntax\n• Lexical this binding\n• Implicit return\n\n3. Classes:\n• Syntactic sugar\n• Constructor and methods\n• Extends for inheritance\n• Super keyword\n\n4. Template Literals:\n• String interpolation\n• Multiline strings\n• Tagged templates\n\n5. Destructuring:\n• Extract from objects/arrays\n• Default values\n• Rest syntax\n\n6. Modules:\n• Import/export\n• Named and default exports\n• Static analysis\n\n7. Promises:\n• Async operations\n• Chaining\n• Error handling\n\n8. Spread/Rest:\n• Array and object spreading\n• Function parameters\n• Collect remaining\n\nES2016+:\n\n1. Async/Await (ES2017):\n• Synchronous-looking async\n• Error handling with try/catch\n• Cleaner than promises\n\n2. Optional Chaining (ES2020):\n• Safe property access\n• ?. operator\n• Prevent errors\n\n3. Nullish Coalescing (ES2020):\n• ?? operator\n• Differentiate null/undefined from falsy\n\n4. Private Fields (ES2022):\n• # prefix\n• True privacy\n• Class encapsulation",
      "explanation": "Modern JavaScript includes let/const (scoping), arrow functions (concise), classes (OOP), template literals (interpolation), destructuring (extraction), modules (import/export), async/await (async), optional chaining (?.), nullish coalescing (??), private fields (#).",
      "difficulty": "Medium",
      "code": "// 1. let and const\nif (true) {\n  var varVariable = 'var'; // Function scoped\n  let letVariable = 'let'; // Block scoped\n  const constVariable = 'const'; // Block scoped, can't reassign\n}\n\nconsole.log(varVariable); // 'var'\n// console.log(letVariable); // ReferenceError\n// console.log(constVariable); // ReferenceError\n\n// 2. Arrow functions\nconst add = (a, b) => a + b; // Implicit return\nconst square = x => x * x; // Single parameter, no parens\nconst log = () => console.log('Hello'); // No parameters\n\n// Lexical this\nclass Timer {\n  constructor() {\n    this.seconds = 0;\n    \n    // Arrow function captures this\n    setInterval(() => {\n      this.seconds++;\n    }, 1000);\n  }\n}\n\n// 3. Classes\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  speak() {\n    console.log(`${this.name} makes a sound`);\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name, breed) {\n    super(name);\n    this.breed = breed;\n  }\n  \n  speak() {\n    console.log(`${this.name} barks`);\n  }\n}\n\nconst dog = new Dog('Rex', 'Labrador');\ndog.speak(); // Rex barks\n\n// 4. Template literals\nconst name = 'John';\nconst age = 30;\n\nconst message = `Hello, my name is ${name} and I'm ${age} years old.`;\n\n// Multiline\nconst html = `\n  <div>\n    <h1>${name}</h1>\n    <p>Age: ${age}</p>\n  </div>\n`;\n\n// Tagged templates\nfunction highlight(strings, ...values) {\n  return strings.reduce((result, str, i) => {\n    return result + str + (values[i] ? `<mark>${values[i]}</mark>` : '');\n  }, '');\n}\n\nconst highlighted = highlight`Name: ${name}, Age: ${age}`;\n// Name: <mark>John</mark>, Age: <mark>30</mark>\n\n// 5. Destructuring\n// Objects\nconst person = { name: 'John', age: 30, city: 'NYC' };\nconst { name: personName, age: personAge } = person;\n\n// Arrays\nconst numbers = [1, 2, 3, 4, 5];\nconst [first, second, ...rest] = numbers;\nconsole.log(first, second, rest); // 1 2 [3, 4, 5]\n\n// Default values\nconst { x = 0, y = 0 } = {};\n\n// Nested\nconst user = {\n  id: 1,\n  profile: {\n    name: 'John',\n    email: 'john@example.com'\n  }\n};\n\nconst { profile: { name: userName, email } } = user;\n\n// Function parameters\nfunction greet({ name, age = 0 }) {\n  console.log(`${name} is ${age} years old`);\n}\n\ngreet({ name: 'John', age: 30 });\n\n// 6. Spread and Rest\n// Spread arrays\nconst arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\nconst combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6]\n\n// Spread objects\nconst obj1 = { a: 1, b: 2 };\nconst obj2 = { c: 3, d: 4 };\nconst merged = { ...obj1, ...obj2 }; // { a: 1, b: 2, c: 3, d: 4 }\n\n// Rest parameters\nfunction sum(...numbers) {\n  return numbers.reduce((acc, n) => acc + n, 0);\n}\n\nconsole.log(sum(1, 2, 3, 4, 5)); // 15\n\n// 7. Modules\n// math.js\nexport const PI = 3.14159;\nexport function add(a, b) {\n  return a + b;\n}\nexport default class Calculator {}\n\n// app.js\nimport Calculator, { PI, add } from './math.js';\nimport * as math from './math.js';\n\n// 8. Async/Await\nasync function fetchUser(id) {\n  try {\n    const response = await fetch(`/api/users/${id}`);\n    const user = await response.json();\n    return user;\n  } catch (error) {\n    console.error('Error fetching user:', error);\n    throw error;\n  }\n}\n\n// Parallel execution\nasync function fetchMultiple(ids) {\n  const promises = ids.map(id => fetchUser(id));\n  const users = await Promise.all(promises);\n  return users;\n}\n\n// 9. Optional chaining (ES2020)\nconst user2 = {\n  name: 'John',\n  address: {\n    street: '123 Main St'\n  }\n};\n\n// Without optional chaining\nconst zip1 = user2 && user2.address && user2.address.zip;\n\n// With optional chaining\nconst zip2 = user2?.address?.zip; // undefined (no error)\n\n// Array access\nconst firstItem = arr?.[0];\n\n// Function call\nconst result = user2.getProfile?.(); // Only calls if exists\n\n// 10. Nullish coalescing (ES2020)\nconst value1 = 0 || 'default'; // 'default' (0 is falsy)\nconst value2 = 0 ?? 'default'; // 0 (only null/undefined use default)\n\nconst value3 = null ?? 'default'; // 'default'\nconst value4 = undefined ?? 'default'; // 'default'\nconst value5 = '' ?? 'default'; // '' (empty string is not nullish)\n\n// 11. Private fields (ES2022)\nclass Counter {\n  #count = 0; // Private field\n  \n  increment() {\n    this.#count++;\n  }\n  \n  getCount() {\n    return this.#count;\n  }\n}\n\nconst counter = new Counter();\ncounter.increment();\nconsole.log(counter.getCount()); // 1\n// console.log(counter.#count); // SyntaxError: Private field\n\n// 12. Logical assignment (ES2021)\nlet a = 1;\na ||= 2; // a = a || 2\nconsole.log(a); // 1\n\nlet b = 0;\nb ||= 2;\nconsole.log(b); // 2\n\nlet c = null;\nc ??= 'default'; // c = c ?? 'default'\nconsole.log(c); // 'default'\n\nlet d = 10;\nd &&= 20; // d = d && 20\nconsole.log(d); // 20\n\n// 13. Numeric separators (ES2021)\nconst billion = 1_000_000_000;\nconst bytes = 0b1111_1111; // Binary\nconst hex = 0xFF_FF_FF; // Hexadecimal\n\n// 14. Top-level await (ES2022)\n// Can use await at module top level\n// const data = await fetch('/api/data').then(r => r.json());\n\n// 15. Array methods (ES2019+)\nconst nested = [1, [2, [3, [4]]]];\nconst flat = nested.flat(Infinity); // [1, 2, 3, 4]\n\nconst arr3 = [1, 2, 3];\nconst mapped = arr3.flatMap(x => [x, x * 2]);\nconsole.log(mapped); // [1, 2, 2, 4, 3, 6]\n\n// Object.fromEntries (ES2019)\nconst entries = [['a', 1], ['b', 2]];\nconst obj3 = Object.fromEntries(entries);\nconsole.log(obj3); // { a: 1, b: 2 }\n\n// String methods\nconst str = '  hello  ';\nconsole.log(str.trimStart()); // 'hello  '\nconsole.log(str.trimEnd());   // '  hello'\n\n// 16. BigInt (ES2020)\nconst bigInt = 1234567890123456789012345678901234567890n;\nconst big = BigInt('1234567890123456789012345678901234567890');\nconsole.log(bigInt + 1n); // Can't mix with regular numbers"
    },
    {
      "id": 91,
      "question": "What are JavaScript state management patterns and solutions?",
      "answer": "State management handles application data and ensures UI consistency across components.\n\nPatterns:\n\n1. Local State:\n• Component-level\n• useState in React\n• Isolated data\n• Simple cases\n• No sharing\n\n2. Lifted State:\n• Parent component\n• Props drilling\n• Shared between siblings\n• Limited scope\n\n3. Context API:\n• React context\n• Avoid props drilling\n• Global or scoped state\n• Provider-consumer pattern\n\n4. Redux:\n• Centralized store\n• Actions and reducers\n• Predictable state\n• Time-travel debugging\n• DevTools\n\n5. MobX:\n• Observable state\n• Reactive updates\n• Less boilerplate\n• Automatic tracking\n\n6. Recoil:\n• Atomic state\n• Fine-grained updates\n• Minimal re-renders\n• React-specific\n\n7. Zustand:\n• Simple API\n• No providers\n• Hooks-based\n• Small bundle\n\nBest Practices:\n• Minimize global state\n• Normalize data\n• Immutable updates\n• Single source of truth\n• Derive computed values\n• Avoid redundant state\n• Use selectors\n• Optimize re-renders",
      "explanation": "State management uses local state (component), lifted state (parent), Context (avoid drilling), Redux (centralized store), MobX (observable), Recoil (atomic), Zustand (simple) with immutable updates and minimal global state.",
      "difficulty": "Hard",
      "code": "// State management examples\nconst store = createStore(reducer);\nstore.dispatch({ type: 'INCREMENT' });"
    },
    {
      "id": 92,
      "question": "What are JavaScript bundling and module systems?",
      "answer": "Module systems organize code into reusable units with explicit dependencies.\n\nModule Systems:\n\n1. CommonJS:\n• Node.js default\n• require() and module.exports\n• Synchronous loading\n• Runtime resolution\n• Server-side focus\n\n2. ES6 Modules (ESM):\n• import and export\n• Static analysis\n• Tree shaking\n• Browser support\n• Async loading\n• Standard format\n\n3. AMD (Async Module Definition):\n• RequireJS\n• Browser-focused\n• Async loading\n• Legacy\n\n4. UMD (Universal Module Definition):\n• Works everywhere\n• CommonJS + AMD + global\n• Library distribution\n\nBundling:\n\n1. Code Splitting:\n• Break into chunks\n• Load on demand\n• Reduce initial size\n• Dynamic imports\n\n2. Tree Shaking:\n• Remove dead code\n• ES6 modules required\n• Static analysis\n• Smaller bundles\n\n3. Minification:\n• Remove whitespace\n• Shorten names\n• Reduce file size\n• UglifyJS, Terser\n\n4. Source Maps:\n• Debug production code\n• Map to original\n• DevTools support\n\nOptimizations:\n• Code splitting\n• Lazy loading\n• Caching strategies\n• Compression\n• CDN usage",
      "explanation": "Module systems include CommonJS (require, Node.js), ESM (import/export, standard), AMD (async), UMD (universal) with bundling features like code splitting (chunks), tree shaking (dead code removal), minification (size), source maps (debugging).",
      "difficulty": "Hard",
      "code": "// CommonJS\nmodule.exports = { add };\n\n// ES6 Modules\nexport function add(a, b) { return a + b; }"
    },
    {
      "id": 93,
      "question": "What are JavaScript API design and best practices?",
      "answer": "Good API design creates intuitive, maintainable, and developer-friendly interfaces.\n\nAPI Design Principles:\n\n1. Consistency:\n• Naming conventions\n• Parameter order\n• Return types\n• Error handling\n\n2. Simplicity:\n• Minimal complexity\n• Clear purpose\n• Easy to use\n• Hide implementation\n\n3. Flexibility:\n• Extensible\n• Configurable\n• Backward compatible\n• Optional parameters\n\n4. Documentation:\n• Clear examples\n• Type definitions\n• API reference\n• Migration guides\n\n5. Error Handling:\n• Descriptive errors\n• Consistent patterns\n• Fail fast\n• Helpful messages\n\nFunction Design:\n\n1. Pure Functions:\n• No side effects\n• Predictable\n• Testable\n\n2. Single Responsibility:\n• One task\n• Focused\n• Composable\n\n3. Default Parameters:\n• Sensible defaults\n• Optional config\n• Less boilerplate\n\n4. Options Object:\n• Many parameters\n• Named arguments\n• Optional values\n• Extensible\n\nClass Design:\n• Clear constructors\n• Method chaining\n• Private fields\n• Getters/setters\n• Factory methods\n\nAsync APIs:\n• Promise-based\n• Async/await support\n• Cancellation\n• Progress updates",
      "explanation": "API design prioritizes consistency (naming, patterns), simplicity (easy use), flexibility (extensible), documentation (examples), error handling (descriptive) with pure functions, single responsibility, default parameters, options objects, and Promise-based async APIs.",
      "difficulty": "Hard",
      "code": "// Options pattern\nfunction createUser(options) {\n  const { name, age = 0 } = options;\n  return { name, age };\n}"
    },
    {
      "id": 94,
      "question": "What are JavaScript progressive web app (PWA) concepts?",
      "answer": "PWAs are web applications that provide native app-like experiences using modern web capabilities.\n\nCore Features:\n\n1. Service Workers:\n• Offline functionality\n• Background sync\n• Push notifications\n• Cache strategies\n• Proxy between app and network\n\n2. Web App Manifest:\n• App metadata\n• Install prompts\n• Icons and theme\n• Display mode\n• Splash screen\n\n3. HTTPS:\n• Required for PWA\n• Security\n• Service worker requirement\n\n4. Responsive Design:\n• Mobile-first\n• Adaptive layouts\n• Touch-friendly\n• Cross-device\n\nCapabilities:\n\n1. Offline Mode:\n• Cache-first strategy\n• Network fallback\n• Background sync\n• Queue operations\n\n2. Push Notifications:\n• User engagement\n• Re-engagement\n• Permission-based\n• Cross-platform\n\n3. Install Prompts:\n• Add to home screen\n• App-like experience\n• No app store\n• Easy updates\n\n4. Background Sync:\n• Queue when offline\n• Sync when online\n• Reliable delivery\n\nBest Practices:\n• App shell model\n• Lazy loading\n• Performance optimization\n• Lighthouse audits\n• Progressive enhancement",
      "explanation": "PWAs use service workers (offline, caching, push), web manifest (install, icons), HTTPS (security), responsive design (mobile-first) for offline mode, push notifications, install prompts, and background sync with app shell architecture.",
      "difficulty": "Hard",
      "code": "// Service Worker registration\nif ('serviceWorker' in navigator) {\n  navigator.serviceWorker.register('/sw.js');\n}"
    },
    {
      "id": 95,
      "question": "What are JavaScript performance optimization techniques?",
      "answer": "Performance optimization improves application speed, responsiveness, and resource efficiency.\n\nCode-Level Optimizations:\n\n1. Debouncing/Throttling:\n• Limit function calls\n• User input handling\n• Scroll/resize events\n• API request control\n\n2. Memoization:\n• Cache computed results\n• Avoid recalculations\n• Expensive operations\n• React.memo, useMemo\n\n3. Lazy Loading:\n• Load on demand\n• Code splitting\n• Dynamic imports\n• Reduce initial bundle\n\n4. Virtual Scrolling:\n• Render visible items\n• Large lists\n• Intersection Observer\n• Memory efficient\n\n5. Web Workers:\n• CPU-intensive tasks\n• Background threads\n• Non-blocking\n• Parallel processing\n\nDOM Optimizations:\n\n1. Batch DOM Updates:\n• Minimize reflows\n• DocumentFragment\n• RequestAnimationFrame\n• Avoid layout thrashing\n\n2. Event Delegation:\n• Single listener\n• Parent element\n• Memory efficient\n• Dynamic elements\n\n3. CSS Animations:\n• GPU acceleration\n• Transform and opacity\n• Avoid layout properties\n• will-change hint\n\nNetwork Optimizations:\n• CDN usage\n• Compression (gzip, brotli)\n• HTTP/2\n• Resource hints\n• Caching strategies\n\nMeasurement:\n• Performance API\n• Lighthouse\n• Chrome DevTools\n• Real User Monitoring",
      "explanation": "Performance optimization uses debouncing/throttling (limit calls), memoization (cache results), lazy loading (on-demand), virtual scrolling (visible only), Web Workers (background), batch DOM updates (minimize reflows), event delegation (single listener), and Performance API measurement.",
      "difficulty": "Hard",
      "code": "// Debouncing example\nfunction debounce(func, delay) {\n  let timeout;\n  return (...args) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func(...args), delay);\n  };\n}"
    },
    {
      "id": 96,
      "question": "What are JavaScript architectural patterns for large-scale applications?",
      "answer": "Architectural patterns provide structure for building scalable, maintainable large applications.\n\nArchitectural Patterns:\n\n1. MVC (Model-View-Controller):\n• Separation of concerns\n• Model: data and business logic\n• View: presentation\n• Controller: user input handling\n• Traditional web apps\n\n2. MVVM (Model-View-ViewModel):\n• Two-way data binding\n• ViewModel mediates\n• View and Model decoupled\n• Angular, Vue pattern\n\n3. Flux/Redux:\n• Unidirectional data flow\n• Single state tree\n• Actions trigger changes\n• Predictable state\n• React ecosystem\n\n4. Component-Based:\n• Reusable components\n• Encapsulation\n• Composition\n• React, Vue, Web Components\n\n5. Microservices:\n• Independent services\n• API-based communication\n• Technology agnostic\n• Scalable\n\n6. Event-Driven:\n• Loosely coupled\n• Event bus\n• Publish-subscribe\n• Reactive systems\n\n7. Layered Architecture:\n• Presentation layer\n• Business logic layer\n• Data access layer\n• Clear boundaries\n\nBest Practices:\n• Clear separation\n• Dependency injection\n• Domain-driven design\n• SOLID principles\n• Testing strategy\n• Documentation",
      "explanation": "Architectural patterns include MVC (model-view-controller separation), MVVM (two-way binding), Flux/Redux (unidirectional flow), Component-Based (reusable encapsulation), Microservices (independent), Event-Driven (pub-sub), Layered (presentation, business, data) for scalable applications.",
      "difficulty": "Hard",
      "code": "// MVC Pattern\nclass Model {\n  constructor() { this.data = []; }\n  add(item) { this.data.push(item); }\n}"
    },
    {
      "id": 97,
      "question": "What are JavaScript serverless and edge computing concepts?",
      "answer": "Serverless and edge computing enable scalable, cost-effective applications with reduced infrastructure management.\n\nServerless Functions:\n\n1. Function-as-a-Service (FaaS):\n• AWS Lambda\n• Azure Functions\n• Google Cloud Functions\n• Event-driven\n• Auto-scaling\n• Pay-per-execution\n\n2. Benefits:\n• No server management\n• Automatic scaling\n• Cost-effective\n• Fast deployment\n• Built-in monitoring\n\n3. Limitations:\n• Cold starts\n• Execution time limits\n• Stateless\n• Vendor lock-in\n• Debugging challenges\n\nEdge Computing:\n\n1. Edge Functions:\n• Cloudflare Workers\n• Vercel Edge Functions\n• Fastly Compute\n• Run at CDN edge\n• Low latency\n\n2. Benefits:\n• Reduced latency\n• Improved performance\n• Global distribution\n• Reduced origin load\n• Enhanced security\n\n3. Use Cases:\n• Authentication\n• A/B testing\n• Personalization\n• Request routing\n• API middleware\n• DDoS protection\n\nBest Practices:\n• Minimize cold starts\n• Optimize bundle size\n• Use environment variables\n• Implement proper logging\n• Handle errors gracefully\n• Monitor performance",
      "explanation": "Serverless uses FaaS (Lambda, Azure, Google) for event-driven, auto-scaling, pay-per-execution functions with no server management. Edge computing (Cloudflare Workers, Vercel) runs at CDN edge for low latency, global distribution, and reduced origin load.",
      "difficulty": "Hard",
      "code": "// AWS Lambda\nexports.handler = async (event) => {\n  return { statusCode: 200, body: 'Hello' };\n};"
    },
    {
      "id": 98,
      "question": "What are JavaScript cross-platform development approaches?",
      "answer": "Cross-platform development enables writing code once and deploying to multiple platforms.\n\nMobile Development:\n\n1. React Native:\n• Native mobile apps\n• JavaScript and React\n• Hot reloading\n• Native components\n• Large ecosystem\n• iOS and Android\n\n2. Ionic:\n• Hybrid mobile apps\n• Web technologies\n• Capacitor or Cordova\n• Angular, React, Vue\n• Progressive Web Apps\n\n3. NativeScript:\n• Native UI\n• Direct native API access\n• Angular or Vue\n• Performance focus\n\nDesktop Development:\n\n1. Electron:\n• Desktop apps\n• Chromium + Node.js\n• Cross-platform\n• VS Code, Slack, Discord\n• Large bundle size\n\n2. Tauri:\n• Lightweight alternative\n• Rust backend\n• System webview\n• Smaller bundles\n• Better security\n\nUniversal Frameworks:\n\n1. Node.js:\n• Server-side JavaScript\n• API development\n• Microservices\n• Real-time apps\n\n2. Deno:\n• Modern runtime\n• TypeScript support\n• Security-first\n• No package.json\n\nBenefits:\n• Code reusability\n• Single team\n• Faster development\n• Consistent UX\n• Shared logic",
      "explanation": "Cross-platform uses React Native (native mobile), Ionic (hybrid), NativeScript (native UI), Electron (desktop, Chromium), Tauri (lightweight), Node.js (server), Deno (modern) for code reusability, single team, faster development across platforms.",
      "difficulty": "Medium",
      "code": "// React Native\nimport { View, Text } from 'react-native';\n\nfunction App() {\n  return <View><Text>Hello</Text></View>;\n}"
    },
    {
      "id": 99,
      "question": "What are JavaScript internationalization (i18n) and localization (l10n) techniques?",
      "answer": "Internationalization and localization enable applications to support multiple languages and regions.\n\nInternationalization (i18n):\n\n1. Design Approach:\n• Separate content from code\n• Unicode support\n• Flexible layouts\n• Date/time formatting\n• Number formatting\n• Currency handling\n\n2. Key Concepts:\n• Locale: language + region\n• Translation keys\n• Plural rules\n• Gender rules\n• Directionality (LTR/RTL)\n\nLocalization (l10n):\n\n1. Translation:\n• Text content\n• Images with text\n• Audio/video\n• Documentation\n• Error messages\n\n2. Regional Adaptation:\n• Date formats\n• Number formats\n• Currency symbols\n• Units of measurement\n• Cultural preferences\n\nTools and Libraries:\n\n1. Intl API:\n• Built-in JavaScript\n• Number formatting\n• Date formatting\n• Collation\n• Plural rules\n\n2. i18next:\n• Popular library\n• React integration\n• Namespace support\n• Lazy loading\n• Backend plugins\n\n3. FormatJS:\n• React Intl\n• Message formatting\n• Plural rules\n• Gender handling\n\nBest Practices:\n• Extract all strings\n• Use translation keys\n• Support RTL\n• Test translations\n• Fallback language\n• Context-aware translations",
      "explanation": "i18n/l10n uses Intl API (dates, numbers), i18next (translations), FormatJS (React Intl) for locale support (language + region), translation keys, plural/gender rules, date/number formatting, currency, RTL support, and cultural adaptation.",
      "difficulty": "Medium",
      "code": "// Intl.DateTimeFormat\nconst date = new Date();\nconst us = new Intl.DateTimeFormat('en-US').format(date);\nconst fr = new Intl.DateTimeFormat('fr-FR').format(date);"
    },
    {
      "id": 100,
      "question": "What are JavaScript ecosystem trends and future features?",
      "answer": "JavaScript continues evolving with new features, tools, and paradigms shaping modern development.\n\nRecent Trends:\n\n1. TypeScript Adoption:\n• Type safety\n• Better tooling\n• Large-scale apps\n• Industry standard\n\n2. Build Tools Evolution:\n• Vite (fast dev server)\n• esbuild (native speed)\n• Turbopack (incremental)\n• Module federation\n\n3. Edge Computing:\n• Cloudflare Workers\n• Vercel Edge Functions\n• Low latency\n• Global distribution\n\n4. Full-Stack Frameworks:\n• Next.js (React)\n• Remix (React)\n• SvelteKit (Svelte)\n• Nuxt (Vue)\n• SSR and SSG\n\n5. Serverless:\n• Function-as-a-Service\n• Auto-scaling\n• Cost-effective\n• Simplified deployment\n\nUpcoming Features:\n\n1. Decorators (Stage 3):\n• Class metadata\n• Method enhancement\n• Aspect-oriented\n\n2. Pattern Matching (Stage 1):\n• Match expressions\n• Destructuring\n• Type checking\n\n3. Temporal API (Stage 3):\n• Modern date/time\n• Replace Date\n• Better timezone support\n\n4. Records and Tuples (Stage 2):\n• Immutable structures\n• Value semantics\n• Deep equality\n\nBest Practices:\n• Stay updated\n• Learn fundamentals first\n• Use modern features\n• Follow standards\n• Community engagement",
      "explanation": "JavaScript trends include TypeScript (type safety), modern build tools (Vite, esbuild), edge computing (Workers), full-stack frameworks (Next.js, Remix), serverless with upcoming features like Decorators, Pattern Matching, Temporal API, Records/Tuples.",
      "difficulty": "Medium",
      "code": "// TypeScript\ninterface User { id: number; name: string; }\n\nfunction getUser(id: number): User {\n  return { id, name: 'John' };\n}"
    }
  ]
}
