{
  "topic": "MySQL",
  "questions": [
    {
      "id": 1,
      "question": "What is the difference between SQL and MySQL?",
      "answer": "SQL (Structured Query Language):\n• Language standard for databases\n• Used to query and manipulate data\n• ANSI/ISO standard\n• Portable across databases\n\nMySQL:\n• Relational Database Management System (RDBMS)\n• Implements SQL language\n• Open-source (Oracle owns)\n• One of many SQL databases\n\nOthers: PostgreSQL, Oracle, SQL Server, SQLite",
      "explanation": "SQL is the language, MySQL is a database that uses SQL. Different databases may have slight SQL syntax variations.",
      "difficulty": "Easy"
    },
    {
      "id": 2,
      "question": "What are the different types of JOINs in MySQL?",
      "answer": "INNER JOIN:\n• Returns matching rows from both tables\n\nLEFT JOIN (LEFT OUTER JOIN):\n• All rows from left table + matching from right\n• NULL for non-matching right rows\n\nRIGHT JOIN (RIGHT OUTER JOIN):\n• All rows from right table + matching from left\n\nCROSS JOIN:\n• Cartesian product (all combinations)\n\nSELF JOIN:\n• Table joined with itself",
      "explanation": "INNER JOIN is most common. LEFT JOIN is useful when you need all records from one table regardless of matches.",
      "difficulty": "Medium",
      "code": "-- Sample tables\n-- users: id, name, department_id\n-- departments: id, name\n\n-- INNER JOIN: Only matching rows\nSELECT u.name, d.name AS department\nFROM users u\nINNER JOIN departments d ON u.department_id = d.id;\n\n-- LEFT JOIN: All users, even without department\nSELECT u.name, d.name AS department\nFROM users u\nLEFT JOIN departments d ON u.department_id = d.id;\n-- Returns NULL for department if no match\n\n-- RIGHT JOIN: All departments, even empty ones\nSELECT u.name, d.name AS department\nFROM users u\nRIGHT JOIN departments d ON u.department_id = d.id;\n\n-- CROSS JOIN: All combinations\nSELECT u.name, d.name\nFROM users u\nCROSS JOIN departments d;\n\n-- SELF JOIN: Employee with manager\nSELECT e.name AS employee, m.name AS manager\nFROM employees e\nLEFT JOIN employees m ON e.manager_id = m.id;\n\n-- Multiple JOINs\nSELECT o.id, u.name, p.name AS product\nFROM orders o\nJOIN users u ON o.user_id = u.id\nJOIN products p ON o.product_id = p.id;"
    },
    {
      "id": 3,
      "question": "What is the difference between WHERE and HAVING clause?",
      "answer": "WHERE:\n• Filters rows BEFORE grouping\n• Cannot use aggregate functions\n• Applied to individual rows\n• Faster (filters early)\n\nHAVING:\n• Filters groups AFTER grouping\n• Can use aggregate functions\n• Applied to grouped results\n• Requires GROUP BY\n\nOrder: WHERE → GROUP BY → HAVING",
      "explanation": "Use WHERE for row-level filtering, HAVING for aggregate conditions. WHERE is more efficient as it filters before grouping.",
      "difficulty": "Medium",
      "code": "-- WHERE: Filter before grouping\nSELECT department_id, COUNT(*) as emp_count\nFROM employees\nWHERE salary > 50000  -- Filter individual rows\nGROUP BY department_id;\n\n-- HAVING: Filter after grouping\nSELECT department_id, COUNT(*) as emp_count\nFROM employees\nGROUP BY department_id\nHAVING COUNT(*) > 5;  -- Filter groups\n\n-- Combined\nSELECT department_id, AVG(salary) as avg_salary\nFROM employees\nWHERE status = 'active'  -- Filter active employees first\nGROUP BY department_id\nHAVING AVG(salary) > 60000;  -- Then filter by average\n\n-- Cannot do this:\n-- SELECT department_id\n-- FROM employees\n-- WHERE COUNT(*) > 5;  -- ERROR! Aggregate in WHERE\n\n-- Complete order of execution:\n-- FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT"
    },
    {
      "id": 4,
      "question": "What are Indexes in MySQL and why are they important?",
      "answer": "Indexes are data structures that speed up data retrieval.\n\nTypes:\n• PRIMARY KEY: Unique, not null, one per table\n• UNIQUE: Unique values, allows NULL\n• INDEX: Non-unique, general purpose\n• FULLTEXT: Text search\n• COMPOSITE: Multiple columns\n\nPros:\n• Faster SELECT, WHERE, JOIN\n• Speed up ORDER BY, GROUP BY\n\nCons:\n• Slower INSERT, UPDATE, DELETE\n• Uses extra storage",
      "explanation": "Indexes work like book indexes - find data without scanning entire table. Add indexes on frequently searched/joined columns.",
      "difficulty": "Medium",
      "code": "-- Create index\nCREATE INDEX idx_email ON users(email);\nCREATE UNIQUE INDEX idx_username ON users(username);\n\n-- Composite index (column order matters)\nCREATE INDEX idx_name ON users(last_name, first_name);\n\n-- FULLTEXT index for text search\nCREATE FULLTEXT INDEX idx_content ON articles(title, body);\n\n-- Add index to existing table\nALTER TABLE users ADD INDEX idx_status(status);\n\n-- Drop index\nDROP INDEX idx_email ON users;\n\n-- Show indexes\nSHOW INDEX FROM users;\n\n-- Explain query (check if index is used)\nEXPLAIN SELECT * FROM users WHERE email = 'test@test.com';\n\n-- FULLTEXT search\nSELECT * FROM articles\nWHERE MATCH(title, body) AGAINST('database optimization');\n\n-- Covering index (includes all needed columns)\nCREATE INDEX idx_cover ON orders(user_id, status, created_at);\n\n-- This query uses only the index:\nSELECT status, created_at FROM orders WHERE user_id = 1;\n\n-- When to add indexes:\n-- Columns in WHERE clauses\n-- Columns in JOIN conditions\n-- Columns in ORDER BY\n-- Foreign keys"
    },
    {
      "id": 5,
      "question": "What is Normalization and what are the Normal Forms?",
      "answer": "Normalization organizes data to reduce redundancy and improve integrity.\n\n1NF (First Normal Form):\n• Atomic values (no repeating groups)\n• Each column has single value\n\n2NF:\n• 1NF + no partial dependencies\n• All non-key columns depend on entire primary key\n\n3NF:\n• 2NF + no transitive dependencies\n• Non-key columns don't depend on other non-key columns\n\nBCNF (Boyce-Codd):\n• Stricter 3NF",
      "explanation": "Higher normalization = less redundancy but more JOINs. Balance normalization with query performance needs.",
      "difficulty": "Medium",
      "code": "-- Unnormalized (violates 1NF)\n-- orders: id, customer, items (\"laptop,mouse,keyboard\")\n\n-- 1NF: Atomic values\n-- orders: id, customer\n-- order_items: order_id, item\n\n-- 2NF violation: Partial dependency\n-- order_items: order_id, product_id, product_name, quantity\n-- product_name depends only on product_id, not full key\n\n-- 2NF: Separate products\n-- order_items: order_id, product_id, quantity\n-- products: id, name, price\n\n-- 3NF violation: Transitive dependency\n-- employees: id, name, dept_id, dept_name, dept_location\n-- dept_name depends on dept_id, not employee\n\n-- 3NF: Separate departments\n-- employees: id, name, dept_id\n-- departments: id, name, location\n\n-- Denormalization (for performance)\n-- Sometimes we intentionally add redundancy:\nCREATE TABLE orders (\n  id INT PRIMARY KEY,\n  user_id INT,\n  user_name VARCHAR(100),  -- Denormalized for faster reads\n  total DECIMAL(10,2)\n);\n\n-- Trade-off: Faster reads, but must update user_name\n-- in multiple places if it changes"
    },
    {
      "id": 6,
      "question": "What is the difference between DELETE, TRUNCATE, and DROP?",
      "answer": "DELETE:\n• Removes specific rows (with WHERE)\n• Can be rolled back (transaction)\n• Triggers fire\n• Slower (row-by-row)\n• Keeps auto_increment value\n\nTRUNCATE:\n• Removes ALL rows\n• Cannot be rolled back (DDL)\n• No triggers\n• Faster (deallocates pages)\n• Resets auto_increment\n\nDROP:\n• Removes entire table structure\n• Cannot be rolled back\n• Removes indexes, constraints, triggers",
      "explanation": "DELETE for selective removal, TRUNCATE to empty table quickly, DROP to remove table completely.",
      "difficulty": "Easy",
      "code": "-- DELETE: Remove specific rows\nDELETE FROM users WHERE status = 'inactive';\nDELETE FROM users WHERE created_at < '2020-01-01';\n\n-- Delete all (slower than TRUNCATE)\nDELETE FROM logs;\n\n-- With transaction (can rollback)\nSTART TRANSACTION;\nDELETE FROM users WHERE id = 5;\nROLLBACK; -- Undo\n-- or COMMIT;\n\n-- TRUNCATE: Empty table quickly\nTRUNCATE TABLE logs;\n-- Resets auto_increment to 1\n-- Cannot use WHERE\n-- Cannot rollback\n\n-- DROP: Remove table entirely\nDROP TABLE IF EXISTS temp_users;\n\n-- Drop multiple\nDROP TABLE table1, table2, table3;\n\n-- Drop database\nDROP DATABASE IF EXISTS test_db;\n\n-- Comparison:\n-- DELETE FROM users;  -- Slow, can rollback, auto_inc continues\n-- TRUNCATE TABLE users;  -- Fast, no rollback, auto_inc resets\n-- DROP TABLE users;  -- Table gone completely"
    },
    {
      "id": 7,
      "question": "What are Transactions and ACID properties?",
      "answer": "Transaction: Group of operations executed as single unit.\n\nACID properties:\n\nAtomicity:\n• All or nothing - complete success or rollback\n\nConsistency:\n• Database remains in valid state\n• Constraints maintained\n\nIsolation:\n• Concurrent transactions don't interfere\n• Isolation levels control visibility\n\nDurability:\n• Committed changes are permanent\n• Survives system failures",
      "explanation": "Transactions ensure data integrity. Use for operations that must succeed together (e.g., bank transfer: debit and credit).",
      "difficulty": "Medium",
      "code": "-- Basic transaction\nSTART TRANSACTION;\n\nUPDATE accounts SET balance = balance - 100 WHERE id = 1;\nUPDATE accounts SET balance = balance + 100 WHERE id = 2;\n\nCOMMIT;\n-- or ROLLBACK if error\n\n-- With error handling (stored procedure)\nDELIMITER //\nCREATE PROCEDURE transfer_money(\n  IN from_id INT,\n  IN to_id INT,\n  IN amount DECIMAL(10,2)\n)\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION\n  BEGIN\n    ROLLBACK;\n    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Transfer failed';\n  END;\n\n  START TRANSACTION;\n  \n  UPDATE accounts SET balance = balance - amount WHERE id = from_id;\n  UPDATE accounts SET balance = balance + amount WHERE id = to_id;\n  \n  COMMIT;\nEND //\nDELIMITER ;\n\n-- Isolation levels\nSET TRANSACTION ISOLATION LEVEL READ COMMITTED;\nSET TRANSACTION ISOLATION LEVEL REPEATABLE READ;  -- MySQL default\nSET TRANSACTION ISOLATION LEVEL SERIALIZABLE;\n\n-- Savepoints\nSTART TRANSACTION;\nINSERT INTO orders VALUES (...);\nSAVEPOINT after_order;\nINSERT INTO order_items VALUES (...);\n-- If error here:\nROLLBACK TO after_order;\n-- order is kept, items rolled back"
    },
    {
      "id": 8,
      "question": "What is the difference between UNION and UNION ALL?",
      "answer": "UNION:\n• Combines results from multiple SELECTs\n• Removes duplicate rows\n• Slower (must check duplicates)\n• Sorts results\n\nUNION ALL:\n• Combines results without removing duplicates\n• Faster (no duplicate check)\n• Preserves all rows\n• No implicit sorting\n\nRequirements:\n• Same number of columns\n• Compatible data types\n• Column names from first SELECT",
      "explanation": "Use UNION ALL when you know there are no duplicates or want to keep them. It's significantly faster.",
      "difficulty": "Easy",
      "code": "-- UNION: Removes duplicates\nSELECT city FROM customers\nUNION\nSELECT city FROM suppliers;\n-- Returns unique cities from both tables\n\n-- UNION ALL: Keeps all rows\nSELECT city FROM customers\nUNION ALL\nSELECT city FROM suppliers;\n-- Returns all cities, including duplicates\n\n-- Multiple UNIONs\nSELECT name, 'customer' AS type FROM customers\nUNION ALL\nSELECT name, 'supplier' AS type FROM suppliers\nUNION ALL\nSELECT name, 'employee' AS type FROM employees;\n\n-- With ORDER BY (applies to final result)\nSELECT name, city FROM customers\nUNION\nSELECT name, city FROM suppliers\nORDER BY name;\n\n-- Performance example\n-- If combining active and archived orders:\nSELECT * FROM active_orders WHERE user_id = 1\nUNION ALL  -- Use UNION ALL - no overlap possible\nSELECT * FROM archived_orders WHERE user_id = 1;\n\n-- Column count and types must match\nSELECT id, name FROM users\nUNION\nSELECT product_id, product_name FROM products;"
    },
    {
      "id": 9,
      "question": "What are Stored Procedures and their benefits?",
      "answer": "Stored Procedures are precompiled SQL code stored in the database.\n\nBenefits:\n• Performance: Precompiled, cached\n• Security: Grant execute without table access\n• Reduced network traffic: One call, multiple statements\n• Maintainability: Business logic in one place\n• Code reuse: Called from multiple applications\n\nCan have:\n• Input/output parameters\n• Variables, loops, conditionals\n• Error handling\n• Transactions",
      "explanation": "Stored procedures move logic to the database. Good for complex operations, security, and performance. Be careful of vendor lock-in.",
      "difficulty": "Medium",
      "code": "-- Create procedure\nDELIMITER //\nCREATE PROCEDURE GetUserOrders(\n  IN user_id INT,\n  IN status VARCHAR(20)\n)\nBEGIN\n  SELECT o.id, o.total, o.created_at, p.name\n  FROM orders o\n  JOIN order_items oi ON o.id = oi.order_id\n  JOIN products p ON oi.product_id = p.id\n  WHERE o.user_id = user_id\n    AND (status IS NULL OR o.status = status)\n  ORDER BY o.created_at DESC;\nEND //\nDELIMITER ;\n\n-- Call procedure\nCALL GetUserOrders(1, 'completed');\nCALL GetUserOrders(1, NULL);  -- All statuses\n\n-- Procedure with OUT parameter\nDELIMITER //\nCREATE PROCEDURE GetOrderTotal(\n  IN order_id INT,\n  OUT total DECIMAL(10,2)\n)\nBEGIN\n  SELECT SUM(quantity * price)\n  INTO total\n  FROM order_items\n  WHERE order_id = order_id;\nEND //\nDELIMITER ;\n\n-- Call with OUT\nCALL GetOrderTotal(1, @total);\nSELECT @total;\n\n-- Procedure with logic\nDELIMITER //\nCREATE PROCEDURE ApplyDiscount(\n  IN order_id INT,\n  IN discount_percent INT\n)\nBEGIN\n  DECLARE order_total DECIMAL(10,2);\n  \n  SELECT total INTO order_total FROM orders WHERE id = order_id;\n  \n  IF order_total > 100 THEN\n    UPDATE orders\n    SET total = total * (1 - discount_percent/100)\n    WHERE id = order_id;\n  END IF;\nEND //\nDELIMITER ;\n\n-- Drop procedure\nDROP PROCEDURE IF EXISTS GetUserOrders;"
    },
    {
      "id": 10,
      "question": "What is the difference between Primary Key and Unique Key?",
      "answer": "Primary Key:\n• Uniquely identifies each row\n• Only ONE per table\n• Cannot be NULL\n• Creates clustered index (InnoDB)\n• Used for relationships (foreign keys)\n\nUnique Key:\n• Ensures unique values\n• Multiple per table allowed\n• Can have ONE NULL (in MySQL)\n• Creates non-clustered index\n• Used for business rules (email, username)",
      "explanation": "Primary key is the main identifier. Unique keys enforce uniqueness on other columns like email or phone.",
      "difficulty": "Easy",
      "code": "-- Primary key\nCREATE TABLE users (\n  id INT AUTO_INCREMENT PRIMARY KEY,\n  email VARCHAR(255),\n  username VARCHAR(50)\n);\n\n-- Composite primary key\nCREATE TABLE order_items (\n  order_id INT,\n  product_id INT,\n  quantity INT,\n  PRIMARY KEY (order_id, product_id)\n);\n\n-- Unique key\nCREATE TABLE users (\n  id INT AUTO_INCREMENT PRIMARY KEY,\n  email VARCHAR(255) UNIQUE,  -- Cannot duplicate\n  username VARCHAR(50) UNIQUE,\n  phone VARCHAR(20) UNIQUE\n);\n\n-- Named unique constraint\nCREATE TABLE users (\n  id INT AUTO_INCREMENT PRIMARY KEY,\n  email VARCHAR(255),\n  UNIQUE KEY uk_email (email)\n);\n\n-- Composite unique key\nCREATE TABLE user_roles (\n  user_id INT,\n  role_id INT,\n  UNIQUE KEY uk_user_role (user_id, role_id)\n);\n\n-- Add unique to existing table\nALTER TABLE users ADD UNIQUE (email);\n\n-- NULL behavior\nINSERT INTO users (email) VALUES (NULL);  -- OK\nINSERT INTO users (email) VALUES (NULL);  -- Error in some DBs, OK in MySQL"
    },
    {
      "id": 11,
      "question": "What are Aggregate Functions in MySQL?",
      "answer": "Aggregate functions perform calculations on multiple rows.\n\nCommon functions:\n• COUNT(): Number of rows\n• SUM(): Total of values\n• AVG(): Average value\n• MAX(): Maximum value\n• MIN(): Minimum value\n• GROUP_CONCAT(): Concatenate values\n\nUsed with GROUP BY for grouped calculations.",
      "explanation": "Aggregate functions summarize data. Without GROUP BY, they operate on all rows. With GROUP BY, they operate per group.",
      "difficulty": "Easy",
      "code": "-- Basic aggregates\nSELECT \n  COUNT(*) AS total_orders,\n  SUM(total) AS revenue,\n  AVG(total) AS avg_order,\n  MAX(total) AS largest_order,\n  MIN(total) AS smallest_order\nFROM orders;\n\n-- COUNT variations\nSELECT \n  COUNT(*) AS total_rows,       -- Counts all rows\n  COUNT(email) AS with_email,   -- Counts non-NULL\n  COUNT(DISTINCT country) AS countries  -- Counts unique\nFROM users;\n\n-- With GROUP BY\nSELECT \n  department_id,\n  COUNT(*) AS employee_count,\n  AVG(salary) AS avg_salary\nFROM employees\nGROUP BY department_id;\n\n-- GROUP_CONCAT\nSELECT \n  order_id,\n  GROUP_CONCAT(product_name SEPARATOR ', ') AS products\nFROM order_items\nGROUP BY order_id;\n-- Result: \"Laptop, Mouse, Keyboard\"\n\n-- With HAVING\nSELECT \n  category_id,\n  COUNT(*) AS product_count,\n  AVG(price) AS avg_price\nFROM products\nGROUP BY category_id\nHAVING COUNT(*) > 10\nORDER BY avg_price DESC;\n\n-- Nested aggregates (using subquery)\nSELECT AVG(order_count)\nFROM (\n  SELECT user_id, COUNT(*) AS order_count\n  FROM orders\n  GROUP BY user_id\n) AS user_orders;"
    },
    {
      "id": 12,
      "question": "What are Views in MySQL?",
      "answer": "Views are virtual tables based on SELECT queries.\n\nBenefits:\n• Simplify complex queries\n• Abstract underlying tables\n• Security: Expose only certain columns\n• Consistent interface even if tables change\n\nLimitations:\n• Not always updatable\n• Can have performance overhead\n• No indexes on views",
      "explanation": "Views provide abstraction layer. They don't store data - they execute the underlying query. Good for common queries and security.",
      "difficulty": "Medium",
      "code": "-- Create view\nCREATE VIEW active_users AS\nSELECT id, name, email, created_at\nFROM users\nWHERE status = 'active';\n\n-- Use view like table\nSELECT * FROM active_users WHERE name LIKE 'John%';\n\n-- Complex view\nCREATE VIEW order_summary AS\nSELECT \n  o.id AS order_id,\n  u.name AS customer_name,\n  o.total,\n  o.status,\n  COUNT(oi.id) AS item_count\nFROM orders o\nJOIN users u ON o.user_id = u.id\nJOIN order_items oi ON o.id = oi.order_id\nGROUP BY o.id, u.name, o.total, o.status;\n\n-- Updatable view (simple views)\nCREATE VIEW user_emails AS\nSELECT id, email FROM users;\n\nUPDATE user_emails SET email = 'new@test.com' WHERE id = 1;\n-- Updates underlying table\n\n-- With CHECK OPTION\nCREATE VIEW active_users AS\nSELECT * FROM users WHERE status = 'active'\nWITH CHECK OPTION;\n-- Cannot insert inactive user through this view\n\n-- Replace view\nCREATE OR REPLACE VIEW active_users AS\nSELECT id, name, email, last_login\nFROM users\nWHERE status = 'active';\n\n-- Drop view\nDROP VIEW IF EXISTS active_users;"
    },
    {
      "id": 13,
      "question": "What is the difference between CHAR and VARCHAR?",
      "answer": "CHAR:\n• Fixed length\n• Padded with spaces to length\n• Faster for fixed-size data\n• Max 255 characters\n• Good for: codes, status flags\n\nVARCHAR:\n• Variable length\n• Stores actual length + 1-2 bytes\n• More space efficient for varying data\n• Max 65,535 characters\n• Good for: names, emails, descriptions",
      "explanation": "Use CHAR for fixed-length data (country codes, yes/no). Use VARCHAR for variable-length data to save space.",
      "difficulty": "Easy",
      "code": "-- CHAR: Fixed length\nCREATE TABLE countries (\n  code CHAR(2),         -- Always 2 chars: 'US', 'UK'\n  code3 CHAR(3)         -- Always 3 chars: 'USA', 'GBR'\n);\n\n-- Padding behavior\nINSERT INTO test (char_col) VALUES ('AB');\n-- Stored as 'AB   ' if CHAR(5)\n-- Trailing spaces removed on retrieval\n\n-- VARCHAR: Variable length\nCREATE TABLE users (\n  name VARCHAR(100),    -- 1-100 characters\n  email VARCHAR(255),   -- 1-255 characters\n  bio VARCHAR(1000)     -- 1-1000 characters\n);\n\n-- Storage comparison\n-- CHAR(10): Always uses 10 bytes\n-- VARCHAR(10): 1-11 bytes (data + length byte)\n\n-- Storing 'hello' (5 chars):\n-- CHAR(10): 10 bytes\n-- VARCHAR(10): 6 bytes (5 + 1)\n\n-- Practical choices\nCREATE TABLE products (\n  sku CHAR(10),                    -- Fixed format\n  status CHAR(1),                  -- 'A', 'I', 'D'\n  name VARCHAR(200),               -- Variable\n  description VARCHAR(5000),        -- Long text\n  slug VARCHAR(255)                -- SEO URL\n);\n\n-- TEXT types for longer content\nCREATE TABLE articles (\n  title VARCHAR(255),\n  content TEXT,          -- Up to 65KB\n  full_content MEDIUMTEXT -- Up to 16MB\n);"
    },
    {
      "id": 14,
      "question": "What are Triggers in MySQL?",
      "answer": "Triggers are automatic actions executed before/after DML events.\n\nEvents:\n• INSERT, UPDATE, DELETE\n\nTiming:\n• BEFORE: Validate/modify data before action\n• AFTER: Log changes, update related tables\n\nAccess:\n• NEW: New row values (INSERT, UPDATE)\n• OLD: Old row values (UPDATE, DELETE)\n\nUse cases:\n• Audit logging\n• Validation\n• Maintaining derived data",
      "explanation": "Triggers automate database logic. Use carefully - they can be hard to debug and impact performance.",
      "difficulty": "Medium",
      "code": "-- Audit log trigger\nCREATE TABLE audit_log (\n  id INT AUTO_INCREMENT PRIMARY KEY,\n  table_name VARCHAR(50),\n  action VARCHAR(10),\n  old_data JSON,\n  new_data JSON,\n  changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  changed_by INT\n);\n\nDELIMITER //\nCREATE TRIGGER users_after_update\nAFTER UPDATE ON users\nFOR EACH ROW\nBEGIN\n  INSERT INTO audit_log (table_name, action, old_data, new_data)\n  VALUES (\n    'users',\n    'UPDATE',\n    JSON_OBJECT('name', OLD.name, 'email', OLD.email),\n    JSON_OBJECT('name', NEW.name, 'email', NEW.email)\n  );\nEND //\nDELIMITER ;\n\n-- BEFORE trigger for validation/modification\nDELIMITER //\nCREATE TRIGGER orders_before_insert\nBEFORE INSERT ON orders\nFOR EACH ROW\nBEGIN\n  IF NEW.total < 0 THEN\n    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Total cannot be negative';\n  END IF;\n  \n  SET NEW.created_at = NOW();\n  SET NEW.status = COALESCE(NEW.status, 'pending');\nEND //\nDELIMITER ;\n\n-- Update derived data\nDELIMITER //\nCREATE TRIGGER order_items_after_insert\nAFTER INSERT ON order_items\nFOR EACH ROW\nBEGIN\n  UPDATE orders\n  SET total = total + (NEW.quantity * NEW.price)\n  WHERE id = NEW.order_id;\nEND //\nDELIMITER ;\n\n-- Show/drop triggers\nSHOW TRIGGERS;\nDROP TRIGGER IF EXISTS users_after_update;"
    },
    {
      "id": 15,
      "question": "How do you optimize MySQL queries?",
      "answer": "Query optimization techniques:\n\n1. Use EXPLAIN to analyze queries\n2. Add indexes on WHERE, JOIN columns\n3. Avoid SELECT * - select only needed columns\n4. Use LIMIT for large result sets\n5. Optimize JOINs - smaller table first\n6. Avoid functions on indexed columns in WHERE\n7. Use appropriate data types\n8. Avoid N+1 queries\n9. Use connection pooling\n10. Consider query caching",
      "explanation": "Start with EXPLAIN to understand query execution plan. Most optimizations involve proper indexing and query structure.",
      "difficulty": "Hard",
      "code": "-- Use EXPLAIN to analyze\nEXPLAIN SELECT * FROM users WHERE email = 'test@test.com';\nEXPLAIN ANALYZE SELECT * FROM users WHERE email = 'test@test.com';\n\n-- Bad: Function on indexed column\nSELECT * FROM orders WHERE YEAR(created_at) = 2024;\n\n-- Good: Range query (can use index)\nSELECT * FROM orders \nWHERE created_at >= '2024-01-01' \n  AND created_at < '2025-01-01';\n\n-- Bad: SELECT *\nSELECT * FROM users WHERE status = 'active';\n\n-- Good: Select needed columns\nSELECT id, name, email FROM users WHERE status = 'active';\n\n-- Bad: N+1 query problem\n-- First query: Get all orders\n-- Then N queries: Get user for each order\n\n-- Good: Single JOIN query\nSELECT o.*, u.name, u.email\nFROM orders o\nJOIN users u ON o.user_id = u.id;\n\n-- Use covering index\nCREATE INDEX idx_orders_cover \nON orders(user_id, status, created_at);\n\n-- Pagination optimization\n-- Bad for large offsets\nSELECT * FROM orders LIMIT 10 OFFSET 100000;\n\n-- Better: Keyset pagination\nSELECT * FROM orders \nWHERE id > 100000 \nORDER BY id LIMIT 10;\n\n-- Index hints (if optimizer chooses wrong index)\nSELECT * FROM orders \nFORCE INDEX (idx_user_id)\nWHERE user_id = 1;\n\n-- Analyze slow query log\nSET GLOBAL slow_query_log = 'ON';\nSET GLOBAL long_query_time = 1; -- seconds"
    },
    {
      "id": 16,
      "question": "What are Foreign Keys and Referential Integrity?",
      "answer": "Foreign Key: Column(s) that reference primary key in another table.\n\nReferential Integrity: Ensures relationships remain valid.\n\nActions on DELETE/UPDATE:\n• CASCADE: Delete/update child rows\n• SET NULL: Set foreign key to NULL\n• RESTRICT/NO ACTION: Prevent if children exist\n• SET DEFAULT: Set to default value\n\nBenefits:\n• Data consistency\n• Prevents orphaned records\n• Documents relationships",
      "explanation": "Foreign keys enforce relationships at database level. Choose appropriate ON DELETE/UPDATE actions based on business requirements.",
      "difficulty": "Medium",
      "code": "-- Create tables with foreign key\nCREATE TABLE departments (\n  id INT PRIMARY KEY AUTO_INCREMENT,\n  name VARCHAR(100) NOT NULL\n);\n\nCREATE TABLE employees (\n  id INT PRIMARY KEY AUTO_INCREMENT,\n  name VARCHAR(100) NOT NULL,\n  department_id INT,\n  FOREIGN KEY (department_id) \n    REFERENCES departments(id)\n    ON DELETE SET NULL\n    ON UPDATE CASCADE\n);\n\n-- Orders with CASCADE delete\nCREATE TABLE orders (\n  id INT PRIMARY KEY AUTO_INCREMENT,\n  user_id INT NOT NULL,\n  FOREIGN KEY (user_id) \n    REFERENCES users(id)\n    ON DELETE CASCADE  -- Delete orders when user deleted\n);\n\nCREATE TABLE order_items (\n  id INT PRIMARY KEY AUTO_INCREMENT,\n  order_id INT NOT NULL,\n  product_id INT NOT NULL,\n  FOREIGN KEY (order_id) \n    REFERENCES orders(id)\n    ON DELETE CASCADE,  -- Delete items when order deleted\n  FOREIGN KEY (product_id) \n    REFERENCES products(id)\n    ON DELETE RESTRICT  -- Prevent product deletion if in orders\n);\n\n-- Add foreign key to existing table\nALTER TABLE employees\nADD CONSTRAINT fk_department\nFOREIGN KEY (department_id) REFERENCES departments(id);\n\n-- Drop foreign key\nALTER TABLE employees DROP FOREIGN KEY fk_department;\n\n-- View foreign keys\nSELECT * FROM information_schema.KEY_COLUMN_USAGE\nWHERE TABLE_SCHEMA = 'mydb' AND REFERENCED_TABLE_NAME IS NOT NULL;"
    },
    {
      "id": 17,
      "question": "What is the difference between InnoDB and MyISAM storage engines?",
      "answer": "InnoDB (Default since MySQL 5.5):\n• Transactions (ACID compliant)\n• Row-level locking\n• Foreign key support\n• Crash recovery\n• MVCC for concurrent reads\n• Better for write-heavy, concurrent access\n\nMyISAM:\n• No transactions\n• Table-level locking\n• No foreign keys\n• Full-text search (older versions)\n• Faster for read-heavy, simple queries\n• Smaller disk footprint",
      "explanation": "Use InnoDB for most applications - it's the modern default with transactions and better concurrency. MyISAM is legacy.",
      "difficulty": "Medium",
      "code": "-- Check current engine\nSHOW TABLE STATUS WHERE Name = 'users';\n\n-- Create with specific engine\nCREATE TABLE logs (\n  id INT AUTO_INCREMENT PRIMARY KEY,\n  message TEXT,\n  created_at TIMESTAMP\n) ENGINE=InnoDB;\n\n-- Change engine\nALTER TABLE logs ENGINE=InnoDB;\n\n-- InnoDB transaction example\nSTART TRANSACTION;\nUPDATE accounts SET balance = balance - 100 WHERE id = 1;\nUPDATE accounts SET balance = balance + 100 WHERE id = 2;\nCOMMIT;\n\n-- InnoDB row-level locking\nSELECT * FROM orders WHERE id = 1 FOR UPDATE;\n-- Only this row is locked\n\n-- Check default engine\nSHOW VARIABLES LIKE 'default_storage_engine';\n\n-- Set default engine\nSET default_storage_engine=InnoDB;\n\n-- InnoDB buffer pool (main memory cache)\nSHOW VARIABLES LIKE 'innodb_buffer_pool_size';\n\n-- Key differences impact:\n-- InnoDB: Better for concurrent writes, transactions required\n-- MyISAM: Legacy, avoid for new applications\n\n-- Memory engine (temporary tables)\nCREATE TABLE cache (\n  key VARCHAR(255) PRIMARY KEY,\n  value TEXT\n) ENGINE=MEMORY;"
    },
    {
      "id": 18,
      "question": "How do you implement Pagination in MySQL?",
      "answer": "Basic pagination:\n• LIMIT: Number of rows to return\n• OFFSET: Number of rows to skip\n\nKeyset pagination (better for large datasets):\n• Use WHERE with last seen value\n• More efficient, no OFFSET\n\nTotal count for pagination UI:\n• Separate COUNT query\n• Or SQL_CALC_FOUND_ROWS (deprecated)",
      "explanation": "LIMIT/OFFSET is simple but slow for large offsets. Keyset pagination scales better - use it for large datasets.",
      "difficulty": "Medium",
      "code": "-- Basic LIMIT/OFFSET pagination\n-- Page 1 (first 10 rows)\nSELECT * FROM products ORDER BY id LIMIT 10 OFFSET 0;\n\n-- Page 2 (rows 11-20)\nSELECT * FROM products ORDER BY id LIMIT 10 OFFSET 10;\n\n-- Page N\nSELECT * FROM products ORDER BY id LIMIT 10 OFFSET (page - 1) * 10;\n\n-- Get total count for pagination UI\nSELECT COUNT(*) FROM products WHERE category_id = 1;\n\n-- Combined (two queries)\n-- Query 1: Get total\nSELECT COUNT(*) as total FROM products WHERE active = 1;\n-- Query 2: Get page\nSELECT * FROM products WHERE active = 1 ORDER BY id LIMIT 10 OFFSET 20;\n\n-- PROBLEM: Large offset is slow\nSELECT * FROM products ORDER BY id LIMIT 10 OFFSET 1000000;\n-- MySQL must scan 1M rows to skip them!\n\n-- SOLUTION: Keyset pagination\n-- First page\nSELECT * FROM products ORDER BY id LIMIT 10;\n\n-- Next page (use last id from previous page)\nSELECT * FROM products \nWHERE id > 1234  -- Last seen ID\nORDER BY id \nLIMIT 10;\n\n-- With multiple sort columns\nSELECT * FROM products\nWHERE (created_at, id) > ('2024-01-15', 1234)\nORDER BY created_at, id\nLIMIT 10;\n\n-- Deferred join (optimization)\nSELECT * FROM products\nINNER JOIN (\n  SELECT id FROM products ORDER BY id LIMIT 10 OFFSET 100000\n) AS tmp USING (id);"
    },
    {
      "id": 19,
      "question": "What are Subqueries and Correlated Subqueries?",
      "answer": "Subquery: Query nested inside another query.\n\nTypes:\n• Scalar: Returns single value\n• Row: Returns single row\n• Table: Returns table (derived table)\n• Correlated: References outer query\n\nCorrelated Subquery:\n• Executed once per outer row\n• References outer query columns\n• Can be slower than JOINs\n• Useful for row-by-row comparisons",
      "explanation": "Regular subqueries execute once. Correlated subqueries execute for each outer row - powerful but can be slow.",
      "difficulty": "Hard",
      "code": "-- Scalar subquery (single value)\nSELECT name, salary,\n  (SELECT AVG(salary) FROM employees) AS avg_salary\nFROM employees;\n\n-- Subquery in WHERE\nSELECT * FROM products\nWHERE price > (SELECT AVG(price) FROM products);\n\n-- IN with subquery\nSELECT * FROM users\nWHERE id IN (SELECT user_id FROM orders WHERE total > 1000);\n\n-- EXISTS (often better than IN)\nSELECT * FROM users u\nWHERE EXISTS (\n  SELECT 1 FROM orders o \n  WHERE o.user_id = u.id AND o.total > 1000\n);\n\n-- Derived table (subquery in FROM)\nSELECT category, avg_price\nFROM (\n  SELECT category_id AS category, AVG(price) AS avg_price\n  FROM products\n  GROUP BY category_id\n) AS category_averages\nWHERE avg_price > 100;\n\n-- CORRELATED subquery (executes per row)\nSELECT e.name, e.salary, e.department_id\nFROM employees e\nWHERE e.salary > (\n  SELECT AVG(salary) \n  FROM employees \n  WHERE department_id = e.department_id  -- References outer query!\n);\n-- Returns employees earning above their department average\n\n-- Get latest order per user (correlated)\nSELECT *\nFROM orders o1\nWHERE created_at = (\n  SELECT MAX(created_at)\n  FROM orders o2\n  WHERE o2.user_id = o1.user_id\n);\n\n-- Often rewritten as JOIN for performance\nSELECT o.*\nFROM orders o\nINNER JOIN (\n  SELECT user_id, MAX(created_at) AS max_date\n  FROM orders\n  GROUP BY user_id\n) latest ON o.user_id = latest.user_id \n        AND o.created_at = latest.max_date;"
    },
    {
      "id": 20,
      "question": "What are Window Functions in MySQL?",
      "answer": "Window functions perform calculations across related rows without grouping.\n\nComponents:\n• Function (ROW_NUMBER, RANK, SUM...)\n• OVER clause defines window\n• PARTITION BY: Groups for calculation\n• ORDER BY: Order within partition\n• Frame: ROWS BETWEEN...\n\nCommon functions:\n• ROW_NUMBER(), RANK(), DENSE_RANK()\n• LAG(), LEAD() - access adjacent rows\n• SUM(), AVG() - running totals\n• FIRST_VALUE(), LAST_VALUE()",
      "explanation": "Window functions are powerful for analytics - running totals, rankings, comparisons with adjacent rows. Added in MySQL 8.0.",
      "difficulty": "Hard",
      "code": "-- ROW_NUMBER: Unique sequential number\nSELECT \n  name, department_id, salary,\n  ROW_NUMBER() OVER (ORDER BY salary DESC) AS rank\nFROM employees;\n\n-- RANK with PARTITION BY department\nSELECT \n  name, department_id, salary,\n  RANK() OVER (\n    PARTITION BY department_id \n    ORDER BY salary DESC\n  ) AS dept_rank\nFROM employees;\n-- Rank resets for each department\n\n-- Get top 3 per department\nSELECT * FROM (\n  SELECT \n    name, department_id, salary,\n    ROW_NUMBER() OVER (\n      PARTITION BY department_id \n      ORDER BY salary DESC\n    ) AS rn\n  FROM employees\n) ranked\nWHERE rn <= 3;\n\n-- Running total\nSELECT \n  order_date, total,\n  SUM(total) OVER (ORDER BY order_date) AS running_total\nFROM orders;\n\n-- LAG/LEAD: Compare with previous/next row\nSELECT \n  order_date, total,\n  LAG(total) OVER (ORDER BY order_date) AS prev_total,\n  total - LAG(total) OVER (ORDER BY order_date) AS difference\nFROM orders;\n\n-- Moving average\nSELECT \n  order_date, total,\n  AVG(total) OVER (\n    ORDER BY order_date\n    ROWS BETWEEN 2 PRECEDING AND CURRENT ROW\n  ) AS moving_avg_3\nFROM orders;\n\n-- Percentage of total\nSELECT \n  name, salary,\n  salary / SUM(salary) OVER () * 100 AS salary_percentage\nFROM employees;\n\n-- DENSE_RANK vs RANK\n-- RANK: 1, 2, 2, 4 (skips after tie)\n-- DENSE_RANK: 1, 2, 2, 3 (no skip)"
    }
  ]
}
