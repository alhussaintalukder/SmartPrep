{
  "topic": "Native Android (Java)",
  "questions": [
    {
      "id": 1,
      "question": "What is an Activity in Android?",
      "answer": "An Activity represents a single screen with a user interface in an Android application.\n\nKey Characteristics:\n• Represents one screen of the app\n• Entry point for interacting with the user\n• Has its own lifecycle managed by Android system\n• Can contain Fragments for modular UI design\n\nLifecycle Methods:\n• onCreate() - Initialize activity\n• onStart() - Make activity visible\n• onResume() - Start interacting with user\n• onPause() - Activity loses focus\n• onStop() - Activity no longer visible\n• onDestroy() - Activity is being destroyed",
      "explanation": "Activity is a fundamental component that represents a single screen with UI and manages user interactions through a well-defined lifecycle.",
      "difficulty": "Easy",
      "code": "public class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        // Initialize views and setup listeners\n        Button button = findViewById(R.id.myButton);\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                // Handle click\n            }\n        });\n    }\n    \n    @Override\n    protected void onStart() {\n        super.onStart();\n        // Activity is visible\n    }\n}"
    },
    {
      "id": 2,
      "question": "What is the difference between Activity and Fragment?",
      "answer": "Activity and Fragment are both UI components but serve different purposes in Android architecture.\n\nActivity:\n• Represents entire screen\n• Has its own window\n• Cannot be nested inside another Activity\n• Entry point declared in AndroidManifest.xml\n• Independent lifecycle\n\nFragment:\n• Represents portion of UI within Activity\n• Must be hosted by Activity or another Fragment\n• Reusable across multiple Activities\n• Can be dynamically added or removed\n• Lifecycle tied to host Activity\n\nUse Cases:\n• Use Activity for main screens\n• Use Fragment for modular, reusable UI components\n• Use Fragment for responsive design (tablet vs phone)",
      "explanation": "Activity represents a complete screen with its own window, while Fragment is a modular UI component that must be hosted within an Activity and can be reused across multiple screens.",
      "difficulty": "Easy",
      "code": "// Activity hosting a Fragment\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        // Add Fragment to Activity\n        if (savedInstanceState == null) {\n            getSupportFragmentManager()\n                .beginTransaction()\n                .add(R.id.fragment_container, new MyFragment())\n                .commit();\n        }\n    }\n}\n\n// Fragment class\npublic class MyFragment extends Fragment {\n    @Override\n    public View onCreateView(LayoutInflater inflater, \n                           ViewGroup container, \n                           Bundle savedInstanceState) {\n        return inflater.inflate(R.layout.fragment_my, container, false);\n    }\n}"
    },
    {
      "id": 3,
      "question": "Explain the Android Activity lifecycle.",
      "answer": "The Activity lifecycle consists of callback methods that are called as the Activity transitions through different states.\n\nLifecycle States:\n• Created - Activity is being initialized\n• Started - Activity becomes visible\n• Resumed - Activity is in foreground and interactive\n• Paused - Activity loses focus but still visible\n• Stopped - Activity no longer visible\n• Destroyed - Activity is being removed from memory\n\nCallback Methods Flow:\n• onCreate() - Called when Activity is first created\n• onStart() - Called when Activity becomes visible\n• onResume() - Called when Activity starts interacting with user\n• onPause() - Called when Activity loses focus\n• onStop() - Called when Activity is no longer visible\n• onRestart() - Called when Activity is restarting from stopped state\n• onDestroy() - Called before Activity is destroyed\n\nCommon Scenarios:\n• App Launch: onCreate() → onStart() → onResume()\n• User Leaves: onPause() → onStop()\n• User Returns: onRestart() → onStart() → onResume()\n• App Closes: onPause() → onStop() → onDestroy()",
      "explanation": "Activity lifecycle is a series of callback methods that track an Activity's state from creation to destruction, allowing proper resource management and state preservation.",
      "difficulty": "Easy",
      "code": "public class MainActivity extends AppCompatActivity {\n    private static final String TAG = \"MainActivity\";\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Log.d(TAG, \"onCreate called\");\n    }\n    \n    @Override\n    protected void onStart() {\n        super.onStart();\n        Log.d(TAG, \"onStart called\");\n    }\n    \n    @Override\n    protected void onResume() {\n        super.onResume();\n        Log.d(TAG, \"onResume called - Activity interactive\");\n    }\n    \n    @Override\n    protected void onPause() {\n        super.onPause();\n        Log.d(TAG, \"onPause called - Losing focus\");\n        // Save critical data\n    }\n    \n    @Override\n    protected void onStop() {\n        super.onStop();\n        Log.d(TAG, \"onStop called - No longer visible\");\n    }\n    \n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        Log.d(TAG, \"onDestroy called - Cleaning up\");\n    }\n}"
    },
    {
      "id": 4,
      "question": "What is an Intent in Android?",
      "answer": "Intent is a messaging object used to request an action from another app component or to communicate between components.\n\nTypes of Intents:\n• Explicit Intent - Specifies exact component to start\n• Implicit Intent - Declares general action, system finds suitable component\n\nCommon Uses:\n• Starting Activities\n• Starting Services\n• Delivering Broadcasts\n• Passing data between components\n\nIntent Components:\n• Action - Operation to perform (ACTION_VIEW, ACTION_SEND)\n• Data - URI of data to operate on\n• Category - Additional information about action\n• Extras - Key-value pairs of additional data\n• Component - Explicit component name\n• Flags - Control how Activity is launched",
      "explanation": "Intent is a messaging object that facilitates communication between Android components and can start activities, services, or deliver broadcasts either explicitly or implicitly.",
      "difficulty": "Easy",
      "code": "// Explicit Intent - Start specific Activity\nIntent explicitIntent = new Intent(MainActivity.this, SecondActivity.class);\nexplicitIntent.putExtra(\"key\", \"value\");\nexplicitIntent.putExtra(\"userId\", 123);\nstartActivity(explicitIntent);\n\n// Implicit Intent - Share text\nIntent shareIntent = new Intent(Intent.ACTION_SEND);\nshareIntent.setType(\"text/plain\");\nshareIntent.putExtra(Intent.EXTRA_TEXT, \"Share this text\");\nstartActivity(Intent.createChooser(shareIntent, \"Share via\"));\n\n// Implicit Intent - Open URL\nIntent browserIntent = new Intent(Intent.ACTION_VIEW, \n    Uri.parse(\"https://www.example.com\"));\nstartActivity(browserIntent);\n\n// Receiving Intent data in target Activity\npublic class SecondActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        \n        Intent intent = getIntent();\n        String value = intent.getStringExtra(\"key\");\n        int userId = intent.getIntExtra(\"userId\", 0);\n    }\n}"
    },
    {
      "id": 5,
      "question": "What is the difference between Explicit and Implicit Intents?",
      "answer": "Explicit and Implicit Intents differ in how they specify the target component to be invoked.\n\nExplicit Intent:\n• Specifies exact component by class name\n• Used for internal app navigation\n• Target component is known at compile time\n• More secure for sensitive operations\n• Direct component invocation\n\nImplicit Intent:\n• Declares general action to perform\n• System determines suitable component\n• Used to invoke external app components\n• Based on Intent Filter matching\n• Multiple apps can handle same Intent\n\nWhen to Use:\n• Explicit - Navigation within your app\n• Implicit - Sharing, opening URLs, making calls\n• Explicit - Starting your own Service\n• Implicit - Requesting system or third-party functionality",
      "explanation": "Explicit Intent directly specifies the target component by class name for internal app use, while Implicit Intent declares a general action allowing the system to find a suitable component from any app.",
      "difficulty": "Easy",
      "code": "// Explicit Intent - Navigate to specific Activity\nIntent explicit = new Intent(this, ProfileActivity.class);\nexplicit.putExtra(\"username\", \"john_doe\");\nstartActivity(explicit);\n\n// Implicit Intent - Make phone call\nIntent callIntent = new Intent(Intent.ACTION_DIAL);\ncallIntent.setData(Uri.parse(\"tel:1234567890\"));\nif (callIntent.resolveActivity(getPackageManager()) != null) {\n    startActivity(callIntent);\n}\n\n// Implicit Intent - Send email\nIntent emailIntent = new Intent(Intent.ACTION_SENDTO);\nemailIntent.setData(Uri.parse(\"mailto:test@example.com\"));\nemailIntent.putExtra(Intent.EXTRA_SUBJECT, \"Subject\");\nemailIntent.putExtra(Intent.EXTRA_TEXT, \"Email body\");\nif (emailIntent.resolveActivity(getPackageManager()) != null) {\n    startActivity(emailIntent);\n}\n\n// Intent Filter in AndroidManifest.xml for receiving Implicit Intents\n// <activity android:name=\".ShareActivity\">\n//     <intent-filter>\n//         <action android:name=\"android.intent.action.SEND\" />\n//         <category android:name=\"android.intent.category.DEFAULT\" />\n//         <data android:mimeType=\"text/plain\" />\n//     </intent-filter>\n// </activity>"
    },
    {
      "id": 6,
      "question": "What is a Service in Android?",
      "answer": "A Service is an application component that performs long-running operations in the background without providing a user interface.\n\nTypes of Services:\n• Foreground Service - Noticeable to user, shows notification\n• Background Service - Runs without user awareness\n• Bound Service - Allows components to bind and interact with it\n\nKey Characteristics:\n• Runs in background\n• No user interface\n• Continues running even if user switches apps\n• Runs on main thread by default\n• Must be declared in AndroidManifest.xml\n\nCommon Use Cases:\n• Playing music in background\n• Downloading files\n• Network operations\n• Syncing data\n• Location tracking",
      "explanation": "Service is a background component for long-running operations without UI, running independently of the user interface lifecycle.",
      "difficulty": "Easy",
      "code": "// Service class\npublic class MusicService extends Service {\n    private MediaPlayer mediaPlayer;\n    \n    @Override\n    public void onCreate() {\n        super.onCreate();\n        mediaPlayer = MediaPlayer.create(this, R.raw.song);\n    }\n    \n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        mediaPlayer.start();\n        return START_STICKY; // Restart if killed\n    }\n    \n    @Override\n    public void onDestroy() {\n        mediaPlayer.stop();\n        mediaPlayer.release();\n        super.onDestroy();\n    }\n    \n    @Override\n    public IBinder onBind(Intent intent) {\n        return null; // Not a bound service\n    }\n}\n\n// Starting Service from Activity\nIntent serviceIntent = new Intent(this, MusicService.class);\nstartService(serviceIntent);\n\n// Stopping Service\nstopService(serviceIntent);"
    },
    {
      "id": 7,
      "question": "What is the difference between Service and IntentService?",
      "answer": "Service and IntentService are both used for background operations but differ in implementation and threading model.\n\nService:\n• Runs on main thread\n• Must manually handle threading\n• Handles multiple requests simultaneously\n• Must call stopSelf() to stop\n• Suitable for ongoing operations\n\nIntentService:\n• Runs on separate worker thread automatically\n• Handles one request at a time in queue\n• Stops automatically when work is done\n• No need to manage threading\n• Suitable for one-off tasks\n\nNote:\n• IntentService is deprecated since API 30\n• Use WorkManager or JobIntentService instead\n• Service requires manual thread management with HandlerThread or Executors",
      "explanation": "Service runs on the main thread and requires manual threading for concurrent operations, while IntentService automatically handles threading and processes requests sequentially on a worker thread.",
      "difficulty": "Medium",
      "code": "// Regular Service - Manual threading\npublic class DownloadService extends Service {\n    private ExecutorService executor;\n    \n    @Override\n    public void onCreate() {\n        super.onCreate();\n        executor = Executors.newFixedThreadPool(3);\n    }\n    \n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        final String url = intent.getStringExtra(\"url\");\n        \n        executor.execute(new Runnable() {\n            @Override\n            public void run() {\n                // Download file on background thread\n                downloadFile(url);\n            }\n        });\n        \n        return START_NOT_STICKY;\n    }\n    \n    @Override\n    public IBinder onBind(Intent intent) {\n        return null;\n    }\n}\n\n// IntentService - Automatic threading (Deprecated)\npublic class DownloadIntentService extends IntentService {\n    public DownloadIntentService() {\n        super(\"DownloadIntentService\");\n    }\n    \n    @Override\n    protected void onHandleIntent(Intent intent) {\n        // Already on worker thread\n        String url = intent.getStringExtra(\"url\");\n        downloadFile(url);\n        // Service stops automatically when done\n    }\n}"
    },
    {
      "id": 8,
      "question": "What is a BroadcastReceiver in Android?",
      "answer": "BroadcastReceiver is a component that responds to system-wide broadcast announcements or custom broadcasts from apps.\n\nKey Features:\n• Listens for broadcast messages\n• Can be registered statically or dynamically\n• Receives Intent objects as broadcasts\n• Runs for short duration (10 seconds limit)\n• Cannot show UI directly\n\nTypes of Registration:\n• Static - Declared in AndroidManifest.xml\n• Dynamic - Registered programmatically in code\n\nCommon System Broadcasts:\n• BOOT_COMPLETED - Device finished booting\n• BATTERY_LOW - Battery is low\n• CONNECTIVITY_CHANGE - Network connectivity changed\n• SMS_RECEIVED - SMS message received\n• SCREEN_ON/OFF - Screen turned on/off\n\nBest Practices:\n• Keep onReceive() method lightweight\n• Use JobScheduler or WorkManager for long tasks\n• Unregister dynamic receivers to avoid memory leaks",
      "explanation": "BroadcastReceiver is a component that listens for and responds to broadcast messages from the system or other applications, executing short-lived operations in response to events.",
      "difficulty": "Easy",
      "code": "// BroadcastReceiver class\npublic class NetworkChangeReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        if (ConnectivityManager.CONNECTIVITY_ACTION.equals(intent.getAction())) {\n            boolean isConnected = isNetworkConnected(context);\n            Toast.makeText(context, \n                \"Network: \" + (isConnected ? \"Connected\" : \"Disconnected\"), \n                Toast.LENGTH_SHORT).show();\n        }\n    }\n    \n    private boolean isNetworkConnected(Context context) {\n        ConnectivityManager cm = (ConnectivityManager) \n            context.getSystemService(Context.CONNECTIVITY_SERVICE);\n        NetworkInfo activeNetwork = cm.getActiveNetworkInfo();\n        return activeNetwork != null && activeNetwork.isConnectedOrConnecting();\n    }\n}\n\n// Dynamic Registration in Activity\npublic class MainActivity extends AppCompatActivity {\n    private NetworkChangeReceiver receiver;\n    \n    @Override\n    protected void onResume() {\n        super.onResume();\n        receiver = new NetworkChangeReceiver();\n        IntentFilter filter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);\n        registerReceiver(receiver, filter);\n    }\n    \n    @Override\n    protected void onPause() {\n        super.onPause();\n        unregisterReceiver(receiver);\n    }\n}\n\n// Static Registration in AndroidManifest.xml\n// <receiver android:name=\".NetworkChangeReceiver\">\n//     <intent-filter>\n//         <action android:name=\"android.net.conn.CONNECTIVITY_CHANGE\" />\n//     </intent-filter>\n// </receiver>"
    },
    {
      "id": 9,
      "question": "What is a ContentProvider in Android?",
      "answer": "ContentProvider is a component that manages access to a structured set of data and provides a standard interface for data access across applications.\n\nKey Features:\n• Centralized data management\n• Enables data sharing between apps\n• Provides standard CRUD operations\n• Supports different data sources (SQLite, files, network)\n• Handles data security and permissions\n\nMain Methods:\n• query() - Retrieve data\n• insert() - Add new data\n• update() - Modify existing data\n• delete() - Remove data\n• getType() - Return MIME type of data\n\nCommon Use Cases:\n• Contacts provider\n• Media store provider\n• Calendar provider\n• Custom app data sharing\n\nContent URI Format:\n• content://authority/path/id\n• Example: content://com.example.provider/users/1",
      "explanation": "ContentProvider is a standardized interface for managing and sharing structured data across applications, supporting CRUD operations and data encapsulation.",
      "difficulty": "Medium",
      "code": "// ContentProvider implementation\npublic class UserProvider extends ContentProvider {\n    private static final String AUTHORITY = \"com.example.provider\";\n    private static final String USERS_PATH = \"users\";\n    private static final Uri CONTENT_URI = \n        Uri.parse(\"content://\" + AUTHORITY + \"/\" + USERS_PATH);\n    \n    private static final int USERS = 1;\n    private static final int USER_ID = 2;\n    private static UriMatcher uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n    \n    static {\n        uriMatcher.addURI(AUTHORITY, USERS_PATH, USERS);\n        uriMatcher.addURI(AUTHORITY, USERS_PATH + \"/#\", USER_ID);\n    }\n    \n    private DatabaseHelper dbHelper;\n    \n    @Override\n    public boolean onCreate() {\n        dbHelper = new DatabaseHelper(getContext());\n        return true;\n    }\n    \n    @Override\n    public Cursor query(Uri uri, String[] projection, String selection,\n                       String[] selectionArgs, String sortOrder) {\n        SQLiteDatabase db = dbHelper.getReadableDatabase();\n        Cursor cursor;\n        \n        switch (uriMatcher.match(uri)) {\n            case USERS:\n                cursor = db.query(\"users\", projection, selection, \n                                selectionArgs, null, null, sortOrder);\n                break;\n            case USER_ID:\n                selection = \"_id=?\";\n                selectionArgs = new String[] { uri.getLastPathSegment() };\n                cursor = db.query(\"users\", projection, selection, \n                                selectionArgs, null, null, sortOrder);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n        \n        cursor.setNotificationUri(getContext().getContentResolver(), uri);\n        return cursor;\n    }\n    \n    @Override\n    public Uri insert(Uri uri, ContentValues values) {\n        SQLiteDatabase db = dbHelper.getWritableDatabase();\n        long id = db.insert(\"users\", null, values);\n        getContext().getContentResolver().notifyChange(uri, null);\n        return Uri.withAppendedPath(CONTENT_URI, String.valueOf(id));\n    }\n    \n    @Override\n    public String getType(Uri uri) {\n        return null;\n    }\n    \n    @Override\n    public int delete(Uri uri, String selection, String[] selectionArgs) {\n        return 0;\n    }\n    \n    @Override\n    public int update(Uri uri, ContentValues values, String selection, \n                     String[] selectionArgs) {\n        return 0;\n    }\n}"
    },
    {
      "id": 10,
      "question": "What is the AndroidManifest.xml file?",
      "answer": "AndroidManifest.xml is an essential configuration file that describes fundamental information about the Android application.\n\nKey Information Declared:\n• Package name and application ID\n• App components (Activities, Services, Receivers, Providers)\n• Permissions required by app\n• Hardware and software features required\n• API level requirements (minSdk, targetSdk)\n• App theme and configuration\n\nComponent Declaration:\n• All Activities must be declared\n• Services, BroadcastReceivers, ContentProviders\n• Intent filters for components\n• Launch Activity specification\n\nPermissions:\n• Normal permissions (granted automatically)\n• Dangerous permissions (require runtime request)\n• Custom permissions definition\n\nConfiguration Elements:\n• Application name and icon\n• Screen orientations\n• Hardware requirements (camera, GPS)\n• Backup and security settings",
      "explanation": "AndroidManifest.xml is the essential XML configuration file that declares all app components, permissions, requirements, and fundamental application metadata required by the Android system.",
      "difficulty": "Easy",
      "code": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.myapp\">\n    \n    <!-- Permissions -->\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\n    <uses-permission android:name=\"android.permission.CAMERA\" />\n    \n    <!-- Hardware features -->\n    <uses-feature android:name=\"android.hardware.camera\" \n                  android:required=\"false\" />\n    \n    <!-- API level requirements -->\n    <uses-sdk\n        android:minSdkVersion=\"21\"\n        android:targetSdkVersion=\"33\" />\n    \n    <application\n        android:name=\".MyApplication\"\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:theme=\"@style/AppTheme\">\n        \n        <!-- Main Activity with launcher intent -->\n        <activity android:name=\".MainActivity\"\n                  android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n        \n        <!-- Other Activity -->\n        <activity android:name=\".DetailActivity\"\n                  android:parentActivityName=\".MainActivity\" />\n        \n        <!-- Service -->\n        <service android:name=\".MusicService\" />\n        \n        <!-- Broadcast Receiver -->\n        <receiver android:name=\".NetworkReceiver\">\n            <intent-filter>\n                <action android:name=\"android.net.conn.CONNECTIVITY_CHANGE\" />\n            </intent-filter>\n        </receiver>\n        \n        <!-- Content Provider -->\n        <provider\n            android:name=\".UserProvider\"\n            android:authorities=\"com.example.myapp.provider\"\n            android:exported=\"false\" />\n    </application>\n    \n</manifest>"
    },
    {
      "id": 11,
      "question": "What is the difference between View and ViewGroup in Android?",
      "answer": "View and ViewGroup are fundamental building blocks of Android UI, forming a tree-like hierarchy.\n\nView:\n• Basic UI component\n• Cannot contain other views\n• Occupies rectangular area on screen\n• Examples: Button, TextView, ImageView, EditText\n• Handles drawing and event processing\n\nViewGroup:\n• Container for other views\n• Extends View class\n• Defines layout structure\n• Examples: LinearLayout, RelativeLayout, ConstraintLayout\n• Manages child view positioning and sizing\n\nView Hierarchy:\n• ViewGroup contains Views or other ViewGroups\n• Forms tree structure\n• Root is always a ViewGroup\n• Depth affects performance\n\nKey Differences:\n• View is leaf node, ViewGroup is container\n• ViewGroup has addView() and removeView() methods\n• ViewGroup determines child layout through onLayout()",
      "explanation": "View is a basic UI component that draws content and handles events, while ViewGroup is a container that can hold and arrange multiple Views or other ViewGroups in a hierarchical structure.",
      "difficulty": "Easy",
      "code": "// Custom View\npublic class CircleView extends View {\n    private Paint paint;\n    \n    public CircleView(Context context) {\n        super(context);\n        init();\n    }\n    \n    private void init() {\n        paint = new Paint();\n        paint.setColor(Color.RED);\n        paint.setAntiAlias(true);\n    }\n    \n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        int centerX = getWidth() / 2;\n        int centerY = getHeight() / 2;\n        int radius = Math.min(centerX, centerY) - 10;\n        canvas.drawCircle(centerX, centerY, radius, paint);\n    }\n}\n\n// Custom ViewGroup\npublic class CustomLayout extends ViewGroup {\n    public CustomLayout(Context context) {\n        super(context);\n    }\n    \n    @Override\n    protected void onLayout(boolean changed, int l, int t, int r, int b) {\n        int childCount = getChildCount();\n        int x = 0;\n        int y = 0;\n        \n        for (int i = 0; i < childCount; i++) {\n            View child = getChildAt(i);\n            child.layout(x, y, x + child.getMeasuredWidth(), \n                        y + child.getMeasuredHeight());\n            x += child.getMeasuredWidth();\n        }\n    }\n    \n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        measureChildren(widthMeasureSpec, heightMeasureSpec);\n    }\n}"
    },
    {
      "id": 12,
      "question": "Explain the different types of Android layouts.",
      "answer": "Android provides various layout types to arrange UI components in different ways.\n\nLinearLayout:\n• Arranges children in single row or column\n• Supports weights for proportional sizing\n• Simple but can create deep hierarchies\n\nRelativeLayout:\n• Positions children relative to parent or siblings\n• Reduces view hierarchy depth\n• More complex attribute definitions\n\nConstraintLayout:\n• Modern flexible layout\n• Flat hierarchy with complex positioning\n• Uses constraints to define relationships\n• Best performance for complex layouts\n• Recommended for new development\n\nFrameLayout:\n• Simplest layout\n• Stacks children on top of each other\n• Used for single child or overlapping views\n\nGridLayout:\n• Arranges children in grid structure\n• Defines rows and columns\n• Flexible cell spanning\n\nCoordinatorLayout:\n• Advanced FrameLayout\n• Coordinates animations and behaviors\n• Used with Material Design components",
      "explanation": "Android offers multiple layout types including LinearLayout for linear arrangement, RelativeLayout for relative positioning, ConstraintLayout for flexible flat hierarchies, and specialized layouts like FrameLayout and GridLayout for specific use cases.",
      "difficulty": "Easy",
      "code": "<!-- LinearLayout with weights -->\n<LinearLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"horizontal\">\n    \n    <Button\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_weight=\"1\"\n        android:text=\"Button 1\" />\n    \n    <Button\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_weight=\"2\"\n        android:text=\"Button 2\" />\n</LinearLayout>\n\n<!-- ConstraintLayout -->\n<androidx.constraintlayout.widget.ConstraintLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    \n    <TextView\n        android:id=\"@+id/title\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Title\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n    \n    <Button\n        android:id=\"@+id/button\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Click Me\"\n        app:layout_constraintTop_toBottomOf=\"@id/title\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        android:layout_marginTop=\"16dp\" />\n</androidx.constraintlayout.widget.ConstraintLayout>"
    },
    {
      "id": 13,
      "question": "What is a RecyclerView and how does it work?",
      "answer": "RecyclerView is an advanced and flexible widget for displaying large datasets efficiently by recycling views.\n\nKey Components:\n• Adapter - Binds data to views\n• ViewHolder - Holds references to views for reuse\n• LayoutManager - Positions items (Linear, Grid, Staggered)\n• ItemDecoration - Adds visual decorations\n• ItemAnimator - Animates item changes\n\nView Recycling:\n• Creates limited number of views\n• Reuses views as they scroll off screen\n• ViewHolder pattern caches view references\n• Reduces findViewById() calls\n• Improves scrolling performance\n\nAdvantages over ListView:\n• Better performance with view recycling\n• Flexible layout managers\n• Built-in animations\n• Forced ViewHolder pattern\n• Easier item decorations\n\nCommon LayoutManagers:\n• LinearLayoutManager - Vertical or horizontal list\n• GridLayoutManager - Grid layout\n• StaggeredGridLayoutManager - Pinterest-style layout",
      "explanation": "RecyclerView is a high-performance widget for displaying large lists by efficiently recycling views through a ViewHolder pattern and flexible LayoutManagers, offering better performance than ListView.",
      "difficulty": "Medium",
      "code": "// ViewHolder class\npublic class UserViewHolder extends RecyclerView.ViewHolder {\n    TextView nameText;\n    TextView emailText;\n    \n    public UserViewHolder(View itemView) {\n        super(itemView);\n        nameText = itemView.findViewById(R.id.nameText);\n        emailText = itemView.findViewById(R.id.emailText);\n    }\n    \n    public void bind(User user) {\n        nameText.setText(user.getName());\n        emailText.setText(user.getEmail());\n    }\n}\n\n// Adapter class\npublic class UserAdapter extends RecyclerView.Adapter<UserViewHolder> {\n    private List<User> users;\n    \n    public UserAdapter(List<User> users) {\n        this.users = users;\n    }\n    \n    @Override\n    public UserViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        View view = LayoutInflater.from(parent.getContext())\n            .inflate(R.layout.item_user, parent, false);\n        return new UserViewHolder(view);\n    }\n    \n    @Override\n    public void onBindViewHolder(UserViewHolder holder, int position) {\n        User user = users.get(position);\n        holder.bind(user);\n    }\n    \n    @Override\n    public int getItemCount() {\n        return users.size();\n    }\n}\n\n// Setup in Activity\nRecyclerView recyclerView = findViewById(R.id.recyclerView);\nrecyclerView.setLayoutManager(new LinearLayoutManager(this));\nrecyclerView.setAdapter(new UserAdapter(userList));\nrecyclerView.addItemDecoration(\n    new DividerItemDecoration(this, DividerItemDecoration.VERTICAL));"
    },
    {
      "id": 14,
      "question": "What is the ViewHolder pattern and why is it important?",
      "answer": "ViewHolder pattern is a design pattern that caches view references to reduce expensive findViewById() calls during list scrolling.\n\nProblem Without ViewHolder:\n• findViewById() called repeatedly during scrolling\n• Significant performance overhead\n• Causes stuttering and lag\n• Inefficient view lookup\n\nViewHolder Solution:\n• Stores view references in holder object\n• findViewById() called only once per view type\n• Reuses holder when recycling views\n• Dramatically improves performance\n\nBenefits:\n• Faster scrolling performance\n• Reduced CPU usage\n• Smoother user experience\n• Required by RecyclerView\n• Best practice for ListView\n\nImplementation:\n• Create ViewHolder class with view references\n• Initialize views in constructor\n• Store ViewHolder as view tag\n• Reuse holder in adapter getView()",
      "explanation": "ViewHolder pattern improves list scrolling performance by caching view references, eliminating expensive findViewById() calls during view recycling and dramatically reducing CPU overhead.",
      "difficulty": "Medium",
      "code": "// Without ViewHolder (Poor Performance)\npublic View getView(int position, View convertView, ViewGroup parent) {\n    if (convertView == null) {\n        convertView = LayoutInflater.from(context)\n            .inflate(R.layout.item_layout, parent, false);\n    }\n    \n    // findViewById() called on EVERY scroll - SLOW!\n    TextView textView = convertView.findViewById(R.id.textView);\n    ImageView imageView = convertView.findViewById(R.id.imageView);\n    \n    textView.setText(items.get(position));\n    return convertView;\n}\n\n// With ViewHolder (Good Performance)\npublic class ViewHolder {\n    TextView textView;\n    ImageView imageView;\n    \n    public ViewHolder(View view) {\n        // findViewById() called only once per view\n        textView = view.findViewById(R.id.textView);\n        imageView = view.findViewById(R.id.imageView);\n    }\n}\n\npublic View getView(int position, View convertView, ViewGroup parent) {\n    ViewHolder holder;\n    \n    if (convertView == null) {\n        convertView = LayoutInflater.from(context)\n            .inflate(R.layout.item_layout, parent, false);\n        holder = new ViewHolder(convertView);\n        convertView.setTag(holder);\n    } else {\n        holder = (ViewHolder) convertView.getTag();\n    }\n    \n    // Direct access - FAST!\n    holder.textView.setText(items.get(position));\n    return convertView;\n}\n\n// RecyclerView enforces ViewHolder pattern\npublic class MyViewHolder extends RecyclerView.ViewHolder {\n    TextView textView;\n    \n    public MyViewHolder(View itemView) {\n        super(itemView);\n        textView = itemView.findViewById(R.id.textView);\n    }\n}"
    },
    {
      "id": 15,
      "question": "What is the difference between ListView and RecyclerView?",
      "answer": "ListView and RecyclerView are both used for displaying scrollable lists, but RecyclerView offers significant improvements.\n\nListView:\n• Older widget (pre-Lollipop)\n• ViewHolder pattern optional\n• Limited to vertical scrolling\n• No built-in animations\n• Less flexible customization\n• Simpler to implement\n\nRecyclerView:\n• Modern replacement for ListView\n• Enforces ViewHolder pattern\n• Supports multiple layout types\n• Built-in item animations\n• Better performance\n• More flexible and customizable\n• Requires more setup code\n\nKey Advantages of RecyclerView:\n• Multiple LayoutManagers (Linear, Grid, Staggered)\n• Better view recycling mechanism\n• ItemDecoration for dividers and spacing\n• ItemAnimator for smooth animations\n• DiffUtil for efficient updates\n• More efficient than ListView\n\nWhen to Use:\n• RecyclerView - New projects and complex lists\n• ListView - Simple lists in legacy code",
      "explanation": "RecyclerView is the modern, more efficient replacement for ListView with enforced ViewHolder pattern, flexible layouts, built-in animations, and better performance through improved view recycling.",
      "difficulty": "Medium",
      "code": "// ListView implementation\npublic class ListViewAdapter extends ArrayAdapter<String> {\n    public ListViewAdapter(Context context, List<String> items) {\n        super(context, R.layout.item_layout, items);\n    }\n    \n    @Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n        if (convertView == null) {\n            convertView = LayoutInflater.from(getContext())\n                .inflate(R.layout.item_layout, parent, false);\n        }\n        \n        TextView textView = convertView.findViewById(R.id.textView);\n        textView.setText(getItem(position));\n        return convertView;\n    }\n}\n\n// Setup ListView\nListView listView = findViewById(R.id.listView);\nlistView.setAdapter(new ListViewAdapter(this, items));\n\n// RecyclerView implementation (Better)\npublic class RecyclerAdapter extends RecyclerView.Adapter<RecyclerAdapter.ViewHolder> {\n    private List<String> items;\n    \n    public RecyclerAdapter(List<String> items) {\n        this.items = items;\n    }\n    \n    static class ViewHolder extends RecyclerView.ViewHolder {\n        TextView textView;\n        \n        ViewHolder(View view) {\n            super(view);\n            textView = view.findViewById(R.id.textView);\n        }\n    }\n    \n    @Override\n    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        View view = LayoutInflater.from(parent.getContext())\n            .inflate(R.layout.item_layout, parent, false);\n        return new ViewHolder(view);\n    }\n    \n    @Override\n    public void onBindViewHolder(ViewHolder holder, int position) {\n        holder.textView.setText(items.get(position));\n    }\n    \n    @Override\n    public int getItemCount() {\n        return items.size();\n    }\n}\n\n// Setup RecyclerView\nRecyclerView recyclerView = findViewById(R.id.recyclerView);\nrecyclerView.setLayoutManager(new LinearLayoutManager(this));\nrecyclerView.setAdapter(new RecyclerAdapter(items));"
    },
    {
      "id": 16,
      "question": "What is SharedPreferences in Android?",
      "answer": "SharedPreferences is a lightweight key-value storage mechanism for persisting small amounts of primitive data.\n\nKey Features:\n• Stores primitive data types (int, boolean, float, long, String)\n• Persists across app sessions\n• Private to application by default\n• XML-based storage\n• Fast read/write operations\n\nData Types Supported:\n• String, int, long, float, boolean\n• String Set (Set<String>)\n\nCommon Use Cases:\n• User preferences and settings\n• Login status\n• App configuration\n• First-time launch flags\n• Small amounts of data\n\nBest Practices:\n• Not for large data sets\n• Not for sensitive data (use EncryptedSharedPreferences)\n• Apply changes asynchronously with apply()\n• Use commit() only when immediate persistence needed\n• Consider Room database for complex data",
      "explanation": "SharedPreferences provides simple key-value storage for small amounts of primitive data that persists across app sessions, ideal for user preferences and simple app settings.",
      "difficulty": "Easy",
      "code": "// Writing to SharedPreferences\nSharedPreferences prefs = getSharedPreferences(\"MyPrefs\", MODE_PRIVATE);\nSharedPreferences.Editor editor = prefs.edit();\n\neditor.putString(\"username\", \"john_doe\");\neditor.putInt(\"age\", 25);\neditor.putBoolean(\"isLoggedIn\", true);\neditor.putFloat(\"rating\", 4.5f);\n\n// apply() - asynchronous (preferred)\neditor.apply();\n\n// commit() - synchronous (returns boolean)\nboolean success = editor.commit();\n\n// Reading from SharedPreferences\nString username = prefs.getString(\"username\", \"default_user\");\nint age = prefs.getInt(\"age\", 0);\nboolean isLoggedIn = prefs.getBoolean(\"isLoggedIn\", false);\nfloat rating = prefs.getFloat(\"rating\", 0.0f);\n\n// Check if key exists\nif (prefs.contains(\"username\")) {\n    // Key exists\n}\n\n// Remove specific key\neditor.remove(\"username\");\neditor.apply();\n\n// Clear all data\neditor.clear();\neditor.apply();\n\n// PreferenceManager (deprecated but still used)\nSharedPreferences defaultPrefs = \n    PreferenceManager.getDefaultSharedPreferences(this);"
    },
    {
      "id": 17,
      "question": "What is SQLite in Android and how do you use it?",
      "answer": "SQLite is a lightweight relational database engine embedded in Android for structured data storage.\n\nKey Features:\n• Serverless embedded database\n• Full SQL support\n• ACID compliant transactions\n• No configuration required\n• Private to application\n• Efficient for structured data\n\nSQLiteOpenHelper:\n• Abstract class for database management\n• Handles database creation and versioning\n• onCreate() - Creates database first time\n• onUpgrade() - Handles version upgrades\n• Provides readable and writable database instances\n\nBasic Operations (CRUD):\n• insert() - Add new records\n• query() - Retrieve records\n• update() - Modify records\n• delete() - Remove records\n\nBest Practices:\n• Use transactions for multiple operations\n• Close cursors and databases\n• Use parameters to prevent SQL injection\n• Consider Room library for modern approach\n• Index frequently queried columns",
      "explanation": "SQLite is Android's embedded relational database engine for storing structured data locally, managed through SQLiteOpenHelper and supporting standard SQL operations.",
      "difficulty": "Medium",
      "code": "// SQLiteOpenHelper implementation\npublic class DatabaseHelper extends SQLiteOpenHelper {\n    private static final String DATABASE_NAME = \"myapp.db\";\n    private static final int DATABASE_VERSION = 1;\n    \n    private static final String TABLE_USERS = \"users\";\n    private static final String COLUMN_ID = \"_id\";\n    private static final String COLUMN_NAME = \"name\";\n    private static final String COLUMN_EMAIL = \"email\";\n    \n    public DatabaseHelper(Context context) {\n        super(context, DATABASE_NAME, null, DATABASE_VERSION);\n    }\n    \n    @Override\n    public void onCreate(SQLiteDatabase db) {\n        String createTable = \"CREATE TABLE \" + TABLE_USERS + \" (\" +\n            COLUMN_ID + \" INTEGER PRIMARY KEY AUTOINCREMENT, \" +\n            COLUMN_NAME + \" TEXT NOT NULL, \" +\n            COLUMN_EMAIL + \" TEXT UNIQUE)\";\n        db.execSQL(createTable);\n    }\n    \n    @Override\n    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n        db.execSQL(\"DROP TABLE IF EXISTS \" + TABLE_USERS);\n        onCreate(db);\n    }\n    \n    // Insert\n    public long insertUser(String name, String email) {\n        SQLiteDatabase db = getWritableDatabase();\n        ContentValues values = new ContentValues();\n        values.put(COLUMN_NAME, name);\n        values.put(COLUMN_EMAIL, email);\n        \n        long id = db.insert(TABLE_USERS, null, values);\n        db.close();\n        return id;\n    }\n    \n    // Query\n    public Cursor getAllUsers() {\n        SQLiteDatabase db = getReadableDatabase();\n        return db.query(TABLE_USERS, null, null, null, null, null, \n                       COLUMN_NAME + \" ASC\");\n    }\n    \n    // Update\n    public int updateUser(int id, String name, String email) {\n        SQLiteDatabase db = getWritableDatabase();\n        ContentValues values = new ContentValues();\n        values.put(COLUMN_NAME, name);\n        values.put(COLUMN_EMAIL, email);\n        \n        int rows = db.update(TABLE_USERS, values, \n                           COLUMN_ID + \"=?\", \n                           new String[]{String.valueOf(id)});\n        db.close();\n        return rows;\n    }\n    \n    // Delete\n    public int deleteUser(int id) {\n        SQLiteDatabase db = getWritableDatabase();\n        int rows = db.delete(TABLE_USERS, COLUMN_ID + \"=?\", \n                           new String[]{String.valueOf(id)});\n        db.close();\n        return rows;\n    }\n}"
    },
    {
      "id": 18,
      "question": "What is the difference between AsyncTask and Thread in Android?",
      "answer": "AsyncTask and Thread are both used for background operations, but AsyncTask provides UI thread integration.\n\nAsyncTask (Deprecated since API 30):\n• Helper class for UI thread communication\n• Simplifies background tasks with UI updates\n• Built-in lifecycle methods\n• Executes on thread pool\n• Easy to use but deprecated\n\nThread:\n• Basic Java threading\n• No direct UI thread access\n• Requires Handler or runOnUiThread() for UI updates\n• More control over threading\n• Still valid and recommended approach\n\nAsyncTask Methods:\n• onPreExecute() - Runs on UI thread before task\n• doInBackground() - Background work\n• onProgressUpdate() - Update UI during execution\n• onPostExecute() - Runs on UI thread after completion\n\nModern Alternatives:\n• Kotlin Coroutines (recommended)\n• RxJava for reactive programming\n• ExecutorService with Handler\n• WorkManager for deferrable tasks",
      "explanation": "AsyncTask was a helper class simplifying background operations with UI updates but is now deprecated; Thread requires manual UI thread handling using Handler or runOnUiThread, with modern alternatives like Coroutines preferred.",
      "difficulty": "Medium",
      "code": "// AsyncTask (Deprecated - shown for reference)\npublic class DownloadTask extends AsyncTask<String, Integer, String> {\n    @Override\n    protected void onPreExecute() {\n        super.onPreExecute();\n        // Show progress dialog\n    }\n    \n    @Override\n    protected String doInBackground(String... urls) {\n        // Background work\n        for (int i = 0; i <= 100; i += 10) {\n            publishProgress(i);\n            try {\n                Thread.sleep(500);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        return \"Download complete\";\n    }\n    \n    @Override\n    protected void onProgressUpdate(Integer... progress) {\n        super.onProgressUpdate(progress);\n        // Update progress bar\n    }\n    \n    @Override\n    protected void onPostExecute(String result) {\n        super.onPostExecute(result);\n        // Update UI with result\n    }\n}\n\n// Thread with Handler (Modern approach)\npublic class MainActivity extends AppCompatActivity {\n    private Handler handler = new Handler(Looper.getMainLooper());\n    \n    private void performTask() {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                // Background work\n                final String result = downloadData();\n                \n                // Update UI\n                handler.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        textView.setText(result);\n                    }\n                });\n            }\n        }).start();\n    }\n    \n    // Using runOnUiThread\n    private void performTask2() {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                final String result = downloadData();\n                \n                runOnUiThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        textView.setText(result);\n                    }\n                });\n            }\n        }).start();\n    }\n}"
    },
    {
      "id": 19,
      "question": "What is a Context in Android?",
      "answer": "Context is an abstract class that provides access to application-specific resources and classes, as well as application-level operations.\n\nTypes of Context:\n• Application Context - Tied to application lifecycle\n• Activity Context - Tied to Activity lifecycle\n• Service Context - Tied to Service lifecycle\n\nApplication Context:\n• Lives as long as application\n• Use for singleton objects\n• Safe from memory leaks\n• getApplicationContext() to retrieve\n\nActivity Context:\n• Lives as long as Activity\n• Use for UI operations\n• Use for creating views\n• Can cause memory leaks if retained\n\nCommon Uses:\n• Accessing resources (strings, drawables)\n• Starting Activities and Services\n• Inflating layouts\n• Accessing SharedPreferences\n• Getting system services\n• Creating dialogs\n\nBest Practices:\n• Use Application Context for long-lived objects\n• Use Activity Context for UI operations\n• Avoid storing Activity Context in static fields",
      "explanation": "Context is a fundamental Android class providing access to application resources, services, and operations, with Application Context for long-lived operations and Activity Context for UI-related tasks.",
      "difficulty": "Medium",
      "code": "public class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        \n        // Activity Context (this)\n        Context activityContext = this;\n        \n        // Application Context\n        Context appContext = getApplicationContext();\n        \n        // Accessing resources\n        String appName = getString(R.string.app_name);\n        int color = getColor(R.color.primary);\n        Drawable icon = getDrawable(R.drawable.icon);\n        \n        // Inflating layout\n        LayoutInflater inflater = LayoutInflater.from(this);\n        View view = inflater.inflate(R.layout.my_layout, null);\n        \n        // Starting Activity\n        Intent intent = new Intent(this, SecondActivity.class);\n        startActivity(intent);\n        \n        // Getting system service\n        ConnectivityManager cm = (ConnectivityManager) \n            getSystemService(Context.CONNECTIVITY_SERVICE);\n        \n        // SharedPreferences\n        SharedPreferences prefs = getSharedPreferences(\"prefs\", Context.MODE_PRIVATE);\n        \n        // Creating Toast (requires Context)\n        Toast.makeText(this, \"Hello\", Toast.LENGTH_SHORT).show();\n    }\n}\n\n// Singleton using Application Context (correct)\npublic class DatabaseManager {\n    private static DatabaseManager instance;\n    private Context context;\n    \n    private DatabaseManager(Context context) {\n        // Use Application Context to avoid memory leaks\n        this.context = context.getApplicationContext();\n    }\n    \n    public static synchronized DatabaseManager getInstance(Context context) {\n        if (instance == null) {\n            instance = new DatabaseManager(context);\n        }\n        return instance;\n    }\n}\n\n// Getting Context in Fragment\npublic class MyFragment extends Fragment {\n    @Override\n    public void onAttach(Context context) {\n        super.onAttach(context);\n        // Use context here\n    }\n    \n    @Override\n    public View onCreateView(LayoutInflater inflater, \n                           ViewGroup container, \n                           Bundle savedInstanceState) {\n        Context context = getContext(); // Fragment's context\n        Context activity = getActivity(); // Host Activity\n        return inflater.inflate(R.layout.fragment_layout, container, false);\n    }\n}"
    },
    {
      "id": 20,
      "question": "What is the difference between Serializable and Parcelable in Android?",
      "answer": "Serializable and Parcelable are both used to pass objects between Android components, but differ significantly in performance and implementation.\n\nSerializable:\n• Java standard interface\n• Uses reflection\n• Slower performance\n• Creates many temporary objects\n• Easy to implement (marker interface)\n• Cross-platform compatible\n\nParcelable:\n• Android-specific interface\n• Manual implementation\n• Much faster (10x+)\n• Optimized for Android IPC\n• More complex to implement\n• Requires more boilerplate code\n\nPerformance:\n• Parcelable is significantly faster\n• Less garbage collection overhead\n• Preferred for Android development\n\nWhen to Use:\n• Parcelable - Android components communication\n• Serializable - Network transmission, file storage\n• Parcelable - Performance critical operations\n• Serializable - Quick prototyping",
      "explanation": "Parcelable is Android's optimized interface for object passing between components offering 10x better performance than Java's Serializable, though requiring more implementation code.",
      "difficulty": "Medium",
      "code": "// Serializable (Easy but slower)\npublic class User implements Serializable {\n    private String name;\n    private int age;\n    \n    // Just implement interface - done!\n}\n\n// Passing Serializable object\nIntent intent = new Intent(this, DetailActivity.class);\nintent.putExtra(\"user\", userObject);\nstartActivity(intent);\n\n// Receiving Serializable\nUser user = (User) getIntent().getSerializableExtra(\"user\");\n\n// Parcelable (Complex but faster)\npublic class User implements Parcelable {\n    private String name;\n    private int age;\n    \n    public User(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    // Parcel constructor\n    protected User(Parcel in) {\n        name = in.readString();\n        age = in.readInt();\n    }\n    \n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        dest.writeString(name);\n        dest.writeInt(age);\n    }\n    \n    @Override\n    public int describeContents() {\n        return 0;\n    }\n    \n    public static final Creator<User> CREATOR = new Creator<User>() {\n        @Override\n        public User createFromParcel(Parcel in) {\n            return new User(in);\n        }\n        \n        @Override\n        public User[] newArray(int size) {\n            return new User[size];\n        }\n    };\n    \n    // Getters\n    public String getName() { return name; }\n    public int getAge() { return age; }\n}\n\n// Passing Parcelable object\nIntent intent = new Intent(this, DetailActivity.class);\nintent.putExtra(\"user\", userObject);\nstartActivity(intent);\n\n// Receiving Parcelable\nUser user = getIntent().getParcelableExtra(\"user\");"
    },
    {
      "id": 21,
      "question": "What are Android permissions and how do you request them?",
      "answer": "Android permissions protect user privacy by controlling app access to sensitive data and features.\n\nPermission Types:\n• Normal Permissions - Granted automatically at install\n• Dangerous Permissions - Require runtime request (Android 6.0+)\n• Signature Permissions - Granted if app signed with same certificate\n• Special Permissions - Require special UI approval\n\nDangerous Permissions:\n• Camera, Location, Contacts, Storage\n• Microphone, Phone, SMS, Calendar\n• Body Sensors\n\nRuntime Permission Flow:\n• Check if permission granted\n• Request if not granted\n• Handle user response\n• Explain rationale if needed\n\nBest Practices:\n• Request permissions when needed (context)\n• Explain why permission is required\n• Handle denial gracefully\n• Request minimum necessary permissions\n• Check permissions before using protected APIs",
      "explanation": "Android permissions control app access to sensitive features, with dangerous permissions requiring runtime requests since Android 6.0, following a check-request-handle flow with user explanations.",
      "difficulty": "Medium",
      "code": "// AndroidManifest.xml\n// <uses-permission android:name=\"android.permission.CAMERA\" />\n// <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\n\npublic class MainActivity extends AppCompatActivity {\n    private static final int CAMERA_PERMISSION_CODE = 100;\n    private static final int LOCATION_PERMISSION_CODE = 101;\n    \n    private void requestCameraPermission() {\n        // Check if permission is already granted\n        if (ContextCompat.checkSelfPermission(this, \n                Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED) {\n            // Permission already granted\n            openCamera();\n        } else {\n            // Should we show an explanation?\n            if (ActivityCompat.shouldShowRequestPermissionRationale(this,\n                    Manifest.permission.CAMERA)) {\n                // Show explanation to user\n                new AlertDialog.Builder(this)\n                    .setTitle(\"Camera Permission\")\n                    .setMessage(\"This app needs camera access to take photos\")\n                    .setPositiveButton(\"OK\", new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            requestPermission();\n                        }\n                    })\n                    .show();\n            } else {\n                // Request permission directly\n                requestPermission();\n            }\n        }\n    }\n    \n    private void requestPermission() {\n        ActivityCompat.requestPermissions(this,\n            new String[]{Manifest.permission.CAMERA},\n            CAMERA_PERMISSION_CODE);\n    }\n    \n    @Override\n    public void onRequestPermissionsResult(int requestCode, \n                                          String[] permissions, \n                                          int[] grantResults) {\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n        \n        if (requestCode == CAMERA_PERMISSION_CODE) {\n            if (grantResults.length > 0 && \n                grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n                // Permission granted\n                openCamera();\n            } else {\n                // Permission denied\n                Toast.makeText(this, \"Camera permission denied\", \n                             Toast.LENGTH_SHORT).show();\n            }\n        }\n    }\n    \n    // Request multiple permissions\n    private void requestMultiplePermissions() {\n        String[] permissions = {\n            Manifest.permission.CAMERA,\n            Manifest.permission.ACCESS_FINE_LOCATION,\n            Manifest.permission.RECORD_AUDIO\n        };\n        \n        ActivityCompat.requestPermissions(this, permissions, 200);\n    }\n}"
    },
    {
      "id": 22,
      "question": "What is the difference between dp, sp, px, and dip in Android?",
      "answer": "Android uses different measurement units to ensure consistent UI across various screen densities.\n\ndp (Density-independent Pixels):\n• Abstract unit based on screen density\n• 1 dp = 1 pixel on 160 dpi screen\n• Scales automatically with screen density\n• Used for layout dimensions\n\nsp (Scale-independent Pixels):\n• Similar to dp but scales with user font size preferences\n• Used exclusively for text sizes\n• Respects accessibility settings\n• Allows user to control text size\n\npx (Pixels):\n• Actual screen pixels\n• Does not scale with density\n• Avoid using for dimensions\n• Results in inconsistent UI\n\ndip (Device-independent Pixels):\n• Old name for dp\n• Same as dp\n• dp is preferred term\n\nDensity Buckets:\n• ldpi (120 dpi) - 0.75x\n• mdpi (160 dpi) - 1x (baseline)\n• hdpi (240 dpi) - 1.5x\n• xhdpi (320 dpi) - 2x\n• xxhdpi (480 dpi) - 3x\n• xxxhdpi (640 dpi) - 4x",
      "explanation": "dp provides density-independent dimensions for layouts, sp scales with user text size preferences for fonts, px represents raw pixels without scaling, and dip is the deprecated term for dp.",
      "difficulty": "Easy",
      "code": "<!-- XML Layout - Using dp and sp -->\n<TextView\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Hello World\"\n    android:textSize=\"16sp\"\n    android:padding=\"16dp\"\n    android:layout_margin=\"8dp\" />\n\n<ImageView\n    android:layout_width=\"48dp\"\n    android:layout_height=\"48dp\"\n    android:src=\"@drawable/icon\" />\n\n<Button\n    android:layout_width=\"120dp\"\n    android:layout_height=\"48dp\"\n    android:textSize=\"14sp\" />\n\n// Converting between units in Java\npublic class DimensionUtils {\n    // Convert dp to pixels\n    public static int dpToPx(Context context, int dp) {\n        float density = context.getResources()\n            .getDisplayMetrics().density;\n        return Math.round(dp * density);\n    }\n    \n    // Convert pixels to dp\n    public static int pxToDp(Context context, int px) {\n        float density = context.getResources()\n            .getDisplayMetrics().density;\n        return Math.round(px / density);\n    }\n    \n    // Convert sp to pixels\n    public static int spToPx(Context context, int sp) {\n        float scaledDensity = context.getResources()\n            .getDisplayMetrics().scaledDensity;\n        return Math.round(sp * scaledDensity);\n    }\n}\n\n// Usage\nint widthInPx = DimensionUtils.dpToPx(this, 100); // 100dp to pixels\nint heightInDp = DimensionUtils.pxToDp(this, 500); // 500px to dp\n\n// Set dimension programmatically\nTextView textView = findViewById(R.id.textView);\ntextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 16); // 16sp\n\nViewGroup.LayoutParams params = textView.getLayoutParams();\nparams.width = DimensionUtils.dpToPx(this, 200); // 200dp\ntextView.setLayoutParams(params);"
    },
    {
      "id": 23,
      "question": "What is the difference between match_parent and wrap_content?",
      "answer": "match_parent and wrap_content are layout dimension attributes that control view sizing.\n\nmatch_parent:\n• View expands to fill parent container\n• Takes all available space\n• Formerly called fill_parent (deprecated)\n• Used for full-width/height views\n\nwrap_content:\n• View sizes itself to fit content\n• Takes minimum space needed\n• Adjusts based on content size\n• Used for content-sized views\n\nSpecific Dimensions:\n• Can use exact values (e.g., 100dp)\n• Fixed size regardless of content or parent\n• Less flexible but predictable\n\nCommon Patterns:\n• width=\"match_parent\" height=\"wrap_content\" - Full-width, content height\n• Both wrap_content - Size to content\n• Both match_parent - Fill entire parent\n\nConstraintLayout:\n• Uses 0dp with constraints instead\n• More flexible sizing options\n• Better performance",
      "explanation": "match_parent expands a view to fill its parent container's available space, while wrap_content sizes the view to fit its content exactly, providing flexible layout control.",
      "difficulty": "Easy",
      "code": "<!-- Common Layout Patterns -->\n<LinearLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\">\n    \n    <!-- Full-width button with content height -->\n    <Button\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Click Me\" />\n    \n    <!-- Content-sized TextView -->\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Short text\" />\n    \n    <!-- Fixed dimension -->\n    <ImageView\n        android:layout_width=\"100dp\"\n        android:layout_height=\"100dp\"\n        android:src=\"@drawable/icon\" />\n    \n    <!-- Full-width EditText -->\n    <EditText\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:hint=\"Enter text\" />\n    \n    <!-- Fills remaining space in LinearLayout -->\n    <View\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"0dp\"\n        android:layout_weight=\"1\"\n        android:background=\"@color/gray\" />\n</LinearLayout>\n\n<!-- ConstraintLayout approach -->\n<androidx.constraintlayout.widget.ConstraintLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    \n    <!-- 0dp with constraints = match_constraint -->\n    <TextView\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Full width\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n</androidx.constraintlayout.widget.ConstraintLayout>\n\n// Setting dimensions programmatically\nButton button = findViewById(R.id.myButton);\nViewGroup.LayoutParams params = button.getLayoutParams();\nparams.width = ViewGroup.LayoutParams.MATCH_PARENT;\nparams.height = ViewGroup.LayoutParams.WRAP_CONTENT;\nbutton.setLayoutParams(params);"
    },
    {
      "id": 24,
      "question": "What is an Adapter in Android?",
      "answer": "An Adapter acts as a bridge between a data source and AdapterView, providing views for displaying each data item.\n\nKey Concepts:\n• Converts data into view items\n• Manages view creation and recycling\n• Updates UI when data changes\n• Acts as mediator between data and UI\n\nCommon AdapterViews:\n• ListView - Vertical scrolling list\n• GridView - Grid layout\n• Spinner - Dropdown selection\n• RecyclerView - Advanced list (uses different adapter)\n\nAdapter Types:\n• ArrayAdapter - Simple array/list data\n• BaseAdapter - Custom implementation\n• CursorAdapter - Database cursor data\n• RecyclerView.Adapter - For RecyclerView\n\nKey Methods:\n• getCount() - Return number of items\n• getItem() - Get item at position\n• getItemId() - Get item ID\n• getView() - Create/update view for position\n\nBest Practices:\n• Use ViewHolder pattern\n• Implement efficient view recycling\n• Avoid heavy operations in getView()\n• Use notifyDataSetChanged() for updates",
      "explanation": "Adapter bridges data sources and UI components by converting data items into views, managing view recycling for efficient scrolling in list-based widgets like ListView and RecyclerView.",
      "difficulty": "Medium",
      "code": "// Simple ArrayAdapter\nList<String> items = Arrays.asList(\"Item 1\", \"Item 2\", \"Item 3\");\nArrayAdapter<String> adapter = new ArrayAdapter<>(this, \n    android.R.layout.simple_list_item_1, items);\n\nListView listView = findViewById(R.id.listView);\nlistView.setAdapter(adapter);\n\n// Custom BaseAdapter with ViewHolder\npublic class CustomAdapter extends BaseAdapter {\n    private Context context;\n    private List<User> users;\n    \n    public CustomAdapter(Context context, List<User> users) {\n        this.context = context;\n        this.users = users;\n    }\n    \n    @Override\n    public int getCount() {\n        return users.size();\n    }\n    \n    @Override\n    public Object getItem(int position) {\n        return users.get(position);\n    }\n    \n    @Override\n    public long getItemId(int position) {\n        return position;\n    }\n    \n    @Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n        ViewHolder holder;\n        \n        if (convertView == null) {\n            convertView = LayoutInflater.from(context)\n                .inflate(R.layout.item_user, parent, false);\n            \n            holder = new ViewHolder();\n            holder.nameText = convertView.findViewById(R.id.nameText);\n            holder.emailText = convertView.findViewById(R.id.emailText);\n            convertView.setTag(holder);\n        } else {\n            holder = (ViewHolder) convertView.getTag();\n        }\n        \n        User user = users.get(position);\n        holder.nameText.setText(user.getName());\n        holder.emailText.setText(user.getEmail());\n        \n        return convertView;\n    }\n    \n    static class ViewHolder {\n        TextView nameText;\n        TextView emailText;\n    }\n    \n    // Update data\n    public void updateData(List<User> newUsers) {\n        this.users = newUsers;\n        notifyDataSetChanged();\n    }\n}\n\n// Spinner adapter\nArrayAdapter<String> spinnerAdapter = new ArrayAdapter<>(this,\n    android.R.layout.simple_spinner_item, options);\nspinnerAdapter.setDropDownViewResource(\n    android.R.layout.simple_spinner_dropdown_item);\n\nSpinner spinner = findViewById(R.id.spinner);\nspinner.setAdapter(spinnerAdapter);"
    },
    {
      "id": 25,
      "question": "What is Retrofit and how do you use it for networking in Android?",
      "answer": "Retrofit is a type-safe HTTP client library for Android and Java that simplifies REST API communication.\n\nKey Features:\n• Type-safe REST API interface\n• Automatic JSON conversion\n• Support for synchronous and asynchronous calls\n• Integration with RxJava, Coroutines\n• Request/response interceptors\n• Easy error handling\n\nComponents:\n• Retrofit instance - HTTP client configuration\n• API interface - Defines endpoints\n• Converter factory - JSON parsing (Gson, Moshi)\n• Call/Callback - Executes requests\n\nAnnotations:\n• @GET, @POST, @PUT, @DELETE - HTTP methods\n• @Path - URL path parameter\n• @Query - Query parameter\n• @Body - Request body\n• @Header - Request header\n• @FormUrlEncoded - Form data\n\nBenefits:\n• Less boilerplate code\n• Built-in JSON parsing\n• Easy API definition\n• Excellent error handling\n• Widely adopted standard",
      "explanation": "Retrofit is a type-safe HTTP client that simplifies REST API communication through annotated interface methods, automatic JSON conversion, and clean asynchronous request handling.",
      "difficulty": "Medium",
      "code": "// Add dependencies in build.gradle\n// implementation 'com.squareup.retrofit2:retrofit:2.9.0'\n// implementation 'com.squareup.retrofit2:converter-gson:2.9.0'\n\n// Model class\npublic class User {\n    private int id;\n    private String name;\n    private String email;\n    \n    // Getters and setters\n}\n\n// API Interface\npublic interface ApiService {\n    @GET(\"users\")\n    Call<List<User>> getUsers();\n    \n    @GET(\"users/{id}\")\n    Call<User> getUserById(@Path(\"id\") int userId);\n    \n    @GET(\"users\")\n    Call<List<User>> searchUsers(@Query(\"name\") String name);\n    \n    @POST(\"users\")\n    Call<User> createUser(@Body User user);\n    \n    @PUT(\"users/{id}\")\n    Call<User> updateUser(@Path(\"id\") int id, @Body User user);\n    \n    @DELETE(\"users/{id}\")\n    Call<Void> deleteUser(@Path(\"id\") int id);\n    \n    @FormUrlEncoded\n    @POST(\"login\")\n    Call<LoginResponse> login(\n        @Field(\"email\") String email,\n        @Field(\"password\") String password\n    );\n}\n\n// Retrofit Setup\npublic class RetrofitClient {\n    private static final String BASE_URL = \"https://api.example.com/\";\n    private static Retrofit retrofit;\n    \n    public static Retrofit getRetrofit() {\n        if (retrofit == null) {\n            retrofit = new Retrofit.Builder()\n                .baseUrl(BASE_URL)\n                .addConverterFactory(GsonConverterFactory.create())\n                .build();\n        }\n        return retrofit;\n    }\n    \n    public static ApiService getApiService() {\n        return getRetrofit().create(ApiService.class);\n    }\n}\n\n// Making API Call\npublic class MainActivity extends AppCompatActivity {\n    private void fetchUsers() {\n        ApiService apiService = RetrofitClient.getApiService();\n        Call<List<User>> call = apiService.getUsers();\n        \n        call.enqueue(new Callback<List<User>>() {\n            @Override\n            public void onResponse(Call<List<User>> call, \n                                 Response<List<User>> response) {\n                if (response.isSuccessful() && response.body() != null) {\n                    List<User> users = response.body();\n                    // Update UI with users\n                } else {\n                    // Handle error\n                }\n            }\n            \n            @Override\n            public void onFailure(Call<List<User>> call, Throwable t) {\n                // Handle network error\n                Log.e(\"API\", \"Error: \" + t.getMessage());\n            }\n        });\n    }\n}"
    },
    {
      "id": 26,
      "question": "What is ViewModel in Android Architecture Components?",
      "answer": "ViewModel is an Architecture Component designed to store and manage UI-related data in a lifecycle-conscious way, surviving configuration changes.\n\nKey Features:\n• Survives configuration changes (rotation)\n• Lifecycle-aware data holder\n• Separates UI from business logic\n• Reduces memory leaks\n• Enables communication between Fragments\n\nLifecycle:\n• Created when Activity/Fragment created\n• Survives configuration changes\n• Destroyed when Activity finishes or Fragment detached\n• onCleared() called before destruction\n\nBenefits:\n• No need to save/restore state for rotation\n• Clean separation of concerns\n• Testable business logic\n• Shared data between Fragments\n• Works with LiveData for reactive updates\n\nBest Practices:\n• Never pass Context or View references\n• Use AndroidViewModel for Application Context\n• Combine with LiveData for observable data\n• Keep ViewModels free of Android framework dependencies",
      "explanation": "ViewModel stores UI data that survives configuration changes like screen rotation, providing lifecycle-aware data management and clean separation between UI and business logic.",
      "difficulty": "Medium",
      "code": "// Add dependency: implementation 'androidx.lifecycle:lifecycle-viewmodel:2.5.1'\n\n// ViewModel class\npublic class UserViewModel extends ViewModel {\n    private MutableLiveData<List<User>> usersLiveData;\n    private UserRepository repository;\n    \n    public UserViewModel() {\n        repository = new UserRepository();\n    }\n    \n    public LiveData<List<User>> getUsers() {\n        if (usersLiveData == null) {\n            usersLiveData = new MutableLiveData<>();\n            loadUsers();\n        }\n        return usersLiveData;\n    }\n    \n    private void loadUsers() {\n        // Load data from repository\n        repository.fetchUsers(new Callback() {\n            @Override\n            public void onSuccess(List<User> users) {\n                usersLiveData.setValue(users);\n            }\n            \n            @Override\n            public void onError(String error) {\n                // Handle error\n            }\n        });\n    }\n    \n    public void addUser(User user) {\n        repository.addUser(user);\n        loadUsers();\n    }\n    \n    @Override\n    protected void onCleared() {\n        super.onCleared();\n        // Clean up resources\n        repository.cleanup();\n    }\n}\n\n// Using ViewModel in Activity\npublic class MainActivity extends AppCompatActivity {\n    private UserViewModel viewModel;\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        // Get ViewModel\n        viewModel = new ViewModelProvider(this).get(UserViewModel.class);\n        \n        // Observe LiveData\n        viewModel.getUsers().observe(this, new Observer<List<User>>() {\n            @Override\n            public void onChanged(List<User> users) {\n                // Update UI\n                updateUserList(users);\n            }\n        });\n        \n        // Add user\n        findViewById(R.id.addButton).setOnClickListener(v -> {\n            viewModel.addUser(new User(\"John\", \"john@example.com\"));\n        });\n    }\n}\n\n// AndroidViewModel with Application Context\npublic class AppViewModel extends AndroidViewModel {\n    private Application application;\n    \n    public AppViewModel(@NonNull Application application) {\n        super(application);\n        this.application = application;\n    }\n    \n    public String getAppName() {\n        return application.getString(R.string.app_name);\n    }\n}\n\n// Sharing ViewModel between Fragments\npublic class Fragment1 extends Fragment {\n    private SharedViewModel viewModel;\n    \n    @Override\n    public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n        \n        // Get Activity-scoped ViewModel\n        viewModel = new ViewModelProvider(requireActivity())\n            .get(SharedViewModel.class);\n        \n        viewModel.getSelectedItem().observe(getViewLifecycleOwner(), item -> {\n            // Update UI\n        });\n    }\n}"
    },
    {
      "id": 27,
      "question": "What is LiveData in Android?",
      "answer": "LiveData is an observable data holder class that is lifecycle-aware, meaning it respects the lifecycle of other app components.\n\nKey Features:\n• Observable data holder\n• Lifecycle-aware updates\n• No memory leaks\n• Automatic UI updates\n• No crashes from stopped activities\n• Always up-to-date data\n\nLifecycle Awareness:\n• Only updates active observers\n• Active when STARTED or RESUMED\n• Removes observers when DESTROYED\n• Prevents memory leaks\n\nTypes:\n• LiveData - Immutable, read-only\n• MutableLiveData - Mutable, can set values\n• MediatorLiveData - Observes multiple LiveData sources\n\nMethods:\n• observe() - Observe with LifecycleOwner\n• observeForever() - Observe without lifecycle\n• setValue() - Set value on main thread\n• postValue() - Set value from background thread\n\nBenefits:\n• No manual lifecycle management\n• No memory leaks\n• UI always matches data state\n• Proper configuration change handling\n• Data sharing between components",
      "explanation": "LiveData is a lifecycle-aware observable data holder that automatically updates UI components only when they are active, preventing memory leaks and crashes while ensuring data consistency.",
      "difficulty": "Medium",
      "code": "// Basic LiveData usage\npublic class UserViewModel extends ViewModel {\n    private MutableLiveData<String> userName;\n    \n    public LiveData<String> getUserName() {\n        if (userName == null) {\n            userName = new MutableLiveData<>();\n            userName.setValue(\"John Doe\");\n        }\n        return userName;\n    }\n    \n    public void setUserName(String name) {\n        userName.setValue(name);\n    }\n}\n\n// Observing LiveData in Activity\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        UserViewModel viewModel = new ViewModelProvider(this)\n            .get(UserViewModel.class);\n        \n        TextView textView = findViewById(R.id.textView);\n        \n        // Observe LiveData\n        viewModel.getUserName().observe(this, new Observer<String>() {\n            @Override\n            public void onChanged(String name) {\n                textView.setText(name);\n            }\n        });\n        \n        // Update value\n        findViewById(R.id.button).setOnClickListener(v -> {\n            viewModel.setUserName(\"Jane Doe\");\n        });\n    }\n}\n\n// Background thread update with postValue()\npublic class DataViewModel extends ViewModel {\n    private MutableLiveData<List<User>> users = new MutableLiveData<>();\n    \n    public LiveData<List<User>> getUsers() {\n        return users;\n    }\n    \n    public void loadUsers() {\n        new Thread(() -> {\n            // Simulate network call\n            List<User> result = fetchUsersFromNetwork();\n            \n            // Use postValue for background thread\n            users.postValue(result);\n        }).start();\n    }\n}\n\n// MediatorLiveData - Combine multiple sources\npublic class CombinedViewModel extends ViewModel {\n    private MediatorLiveData<String> combinedData = new MediatorLiveData<>();\n    private LiveData<String> source1;\n    private LiveData<String> source2;\n    \n    public CombinedViewModel(LiveData<String> s1, LiveData<String> s2) {\n        source1 = s1;\n        source2 = s2;\n        \n        combinedData.addSource(source1, value -> {\n            combinedData.setValue(combineValues());\n        });\n        \n        combinedData.addSource(source2, value -> {\n            combinedData.setValue(combineValues());\n        });\n    }\n    \n    private String combineValues() {\n        String val1 = source1.getValue();\n        String val2 = source2.getValue();\n        return val1 + \" - \" + val2;\n    }\n    \n    public LiveData<String> getCombinedData() {\n        return combinedData;\n    }\n}\n\n// Transformations\nLiveData<User> userLiveData = userRepository.getUser(userId);\nLiveData<String> userName = Transformations.map(userLiveData, user -> {\n    return user.getFirstName() + \" \" + user.getLastName();\n});\n\nLiveData<User> selectedUser = Transformations.switchMap(userIdLiveData, id -> {\n    return userRepository.getUser(id);\n});"
    },
    {
      "id": 28,
      "question": "What is Room Database in Android?",
      "answer": "Room is a persistence library that provides an abstraction layer over SQLite, making database access more robust and easier to use.\n\nKey Components:\n• Entity - Represents database table\n• DAO (Data Access Object) - Defines database operations\n• Database - Database holder with abstract DAOs\n\nAnnotations:\n• @Entity - Marks class as table\n• @PrimaryKey - Defines primary key\n• @ColumnInfo - Customizes column name\n• @Dao - Marks interface as DAO\n• @Database - Marks database class\n• @Query - Defines SQL query\n• @Insert, @Update, @Delete - CRUD operations\n\nBenefits over SQLite:\n• Compile-time verification of SQL\n• Less boilerplate code\n• Easy migration support\n• LiveData and RxJava integration\n• Type converters for custom types\n\nFeatures:\n• Supports relationships (One-to-Many, Many-to-Many)\n• Foreign key constraints\n• Database migrations\n• Type converters\n• Full-text search",
      "explanation": "Room is Android's SQLite abstraction library providing compile-time SQL verification, reduced boilerplate, and seamless integration with LiveData and other Architecture Components for robust database management.",
      "difficulty": "Medium",
      "code": "// Add dependencies\n// implementation 'androidx.room:room-runtime:2.5.0'\n// annotationProcessor 'androidx.room:room-compiler:2.5.0'\n\n// Entity class\n@Entity(tableName = \"users\")\npublic class User {\n    @PrimaryKey(autoGenerate = true)\n    private int id;\n    \n    @ColumnInfo(name = \"user_name\")\n    private String name;\n    \n    private String email;\n    \n    private long createdAt;\n    \n    // Constructors, getters, setters\n}\n\n// DAO interface\n@Dao\npublic interface UserDao {\n    @Query(\"SELECT * FROM users\")\n    LiveData<List<User>> getAllUsers();\n    \n    @Query(\"SELECT * FROM users WHERE id = :userId\")\n    User getUserById(int userId);\n    \n    @Query(\"SELECT * FROM users WHERE user_name LIKE :search\")\n    List<User> searchUsers(String search);\n    \n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    long insertUser(User user);\n    \n    @Insert\n    void insertAll(List<User> users);\n    \n    @Update\n    void updateUser(User user);\n    \n    @Delete\n    void deleteUser(User user);\n    \n    @Query(\"DELETE FROM users WHERE id = :userId\")\n    void deleteById(int userId);\n    \n    @Query(\"DELETE FROM users\")\n    void deleteAll();\n}\n\n// Database class\n@Database(entities = {User.class}, version = 1, exportSchema = false)\npublic abstract class AppDatabase extends RoomDatabase {\n    private static AppDatabase instance;\n    \n    public abstract UserDao userDao();\n    \n    public static synchronized AppDatabase getInstance(Context context) {\n        if (instance == null) {\n            instance = Room.databaseBuilder(\n                context.getApplicationContext(),\n                AppDatabase.class,\n                \"app_database\"\n            )\n            .fallbackToDestructiveMigration()\n            .build();\n        }\n        return instance;\n    }\n}\n\n// Repository class\npublic class UserRepository {\n    private UserDao userDao;\n    private LiveData<List<User>> allUsers;\n    \n    public UserRepository(Application application) {\n        AppDatabase database = AppDatabase.getInstance(application);\n        userDao = database.userDao();\n        allUsers = userDao.getAllUsers();\n    }\n    \n    public LiveData<List<User>> getAllUsers() {\n        return allUsers;\n    }\n    \n    public void insert(User user) {\n        new Thread(() -> userDao.insertUser(user)).start();\n    }\n    \n    public void update(User user) {\n        new Thread(() -> userDao.updateUser(user)).start();\n    }\n    \n    public void delete(User user) {\n        new Thread(() -> userDao.deleteUser(user)).start();\n    }\n}\n\n// Using with ViewModel\npublic class UserViewModel extends AndroidViewModel {\n    private UserRepository repository;\n    private LiveData<List<User>> allUsers;\n    \n    public UserViewModel(Application application) {\n        super(application);\n        repository = new UserRepository(application);\n        allUsers = repository.getAllUsers();\n    }\n    \n    public LiveData<List<User>> getAllUsers() {\n        return allUsers;\n    }\n    \n    public void insert(User user) {\n        repository.insert(user);\n    }\n}"
    },
    {
      "id": 29,
      "question": "What is Dependency Injection and how is Dagger used in Android?",
      "answer": "Dependency Injection (DI) is a design pattern where objects receive their dependencies from external sources rather than creating them internally.\n\nBenefits of DI:\n• Loose coupling between classes\n• Easier testing with mock dependencies\n• Better code reusability\n• Centralized dependency management\n• Easier maintenance\n\nDagger 2:\n• Compile-time dependency injection framework\n• Generates code for dependency provision\n• No reflection at runtime\n• Fast and efficient\n\nCore Concepts:\n• @Inject - Request dependencies\n• @Module - Provides dependencies\n• @Provides - Method that provides dependency\n• @Component - Bridge between modules and injection\n• @Singleton - Single instance scope\n• @Qualifier - Distinguish similar dependencies\n\nDagger Components:\n• Component - Dependency graph interface\n• Module - Provides objects\n• Scope - Defines lifetime\n• Qualifier - Distinguishes types",
      "explanation": "Dependency Injection provides objects with their dependencies externally; Dagger 2 is a compile-time DI framework that generates efficient dependency provision code, promoting loose coupling and testability.",
      "difficulty": "Hard",
      "code": "// Add dependencies\n// implementation 'com.google.dagger:dagger:2.44'\n// annotationProcessor 'com.google.dagger:dagger-compiler:2.44'\n\n// Module - Provides dependencies\n@Module\npublic class AppModule {\n    private Application application;\n    \n    public AppModule(Application application) {\n        this.application = application;\n    }\n    \n    @Provides\n    @Singleton\n    public Application provideApplication() {\n        return application;\n    }\n    \n    @Provides\n    @Singleton\n    public SharedPreferences provideSharedPreferences() {\n        return application.getSharedPreferences(\"prefs\", Context.MODE_PRIVATE);\n    }\n}\n\n@Module\npublic class NetworkModule {\n    @Provides\n    @Singleton\n    public OkHttpClient provideOkHttpClient() {\n        return new OkHttpClient.Builder()\n            .connectTimeout(30, TimeUnit.SECONDS)\n            .build();\n    }\n    \n    @Provides\n    @Singleton\n    public Retrofit provideRetrofit(OkHttpClient client) {\n        return new Retrofit.Builder()\n            .baseUrl(\"https://api.example.com/\")\n            .client(client)\n            .addConverterFactory(GsonConverterFactory.create())\n            .build();\n    }\n    \n    @Provides\n    @Singleton\n    public ApiService provideApiService(Retrofit retrofit) {\n        return retrofit.create(ApiService.class);\n    }\n}\n\n// Component - Dependency graph\n@Singleton\n@Component(modules = {AppModule.class, NetworkModule.class})\npublic interface AppComponent {\n    void inject(MainActivity activity);\n    void inject(UserRepository repository);\n}\n\n// Application class\npublic class MyApplication extends Application {\n    private AppComponent appComponent;\n    \n    @Override\n    public void onCreate() {\n        super.onCreate();\n        \n        appComponent = DaggerAppComponent.builder()\n            .appModule(new AppModule(this))\n            .networkModule(new NetworkModule())\n            .build();\n    }\n    \n    public AppComponent getAppComponent() {\n        return appComponent;\n    }\n}\n\n// Inject dependencies in Activity\npublic class MainActivity extends AppCompatActivity {\n    @Inject\n    ApiService apiService;\n    \n    @Inject\n    SharedPreferences prefs;\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        // Inject dependencies\n        ((MyApplication) getApplication())\n            .getAppComponent()\n            .inject(this);\n        \n        // Use injected dependencies\n        apiService.getUsers();\n    }\n}\n\n// Constructor injection\npublic class UserRepository {\n    private ApiService apiService;\n    private SharedPreferences prefs;\n    \n    @Inject\n    public UserRepository(ApiService apiService, SharedPreferences prefs) {\n        this.apiService = apiService;\n        this.prefs = prefs;\n    }\n}"
    },
    {
      "id": 30,
      "question": "What is the difference between onCreate(), onStart(), and onResume()?",
      "answer": "These lifecycle methods represent different stages of Activity visibility and interactivity.\n\nonCreate():\n• Called when Activity first created\n• Called only once per Activity instance\n• Initialize Activity (setContentView, findViewById)\n• Restore saved state from Bundle\n• Setup initial data\n\nonStart():\n• Called when Activity becomes visible\n• Called after onCreate() and before onResume()\n• Called multiple times (after onStop())\n• Activity visible but not interactive\n• Start animations or UI updates\n\nonResume():\n• Called when Activity starts interacting with user\n• Activity in foreground and has focus\n• Called every time Activity becomes active\n• Register listeners (sensors, location)\n• Start camera preview or media playback\n\nFlow Examples:\n• App Launch: onCreate() → onStart() → onResume()\n• Home Button: onPause() → onStop()\n• Return to App: onRestart() → onStart() → onResume()\n• Dialog Shown: onPause() only\n• Screen Off: onPause() → onStop()\n\nBest Practices:\n• Heavy initialization in onCreate()\n• Register listeners in onResume()\n• Unregister in onPause()",
      "explanation": "onCreate() initializes the Activity once, onStart() makes it visible, and onResume() makes it interactive; onResume() is called every time the Activity gains focus while onCreate() is called only once.",
      "difficulty": "Medium",
      "code": "public class MainActivity extends AppCompatActivity {\n    private static final String TAG = \"Lifecycle\";\n    private SensorManager sensorManager;\n    private Sensor accelerometer;\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        Log.d(TAG, \"onCreate: Activity created\");\n        \n        // One-time initialization\n        initializeViews();\n        setupToolbar();\n        \n        // Initialize sensors (but don't register yet)\n        sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);\n        accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);\n        \n        // Restore state\n        if (savedInstanceState != null) {\n            String savedData = savedInstanceState.getString(\"key\");\n        }\n    }\n    \n    @Override\n    protected void onStart() {\n        super.onStart();\n        Log.d(TAG, \"onStart: Activity visible\");\n        \n        // Activity is now visible\n        // Start animations\n        // Connect to services\n    }\n    \n    @Override\n    protected void onResume() {\n        super.onResume();\n        Log.d(TAG, \"onResume: Activity interactive\");\n        \n        // Activity has focus and is interactive\n        // Register listeners\n        if (accelerometer != null) {\n            sensorManager.registerListener(sensorListener, accelerometer,\n                SensorManager.SENSOR_DELAY_NORMAL);\n        }\n        \n        // Start camera preview\n        // Resume media playback\n        // Start location updates\n    }\n    \n    @Override\n    protected void onPause() {\n        super.onPause();\n        Log.d(TAG, \"onPause: Losing focus\");\n        \n        // Unregister listeners\n        sensorManager.unregisterListener(sensorListener);\n        \n        // Pause media playback\n        // Stop location updates\n        // Save critical data\n    }\n    \n    @Override\n    protected void onStop() {\n        super.onStop();\n        Log.d(TAG, \"onStop: No longer visible\");\n        \n        // Activity is no longer visible\n        // Release resources\n    }\n    \n    @Override\n    protected void onRestart() {\n        super.onRestart();\n        Log.d(TAG, \"onRestart: Restarting from stopped\");\n    }\n    \n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        Log.d(TAG, \"onDestroy: Activity being destroyed\");\n        \n        // Final cleanup\n    }\n}"
    },
    {
      "id": 31,
      "question": "What are Intent Filters in Android?",
      "answer": "Intent Filters declare the capabilities of a component, specifying which implicit Intents it can respond to.\n\nKey Elements:\n• action - Type of action to perform\n• category - Additional component category information\n• data - Type of data (URI and MIME type)\n\nCommon Actions:\n• ACTION_MAIN - Entry point of app\n• ACTION_VIEW - Display data to user\n• ACTION_SEND - Send data to another app\n• ACTION_EDIT - Edit data\n• ACTION_DIAL - Show dialer\n\nCommon Categories:\n• CATEGORY_DEFAULT - Default category for implicit Intents\n• CATEGORY_LAUNCHER - Shows in app launcher\n• CATEGORY_BROWSABLE - Allows URL linking\n\nData Matching:\n• Scheme (http, https, tel, mailto)\n• Host and port\n• Path\n• MIME type\n\nUse Cases:\n• Declare launcher Activity\n• Handle share functionality\n• Open specific file types\n• Respond to custom URLs\n• Handle deep links",
      "explanation": "Intent Filters specify which implicit Intents a component can handle by declaring action, category, and data requirements, enabling components to respond to system and third-party app requests.",
      "difficulty": "Medium",
      "code": "<!-- AndroidManifest.xml -->\n\n<!-- Launcher Activity -->\n<activity android:name=\".MainActivity\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.MAIN\" />\n        <category android:name=\"android.intent.category.LAUNCHER\" />\n    </intent-filter>\n</activity>\n\n<!-- Share Target -->\n<activity android:name=\".ShareActivity\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.SEND\" />\n        <category android:name=\"android.intent.category.DEFAULT\" />\n        <data android:mimeType=\"text/plain\" />\n    </intent-filter>\n    \n    <intent-filter>\n        <action android:name=\"android.intent.action.SEND\" />\n        <category android:name=\"android.intent.category.DEFAULT\" />\n        <data android:mimeType=\"image/*\" />\n    </intent-filter>\n</activity>\n\n<!-- Deep Link Handler -->\n<activity android:name=\".DeepLinkActivity\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.VIEW\" />\n        <category android:name=\"android.intent.category.DEFAULT\" />\n        <category android:name=\"android.intent.category.BROWSABLE\" />\n        \n        <data\n            android:scheme=\"https\"\n            android:host=\"www.example.com\"\n            android:pathPrefix=\"/products\" />\n    </intent-filter>\n</activity>\n\n<!-- Custom URL Scheme -->\n<activity android:name=\".CustomSchemeActivity\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.VIEW\" />\n        <category android:name=\"android.intent.category.DEFAULT\" />\n        <category android:name=\"android.intent.category.BROWSABLE\" />\n        <data android:scheme=\"myapp\" />\n    </intent-filter>\n</activity>\n\n<!-- File Type Handler -->\n<activity android:name=\".PdfViewerActivity\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.VIEW\" />\n        <category android:name=\"android.intent.category.DEFAULT\" />\n        <data android:mimeType=\"application/pdf\" />\n    </intent-filter>\n</activity>\n\n// Handling received Intent\npublic class ShareActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_share);\n        \n        Intent intent = getIntent();\n        String action = intent.getAction();\n        String type = intent.getType();\n        \n        if (Intent.ACTION_SEND.equals(action) && type != null) {\n            if (\"text/plain\".equals(type)) {\n                String sharedText = intent.getStringExtra(Intent.EXTRA_TEXT);\n                handleTextShare(sharedText);\n            } else if (type.startsWith(\"image/\")) {\n                Uri imageUri = intent.getParcelableExtra(Intent.EXTRA_STREAM);\n                handleImageShare(imageUri);\n            }\n        }\n    }\n}"
    },
    {
      "id": 32,
      "question": "What is a PendingIntent in Android?",
      "answer": "PendingIntent is a wrapper around an Intent that grants permission to a foreign application to execute that Intent with your app's permissions.\n\nKey Characteristics:\n• Token given to another app\n• Executes Intent in future\n• Executes with your app's identity and permissions\n• Can be used multiple times or once\n• Can be cancelled\n\nCommon Use Cases:\n• Notifications - Trigger when user taps\n• AlarmManager - Schedule future actions\n• App Widgets - Handle widget interactions\n• Geofencing - Location-based triggers\n\nTypes:\n• getActivity() - Start Activity\n• getService() - Start Service\n• getBroadcast() - Send Broadcast\n\nFlags:\n• FLAG_ONE_SHOT - Used once then cancelled\n• FLAG_NO_CREATE - Return null if doesn't exist\n• FLAG_CANCEL_CURRENT - Cancel existing before creating\n• FLAG_UPDATE_CURRENT - Update existing Intent extras\n• FLAG_IMMUTABLE - Cannot be modified (required Android 12+)\n• FLAG_MUTABLE - Can be modified\n\nSecurity:\n• Always specify explicit component\n• Use FLAG_IMMUTABLE when possible\n• Required from Android 12+",
      "explanation": "PendingIntent is a token that allows external apps to execute an Intent with your app's permissions at a future time, commonly used for notifications, alarms, and widgets.",
      "difficulty": "Medium",
      "code": "// PendingIntent for Notification\npublic void showNotification() {\n    // Intent to launch when notification is tapped\n    Intent intent = new Intent(this, MainActivity.class);\n    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n    \n    // Create PendingIntent\n    PendingIntent pendingIntent = PendingIntent.getActivity(\n        this,\n        0,\n        intent,\n        PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_UPDATE_CURRENT\n    );\n    \n    // Build notification\n    NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)\n        .setSmallIcon(R.drawable.notification_icon)\n        .setContentTitle(\"My Notification\")\n        .setContentText(\"Tap to open app\")\n        .setPriority(NotificationCompat.PRIORITY_DEFAULT)\n        .setContentIntent(pendingIntent)\n        .setAutoCancel(true);\n    \n    NotificationManagerCompat.from(this).notify(1, builder.build());\n}\n\n// PendingIntent with AlarmManager\npublic void scheduleAlarm() {\n    AlarmManager alarmManager = (AlarmManager) getSystemService(ALARM_SERVICE);\n    \n    Intent intent = new Intent(this, AlarmReceiver.class);\n    intent.putExtra(\"message\", \"Wake up!\");\n    \n    PendingIntent pendingIntent = PendingIntent.getBroadcast(\n        this,\n        0,\n        intent,\n        PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_UPDATE_CURRENT\n    );\n    \n    // Schedule alarm for 10 seconds from now\n    long triggerTime = System.currentTimeMillis() + 10000;\n    alarmManager.setExact(AlarmManager.RTC_WAKEUP, triggerTime, pendingIntent);\n}\n\n// Cancel PendingIntent\npublic void cancelAlarm() {\n    Intent intent = new Intent(this, AlarmReceiver.class);\n    PendingIntent pendingIntent = PendingIntent.getBroadcast(\n        this,\n        0,\n        intent,\n        PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_NO_CREATE\n    );\n    \n    if (pendingIntent != null) {\n        AlarmManager alarmManager = (AlarmManager) getSystemService(ALARM_SERVICE);\n        alarmManager.cancel(pendingIntent);\n        pendingIntent.cancel();\n    }\n}\n\n// PendingIntent for App Widget\npublic class MyWidgetProvider extends AppWidgetProvider {\n    @Override\n    public void onUpdate(Context context, AppWidgetManager manager, int[] widgetIds) {\n        for (int widgetId : widgetIds) {\n            Intent intent = new Intent(context, MainActivity.class);\n            PendingIntent pendingIntent = PendingIntent.getActivity(\n                context,\n                0,\n                intent,\n                PendingIntent.FLAG_IMMUTABLE\n            );\n            \n            RemoteViews views = new RemoteViews(context.getPackageName(), \n                                               R.layout.widget_layout);\n            views.setOnClickPendingIntent(R.id.widget_button, pendingIntent);\n            \n            manager.updateAppWidget(widgetId, views);\n        }\n    }\n}"
    },
    {
      "id": 33,
      "question": "What is the difference between Handler, Looper, and MessageQueue?",
      "answer": "Handler, Looper, and MessageQueue work together to enable thread communication in Android.\n\nLooper:\n• Runs message loop for thread\n• One Looper per thread\n• Main thread has Looper automatically\n• Background threads need explicit Looper creation\n• Processes messages from MessageQueue\n\nMessageQueue:\n• Queue holding messages and runnables\n• Managed by Looper\n• FIFO (First In First Out) structure\n• One MessageQueue per Looper\n\nHandler:\n• Sends and processes messages\n• Associated with thread's Looper\n• Can schedule messages and runnables\n• Enables cross-thread communication\n• handleMessage() processes received messages\n\nRelationship:\n• Handler posts to MessageQueue\n• Looper reads from MessageQueue\n• Handler processes messages on its thread\n\nUse Cases:\n• Update UI from background thread\n• Schedule delayed operations\n• Thread communication\n• Custom thread message processing",
      "explanation": "Looper runs a message loop processing MessageQueue's messages, while Handler posts messages to the queue and processes them, enabling thread communication especially for UI updates.",
      "difficulty": "Hard",
      "code": "// Using Handler with Main Thread\npublic class MainActivity extends AppCompatActivity {\n    private Handler mainHandler = new Handler(Looper.getMainLooper());\n    \n    private void performBackgroundTask() {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                // Background work\n                final String result = doHeavyWork();\n                \n                // Update UI using Handler\n                mainHandler.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        textView.setText(result);\n                    }\n                });\n            }\n        }).start();\n    }\n    \n    // Delayed execution\n    private void scheduleTask() {\n        mainHandler.postDelayed(new Runnable() {\n            @Override\n            public void run() {\n                // Execute after 5 seconds\n                Toast.makeText(MainActivity.this, \"Delayed task\", \n                             Toast.LENGTH_SHORT).show();\n            }\n        }, 5000);\n    }\n    \n    // Remove callbacks\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        mainHandler.removeCallbacksAndMessages(null);\n    }\n}\n\n// Custom Handler with Messages\npublic class MyHandler extends Handler {\n    private static final int MESSAGE_UPDATE = 1;\n    private static final int MESSAGE_COMPLETE = 2;\n    \n    @Override\n    public void handleMessage(Message msg) {\n        switch (msg.what) {\n            case MESSAGE_UPDATE:\n                int progress = msg.arg1;\n                updateProgress(progress);\n                break;\n            case MESSAGE_COMPLETE:\n                String result = (String) msg.obj;\n                showResult(result);\n                break;\n        }\n    }\n}\n\n// Sending Messages\nMyHandler handler = new MyHandler();\n\n// Send message with data\nMessage msg = handler.obtainMessage(MESSAGE_UPDATE);\nmsg.arg1 = 50; // progress value\nhandler.sendMessage(msg);\n\n// Send message with object\nMessage msg2 = handler.obtainMessage(MESSAGE_COMPLETE);\nmsg2.obj = \"Task completed\";\nhandler.sendMessage(msg2);\n\n// Creating HandlerThread (Background thread with Looper)\npublic class WorkerThread extends HandlerThread {\n    private Handler workerHandler;\n    \n    public WorkerThread(String name) {\n        super(name);\n    }\n    \n    public void prepareHandler() {\n        workerHandler = new Handler(getLooper()) {\n            @Override\n            public void handleMessage(Message msg) {\n                // Process message on background thread\n                performBackgroundWork(msg);\n            }\n        };\n    }\n    \n    public Handler getWorkerHandler() {\n        return workerHandler;\n    }\n}\n\n// Using HandlerThread\nWorkerThread workerThread = new WorkerThread(\"MyWorker\");\nworkerThread.start();\nworkerThread.prepareHandler();\n\nHandler backgroundHandler = workerThread.getWorkerHandler();\nbackgroundHandler.post(() -> {\n    // This runs on background thread\n    performHeavyOperation();\n});\n\n// Clean up\nworkerThread.quitSafely();"
    },
    {
      "id": 34,
      "question": "What are Fragments and their lifecycle?",
      "answer": "Fragments are modular, reusable UI components with their own lifecycle, hosted within Activities.\n\nFragment Lifecycle States:\n• Attached - Fragment attached to Activity\n• Created - Fragment instance created\n• View Created - Fragment view inflated\n• Started - Fragment visible\n• Resumed - Fragment interactive\n• Paused - Fragment loses focus\n• Stopped - Fragment not visible\n• View Destroyed - Fragment view destroyed\n• Destroyed - Fragment instance destroyed\n\nLifecycle Methods:\n• onAttach() - Fragment attached to Activity\n• onCreate() - Fragment created\n• onCreateView() - Inflate fragment layout\n• onViewCreated() - View hierarchy created\n• onStart() - Fragment visible\n• onResume() - Fragment interactive\n• onPause() - Fragment loses focus\n• onStop() - Fragment not visible\n• onDestroyView() - View destroyed\n• onDestroy() - Fragment destroyed\n• onDetach() - Fragment detached\n\nFragment vs Activity:\n• Fragment must be hosted by Activity\n• Multiple Fragments in one Activity\n• Fragment lifecycle tied to host Activity\n• Fragments can be dynamically added/removed",
      "explanation": "Fragments are reusable UI components with their own comprehensive lifecycle nested within an Activity's lifecycle, enabling modular and flexible screen designs with dynamic addition and removal.",
      "difficulty": "Medium",
      "code": "public class MyFragment extends Fragment {\n    private static final String TAG = \"FragmentLifecycle\";\n    private TextView textView;\n    \n    // Create Fragment with arguments\n    public static MyFragment newInstance(String text) {\n        MyFragment fragment = new MyFragment();\n        Bundle args = new Bundle();\n        args.putString(\"text\", text);\n        fragment.setArguments(args);\n        return fragment;\n    }\n    \n    @Override\n    public void onAttach(@NonNull Context context) {\n        super.onAttach(context);\n        Log.d(TAG, \"onAttach: Fragment attached to Activity\");\n    }\n    \n    @Override\n    public void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        Log.d(TAG, \"onCreate: Fragment created\");\n        \n        // Get arguments\n        if (getArguments() != null) {\n            String text = getArguments().getString(\"text\");\n        }\n    }\n    \n    @Nullable\n    @Override\n    public View onCreateView(@NonNull LayoutInflater inflater,\n                           @Nullable ViewGroup container,\n                           @Nullable Bundle savedInstanceState) {\n        Log.d(TAG, \"onCreateView: Inflating layout\");\n        return inflater.inflate(R.layout.fragment_my, container, false);\n    }\n    \n    @Override\n    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n        Log.d(TAG, \"onViewCreated: View hierarchy created\");\n        \n        // Initialize views here\n        textView = view.findViewById(R.id.textView);\n        textView.setText(\"Fragment loaded\");\n    }\n    \n    @Override\n    public void onStart() {\n        super.onStart();\n        Log.d(TAG, \"onStart: Fragment visible\");\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        Log.d(TAG, \"onResume: Fragment interactive\");\n    }\n    \n    @Override\n    public void onPause() {\n        super.onPause();\n        Log.d(TAG, \"onPause: Fragment loses focus\");\n    }\n    \n    @Override\n    public void onStop() {\n        super.onStop();\n        Log.d(TAG, \"onStop: Fragment not visible\");\n    }\n    \n    @Override\n    public void onDestroyView() {\n        super.onDestroyView();\n        Log.d(TAG, \"onDestroyView: View destroyed\");\n        textView = null; // Release view references\n    }\n    \n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        Log.d(TAG, \"onDestroy: Fragment destroyed\");\n    }\n    \n    @Override\n    public void onDetach() {\n        super.onDetach();\n        Log.d(TAG, \"onDetach: Fragment detached\");\n    }\n}\n\n// Fragment Transaction in Activity\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        // Add Fragment\n        if (savedInstanceState == null) {\n            MyFragment fragment = MyFragment.newInstance(\"Hello\");\n            getSupportFragmentManager()\n                .beginTransaction()\n                .add(R.id.fragment_container, fragment, \"MY_FRAGMENT\")\n                .commit();\n        }\n    }\n    \n    // Replace Fragment\n    private void replaceFragment() {\n        MyFragment newFragment = MyFragment.newInstance(\"New Fragment\");\n        getSupportFragmentManager()\n            .beginTransaction()\n            .replace(R.id.fragment_container, newFragment)\n            .addToBackStack(null) // Add to back stack\n            .commit();\n    }\n}"
    },
    {
      "id": 35,
      "question": "What is the difference between FragmentTransaction add(), replace(), and remove()?",
      "answer": "FragmentTransaction methods manipulate Fragments differently in the container.\n\nadd():\n• Adds Fragment to container\n• Does not remove existing Fragments\n• Multiple Fragments can be active\n• Previous Fragments remain in layout\n• Useful for overlaying Fragments\n\nreplace():\n• Removes all existing Fragments in container\n• Adds new Fragment\n• Equivalent to remove() + add()\n• Only one Fragment visible\n• Most commonly used\n\nremove():\n• Removes specified Fragment\n• Does not add new Fragment\n• Container may be empty\n• Used for cleanup\n\nBack Stack:\n• addToBackStack() saves transaction\n• Back button reverses transaction\n• Can provide transaction name\n• popBackStack() manually reverses\n\nOther Methods:\n• show() - Makes Fragment visible\n• hide() - Hides Fragment without removing\n• attach() - Reattaches previously detached Fragment\n• detach() - Destroys Fragment view, keeps instance",
      "explanation": "add() keeps existing Fragments while adding new ones, replace() removes all Fragments before adding new one, and remove() simply removes a Fragment, with addToBackStack() enabling back navigation.",
      "difficulty": "Medium",
      "code": "public class MainActivity extends AppCompatActivity {\n    \n    // Using add() - Fragments stack on top\n    private void addFragment() {\n        Fragment1 fragment = new Fragment1();\n        getSupportFragmentManager()\n            .beginTransaction()\n            .add(R.id.container, fragment, \"FRAGMENT_1\")\n            .commit();\n        \n        // Add another - both exist in container\n        Fragment2 fragment2 = new Fragment2();\n        getSupportFragmentManager()\n            .beginTransaction()\n            .add(R.id.container, fragment2, \"FRAGMENT_2\")\n            .commit();\n        // Result: Both fragments exist, Fragment2 on top\n    }\n    \n    // Using replace() - Remove old, add new\n    private void replaceFragment() {\n        Fragment2 fragment = new Fragment2();\n        getSupportFragmentManager()\n            .beginTransaction()\n            .replace(R.id.container, fragment)\n            .addToBackStack(null) // Enable back navigation\n            .commit();\n        // Result: Previous fragments removed, only Fragment2 exists\n    }\n    \n    // Using remove() - Remove specific fragment\n    private void removeFragment() {\n        Fragment fragment = getSupportFragmentManager()\n            .findFragmentByTag(\"FRAGMENT_1\");\n        \n        if (fragment != null) {\n            getSupportFragmentManager()\n                .beginTransaction()\n                .remove(fragment)\n                .commit();\n        }\n    }\n    \n    // Show/Hide - Keep Fragment but control visibility\n    private void toggleFragment() {\n        Fragment fragment = getSupportFragmentManager()\n            .findFragmentById(R.id.container);\n        \n        if (fragment != null) {\n            FragmentTransaction transaction = getSupportFragmentManager()\n                .beginTransaction();\n            \n            if (fragment.isHidden()) {\n                transaction.show(fragment);\n            } else {\n                transaction.hide(fragment);\n            }\n            transaction.commit();\n        }\n    }\n    \n    // Complex transaction with multiple operations\n    private void complexTransaction() {\n        Fragment1 fragment1 = new Fragment1();\n        Fragment2 fragment2 = new Fragment2();\n        \n        getSupportFragmentManager()\n            .beginTransaction()\n            .add(R.id.container1, fragment1)\n            .add(R.id.container2, fragment2)\n            .hide(fragment2)\n            .addToBackStack(\"complex\")\n            .setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE)\n            .commit();\n    }\n    \n    // Pop back stack\n    private void goBack() {\n        if (getSupportFragmentManager().getBackStackEntryCount() > 0) {\n            getSupportFragmentManager().popBackStack();\n        }\n    }\n    \n    // Pop to specific transaction\n    private void popToTransaction() {\n        getSupportFragmentManager().popBackStack(\n            \"transaction_name\",\n            FragmentManager.POP_BACK_STACK_INCLUSIVE\n        );\n    }\n    \n    // Attach/Detach - Destroy view but keep instance\n    private void detachFragment() {\n        Fragment fragment = getSupportFragmentManager()\n            .findFragmentById(R.id.container);\n        \n        if (fragment != null) {\n            getSupportFragmentManager()\n                .beginTransaction()\n                .detach(fragment)\n                .commit();\n            // Fragment view destroyed, but instance kept\n        }\n    }\n    \n    private void reattachFragment() {\n        Fragment fragment = getSupportFragmentManager()\n            .findFragmentByTag(\"MY_FRAGMENT\");\n        \n        if (fragment != null) {\n            getSupportFragmentManager()\n                .beginTransaction()\n                .attach(fragment)\n                .commit();\n            // Fragment view recreated\n        }\n    }\n}"
    },
    {
      "id": 36,
      "question": "What is Material Design and how do you implement it in Android?",
      "answer": "Material Design is Google's design language that provides guidelines for creating beautiful, consistent user interfaces.\n\nCore Principles:\n• Material metaphor - Physical properties\n• Bold, graphic, intentional - Typography and colors\n• Motion provides meaning - Meaningful transitions\n\nKey Components:\n• AppBarLayout - Collapsing toolbars\n• FloatingActionButton - Primary action\n• NavigationView - Navigation drawer\n• BottomNavigationView - Bottom navigation\n• TabLayout - Tabs\n• Snackbar - Brief messages\n• CardView - Card containers\n• CoordinatorLayout - Complex interactions\n\nMaterial Theme:\n• Primary and secondary colors\n• Typography scale\n• Shape theme\n• Motion and transitions\n\nImplementation:\n• Use Material Components library\n• Apply Material theme\n• Follow design guidelines\n• Use elevation and shadows\n• Implement ripple effects",
      "explanation": "Material Design is Google's comprehensive design system providing visual, motion, and interaction guidelines, implemented in Android through Material Components library with themed widgets and coordinated behaviors.",
      "difficulty": "Medium",
      "code": "// Add dependency in build.gradle\n// implementation 'com.google.android.material:material:1.9.0'\n\n// Material Theme in styles.xml\n<!-- res/values/themes.xml -->\n<resources>\n    <style name=\"AppTheme\" parent=\"Theme.MaterialComponents.DayNight.DarkActionBar\">\n        <item name=\"colorPrimary\">@color/purple_500</item>\n        <item name=\"colorPrimaryVariant\">@color/purple_700</item>\n        <item name=\"colorSecondary\">@color/teal_200</item>\n        <item name=\"colorSecondaryVariant\">@color/teal_700</item>\n        <item name=\"colorOnPrimary\">@color/white</item>\n        <item name=\"colorOnSecondary\">@color/black</item>\n        <item name=\"android:statusBarColor\">?attr/colorPrimaryVariant</item>\n    </style>\n</resources>\n\n<!-- Material Components Layout -->\n<androidx.coordinatorlayout.widget.CoordinatorLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    \n    <com.google.android.material.appbar.AppBarLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\">\n        \n        <com.google.android.material.appbar.CollapsingToolbarLayout\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"200dp\"\n            app:layout_scrollFlags=\"scroll|exitUntilCollapsed\">\n            \n            <ImageView\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:scaleType=\"centerCrop\"\n                app:layout_collapseMode=\"parallax\" />\n            \n            <androidx.appcompat.widget.Toolbar\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"?attr/actionBarSize\"\n                app:layout_collapseMode=\"pin\" />\n        </com.google.android.material.appbar.CollapsingToolbarLayout>\n    </com.google.android.material.appbar.AppBarLayout>\n    \n    <androidx.core.widget.NestedScrollView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        app:layout_behavior=\"@string/appbar_scrolling_view_behavior\">\n        \n        <LinearLayout\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:orientation=\"vertical\">\n            \n            <!-- CardView -->\n            <com.google.android.material.card.MaterialCardView\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"wrap_content\"\n                android:layout_margin=\"16dp\"\n                app:cardElevation=\"4dp\"\n                app:cardCornerRadius=\"8dp\">\n                \n                <TextView\n                    android:layout_width=\"match_parent\"\n                    android:layout_height=\"wrap_content\"\n                    android:padding=\"16dp\"\n                    android:text=\"Card Content\" />\n            </com.google.android.material.card.MaterialCardView>\n            \n            <!-- Material Button -->\n            <com.google.android.material.button.MaterialButton\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:text=\"Contained Button\"\n                style=\"@style/Widget.MaterialComponents.Button\" />\n        </LinearLayout>\n    </androidx.core.widget.NestedScrollView>\n    \n    <!-- FAB -->\n    <com.google.android.material.floatingactionbutton.FloatingActionButton\n        android:id=\"@+id/fab\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"bottom|end\"\n        android:layout_margin=\"16dp\"\n        app:srcCompat=\"@drawable/ic_add\" />\n</androidx.coordinatorlayout.widget.CoordinatorLayout>\n\n// Java code for Material components\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        // Setup Toolbar\n        Toolbar toolbar = findViewById(R.id.toolbar);\n        setSupportActionBar(toolbar);\n        \n        // FAB click\n        FloatingActionButton fab = findViewById(R.id.fab);\n        fab.setOnClickListener(v -> {\n            Snackbar.make(v, \"Action performed\", Snackbar.LENGTH_LONG)\n                .setAction(\"UNDO\", view -> {\n                    // Undo action\n                })\n                .show();\n        });\n        \n        // Bottom Navigation\n        BottomNavigationView bottomNav = findViewById(R.id.bottom_navigation);\n        bottomNav.setOnNavigationItemSelectedListener(item -> {\n            switch (item.getItemId()) {\n                case R.id.nav_home:\n                    // Navigate to home\n                    return true;\n                case R.id.nav_search:\n                    // Navigate to search\n                    return true;\n            }\n            return false;\n        });\n    }\n}"
    },
    {
      "id": 37,
      "question": "What is WorkManager and when should you use it?",
      "answer": "WorkManager is a library for deferrable, guaranteed background work that needs to run even if the app is closed or device restarts.\n\nKey Features:\n• Guaranteed execution\n• Works across API levels\n• Respects system health constraints\n• Supports one-time and periodic work\n• Chaining work requests\n• Constraint-based execution\n\nConstraints:\n• Network connectivity (any, connected, unmetered)\n• Battery level (not low)\n• Storage space (not low)\n• Device charging\n• Device idle\n\nWork Types:\n• OneTimeWorkRequest - Executes once\n• PeriodicWorkRequest - Executes periodically\n\nWhen to Use:\n• Background data sync\n• Uploading logs or analytics\n• Image compression\n• Database cleanup\n• Any deferrable background work\n\nWhen NOT to Use:\n• Immediate execution needed (use Executors)\n• Task must run at exact time (use AlarmManager)\n• Real-time communication (use Foreground Service)",
      "explanation": "WorkManager provides guaranteed execution of deferrable background work with constraint-based scheduling, persisting across app restarts and device reboots while respecting system health.",
      "difficulty": "Medium",
      "code": "// Add dependency\n// implementation 'androidx.work:work-runtime:2.8.1'\n\n// Worker class\npublic class UploadWorker extends Worker {\n    public UploadWorker(@NonNull Context context, @NonNull WorkerParameters params) {\n        super(context, params);\n    }\n    \n    @NonNull\n    @Override\n    public Result doWork() {\n        // Get input data\n        String fileUrl = getInputData().getString(\"file_url\");\n        \n        try {\n            // Perform background work\n            uploadFile(fileUrl);\n            \n            // Set output data\n            Data outputData = new Data.Builder()\n                .putString(\"result\", \"Upload successful\")\n                .build();\n            \n            return Result.success(outputData);\n        } catch (Exception e) {\n            // Retry if failure\n            return Result.retry();\n        }\n    }\n    \n    private void uploadFile(String url) {\n        // Upload logic\n    }\n}\n\n// Schedule one-time work\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        // Create input data\n        Data inputData = new Data.Builder()\n            .putString(\"file_url\", \"path/to/file\")\n            .build();\n        \n        // Create constraints\n        Constraints constraints = new Constraints.Builder()\n            .setRequiredNetworkType(NetworkType.CONNECTED)\n            .setRequiresBatteryNotLow(true)\n            .setRequiresStorageNotLow(true)\n            .build();\n        \n        // Create work request\n        OneTimeWorkRequest uploadWork = new OneTimeWorkRequest.Builder(UploadWorker.class)\n            .setInputData(inputData)\n            .setConstraints(constraints)\n            .setInitialDelay(10, TimeUnit.SECONDS)\n            .addTag(\"upload_work\")\n            .setBackoffCriteria(\n                BackoffPolicy.EXPONENTIAL,\n                OneTimeWorkRequest.MIN_BACKOFF_MILLIS,\n                TimeUnit.MILLISECONDS\n            )\n            .build();\n        \n        // Enqueue work\n        WorkManager.getInstance(this).enqueue(uploadWork);\n        \n        // Observe work status\n        WorkManager.getInstance(this)\n            .getWorkInfoByIdLiveData(uploadWork.getId())\n            .observe(this, workInfo -> {\n                if (workInfo != null) {\n                    WorkInfo.State state = workInfo.getState();\n                    \n                    if (state == WorkInfo.State.SUCCEEDED) {\n                        Data output = workInfo.getOutputData();\n                        String result = output.getString(\"result\");\n                        Toast.makeText(this, result, Toast.LENGTH_SHORT).show();\n                    } else if (state == WorkInfo.State.FAILED) {\n                        Toast.makeText(this, \"Upload failed\", Toast.LENGTH_SHORT).show();\n                    }\n                }\n            });\n    }\n    \n    // Periodic work (minimum interval 15 minutes)\n    private void schedulePeriodicWork() {\n        PeriodicWorkRequest syncWork = \n            new PeriodicWorkRequest.Builder(SyncWorker.class, 15, TimeUnit.MINUTES)\n                .setConstraints(new Constraints.Builder()\n                    .setRequiredNetworkType(NetworkType.CONNECTED)\n                    .build())\n                .build();\n        \n        WorkManager.getInstance(this).enqueueUniquePeriodicWork(\n            \"sync_work\",\n            ExistingPeriodicWorkPolicy.KEEP,\n            syncWork\n        );\n    }\n    \n    // Chain work requests\n    private void chainWork() {\n        OneTimeWorkRequest compressWork = \n            new OneTimeWorkRequest.Builder(CompressWorker.class).build();\n        OneTimeWorkRequest uploadWork = \n            new OneTimeWorkRequest.Builder(UploadWorker.class).build();\n        OneTimeWorkRequest cleanupWork = \n            new OneTimeWorkRequest.Builder(CleanupWorker.class).build();\n        \n        WorkManager.getInstance(this)\n            .beginWith(compressWork)\n            .then(uploadWork)\n            .then(cleanupWork)\n            .enqueue();\n    }\n    \n    // Cancel work\n    private void cancelWork() {\n        WorkManager.getInstance(this).cancelAllWorkByTag(\"upload_work\");\n    }\n}"
    },
    {
      "id": 38,
      "question": "What is the difference between Foreground Service and Background Service?",
      "answer": "Foreground and Background Services differ in visibility, priority, and system behavior.\n\nForeground Service:\n• Displays ongoing notification\n• High priority\n• Not killed by system easily\n• User is aware of service\n• Requires notification\n• Can run indefinitely\n• Must declare foreground service type (Android 10+)\n\nBackground Service:\n• No user notification\n• Lower priority\n• Subject to background execution limits\n• Can be killed by system\n• Limited execution time\n• Restricted on Android 8.0+\n\nForeground Service Types:\n• camera - Camera usage\n• location - Location tracking\n• mediaPlayback - Audio/video playback\n• phoneCall - Phone calls\n• microphone - Audio recording\n\nWhen to Use Foreground:\n• Music playback\n• Navigation\n• File downloads user initiated\n• Fitness tracking\n• Any task user should be aware of\n\nWhen to Use Background:\n• Quick operations (< 10 seconds)\n• Use WorkManager instead for most cases",
      "explanation": "Foreground Service displays a persistent notification and has high priority preventing system termination, while Background Service runs silently with lower priority and execution restrictions, especially on Android 8.0+.",
      "difficulty": "Medium",
      "code": "// AndroidManifest.xml\n<uses-permission android:name=\"android.permission.FOREGROUND_SERVICE\" />\n<uses-permission android:name=\"android.permission.FOREGROUND_SERVICE_MEDIA_PLAYBACK\" />\n\n<service\n    android:name=\".MusicService\"\n    android:foregroundServiceType=\"mediaPlayback\"\n    android:exported=\"false\" />\n\n// Foreground Service\npublic class MusicService extends Service {\n    private static final int NOTIFICATION_ID = 1;\n    private static final String CHANNEL_ID = \"music_channel\";\n    private MediaPlayer mediaPlayer;\n    \n    @Override\n    public void onCreate() {\n        super.onCreate();\n        createNotificationChannel();\n    }\n    \n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        // Create notification\n        Notification notification = createNotification();\n        \n        // Start foreground service\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\n            startForeground(NOTIFICATION_ID, notification, \n                ServiceInfo.FOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK);\n        } else {\n            startForeground(NOTIFICATION_ID, notification);\n        }\n        \n        // Start playing music\n        mediaPlayer = MediaPlayer.create(this, R.raw.song);\n        mediaPlayer.setLooping(true);\n        mediaPlayer.start();\n        \n        return START_STICKY;\n    }\n    \n    private Notification createNotification() {\n        Intent notificationIntent = new Intent(this, MainActivity.class);\n        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0,\n            notificationIntent, PendingIntent.FLAG_IMMUTABLE);\n        \n        return new NotificationCompat.Builder(this, CHANNEL_ID)\n            .setContentTitle(\"Music Player\")\n            .setContentText(\"Playing music...\")\n            .setSmallIcon(R.drawable.ic_music)\n            .setContentIntent(pendingIntent)\n            .addAction(R.drawable.ic_pause, \"Pause\",\n                getPendingIntent(\"PAUSE\"))\n            .addAction(R.drawable.ic_stop, \"Stop\",\n                getPendingIntent(\"STOP\"))\n            .build();\n    }\n    \n    private PendingIntent getPendingIntent(String action) {\n        Intent intent = new Intent(this, MusicService.class);\n        intent.setAction(action);\n        return PendingIntent.getService(this, 0, intent, \n            PendingIntent.FLAG_IMMUTABLE);\n    }\n    \n    private void createNotificationChannel() {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            NotificationChannel channel = new NotificationChannel(\n                CHANNEL_ID,\n                \"Music Playback\",\n                NotificationManager.IMPORTANCE_LOW\n            );\n            \n            NotificationManager manager = getSystemService(NotificationManager.class);\n            manager.createNotificationChannel(channel);\n        }\n    }\n    \n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        if (mediaPlayer != null) {\n            mediaPlayer.stop();\n            mediaPlayer.release();\n        }\n        stopForeground(true);\n    }\n    \n    @Override\n    public IBinder onBind(Intent intent) {\n        return null;\n    }\n}\n\n// Start Foreground Service from Activity\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        findViewById(R.id.startButton).setOnClickListener(v -> {\n            Intent serviceIntent = new Intent(this, MusicService.class);\n            \n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n                startForegroundService(serviceIntent);\n            } else {\n                startService(serviceIntent);\n            }\n        });\n        \n        findViewById(R.id.stopButton).setOnClickListener(v -> {\n            Intent serviceIntent = new Intent(this, MusicService.class);\n            stopService(serviceIntent);\n        });\n    }\n}"
    },
    {
      "id": 39,
      "question": "What is Android Data Binding and how does it work?",
      "answer": "Data Binding is a library that binds UI components to data sources declaratively in layout files, reducing boilerplate code.\n\nKey Features:\n• Bind views to data in XML\n• Eliminate findViewById()\n• Two-way data binding\n• Observable data updates\n• Null safety\n• Expression language in XML\n\nBinding Expressions:\n• @{} syntax for one-way binding\n• @={} syntax for two-way binding\n• Supports method calls, operators\n• Null coalescing operator ??\n• String concatenation\n\nObservable Data:\n• BaseObservable - Manual notification\n• ObservableField - Automatic notification\n• ObservableArrayList, ObservableArrayMap\n• LiveData integration\n\nBenefits:\n• Less boilerplate code\n• Null pointer safety\n• Faster than findViewById()\n• Clean separation of concerns\n• Automatic UI updates\n\nBinding Adapters:\n• Custom attribute handling\n• Reusable view logic\n• Type conversions",
      "explanation": "Data Binding eliminates findViewById() by binding UI components directly to data sources in XML layouts, supporting observable data for automatic UI updates and two-way binding.",
      "difficulty": "Medium",
      "code": "// Enable Data Binding in build.gradle\nandroid {\n    buildFeatures {\n        dataBinding true\n    }\n}\n\n// Model class with Observable\npublic class User extends BaseObservable {\n    private String name;\n    private String email;\n    \n    @Bindable\n    public String getName() {\n        return name;\n    }\n    \n    public void setName(String name) {\n        this.name = name;\n        notifyPropertyChanged(BR.name);\n    }\n    \n    @Bindable\n    public String getEmail() {\n        return email;\n    }\n    \n    public void setEmail(String email) {\n        this.email = email;\n        notifyPropertyChanged(BR.email);\n    }\n}\n\n// Using ObservableField (simpler)\npublic class UserViewModel {\n    public ObservableField<String> name = new ObservableField<>();\n    public ObservableField<String> email = new ObservableField<>();\n    \n    public void updateName(String newName) {\n        name.set(newName);\n    }\n}\n\n// Layout with Data Binding\n<!-- activity_main.xml -->\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <data>\n        <variable\n            name=\"user\"\n            type=\"com.example.User\" />\n        \n        <variable\n            name=\"handler\"\n            type=\"com.example.MainActivity.ClickHandler\" />\n    </data>\n    \n    <LinearLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\"\n        android:padding=\"16dp\">\n        \n        <!-- One-way binding -->\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@{user.name}\" />\n        \n        <!-- Two-way binding -->\n        <EditText\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@={user.email}\" />\n        \n        <!-- Expression with null coalescing -->\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@{user.name ?? `No name`}\" />\n        \n        <!-- String concatenation -->\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@{`Email: ` + user.email}\" />\n        \n        <!-- Visibility based on condition -->\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:visibility=\"@{user.email.empty ? View.GONE : View.VISIBLE}\"\n            android:text=\"Email is set\" />\n        \n        <!-- Click handler -->\n        <Button\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Save\"\n            android:onClick=\"@{handler::onSaveClick}\" />\n    </LinearLayout>\n</layout>\n\n// Activity with Data Binding\npublic class MainActivity extends AppCompatActivity {\n    private ActivityMainBinding binding;\n    private User user;\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        \n        // Inflate with binding\n        binding = DataBindingUtil.setContentView(this, R.layout.activity_main);\n        \n        // Create and set data\n        user = new User();\n        user.setName(\"John Doe\");\n        user.setEmail(\"john@example.com\");\n        \n        binding.setUser(user);\n        binding.setHandler(new ClickHandler());\n        \n        // Update data (UI auto-updates)\n        user.setName(\"Jane Doe\");\n    }\n    \n    public class ClickHandler {\n        public void onSaveClick(View view) {\n            Toast.makeText(MainActivity.this, \n                \"Saved: \" + user.getName(), \n                Toast.LENGTH_SHORT).show();\n        }\n    }\n}\n\n// Custom Binding Adapter\n@BindingAdapter(\"imageUrl\")\npublic static void loadImage(ImageView view, String url) {\n    Glide.with(view.getContext())\n        .load(url)\n        .into(view);\n}\n\n// Use custom adapter in XML\n<!-- <ImageView\n    android:layout_width=\"100dp\"\n    android:layout_height=\"100dp\"\n    app:imageUrl=\"@{user.profileUrl}\" /> -->"
    },
    {
      "id": 40,
      "question": "What are Android Notifications and how do you create them?",
      "answer": "Notifications are messages displayed outside your app's UI to provide timely information to users.\n\nNotification Components:\n• Small icon - Required\n• App name - Automatic\n• Timestamp - Automatic\n• Title - setContentTitle()\n• Text - setContentText()\n• Large icon - Optional\n• Actions - Up to 3 action buttons\n\nNotification Channels (Android 8.0+):\n• Required for notifications\n• User can control per channel\n• Define importance level\n• Group similar notifications\n\nImportance Levels:\n• IMPORTANCE_HIGH - Sound, heads-up\n• IMPORTANCE_DEFAULT - Sound, no heads-up\n• IMPORTANCE_LOW - No sound\n• IMPORTANCE_MIN - No sound, no status bar\n\nNotification Styles:\n• BigTextStyle - Large text\n• BigPictureStyle - Large image\n• InboxStyle - Multiple lines\n• MessagingStyle - Conversations\n\nBest Practices:\n• Create channel on app start\n• Use appropriate importance\n• Add meaningful actions\n• Handle notification taps\n• Group related notifications",
      "explanation": "Notifications display timely information outside the app through notification channels with configurable importance levels, supporting various styles and actions for user interaction.",
      "difficulty": "Medium",
      "code": "public class NotificationHelper {\n    private static final String CHANNEL_ID = \"default_channel\";\n    private static final int NOTIFICATION_ID = 1;\n    private Context context;\n    \n    public NotificationHelper(Context context) {\n        this.context = context;\n        createNotificationChannel();\n    }\n    \n    // Create Notification Channel (Android 8.0+)\n    private void createNotificationChannel() {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            CharSequence name = \"Default Channel\";\n            String description = \"Default notification channel\";\n            int importance = NotificationManager.IMPORTANCE_DEFAULT;\n            \n            NotificationChannel channel = new NotificationChannel(\n                CHANNEL_ID, name, importance);\n            channel.setDescription(description);\n            channel.enableLights(true);\n            channel.setLightColor(Color.BLUE);\n            channel.enableVibration(true);\n            channel.setVibrationPattern(new long[]{0, 500, 200, 500});\n            \n            NotificationManager manager = \n                context.getSystemService(NotificationManager.class);\n            manager.createNotificationChannel(channel);\n        }\n    }\n    \n    // Basic Notification\n    public void showBasicNotification() {\n        Intent intent = new Intent(context, MainActivity.class);\n        PendingIntent pendingIntent = PendingIntent.getActivity(\n            context, 0, intent, \n            PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_UPDATE_CURRENT);\n        \n        NotificationCompat.Builder builder = \n            new NotificationCompat.Builder(context, CHANNEL_ID)\n                .setSmallIcon(R.drawable.ic_notification)\n                .setContentTitle(\"New Message\")\n                .setContentText(\"You have a new message\")\n                .setPriority(NotificationCompat.PRIORITY_DEFAULT)\n                .setContentIntent(pendingIntent)\n                .setAutoCancel(true);\n        \n        NotificationManagerCompat.from(context).notify(NOTIFICATION_ID, builder.build());\n    }\n    \n    // Big Text Notification\n    public void showBigTextNotification() {\n        String longText = \"This is a very long text that will be displayed \" +\n            \"in expanded notification view when user expands it...\";\n        \n        NotificationCompat.Builder builder = \n            new NotificationCompat.Builder(context, CHANNEL_ID)\n                .setSmallIcon(R.drawable.ic_notification)\n                .setContentTitle(\"Long Message\")\n                .setContentText(\"Tap to read more\")\n                .setStyle(new NotificationCompat.BigTextStyle()\n                    .bigText(longText))\n                .setPriority(NotificationCompat.PRIORITY_DEFAULT);\n        \n        NotificationManagerCompat.from(context).notify(2, builder.build());\n    }\n    \n    // Notification with Actions\n    public void showActionNotification() {\n        Intent replyIntent = new Intent(context, ReplyActivity.class);\n        PendingIntent replyPending = PendingIntent.getActivity(\n            context, 0, replyIntent, PendingIntent.FLAG_IMMUTABLE);\n        \n        Intent dismissIntent = new Intent(context, DismissReceiver.class);\n        PendingIntent dismissPending = PendingIntent.getBroadcast(\n            context, 0, dismissIntent, PendingIntent.FLAG_IMMUTABLE);\n        \n        NotificationCompat.Builder builder = \n            new NotificationCompat.Builder(context, CHANNEL_ID)\n                .setSmallIcon(R.drawable.ic_notification)\n                .setContentTitle(\"Message from John\")\n                .setContentText(\"Hey, how are you?\")\n                .addAction(R.drawable.ic_reply, \"Reply\", replyPending)\n                .addAction(R.drawable.ic_dismiss, \"Dismiss\", dismissPending)\n                .setPriority(NotificationCompat.PRIORITY_HIGH);\n        \n        NotificationManagerCompat.from(context).notify(3, builder.build());\n    }\n    \n    // Progress Notification\n    public void showProgressNotification() {\n        final int PROGRESS_MAX = 100;\n        \n        NotificationCompat.Builder builder = \n            new NotificationCompat.Builder(context, CHANNEL_ID)\n                .setSmallIcon(R.drawable.ic_download)\n                .setContentTitle(\"Downloading file\")\n                .setContentText(\"Download in progress\")\n                .setPriority(NotificationCompat.PRIORITY_LOW)\n                .setOngoing(true);\n        \n        NotificationManagerCompat notificationManager = \n            NotificationManagerCompat.from(context);\n        \n        // Simulate progress\n        new Thread(() -> {\n            for (int progress = 0; progress <= PROGRESS_MAX; progress += 10) {\n                builder.setProgress(PROGRESS_MAX, progress, false);\n                notificationManager.notify(4, builder.build());\n                \n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            \n            // Complete\n            builder.setContentText(\"Download complete\")\n                .setProgress(0, 0, false)\n                .setOngoing(false);\n            notificationManager.notify(4, builder.build());\n        }).start();\n    }\n    \n    // Cancel notification\n    public void cancelNotification(int notificationId) {\n        NotificationManagerCompat.from(context).cancel(notificationId);\n    }\n}"
    },
    {
      "id": 41,
      "question": "What is Glide and how do you use it for image loading in Android?",
      "answer": "Glide is a fast and efficient image loading library that handles image downloading, caching, and memory management.\n\nKey Features:\n• Automatic memory and disk caching\n• Image transformation (resize, crop, round)\n• GIF and video thumbnail support\n• Lifecycle-aware loading\n• Efficient memory management\n• Placeholder and error images\n• Priority-based loading\n\nCaching Levels:\n• Memory cache - Fast, cleared on app close\n• Disk cache - Persistent across sessions\n• Can customize caching strategy\n\nTransformations:\n• CenterCrop, FitCenter, CircleCrop\n• RoundedCorners\n• Custom transformations\n• Multiple transformation chaining\n\nBenefits:\n• Handles out-of-memory errors\n• Automatic request cancellation\n• Thumbnail support\n• Lifecycle integration\n• Better than manual image loading\n\nAlternatives:\n• Picasso - Simpler API\n• Coil - Kotlin-first\n• Fresco - Facebook's library",
      "explanation": "Glide efficiently loads, caches, and displays images with automatic memory management, lifecycle awareness, transformations, and support for various image formats including GIFs.",
      "difficulty": "Easy",
      "code": "// Add dependencies in build.gradle\n// implementation 'com.github.bumptech.glide:glide:4.15.1'\n// annotationProcessor 'com.github.bumptech.glide:compiler:4.15.1'\n\n// Basic image loading\nImageView imageView = findViewById(R.id.imageView);\n\nGlide.with(this)\n    .load(\"https://example.com/image.jpg\")\n    .into(imageView);\n\n// With placeholder and error images\nGlide.with(this)\n    .load(imageUrl)\n    .placeholder(R.drawable.placeholder)\n    .error(R.drawable.error_image)\n    .into(imageView);\n\n// With transformations\nGlide.with(this)\n    .load(imageUrl)\n    .centerCrop()\n    .into(imageView);\n\n// Circular image\nGlide.with(this)\n    .load(imageUrl)\n    .circleCrop()\n    .into(imageView);\n\n// Rounded corners\nGlide.with(this)\n    .load(imageUrl)\n    .transform(new RoundedCorners(20))\n    .into(imageView);\n\n// Multiple transformations\nGlide.with(this)\n    .load(imageUrl)\n    .transform(new MultiTransformation<>(\n        new CenterCrop(),\n        new RoundedCorners(20)\n    ))\n    .into(imageView);\n\n// Custom size\nGlide.with(this)\n    .load(imageUrl)\n    .override(200, 200)\n    .into(imageView);\n\n// Disk cache strategy\nGlide.with(this)\n    .load(imageUrl)\n    .diskCacheStrategy(DiskCacheStrategy.ALL)\n    .into(imageView);\n\n// Skip memory cache\nGlide.with(this)\n    .load(imageUrl)\n    .skipMemoryCache(true)\n    .into(imageView);\n\n// Loading GIF\nGlide.with(this)\n    .asGif()\n    .load(gifUrl)\n    .into(imageView);\n\n// Thumbnail support\nGlide.with(this)\n    .load(fullImageUrl)\n    .thumbnail(0.1f) // 10% of original\n    .into(imageView);\n\n// Load from multiple sources\nGlide.with(this)\n    .load(imageUrl)\n    .thumbnail(\n        Glide.with(this)\n            .load(thumbnailUrl)\n    )\n    .into(imageView);\n\n// Listener for load completion\nGlide.with(this)\n    .load(imageUrl)\n    .listener(new RequestListener<Drawable>() {\n        @Override\n        public boolean onLoadFailed(@Nullable GlideException e, \n                                   Object model, \n                                   Target<Drawable> target, \n                                   boolean isFirstResource) {\n            // Handle error\n            return false;\n        }\n        \n        @Override\n        public boolean onResourceReady(Drawable resource, \n                                      Object model, \n                                      Target<Drawable> target, \n                                      DataSource dataSource, \n                                      boolean isFirstResource) {\n            // Image loaded successfully\n            return false;\n        }\n    })\n    .into(imageView);\n\n// Preload image\nGlide.with(this)\n    .load(imageUrl)\n    .preload();\n\n// Clear cache\nGlide.get(context).clearMemory(); // On UI thread\nnew Thread(() -> {\n    Glide.get(context).clearDiskCache(); // On background thread\n}).start();"
    },
    {
      "id": 42,
      "question": "What is ProGuard and R8 in Android?",
      "answer": "ProGuard and R8 are code shrinking and obfuscation tools that optimize Android apps by removing unused code and making reverse engineering harder.\n\nProGuard (Legacy):\n• Third-party tool\n• Code shrinking and obfuscation\n• Slower build times\n• Being replaced by R8\n\nR8 (Default since Android Studio 3.4):\n• Google's tool\n• Combines shrinking, desugaring, dexing, obfuscation\n• Faster than ProGuard\n• Better optimization\n• Default for release builds\n\nKey Features:\n• Code shrinking - Removes unused code\n• Obfuscation - Renames classes and members\n• Optimization - Makes code more efficient\n• Resource shrinking - Removes unused resources\n\nProGuard Rules:\n• Keep classes/methods from being removed\n• Keep names for reflection\n• Preserve native methods\n• Keep model classes for JSON parsing\n• Keep library-specific requirements\n\nCommon Issues:\n• Reflection-based code breaks\n• Serialization issues\n• Model classes being obfuscated\n• Missing ProGuard rules for libraries",
      "explanation": "R8 is Android's code optimizer that shrinks, obfuscates, and optimizes code for release builds, replacing ProGuard with better performance while requiring configuration rules to preserve necessary code.",
      "difficulty": "Medium",
      "code": "// Enable in build.gradle (app level)\nandroid {\n    buildTypes {\n        release {\n            minifyEnabled true\n            shrinkResources true\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'),\n                         'proguard-rules.pro'\n        }\n    }\n}\n\n// proguard-rules.pro file\n\n# Keep model classes (for JSON parsing)\n-keep class com.example.model.** { *; }\n\n# Keep Parcelable classes\n-keep class * implements android.os.Parcelable {\n    public static final android.os.Parcelable$Creator *;\n}\n\n# Keep Serializable classes\n-keepclassmembers class * implements java.io.Serializable {\n    static final long serialVersionUID;\n    private static final java.io.ObjectStreamField[] serialPersistentFields;\n    private void writeObject(java.io.ObjectOutputStream);\n    private void readObject(java.io.ObjectInputStream);\n    java.lang.Object writeReplace();\n    java.lang.Object readResolve();\n}\n\n# Keep native methods\n-keepclasseswithmembernames class * {\n    native <methods>;\n}\n\n# Keep custom views\n-keepclasseswithmembers class * {\n    public <init>(android.content.Context, android.util.AttributeSet);\n}\n\n# Keep enums\n-keepclassmembers enum * {\n    public static **[] values();\n    public static ** valueOf(java.lang.String);\n}\n\n# Keep annotations\n-keepattributes *Annotation*\n\n# Keep line numbers for debugging\n-keepattributes SourceFile,LineNumberTable\n\n# Keep generic signatures\n-keepattributes Signature\n\n# Retrofit specific\n-keepattributes Exceptions\n-keep class retrofit2.** { *; }\n-keepclasseswithmembers class * {\n    @retrofit2.http.* <methods>;\n}\n\n# Gson specific\n-keep class com.google.gson.** { *; }\n-keep class * implements com.google.gson.TypeAdapter\n-keep class * implements com.google.gson.TypeAdapterFactory\n-keep class * implements com.google.gson.JsonSerializer\n-keep class * implements com.google.gson.JsonDeserializer\n\n# Glide specific\n-keep public class * implements com.bumptech.glide.module.GlideModule\n-keep class * extends com.bumptech.glide.module.AppGlideModule {\n    <init>(...);\n}\n-keep public enum com.bumptech.glide.load.ImageHeaderParser$** {\n    **[] $VALUES;\n    public *;\n}\n\n# Room Database\n-keep class * extends androidx.room.RoomDatabase\n-keep @androidx.room.Entity class *\n-dontwarn androidx.room.paging.**\n\n# Prevent obfuscation of specific class\n-keep class com.example.MyImportantClass { *; }\n\n# Keep only specific methods\n-keepclassmembers class com.example.MyClass {\n    public void myMethod(*);\n}\n\n# Remove logging in release\n-assumenosideeffects class android.util.Log {\n    public static *** d(...);\n    public static *** v(...);\n    public static *** i(...);\n}\n\n// Checking obfuscation results\n// After building, check mapping file at:\n// app/build/outputs/mapping/release/mapping.txt\n\n// Example of preserved vs obfuscated:\n// Original: com.example.User -> a.b.c\n// Method: getName() -> a()\n// Method: setName(String) -> a(String)"
    },
    {
      "id": 43,
      "question": "What is the Android Application class and when would you use it?",
      "answer": "Application class is the base class that maintains global application state and is instantiated before any other component.\n\nKey Characteristics:\n• Created when app process starts\n• Lives throughout app lifetime\n• Singleton instance accessible from anywhere\n• Created before any Activity, Service, or Receiver\n• One instance per process\n\nCommon Use Cases:\n• Initialize third-party libraries\n• Setup dependency injection (Dagger)\n• Create database instances\n• Initialize crash reporting (Firebase Crashlytics)\n• Setup global configurations\n• Application-wide state management\n\nLifecycle Callbacks:\n• onCreate() - App created\n• onTerminate() - App terminating (not called in production)\n• onLowMemory() - System low on memory\n• onTrimMemory() - Release memory when needed\n• onConfigurationChanged() - Configuration changed\n\nBest Practices:\n• Keep onCreate() lightweight\n• Don't store Activity contexts\n• Use for library initialization only\n• Avoid memory leaks\n• Consider lazy initialization",
      "explanation": "Application class is a singleton base class maintaining global app state, instantiated before any component, ideal for initializing libraries and managing application-wide resources.",
      "difficulty": "Medium",
      "code": "// Custom Application class\npublic class MyApplication extends Application {\n    private static MyApplication instance;\n    private AppDatabase database;\n    private SharedPreferences prefs;\n    \n    @Override\n    public void onCreate() {\n        super.onCreate();\n        instance = this;\n        \n        // Initialize libraries\n        initializeLibraries();\n        \n        // Initialize database\n        database = Room.databaseBuilder(\n            this,\n            AppDatabase.class,\n            \"app_database\"\n        ).build();\n        \n        // Initialize SharedPreferences\n        prefs = getSharedPreferences(\"app_prefs\", MODE_PRIVATE);\n        \n        // Setup crash reporting\n        FirebaseCrashlytics.getInstance().setCrashlyticsCollectionEnabled(true);\n        \n        // Setup Timber for logging\n        if (BuildConfig.DEBUG) {\n            Timber.plant(new Timber.DebugTree());\n        }\n    }\n    \n    private void initializeLibraries() {\n        // Initialize Firebase\n        FirebaseApp.initializeApp(this);\n        \n        // Initialize other libraries\n        // Example: Glide, Retrofit, etc.\n    }\n    \n    public static MyApplication getInstance() {\n        return instance;\n    }\n    \n    public AppDatabase getDatabase() {\n        return database;\n    }\n    \n    public SharedPreferences getPrefs() {\n        return prefs;\n    }\n    \n    @Override\n    public void onLowMemory() {\n        super.onLowMemory();\n        // Clear caches\n        Glide.get(this).clearMemory();\n    }\n    \n    @Override\n    public void onTrimMemory(int level) {\n        super.onTrimMemory(level);\n        \n        switch (level) {\n            case TRIM_MEMORY_UI_HIDDEN:\n                // UI hidden, release UI-related memory\n                break;\n            case TRIM_MEMORY_BACKGROUND:\n            case TRIM_MEMORY_MODERATE:\n            case TRIM_MEMORY_COMPLETE:\n                // App in background, release memory\n                Glide.get(this).clearMemory();\n                break;\n            case TRIM_MEMORY_RUNNING_LOW:\n            case TRIM_MEMORY_RUNNING_MODERATE:\n            case TRIM_MEMORY_RUNNING_CRITICAL:\n                // App running but system low on memory\n                Glide.get(this).trimMemory(level);\n                break;\n        }\n    }\n    \n    @Override\n    public void onConfigurationChanged(Configuration newConfig) {\n        super.onConfigurationChanged(newConfig);\n        // Handle configuration changes\n    }\n}\n\n// Register in AndroidManifest.xml\n<application\n    android:name=\".MyApplication\"\n    android:allowBackup=\"true\"\n    android:icon=\"@mipmap/ic_launcher\"\n    android:label=\"@string/app_name\">\n    <!-- Activities, Services, etc. -->\n</application>\n\n// Access from anywhere\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        \n        // Get Application instance\n        MyApplication app = (MyApplication) getApplication();\n        // or\n        MyApplication app2 = MyApplication.getInstance();\n        \n        // Access global resources\n        AppDatabase database = app.getDatabase();\n        SharedPreferences prefs = app.getPrefs();\n    }\n}\n\n// With Dagger (Dependency Injection)\npublic class MyApplication extends Application {\n    private AppComponent appComponent;\n    \n    @Override\n    public void onCreate() {\n        super.onCreate();\n        \n        appComponent = DaggerAppComponent.builder()\n            .application(this)\n            .build();\n    }\n    \n    public AppComponent getAppComponent() {\n        return appComponent;\n    }\n}\n\n// Multidex support for large apps\npublic class MyApplication extends MultiDexApplication {\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        MultiDex.install(this);\n    }\n}"
    },
    {
      "id": 44,
      "question": "What is the difference between Implicit Intent and Explicit Intent with examples?",
      "answer": "Explicit and Implicit Intents differ in how they specify the component to be invoked.\n\nExplicit Intent:\n• Specifies exact component class\n• Used for internal app navigation\n• Component known at compile time\n• Direct and specific\n• More secure for sensitive operations\n• No Intent Filter needed\n\nImplicit Intent:\n• Declares action to perform\n• System finds suitable component\n• Can invoke external apps\n• Based on Intent Filter matching\n• User may choose from multiple apps\n• Requires Intent Filter in target\n\nIntent Resolution:\n• System checks all Intent Filters\n• Matches action, category, data\n• Shows chooser if multiple matches\n• Returns error if no match\n\nUse Cases:\n• Explicit: Start Activity within app\n• Implicit: Share content, open URL, dial number\n• Explicit: Start Service, bind to Service\n• Implicit: Open camera, send email, view document",
      "explanation": "Explicit Intent directly specifies the target component class for internal app use, while Implicit Intent declares an action allowing the system to find and offer suitable components from any app.",
      "difficulty": "Easy",
      "code": "// EXPLICIT INTENTS\n\n// 1. Start Activity in same app\nIntent intent = new Intent(MainActivity.this, ProfileActivity.class);\nstartActivity(intent);\n\n// 2. Pass data with explicit Intent\nIntent intent = new Intent(this, DetailActivity.class);\nintent.putExtra(\"user_id\", 123);\nintent.putExtra(\"user_name\", \"John\");\nstartActivity(intent);\n\n// 3. Start Service explicitly\nIntent serviceIntent = new Intent(this, MyService.class);\nstartService(serviceIntent);\n\n// 4. Send broadcast explicitly\nIntent broadcastIntent = new Intent(this, MyReceiver.class);\nsendBroadcast(broadcastIntent);\n\n// 5. Start Activity for result\nIntent intent = new Intent(this, SelectActivity.class);\nstartActivityForResult(intent, REQUEST_CODE);\n\n// IMPLICIT INTENTS\n\n// 1. Open URL in browser\nIntent browserIntent = new Intent(Intent.ACTION_VIEW);\nbrowserIntent.setData(Uri.parse(\"https://www.google.com\"));\nif (browserIntent.resolveActivity(getPackageManager()) != null) {\n    startActivity(browserIntent);\n}\n\n// 2. Share text\nIntent shareIntent = new Intent(Intent.ACTION_SEND);\nshareIntent.setType(\"text/plain\");\nshareIntent.putExtra(Intent.EXTRA_TEXT, \"Check out this app!\");\nstartActivity(Intent.createChooser(shareIntent, \"Share via\"));\n\n// 3. Dial phone number\nIntent dialIntent = new Intent(Intent.ACTION_DIAL);\ndialIntent.setData(Uri.parse(\"tel:1234567890\"));\nstartActivity(dialIntent);\n\n// 4. Make phone call (requires permission)\nIntent callIntent = new Intent(Intent.ACTION_CALL);\ncallIntent.setData(Uri.parse(\"tel:1234567890\"));\nif (ContextCompat.checkSelfPermission(this, \n        Manifest.permission.CALL_PHONE) == PackageManager.PERMISSION_GRANTED) {\n    startActivity(callIntent);\n}\n\n// 5. Send email\nIntent emailIntent = new Intent(Intent.ACTION_SENDTO);\nemailIntent.setData(Uri.parse(\"mailto:test@example.com\"));\nemailIntent.putExtra(Intent.EXTRA_SUBJECT, \"Subject\");\nemailIntent.putExtra(Intent.EXTRA_TEXT, \"Email body\");\nif (emailIntent.resolveActivity(getPackageManager()) != null) {\n    startActivity(emailIntent);\n}\n\n// 6. Open camera\nIntent cameraIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);\nif (cameraIntent.resolveActivity(getPackageManager()) != null) {\n    startActivityForResult(cameraIntent, CAMERA_REQUEST);\n}\n\n// 7. Open gallery\nIntent galleryIntent = new Intent(Intent.ACTION_PICK);\ngalleryIntent.setType(\"image/*\");\nstartActivityForResult(galleryIntent, GALLERY_REQUEST);\n\n// 8. Open map location\nIntent mapIntent = new Intent(Intent.ACTION_VIEW);\nmapIntent.setData(Uri.parse(\"geo:37.7749,-122.4194?q=San+Francisco\"));\nif (mapIntent.resolveActivity(getPackageManager()) != null) {\n    startActivity(mapIntent);\n}\n\n// 9. Share image\nIntent shareImageIntent = new Intent(Intent.ACTION_SEND);\nshareImageIntent.setType(\"image/*\");\nshareImageIntent.putExtra(Intent.EXTRA_STREAM, imageUri);\nstartActivity(Intent.createChooser(shareImageIntent, \"Share Image\"));\n\n// 10. Open PDF file\nIntent pdfIntent = new Intent(Intent.ACTION_VIEW);\npdfIntent.setDataAndType(pdfUri, \"application/pdf\");\npdfIntent.setFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);\nif (pdfIntent.resolveActivity(getPackageManager()) != null) {\n    startActivity(pdfIntent);\n}\n\n// Check if implicit Intent can be handled\npublic boolean isIntentAvailable(Intent intent) {\n    PackageManager packageManager = getPackageManager();\n    List<ResolveInfo> list = packageManager.queryIntentActivities(\n        intent, PackageManager.MATCH_DEFAULT_ONLY);\n    return list.size() > 0;\n}\n\n// Intent Filter in AndroidManifest.xml for implicit Intents\n// <activity android:name=\".ShareActivity\">\n//     <intent-filter>\n//         <action android:name=\"android.intent.action.SEND\" />\n//         <category android:name=\"android.intent.category.DEFAULT\" />\n//         <data android:mimeType=\"text/plain\" />\n//     </intent-filter>\n// </activity>"
    },
    {
      "id": 45,
      "question": "What is Android Jetpack and what are its main components?",
      "answer": "Android Jetpack is a suite of libraries, tools, and guidance to help developers build high-quality Android apps more easily.\n\nCore Components:\n• Architecture Components - ViewModel, LiveData, Room, WorkManager\n• Foundation Components - AppCompat, Android KTX, Multidex\n• Behavior Components - Notifications, Permissions, Sharing\n• UI Components - Animations, Fragments, Layout\n\nArchitecture Components:\n• ViewModel - UI-related data holder\n• LiveData - Observable data holder\n• Room - SQLite abstraction\n• Paging - Load data gradually\n• Navigation - In-app navigation\n• WorkManager - Background tasks\n• Data Binding - Bind UI to data\n\nFoundation:\n• AppCompat - Backward compatibility\n• Android KTX - Kotlin extensions\n• Test - Testing framework\n• Multidex - Multiple DEX files\n\nUI:\n• Compose - Modern UI toolkit\n• Fragment - Modular UI\n• RecyclerView - Flexible lists\n• ViewPager2 - Swipeable pages\n\nBehavior:\n• CameraX - Camera use cases\n• Permissions - Runtime permissions\n• Preferences - Settings UI",
      "explanation": "Android Jetpack is Google's collection of libraries and tools providing architecture components, UI components, and behavior components to simplify Android development with modern best practices.",
      "difficulty": "Easy",
      "code": "// Add Jetpack dependencies in build.gradle\n\n// Architecture Components\nimplementation 'androidx.lifecycle:lifecycle-viewmodel:2.5.1'\nimplementation 'androidx.lifecycle:lifecycle-livedata:2.5.1'\nimplementation 'androidx.room:room-runtime:2.5.0'\nannotationProcessor 'androidx.room:room-compiler:2.5.0'\nimplementation 'androidx.work:work-runtime:2.8.1'\nimplementation 'androidx.navigation:navigation-fragment:2.5.3'\nimplementation 'androidx.navigation:navigation-ui:2.5.3'\n\n// Foundation\nimplementation 'androidx.appcompat:appcompat:1.6.1'\nimplementation 'androidx.core:core-ktx:1.9.0'\n\n// UI\nimplementation 'androidx.constraintlayout:constraintlayout:2.1.4'\nimplementation 'androidx.recyclerview:recyclerview:1.3.0'\nimplementation 'androidx.cardview:cardview:1.0.0'\nimplementation 'androidx.viewpager2:viewpager2:1.0.0'\n\n// Material Design\nimplementation 'com.google.android.material:material:1.9.0'\n\n// Example: Using Jetpack Architecture Components together\n\n// 1. Entity (Room)\n@Entity(tableName = \"users\")\npublic class User {\n    @PrimaryKey(autoGenerate = true)\n    private int id;\n    private String name;\n    private String email;\n    \n    // Getters and setters\n}\n\n// 2. DAO (Room)\n@Dao\npublic interface UserDao {\n    @Query(\"SELECT * FROM users\")\n    LiveData<List<User>> getAllUsers();\n    \n    @Insert\n    void insert(User user);\n    \n    @Delete\n    void delete(User user);\n}\n\n// 3. Database (Room)\n@Database(entities = {User.class}, version = 1)\npublic abstract class AppDatabase extends RoomDatabase {\n    public abstract UserDao userDao();\n}\n\n// 4. Repository\npublic class UserRepository {\n    private UserDao userDao;\n    private LiveData<List<User>> allUsers;\n    \n    public UserRepository(Application application) {\n        AppDatabase database = Room.databaseBuilder(\n            application,\n            AppDatabase.class,\n            \"user_database\"\n        ).build();\n        \n        userDao = database.userDao();\n        allUsers = userDao.getAllUsers();\n    }\n    \n    public LiveData<List<User>> getAllUsers() {\n        return allUsers;\n    }\n    \n    public void insert(User user) {\n        new Thread(() -> userDao.insert(user)).start();\n    }\n}\n\n// 5. ViewModel\npublic class UserViewModel extends AndroidViewModel {\n    private UserRepository repository;\n    private LiveData<List<User>> allUsers;\n    \n    public UserViewModel(Application application) {\n        super(application);\n        repository = new UserRepository(application);\n        allUsers = repository.getAllUsers();\n    }\n    \n    public LiveData<List<User>> getAllUsers() {\n        return allUsers;\n    }\n    \n    public void insert(User user) {\n        repository.insert(user);\n    }\n}\n\n// 6. Activity (observing LiveData)\npublic class MainActivity extends AppCompatActivity {\n    private UserViewModel userViewModel;\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        // Get ViewModel\n        userViewModel = new ViewModelProvider(this)\n            .get(UserViewModel.class);\n        \n        // Observe LiveData\n        userViewModel.getAllUsers().observe(this, users -> {\n            // Update UI with users\n            updateRecyclerView(users);\n        });\n    }\n}"
    },
    {
      "id": 46,
      "question": "What is Navigation Component in Android Jetpack?",
      "answer": "Navigation Component is a Jetpack library that manages fragment transactions and handles the back stack automatically.\n\nKey Components:\n• Navigation Graph - XML visualization of navigation paths\n• NavHost - Container displaying destinations\n• NavController - Manages navigation within NavHost\n\nBenefits:\n• Visual navigation editor\n• Type-safe argument passing (Safe Args)\n• Automatic back stack management\n• Deep linking support\n• Animation and transition handling\n• Up and Back button handling\n\nNavigation Graph:\n• Defines all destinations\n• Shows navigation paths\n• Defines actions between destinations\n• Supports nested graphs\n\nSafe Args:\n• Gradle plugin for type-safe arguments\n• Generates classes for each destination\n• Compile-time safety\n• No manual bundle handling\n\nDeep Links:\n• Explicit - Launches specific destination\n• Implicit - From web URLs\n• Notification deep links",
      "explanation": "Navigation Component simplifies fragment navigation through visual navigation graphs, type-safe arguments with Safe Args, automatic back stack management, and built-in deep linking support.",
      "difficulty": "Medium",
      "code": "// Add dependencies in build.gradle\nimplementation 'androidx.navigation:navigation-fragment:2.5.3'\nimplementation 'androidx.navigation:navigation-ui:2.5.3'\n\n// Safe Args plugin\nbuildscript {\n    dependencies {\n        classpath 'androidx.navigation:navigation-safe-args-gradle-plugin:2.5.3'\n    }\n}\napply plugin: 'androidx.navigation.safeargs'\n\n// Navigation Graph (res/navigation/nav_graph.xml)\n<navigation xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:id=\"@+id/nav_graph\"\n    app:startDestination=\"@id/homeFragment\">\n    \n    <fragment\n        android:id=\"@+id/homeFragment\"\n        android:name=\"com.example.HomeFragment\"\n        android:label=\"Home\">\n        \n        <action\n            android:id=\"@+id/action_home_to_detail\"\n            app:destination=\"@id/detailFragment\"\n            app:enterAnim=\"@anim/slide_in_right\"\n            app:exitAnim=\"@anim/slide_out_left\"\n            app:popEnterAnim=\"@anim/slide_in_left\"\n            app:popExitAnim=\"@anim/slide_out_right\" />\n    </fragment>\n    \n    <fragment\n        android:id=\"@+id/detailFragment\"\n        android:name=\"com.example.DetailFragment\"\n        android:label=\"Detail\">\n        \n        <argument\n            android:name=\"userId\"\n            app:argType=\"integer\"\n            android:defaultValue=\"0\" />\n        \n        <argument\n            android:name=\"userName\"\n            app:argType=\"string\" />\n        \n        <!-- Deep Link -->\n        <deepLink\n            app:uri=\"myapp://detail/{userId}\"\n            android:autoVerify=\"true\" />\n    </fragment>\n</navigation>\n\n// Activity with NavHost\npublic class MainActivity extends AppCompatActivity {\n    private NavController navController;\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        // Get NavController\n        NavHostFragment navHostFragment = (NavHostFragment) \n            getSupportFragmentManager()\n                .findFragmentById(R.id.nav_host_fragment);\n        navController = navHostFragment.getNavController();\n        \n        // Setup ActionBar with NavController\n        NavigationUI.setupActionBarWithNavController(this, navController);\n        \n        // Setup BottomNavigationView\n        BottomNavigationView bottomNav = findViewById(R.id.bottom_nav);\n        NavigationUI.setupWithNavController(bottomNav, navController);\n    }\n    \n    @Override\n    public boolean onSupportNavigateUp() {\n        return navController.navigateUp() || super.onSupportNavigateUp();\n    }\n}\n\n// Activity Layout with NavHost\n<androidx.constraintlayout.widget.ConstraintLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    \n    <androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/nav_host_fragment\"\n        android:name=\"androidx.navigation.fragment.NavHostFragment\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"0dp\"\n        app:defaultNavHost=\"true\"\n        app:navGraph=\"@navigation/nav_graph\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toTopOf=\"@id/bottom_nav\" />\n    \n    <com.google.android.material.bottomnavigation.BottomNavigationView\n        android:id=\"@+id/bottom_nav\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:menu=\"@menu/bottom_nav_menu\" />\n</androidx.constraintlayout.widget.ConstraintLayout>\n\n// Navigate from Fragment\npublic class HomeFragment extends Fragment {\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                           Bundle savedInstanceState) {\n        View view = inflater.inflate(R.layout.fragment_home, container, false);\n        \n        view.findViewById(R.id.button).setOnClickListener(v -> {\n            // Simple navigation\n            NavController navController = Navigation.findNavController(v);\n            navController.navigate(R.id.action_home_to_detail);\n        });\n        \n        return view;\n    }\n    \n    // Navigate with arguments (Safe Args)\n    private void navigateWithArgs() {\n        HomeFragmentDirections.ActionHomeToDetail action =\n            HomeFragmentDirections.actionHomeToDetail(123, \"John Doe\");\n        \n        Navigation.findNavController(getView()).navigate(action);\n    }\n}\n\n// Receive arguments in destination\npublic class DetailFragment extends Fragment {\n    @Override\n    public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n        \n        // Receive with Safe Args\n        DetailFragmentArgs args = DetailFragmentArgs.fromBundle(getArguments());\n        int userId = args.getUserId();\n        String userName = args.getUserName();\n        \n        TextView textView = view.findViewById(R.id.textView);\n        textView.setText(\"User: \" + userName + \" (ID: \" + userId + \")\");\n    }\n}"
    },
    {
      "id": 47,
      "question": "What is Paging Library in Android?",
      "answer": "Paging Library helps load and display large datasets efficiently by loading data in chunks (pages) as needed.\n\nKey Concepts:\n• PagedList - Immutable list that loads data in chunks\n• DataSource - Source of paged data\n• PagedListAdapter - RecyclerView adapter for paged data\n• Boundary Callback - Load more data when reaching end\n\nPaging 3 Components (Latest):\n• PagingSource - Defines data source\n• PagingData - Container for paged data\n• PagingDataAdapter - Adapter for RecyclerView\n• Pager - Creates PagingData Flow\n\nData Sources:\n• Network only\n• Database only\n• Network + Database (Repository pattern)\n\nBenefits:\n• Memory efficient\n• Smooth scrolling\n• Built-in loading states\n• Error handling support\n• Network and database integration\n\nPaging Strategies:\n• Load initial page\n• Load before (prepend)\n• Load after (append)\n• Refresh entire list",
      "explanation": "Paging Library efficiently loads large datasets by paginating data into chunks, providing smooth scrolling with memory efficiency through PagingSource, PagingData, and PagingDataAdapter components.",
      "difficulty": "Hard",
      "code": "// Add Paging 3 dependency\nimplementation 'androidx.paging:paging-runtime:3.1.1'\n\n// 1. Data Model\npublic class User {\n    private int id;\n    private String name;\n    private String email;\n    \n    // Getters and setters\n}\n\n// 2. PagingSource\npublic class UserPagingSource extends PagingSource<Integer, User> {\n    private ApiService apiService;\n    \n    public UserPagingSource(ApiService apiService) {\n        this.apiService = apiService;\n    }\n    \n    @Nullable\n    @Override\n    public Integer getRefreshKey(@NonNull PagingState<Integer, User> state) {\n        Integer anchorPosition = state.getAnchorPosition();\n        if (anchorPosition == null) {\n            return null;\n        }\n        \n        LoadResult.Page<Integer, User> anchorPage = \n            state.closestPageToPosition(anchorPosition);\n        if (anchorPage == null) {\n            return null;\n        }\n        \n        Integer prevKey = anchorPage.getPrevKey();\n        if (prevKey != null) {\n            return prevKey + 1;\n        }\n        \n        Integer nextKey = anchorPage.getNextKey();\n        if (nextKey != null) {\n            return nextKey - 1;\n        }\n        \n        return null;\n    }\n    \n    @NonNull\n    @Override\n    public Object load(@NonNull LoadParams<Integer> params) {\n        int page = params.getKey() != null ? params.getKey() : 1;\n        int pageSize = params.getLoadSize();\n        \n        try {\n            // Network call\n            Response<List<User>> response = apiService.getUsers(page, pageSize)\n                .execute();\n            \n            if (response.isSuccessful() && response.body() != null) {\n                List<User> users = response.body();\n                \n                Integer prevKey = page > 1 ? page - 1 : null;\n                Integer nextKey = users.size() == pageSize ? page + 1 : null;\n                \n                return new LoadResult.Page<>(\n                    users,\n                    prevKey,\n                    nextKey\n                );\n            } else {\n                return new LoadResult.Error<>(new Exception(\"Error loading data\"));\n            }\n        } catch (IOException e) {\n            return new LoadResult.Error<>(e);\n        }\n    }\n}\n\n// 3. Repository\npublic class UserRepository {\n    private ApiService apiService;\n    \n    public UserRepository(ApiService apiService) {\n        this.apiService = apiService;\n    }\n    \n    public Flow<PagingData<User>> getUserStream() {\n        PagingConfig config = new PagingConfig(\n            /* pageSize */ 20,\n            /* prefetchDistance */ 5,\n            /* enablePlaceholders */ false\n        );\n        \n        return Pager<>(config, () -> new UserPagingSource(apiService))\n            .getFlow();\n    }\n}\n\n// 4. ViewModel\npublic class UserViewModel extends ViewModel {\n    private UserRepository repository;\n    public LiveData<PagingData<User>> usersLiveData;\n    \n    public UserViewModel(UserRepository repository) {\n        this.repository = repository;\n        usersLiveData = PagingLiveData.getLiveData(\n            repository.getUserStream()\n        );\n    }\n}\n\n// 5. PagingDataAdapter\npublic class UserPagingAdapter extends PagingDataAdapter<User, UserPagingAdapter.UserViewHolder> {\n    \n    protected UserPagingAdapter() {\n        super(DIFF_CALLBACK);\n    }\n    \n    private static final DiffUtil.ItemCallback<User> DIFF_CALLBACK = \n        new DiffUtil.ItemCallback<User>() {\n            @Override\n            public boolean areItemsTheSame(@NonNull User oldItem, \n                                         @NonNull User newItem) {\n                return oldItem.getId() == newItem.getId();\n            }\n            \n            @Override\n            public boolean areContentsTheSame(@NonNull User oldItem, \n                                            @NonNull User newItem) {\n                return oldItem.equals(newItem);\n            }\n        };\n    \n    @NonNull\n    @Override\n    public UserViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {\n        View view = LayoutInflater.from(parent.getContext())\n            .inflate(R.layout.item_user, parent, false);\n        return new UserViewHolder(view);\n    }\n    \n    @Override\n    public void onBindViewHolder(@NonNull UserViewHolder holder, int position) {\n        User user = getItem(position);\n        if (user != null) {\n            holder.bind(user);\n        }\n    }\n    \n    static class UserViewHolder extends RecyclerView.ViewHolder {\n        TextView nameText;\n        TextView emailText;\n        \n        UserViewHolder(View itemView) {\n            super(itemView);\n            nameText = itemView.findViewById(R.id.nameText);\n            emailText = itemView.findViewById(R.id.emailText);\n        }\n        \n        void bind(User user) {\n            nameText.setText(user.getName());\n            emailText.setText(user.getEmail());\n        }\n    }\n}\n\n// 6. Activity\npublic class MainActivity extends AppCompatActivity {\n    private UserViewModel viewModel;\n    private UserPagingAdapter adapter;\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        RecyclerView recyclerView = findViewById(R.id.recyclerView);\n        adapter = new UserPagingAdapter();\n        \n        recyclerView.setLayoutManager(new LinearLayoutManager(this));\n        recyclerView.setAdapter(adapter);\n        \n        viewModel = new ViewModelProvider(this).get(UserViewModel.class);\n        \n        viewModel.usersLiveData.observe(this, pagingData -> {\n            adapter.submitData(getLifecycle(), pagingData);\n        });\n    }\n}"
    },
    {
      "id": 48,
      "question": "What is OkHttp and how is it used in Android?",
      "answer": "OkHttp is a modern HTTP client library for Android and Java that efficiently handles network requests.\n\nKey Features:\n• HTTP/2 support\n• Connection pooling\n• Transparent GZIP compression\n• Response caching\n• Request/Response interceptors\n• Automatic retries\n• WebSocket support\n\nCore Components:\n• OkHttpClient - HTTP client instance\n• Request - HTTP request\n• Response - HTTP response\n• Call - Prepared request for execution\n• Interceptors - Request/Response middleware\n• Cache - Response caching\n\nInterceptors:\n• Application Interceptors - High level\n• Network Interceptors - Low level\n• Used for logging, headers, authentication\n\nBenefits:\n• Efficient connection management\n• Reduced latency\n• Bandwidth optimization\n• Built into Retrofit\n• Thread-safe\n\nCommon Use Cases:\n• REST API calls\n• File downloads/uploads\n• Custom authentication\n• Request logging\n• Header manipulation",
      "explanation": "OkHttp is an efficient HTTP client providing connection pooling, caching, interceptors, and HTTP/2 support for optimized network communication in Android applications.",
      "difficulty": "Medium",
      "code": "// Add dependency\nimplementation 'com.squareup.okhttp3:okhttp:4.11.0'\nimplementation 'com.squareup.okhttp3:logging-interceptor:4.11.0'\n\n// 1. Basic GET request\nOkHttpClient client = new OkHttpClient();\n\nRequest request = new Request.Builder()\n    .url(\"https://api.example.com/users\")\n    .build();\n\ntry (Response response = client.newCall(request).execute()) {\n    if (response.isSuccessful()) {\n        String responseBody = response.body().string();\n        // Process response\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}\n\n// 2. Async GET request\nclient.newCall(request).enqueue(new Callback() {\n    @Override\n    public void onFailure(@NonNull Call call, @NonNull IOException e) {\n        // Handle error\n    }\n    \n    @Override\n    public void onResponse(@NonNull Call call, @NonNull Response response) \n            throws IOException {\n        if (response.isSuccessful()) {\n            String responseBody = response.body().string();\n            // Update UI on main thread\n            runOnUiThread(() -> {\n                textView.setText(responseBody);\n            });\n        }\n    }\n});\n\n// 3. POST request with JSON\nMediaType JSON = MediaType.get(\"application/json; charset=utf-8\");\nString json = \"{\\\"name\\\":\\\"John\\\",\\\"email\\\":\\\"john@example.com\\\"}\";\n\nRequestBody body = RequestBody.create(json, JSON);\n\nRequest postRequest = new Request.Builder()\n    .url(\"https://api.example.com/users\")\n    .post(body)\n    .build();\n\nclient.newCall(postRequest).enqueue(callback);\n\n// 4. POST with Form data\nRequestBody formBody = new FormBody.Builder()\n    .add(\"username\", \"john\")\n    .add(\"password\", \"secret\")\n    .build();\n\nRequest formRequest = new Request.Builder()\n    .url(\"https://api.example.com/login\")\n    .post(formBody)\n    .build();\n\n// 5. File Upload (Multipart)\nFile file = new File(\"/path/to/file.jpg\");\nRequestBody fileBody = RequestBody.create(\n    file, \n    MediaType.parse(\"image/jpeg\")\n);\n\nRequestBody multipartBody = new MultipartBody.Builder()\n    .setType(MultipartBody.FORM)\n    .addFormDataPart(\"title\", \"Profile Picture\")\n    .addFormDataPart(\"file\", file.getName(), fileBody)\n    .build();\n\nRequest uploadRequest = new Request.Builder()\n    .url(\"https://api.example.com/upload\")\n    .post(multipartBody)\n    .build();\n\n// 6. Custom Headers\nRequest headerRequest = new Request.Builder()\n    .url(\"https://api.example.com/users\")\n    .addHeader(\"Authorization\", \"Bearer token123\")\n    .addHeader(\"Content-Type\", \"application/json\")\n    .build();\n\n// 7. Logging Interceptor\nHttpLoggingInterceptor loggingInterceptor = new HttpLoggingInterceptor();\nloggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);\n\nOkHttpClient clientWithLogging = new OkHttpClient.Builder()\n    .addInterceptor(loggingInterceptor)\n    .build();\n\n// 8. Custom Interceptor for Authentication\nInterceptor authInterceptor = new Interceptor() {\n    @NonNull\n    @Override\n    public Response intercept(@NonNull Chain chain) throws IOException {\n        Request original = chain.request();\n        \n        Request.Builder requestBuilder = original.newBuilder()\n            .header(\"Authorization\", \"Bearer \" + getToken())\n            .header(\"User-Agent\", \"MyApp/1.0\")\n            .method(original.method(), original.body());\n        \n        Request request = requestBuilder.build();\n        return chain.proceed(request);\n    }\n};\n\n// 9. Complete OkHttpClient Configuration\nOkHttpClient configuredClient = new OkHttpClient.Builder()\n    .connectTimeout(30, TimeUnit.SECONDS)\n    .readTimeout(30, TimeUnit.SECONDS)\n    .writeTimeout(30, TimeUnit.SECONDS)\n    .addInterceptor(authInterceptor)\n    .addInterceptor(loggingInterceptor)\n    .cache(new Cache(getCacheDir(), 10 * 1024 * 1024)) // 10MB cache\n    .build();\n\n// 10. Using with Retrofit\nRetrofit retrofit = new Retrofit.Builder()\n    .baseUrl(\"https://api.example.com/\")\n    .client(configuredClient)\n    .addConverterFactory(GsonConverterFactory.create())\n    .build();"
    },
    {
      "id": 49,
      "question": "What is the difference between Service, IntentService, and JobIntentService?",
      "answer": "These are different types of background service components with varying threading models and lifecycle management.\n\nService:\n• Runs on main thread\n• Must manually create worker threads\n• Runs indefinitely until stopped\n• Multiple requests handled simultaneously\n• Must call stopSelf() or stopService()\n• Suitable for long-running operations\n\nIntentService (Deprecated API 30):\n• Runs on separate worker thread automatically\n• Processes one Intent at a time in queue\n• Stops automatically when queue empty\n• No need to manage threading\n• Simple for sequential tasks\n• onHandleIntent() on worker thread\n\nJobIntentService:\n• Replacement for IntentService\n• Uses JobScheduler on Android 8.0+\n• Uses Service on older versions\n• Respects background execution limits\n• onHandleWork() on worker thread\n• Better battery and resource management\n\nWhen to Use:\n• Service - Custom threading, long operations\n• IntentService - Legacy simple tasks (deprecated)\n• JobIntentService - Simple sequential background work\n• WorkManager - Preferred for deferrable work",
      "explanation": "Service requires manual threading for main thread execution, IntentService automatically handles threading but is deprecated, and JobIntentService is the modern replacement respecting background execution limits.",
      "difficulty": "Hard",
      "code": "// 1. Regular Service (Manual Threading)\npublic class MyService extends Service {\n    private ExecutorService executorService;\n    \n    @Override\n    public void onCreate() {\n        super.onCreate();\n        executorService = Executors.newFixedThreadPool(2);\n    }\n    \n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        final String data = intent.getStringExtra(\"data\");\n        \n        // Must create own thread\n        executorService.execute(() -> {\n            // Background work\n            processData(data);\n            \n            // Stop service when done\n            stopSelf(startId);\n        });\n        \n        return START_STICKY;\n    }\n    \n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        executorService.shutdown();\n    }\n    \n    @Override\n    public IBinder onBind(Intent intent) {\n        return null;\n    }\n    \n    private void processData(String data) {\n        // Long running operation\n    }\n}\n\n// 2. IntentService (Deprecated but shown for reference)\npublic class MyIntentService extends IntentService {\n    public MyIntentService() {\n        super(\"MyIntentService\");\n    }\n    \n    @Override\n    protected void onHandleIntent(@Nullable Intent intent) {\n        // Already on worker thread\n        String data = intent.getStringExtra(\"data\");\n        processData(data);\n        // Service stops automatically\n    }\n    \n    private void processData(String data) {\n        // Long running operation\n        // This is on worker thread, not main thread\n    }\n}\n\n// 3. JobIntentService (Better alternative)\npublic class MyJobIntentService extends JobIntentService {\n    private static final int JOB_ID = 1000;\n    \n    public static void enqueueWork(Context context, Intent work) {\n        enqueueWork(context, MyJobIntentService.class, JOB_ID, work);\n    }\n    \n    @Override\n    protected void onHandleWork(@NonNull Intent intent) {\n        // Already on worker thread\n        String data = intent.getStringExtra(\"data\");\n        processData(data);\n        // Service handles lifecycle automatically\n    }\n    \n    private void processData(String data) {\n        // Long running operation\n    }\n}\n\n// Starting the services\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        // Start regular Service\n        Intent serviceIntent = new Intent(this, MyService.class);\n        serviceIntent.putExtra(\"data\", \"test data\");\n        startService(serviceIntent);\n        \n        // Start IntentService (Deprecated)\n        Intent intentServiceIntent = new Intent(this, MyIntentService.class);\n        intentServiceIntent.putExtra(\"data\", \"test data\");\n        startService(intentServiceIntent);\n        \n        // Start JobIntentService\n        Intent jobIntent = new Intent();\n        jobIntent.putExtra(\"data\", \"test data\");\n        MyJobIntentService.enqueueWork(this, jobIntent);\n    }\n}\n\n// Comparison Table\n/*\n| Feature              | Service        | IntentService  | JobIntentService |\n|---------------------|----------------|----------------|------------------|\n| Thread              | Main           | Worker         | Worker           |\n| Threading Handle    | Manual         | Automatic      | Automatic        |\n| Multiple Requests   | Simultaneous   | Sequential     | Sequential       |\n| Auto Stop           | No             | Yes            | Yes              |\n| Status              | Active         | Deprecated     | Active           |\n| Background Limits   | Not respected  | Not respected  | Respected        |\n| Use Case            | Complex tasks  | Simple tasks   | Simple tasks     |\n*/\n\n// Modern Alternative: WorkManager\npublic class MyWorker extends Worker {\n    public MyWorker(@NonNull Context context, @NonNull WorkerParameters params) {\n        super(context, params);\n    }\n    \n    @NonNull\n    @Override\n    public Result doWork() {\n        String data = getInputData().getString(\"data\");\n        processData(data);\n        return Result.success();\n    }\n}\n\n// Enqueue WorkManager\nData inputData = new Data.Builder()\n    .putString(\"data\", \"test data\")\n    .build();\n\nOneTimeWorkRequest workRequest = new OneTimeWorkRequest.Builder(MyWorker.class)\n    .setInputData(inputData)\n    .build();\n\nWorkManager.getInstance(this).enqueue(workRequest);"
    },
    {
      "id": 50,
      "question": "What is Memory Leak in Android and how do you prevent it?",
      "answer": "Memory leak occurs when objects are no longer needed but cannot be garbage collected because they are still referenced.\n\nCommon Causes:\n• Static references to Activities or Views\n• Non-static inner classes holding implicit references\n• Handlers and Runnables not removed\n• Listeners not unregistered\n• Anonymous classes in long-lived objects\n• Context references in singletons\n• Threads not properly terminated\n\nPrevention Strategies:\n• Use WeakReference for Activity/View references\n• Make inner classes static\n• Remove callbacks in onDestroy()\n• Unregister listeners and receivers\n• Use Application Context for singletons\n• Cancel AsyncTasks properly\n• Use lifecycle-aware components\n\nDetection Tools:\n• Android Profiler\n• LeakCanary library\n• Memory Analyzer (MAT)\n• Android Studio Memory Inspector\n\nBest Practices:\n• Avoid static Activity/View references\n• Clear references in lifecycle methods\n• Use ViewModel for UI data\n• Prefer LiveData for observers\n• Use WeakReferences when necessary",
      "explanation": "Memory leaks occur when objects remain referenced preventing garbage collection; prevent by avoiding static Activity references, removing callbacks, unregistering listeners, and using lifecycle-aware components.",
      "difficulty": "Hard",
      "code": "// BAD: Memory Leak Examples\n\n// 1. Static Activity reference (LEAK)\npublic class MainActivity extends AppCompatActivity {\n    private static MainActivity instance; // LEAK!\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        instance = this; // Activity can't be garbage collected\n    }\n}\n\n// 2. Non-static inner class (LEAK)\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        \n        // Inner class holds implicit reference to Activity\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                // Long running task\n                // Activity can't be GC'd while thread runs\n            }\n        }).start();\n    }\n}\n\n// 3. Handler leak (LEAK)\npublic class MainActivity extends AppCompatActivity {\n    private Handler handler = new Handler(); // LEAK!\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        \n        handler.postDelayed(new Runnable() {\n            @Override\n            public void run() {\n                // Delayed task\n            }\n        }, 60000); // 1 minute delay\n    }\n}\n\n// 4. Listener not unregistered (LEAK)\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        \n        SomeManager.getInstance().addListener(new MyListener() {\n            @Override\n            public void onEvent() {\n                // Handle event\n            }\n        });\n        // Never removed - LEAK!\n    }\n}\n\n// GOOD: Prevention Examples\n\n// 1. Static inner class with WeakReference\npublic class MainActivity extends AppCompatActivity {\n    private MyHandler handler;\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        handler = new MyHandler(this);\n    }\n    \n    // Static inner class\n    private static class MyHandler extends Handler {\n        private WeakReference<MainActivity> activityRef;\n        \n        MyHandler(MainActivity activity) {\n            activityRef = new WeakReference<>(activity);\n        }\n        \n        @Override\n        public void handleMessage(Message msg) {\n            MainActivity activity = activityRef.get();\n            if (activity != null) {\n                // Safe to use activity\n            }\n        }\n    }\n    \n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        handler.removeCallbacksAndMessages(null);\n    }\n}\n\n// 2. Proper listener registration/unregistration\npublic class MainActivity extends AppCompatActivity {\n    private MyListener listener;\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        \n        listener = new MyListener() {\n            @Override\n            public void onEvent() {\n                // Handle event\n            }\n        };\n        \n        SomeManager.getInstance().addListener(listener);\n    }\n    \n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        SomeManager.getInstance().removeListener(listener);\n    }\n}\n\n// 3. Using Application Context in Singleton\npublic class DatabaseManager {\n    private static DatabaseManager instance;\n    private Context context;\n    \n    private DatabaseManager(Context context) {\n        // Use Application Context, not Activity Context\n        this.context = context.getApplicationContext();\n    }\n    \n    public static synchronized DatabaseManager getInstance(Context context) {\n        if (instance == null) {\n            instance = new DatabaseManager(context);\n        }\n        return instance;\n    }\n}\n\n// 4. Proper BroadcastReceiver unregistration\npublic class MainActivity extends AppCompatActivity {\n    private BroadcastReceiver receiver;\n    \n    @Override\n    protected void onResume() {\n        super.onResume();\n        \n        receiver = new MyReceiver();\n        IntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);\n        registerReceiver(receiver, filter);\n    }\n    \n    @Override\n    protected void onPause() {\n        super.onPause();\n        if (receiver != null) {\n            unregisterReceiver(receiver);\n        }\n    }\n}\n\n// 5. Using ViewModel (lifecycle-aware)\npublic class MyViewModel extends ViewModel {\n    private MutableLiveData<String> data = new MutableLiveData<>();\n    \n    public LiveData<String> getData() {\n        return data;\n    }\n    \n    @Override\n    protected void onCleared() {\n        super.onCleared();\n        // Clean up resources\n    }\n}\n\n// 6. LeakCanary for detection (in Application class)\npublic class MyApplication extends Application {\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        \n        if (BuildConfig.DEBUG) {\n            // LeakCanary automatically detects leaks\n            // Just add dependency:\n            // debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.10'\n        }\n    }\n}"
    },
    {
      "id": 51,
      "question": "What is Sensor in Android and how do you use it?",
      "answer": "Android Sensors provide access to device hardware sensors for measuring motion, position, and environmental conditions.\n\nSensor Categories:\n• Motion Sensors - Accelerometer, gyroscope, gravity\n• Position Sensors - Orientation, magnetometer\n• Environmental Sensors - Temperature, pressure, humidity, light\n\nCommon Sensors:\n• TYPE_ACCELEROMETER - Device acceleration\n• TYPE_GYROSCOPE - Device rotation\n• TYPE_MAGNETIC_FIELD - Geomagnetic field\n• TYPE_LIGHT - Ambient light level\n• TYPE_PROXIMITY - Distance to object\n• TYPE_PRESSURE - Air pressure\n\nSensor Framework:\n• SensorManager - Access sensors\n• Sensor - Specific sensor instance\n• SensorEvent - Sensor data\n• SensorEventListener - Receive sensor data\n\nBest Practices:\n• Register in onResume(), unregister in onPause()\n• Choose appropriate sensor delay\n• Check sensor availability\n• Battery efficient sensor usage\n• Handle sensor accuracy changes",
      "explanation": "Android Sensors access device hardware for motion, position, and environmental measurements through SensorManager, providing real-time data via SensorEventListener with various sampling rates.",
      "difficulty": "Medium",
      "code": "public class SensorActivity extends AppCompatActivity implements SensorEventListener {\n    private SensorManager sensorManager;\n    private Sensor accelerometer;\n    private Sensor gyroscope;\n    private Sensor lightSensor;\n    private Sensor proximitySensor;\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_sensor);\n        \n        // Get SensorManager\n        sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);\n        \n        // Get specific sensors\n        accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);\n        gyroscope = sensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE);\n        lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT);\n        proximitySensor = sensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY);\n        \n        // Check sensor availability\n        if (accelerometer == null) {\n            Toast.makeText(this, \"Accelerometer not available\", \n                         Toast.LENGTH_SHORT).show();\n        }\n        \n        // List all available sensors\n        List<Sensor> sensors = sensorManager.getSensorList(Sensor.TYPE_ALL);\n        for (Sensor sensor : sensors) {\n            Log.d(\"Sensors\", \"Name: \" + sensor.getName() + \n                  \", Type: \" + sensor.getType());\n        }\n    }\n    \n    @Override\n    protected void onResume() {\n        super.onResume();\n        \n        // Register listeners\n        if (accelerometer != null) {\n            sensorManager.registerListener(this, accelerometer,\n                SensorManager.SENSOR_DELAY_NORMAL);\n        }\n        \n        if (gyroscope != null) {\n            sensorManager.registerListener(this, gyroscope,\n                SensorManager.SENSOR_DELAY_GAME);\n        }\n        \n        if (lightSensor != null) {\n            sensorManager.registerListener(this, lightSensor,\n                SensorManager.SENSOR_DELAY_UI);\n        }\n        \n        if (proximitySensor != null) {\n            sensorManager.registerListener(this, proximitySensor,\n                SensorManager.SENSOR_DELAY_FASTEST);\n        }\n    }\n    \n    @Override\n    protected void onPause() {\n        super.onPause();\n        // Unregister to save battery\n        sensorManager.unregisterListener(this);\n    }\n    \n    @Override\n    public void onSensorChanged(SensorEvent event) {\n        int sensorType = event.sensor.getType();\n        \n        switch (sensorType) {\n            case Sensor.TYPE_ACCELEROMETER:\n                handleAccelerometer(event);\n                break;\n            case Sensor.TYPE_GYROSCOPE:\n                handleGyroscope(event);\n                break;\n            case Sensor.TYPE_LIGHT:\n                handleLight(event);\n                break;\n            case Sensor.TYPE_PROXIMITY:\n                handleProximity(event);\n                break;\n        }\n    }\n    \n    private void handleAccelerometer(SensorEvent event) {\n        // event.values[0] = x-axis acceleration\n        // event.values[1] = y-axis acceleration\n        // event.values[2] = z-axis acceleration\n        float x = event.values[0];\n        float y = event.values[1];\n        float z = event.values[2];\n        \n        Log.d(\"Accelerometer\", \"X: \" + x + \", Y: \" + y + \", Z: \" + z);\n        \n        // Detect shake\n        float acceleration = (float) Math.sqrt(x * x + y * y + z * z);\n        if (acceleration > 15) {\n            Log.d(\"Accelerometer\", \"Device shaken!\");\n        }\n    }\n    \n    private void handleGyroscope(SensorEvent event) {\n        // Angular velocity around each axis\n        float rotationX = event.values[0];\n        float rotationY = event.values[1];\n        float rotationZ = event.values[2];\n        \n        Log.d(\"Gyroscope\", \"X: \" + rotationX + \n              \", Y: \" + rotationY + \", Z: \" + rotationZ);\n    }\n    \n    private void handleLight(SensorEvent event) {\n        // Light level in lux\n        float lux = event.values[0];\n        Log.d(\"Light\", \"Lux: \" + lux);\n        \n        // Adjust screen brightness based on light\n        if (lux < 100) {\n            // Low light - dim screen\n        } else {\n            // Bright light - increase brightness\n        }\n    }\n    \n    private void handleProximity(SensorEvent event) {\n        // Distance in centimeters\n        float distance = event.values[0];\n        Log.d(\"Proximity\", \"Distance: \" + distance + \" cm\");\n        \n        if (distance < 5) {\n            // Object nearby - turn off screen during call\n        }\n    }\n    \n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy) {\n        switch (accuracy) {\n            case SensorManager.SENSOR_STATUS_ACCURACY_HIGH:\n                Log.d(\"Sensor\", \"High accuracy\");\n                break;\n            case SensorManager.SENSOR_STATUS_ACCURACY_MEDIUM:\n                Log.d(\"Sensor\", \"Medium accuracy\");\n                break;\n            case SensorManager.SENSOR_STATUS_ACCURACY_LOW:\n                Log.d(\"Sensor\", \"Low accuracy\");\n                break;\n            case SensorManager.SENSOR_STATUS_UNRELIABLE:\n                Log.d(\"Sensor\", \"Unreliable\");\n                break;\n        }\n    }\n}\n\n// Sensor Delay Constants\n/*\n - SENSOR_DELAY_NORMAL (200,000 microseconds) - Default\n - SENSOR_DELAY_UI (60,000 microseconds) - UI updates\n - SENSOR_DELAY_GAME (20,000 microseconds) - Games\n - SENSOR_DELAY_FASTEST (0 microseconds) - Maximum rate\n*/"
    },
    {
      "id": 52,
      "question": "What is JobScheduler in Android?",
      "answer": "JobScheduler is an API for scheduling background work that executes under specific conditions while respecting system constraints.\n\nKey Features:\n• Deferred task execution\n• Condition-based scheduling\n• Battery efficient\n• Persistent across reboots\n• Automatic retry on failure\n• Deadline constraints\n\nJob Constraints:\n• Network type required (any, unmetered, not roaming)\n• Device charging state\n• Device idle state\n• Minimum latency\n• Maximum execution delay\n• Periodic execution\n\nComponents:\n• JobInfo - Defines job requirements\n• JobScheduler - Schedules jobs\n• JobService - Executes job work\n• JobParameters - Job execution info\n\nBenefits:\n• System-managed scheduling\n• Battery optimization\n• Respects Doze mode\n• Network aware\n• Flexible scheduling\n\nWhen to Use:\n• Background sync operations\n• Scheduled maintenance tasks\n• Periodic data updates\n• Network-dependent uploads\n• Tasks requiring specific conditions",
      "explanation": "JobScheduler schedules background tasks to run under specific system conditions like network availability or charging state, optimizing battery life while ensuring reliable execution even after reboot.",
      "difficulty": "Hard",
      "code": "// 1. Create JobService\npublic class MyJobService extends JobService {\n    private static final String TAG = \"MyJobService\";\n    \n    @Override\n    public boolean onStartJob(JobParameters params) {\n        Log.d(TAG, \"Job started\");\n        \n        // Perform work on background thread\n        new Thread(() -> {\n            doBackgroundWork(params);\n        }).start();\n        \n        // Return true if work continues on separate thread\n        return true;\n    }\n    \n    private void doBackgroundWork(JobParameters params) {\n        // Simulate long-running task\n        try {\n            Thread.sleep(5000);\n            Log.d(TAG, \"Work completed\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        \n        // Notify system that job is complete\n        jobFinished(params, false); // false = don't reschedule\n    }\n    \n    @Override\n    public boolean onStopJob(JobParameters params) {\n        // Called when job must stop before completion\n        Log.d(TAG, \"Job stopped\");\n        \n        // Return true to reschedule the job\n        return true;\n    }\n}\n\n// 2. Register JobService in AndroidManifest.xml\n// <service\n//     android:name=\".MyJobService\"\n//     android:permission=\"android.permission.BIND_JOB_SERVICE\"\n//     android:exported=\"true\" />\n\n// 3. Schedule Job in Activity\npublic class MainActivity extends AppCompatActivity {\n    private static final int JOB_ID = 1;\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        findViewById(R.id.scheduleButton).setOnClickListener(v -> {\n            scheduleJob();\n        });\n        \n        findViewById(R.id.cancelButton).setOnClickListener(v -> {\n            cancelJob();\n        });\n    }\n    \n    private void scheduleJob() {\n        ComponentName componentName = new ComponentName(this, MyJobService.class);\n        \n        JobInfo jobInfo = new JobInfo.Builder(JOB_ID, componentName)\n            // Network constraint\n            .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED)\n            \n            // Charging constraint\n            .setRequiresCharging(true)\n            \n            // Device idle constraint\n            .setRequiresDeviceIdle(false)\n            \n            // Minimum latency (wait 10 seconds)\n            .setMinimumLatency(10000)\n            \n            // Maximum delay (run within 30 seconds)\n            .setOverrideDeadline(30000)\n            \n            // Persist across reboots\n            .setPersisted(true)\n            \n            // Retry on failure\n            .setBackoffCriteria(5000, JobInfo.BACKOFF_POLICY_LINEAR)\n            \n            .build();\n        \n        JobScheduler jobScheduler = (JobScheduler) \n            getSystemService(Context.JOB_SCHEDULER_SERVICE);\n        \n        int result = jobScheduler.schedule(jobInfo);\n        \n        if (result == JobScheduler.RESULT_SUCCESS) {\n            Toast.makeText(this, \"Job scheduled successfully\", \n                         Toast.LENGTH_SHORT).show();\n        } else {\n            Toast.makeText(this, \"Job scheduling failed\", \n                         Toast.LENGTH_SHORT).show();\n        }\n    }\n    \n    // Periodic Job (minimum 15 minutes)\n    private void schedulePeriodicJob() {\n        ComponentName componentName = new ComponentName(this, MyJobService.class);\n        \n        JobInfo jobInfo = new JobInfo.Builder(JOB_ID, componentName)\n            .setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY)\n            .setPeriodic(15 * 60 * 1000) // 15 minutes\n            .setPersisted(true)\n            .build();\n        \n        JobScheduler jobScheduler = (JobScheduler) \n            getSystemService(Context.JOB_SCHEDULER_SERVICE);\n        jobScheduler.schedule(jobInfo);\n    }\n    \n    // Flexible periodic job\n    private void scheduleFlexiblePeriodicJob() {\n        ComponentName componentName = new ComponentName(this, MyJobService.class);\n        \n        JobInfo jobInfo = new JobInfo.Builder(JOB_ID, componentName)\n            .setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY)\n            // Run every 30 minutes, flexible window of last 10 minutes\n            .setPeriodic(30 * 60 * 1000, 10 * 60 * 1000)\n            .build();\n        \n        JobScheduler jobScheduler = (JobScheduler) \n            getSystemService(Context.JOB_SCHEDULER_SERVICE);\n        jobScheduler.schedule(jobInfo);\n    }\n    \n    private void cancelJob() {\n        JobScheduler jobScheduler = (JobScheduler) \n            getSystemService(Context.JOB_SCHEDULER_SERVICE);\n        jobScheduler.cancel(JOB_ID);\n        \n        Toast.makeText(this, \"Job cancelled\", Toast.LENGTH_SHORT).show();\n    }\n    \n    // Cancel all jobs\n    private void cancelAllJobs() {\n        JobScheduler jobScheduler = (JobScheduler) \n            getSystemService(Context.JOB_SCHEDULER_SERVICE);\n        jobScheduler.cancelAll();\n    }\n    \n    // Check pending jobs\n    private void checkPendingJobs() {\n        JobScheduler jobScheduler = (JobScheduler) \n            getSystemService(Context.JOB_SCHEDULER_SERVICE);\n        \n        List<JobInfo> pendingJobs = jobScheduler.getAllPendingJobs();\n        \n        Log.d(\"JobScheduler\", \"Pending jobs: \" + pendingJobs.size());\n        \n        for (JobInfo job : pendingJobs) {\n            Log.d(\"JobScheduler\", \"Job ID: \" + job.getId());\n        }\n    }\n}\n\n// Network Type Constants\n/*\n - NETWORK_TYPE_NONE - No network required\n - NETWORK_TYPE_ANY - Any network\n - NETWORK_TYPE_UNMETERED - WiFi only\n - NETWORK_TYPE_NOT_ROAMING - Not roaming\n - NETWORK_TYPE_METERED - Mobile data\n*/"
    },
    {
      "id": 53,
      "question": "What is Doze Mode and App Standby in Android?",
      "answer": "Doze Mode and App Standby are battery optimization features that limit app activity when device is idle or apps are unused.\n\nDoze Mode:\n• Activates when device is stationary, screen off, unplugged\n• Defers network access, jobs, syncs, alarms\n• Periodic maintenance windows for pending work\n• Two levels: Light Doze, Deep Doze\n\nLight Doze:\n• Device stationary with screen off\n• Less restrictive\n• Shorter maintenance windows\n\nDeep Doze:\n• Device stationary, screen off, longer period\n• More restrictive\n• Longer maintenance windows\n\nApp Standby:\n• Apps not actively used enter standby\n• Network access restricted\n• Sync and jobs deferred\n• Based on app usage patterns\n\nStandby Buckets:\n• Active - Currently in use\n• Working Set - Used regularly\n• Frequent - Used often\n• Rare - Rarely used\n• Restricted - Minimal background activity\n\nWhitelisting:\n• REQUEST_IGNORE_BATTERY_OPTIMIZATIONS permission\n• High-priority FCM messages\n• Foreground services unaffected",
      "explanation": "Doze Mode restricts background activity when device is idle to save battery, while App Standby limits unused apps based on usage patterns, both requiring apps to handle restrictions appropriately.",
      "difficulty": "Hard",
      "code": "// 1. Check if app is in battery optimization\npublic boolean isIgnoringBatteryOptimizations() {\n    PowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE);\n    String packageName = getPackageName();\n    \n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n        return powerManager.isIgnoringBatteryOptimizations(packageName);\n    }\n    return true;\n}\n\n// 2. Request to ignore battery optimizations\n// Add permission in AndroidManifest.xml:\n// <uses-permission android:name=\"android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS\" />\n\npublic void requestIgnoreBatteryOptimizations() {\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n        Intent intent = new Intent();\n        String packageName = getPackageName();\n        PowerManager pm = (PowerManager) getSystemService(POWER_SERVICE);\n        \n        if (!pm.isIgnoringBatteryOptimizations(packageName)) {\n            intent.setAction(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);\n            intent.setData(Uri.parse(\"package:\" + packageName));\n            startActivity(intent);\n        }\n    }\n}\n\n// 3. Open battery optimization settings\npublic void openBatteryOptimizationSettings() {\n    Intent intent = new Intent();\n    intent.setAction(Settings.ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS);\n    startActivity(intent);\n}\n\n// 4. Schedule work that respects Doze\n// Use WorkManager with constraints\nConstraints constraints = new Constraints.Builder()\n    .setRequiredNetworkType(NetworkType.CONNECTED)\n    .setRequiresBatteryNotLow(true)\n    .build();\n\nOneTimeWorkRequest workRequest = new OneTimeWorkRequest.Builder(MyWorker.class)\n    .setConstraints(constraints)\n    .build();\n\nWorkManager.getInstance(this).enqueue(workRequest);\n\n// 5. Use AlarmManager for critical time-sensitive tasks\nAlarmManager alarmManager = (AlarmManager) getSystemService(ALARM_SERVICE);\nIntent intent = new Intent(this, AlarmReceiver.class);\nPendingIntent pendingIntent = PendingIntent.getBroadcast(\n    this, 0, intent, PendingIntent.FLAG_IMMUTABLE);\n\nlong triggerTime = System.currentTimeMillis() + 60000;\n\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n    // setExactAndAllowWhileIdle works in Doze\n    alarmManager.setExactAndAllowWhileIdle(\n        AlarmManager.RTC_WAKEUP, \n        triggerTime, \n        pendingIntent\n    );\n} else {\n    alarmManager.setExact(\n        AlarmManager.RTC_WAKEUP, \n        triggerTime, \n        pendingIntent\n    );\n}\n\n// 6. High-priority FCM message (works in Doze)\n// In FCM payload:\n/*\n{\n  \"message\": {\n    \"token\": \"device_token\",\n    \"android\": {\n      \"priority\": \"high\"\n    },\n    \"notification\": {\n      \"title\": \"Important\",\n      \"body\": \"This works in Doze\"\n    }\n  }\n}\n*/\n\n// 7. Check current standby bucket\npublic String getStandbyBucket() {\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {\n        UsageStatsManager usageStatsManager = \n            (UsageStatsManager) getSystemService(USAGE_STATS_SERVICE);\n        \n        int bucket = usageStatsManager.getAppStandbyBucket();\n        \n        switch (bucket) {\n            case UsageStatsManager.STANDBY_BUCKET_ACTIVE:\n                return \"Active\";\n            case UsageStatsManager.STANDBY_BUCKET_WORKING_SET:\n                return \"Working Set\";\n            case UsageStatsManager.STANDBY_BUCKET_FREQUENT:\n                return \"Frequent\";\n            case UsageStatsManager.STANDBY_BUCKET_RARE:\n                return \"Rare\";\n            case UsageStatsManager.STANDBY_BUCKET_RESTRICTED:\n                return \"Restricted\";\n            default:\n                return \"Unknown\";\n        }\n    }\n    return \"Not supported\";\n}\n\n// 8. Foreground Service (not affected by Doze)\npublic class MyForegroundService extends Service {\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        // Foreground services continue running in Doze\n        Notification notification = createNotification();\n        startForeground(1, notification);\n        \n        // Do work\n        return START_STICKY;\n    }\n    \n    @Override\n    public IBinder onBind(Intent intent) {\n        return null;\n    }\n}\n\n// 9. Testing Doze Mode with ADB\n/*\nADB Commands:\n\n// Force device into Doze\nadb shell dumpsys battery unplug\nadb shell dumpsys deviceidle step [light|deep]\n\n// Force App Standby\nadb shell dumpsys battery unplug\nadb shell am set-inactive <package_name> true\n\n// Check Doze state\nadb shell dumpsys deviceidle get [light|deep|force|screen|charging|network]\n\n// Exit Doze\nadb shell dumpsys deviceidle unforce\nadb shell dumpsys battery reset\n\n// Check app standby bucket\nadb shell am get-standby-bucket <package_name>\n*/\n\n// Best Practices:\n// 1. Use WorkManager for deferrable tasks\n// 2. Use Foreground Service for important ongoing work\n// 3. Don't request whitelist unless absolutely necessary\n// 4. Test app behavior in Doze and App Standby\n// 5. Use high-priority FCM for critical notifications"
    },
    {
      "id": 54,
      "question": "What is ANR (Application Not Responding) and how do you fix it?",
      "answer": "ANR occurs when Android detects that an app is not responding to user input or has blocked the main thread for too long.\n\nANR Triggers:\n• Activity: 5 seconds without responding to input\n• BroadcastReceiver: 10 seconds to complete onReceive()\n• Service: 20 seconds in foreground, 200 seconds in background\n\nCommon Causes:\n• Network operations on main thread\n• Database queries on main thread\n• Heavy computations blocking UI thread\n• Deadlock situations\n• Infinite loops\n• Synchronous file I/O operations\n\nDetection:\n• ANR dialog shown to user\n• Logs in /data/anr/traces.txt\n• StrictMode warnings\n• Android Profiler\n\nPrevention:\n• Move long operations to background threads\n• Use AsyncTask, Handlers, or Coroutines\n• Keep BroadcastReceiver.onReceive() quick\n• Use WorkManager for background tasks\n• Avoid blocking synchronized methods\n• Use StrictMode during development\n\nDebugging:\n• Enable StrictMode\n• Check ANR traces\n• Use Android Profiler\n• Add performance monitoring",
      "explanation": "ANR occurs when the main thread is blocked beyond timeout limits (5s for activities); prevent by moving long operations to background threads using AsyncTask, WorkManager, or Coroutines.",
      "difficulty": "Medium",
      "code": "// BAD: Operations causing ANR\n\n// 1. Network on main thread - ANR!\npublic void badNetworkCall() {\n    try {\n        URL url = new URL(\"https://api.example.com/data\");\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.connect();\n        // This blocks main thread - ANR!\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n\n// 2. Database query on main thread - ANR!\npublic void badDatabaseQuery() {\n    SQLiteDatabase db = dbHelper.getReadableDatabase();\n    Cursor cursor = db.query(\"large_table\", null, null, null, null, null, null);\n    // Processing large result set on main thread - ANR!\n    while (cursor.moveToNext()) {\n        // Heavy processing\n    }\n}\n\n// 3. Heavy computation on main thread - ANR!\npublic void badComputation() {\n    for (int i = 0; i < 1000000; i++) {\n        // Complex calculation\n        double result = Math.sqrt(i) * Math.pow(i, 2);\n    }\n}\n\n// GOOD: Proper implementations\n\n// 1. Network call on background thread\npublic void goodNetworkCall() {\n    new Thread(() -> {\n        try {\n            URL url = new URL(\"https://api.example.com/data\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.connect();\n            \n            // Read response\n            final String result = readResponse(conn);\n            \n            // Update UI on main thread\n            runOnUiThread(() -> {\n                textView.setText(result);\n            });\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }).start();\n}\n\n// 2. Using ExecutorService\nprivate ExecutorService executorService = Executors.newFixedThreadPool(2);\n\npublic void executeInBackground() {\n    executorService.execute(() -> {\n        // Background work\n        String result = doHeavyWork();\n        \n        // Update UI\n        runOnUiThread(() -> {\n            textView.setText(result);\n        });\n    });\n}\n\n// 3. Using Handler\nprivate Handler handler = new Handler(Looper.getMainLooper());\n\npublic void executeWithHandler() {\n    new Thread(() -> {\n        // Background work\n        String result = doHeavyWork();\n        \n        // Post to main thread\n        handler.post(() -> {\n            textView.setText(result);\n        });\n    }).start();\n}\n\n// 4. Enable StrictMode for development\npublic class MyApplication extends Application {\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        \n        if (BuildConfig.DEBUG) {\n            StrictMode.setThreadPolicy(\n                new StrictMode.ThreadPolicy.Builder()\n                    .detectAll()\n                    .penaltyLog()\n                    .penaltyDialog() // Shows dialog on violation\n                    .build()\n            );\n            \n            StrictMode.setVmPolicy(\n                new StrictMode.VmPolicy.Builder()\n                    .detectAll()\n                    .penaltyLog()\n                    .build()\n            );\n        }\n    }\n}\n\n// 5. Using ViewModel with LiveData\npublic class MyViewModel extends ViewModel {\n    private MutableLiveData<String> dataLiveData = new MutableLiveData<>();\n    private ExecutorService executor = Executors.newSingleThreadExecutor();\n    \n    public LiveData<String> getData() {\n        return dataLiveData;\n    }\n    \n    public void loadData() {\n        executor.execute(() -> {\n            // Background work\n            String result = fetchDataFromNetwork();\n            \n            // Post to LiveData (automatically on main thread)\n            dataLiveData.postValue(result);\n        });\n    }\n    \n    @Override\n    protected void onCleared() {\n        super.onCleared();\n        executor.shutdown();\n    }\n}\n\n// 6. Quick BroadcastReceiver\npublic class MyReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // Must complete within 10 seconds\n        \n        // BAD: Long operation here - ANR!\n        // doHeavyWork();\n        \n        // GOOD: Start Service or WorkManager\n        Intent serviceIntent = new Intent(context, MyIntentService.class);\n        serviceIntent.putExtras(intent);\n        context.startService(serviceIntent);\n    }\n}\n\n// 7. Using WorkManager for background tasks\npublic void scheduleBackgroundWork() {\n    OneTimeWorkRequest workRequest = \n        new OneTimeWorkRequest.Builder(MyWorker.class)\n            .build();\n    \n    WorkManager.getInstance(this).enqueue(workRequest);\n}\n\npublic class MyWorker extends Worker {\n    public MyWorker(@NonNull Context context, \n                   @NonNull WorkerParameters params) {\n        super(context, params);\n    }\n    \n    @NonNull\n    @Override\n    public Result doWork() {\n        // Heavy work here - won't cause ANR\n        performHeavyOperation();\n        return Result.success();\n    }\n}\n\n// 8. Monitoring main thread blocks\npublic void monitorMainThread() {\n    Looper.getMainLooper().setMessageLogging(new Printer() {\n        private static final long THRESHOLD = 100; // ms\n        private long startTime;\n        \n        @Override\n        public void println(String log) {\n            if (log.startsWith(\">>>>>\")) {\n                startTime = System.currentTimeMillis();\n            } else if (log.startsWith(\"<<<<<\")) {\n                long duration = System.currentTimeMillis() - startTime;\n                if (duration > THRESHOLD) {\n                    Log.w(\"ANR\", \"Main thread blocked for \" + duration + \"ms\");\n                }\n            }\n        }\n    });\n}\n\n// 9. Reading ANR traces\n/*\nADB command to pull ANR traces:\nadb pull /data/anr/traces.txt\n\nLook for:\n- Thread state: BLOCKED, WAITING\n- Lock information\n- Stack traces showing where code is stuck\n*/"
    },
    {
      "id": 55,
      "question": "What is Firebase Cloud Messaging (FCM) and how does it work?",
      "answer": "Firebase Cloud Messaging is a cross-platform messaging solution for sending notifications and data messages to client apps.\n\nKey Components:\n• FCM Server - Sends messages\n• FCM SDK - Receives messages\n• App Server - Your backend\n• Device Token - Unique device identifier\n\nMessage Types:\n• Notification Messages - Automatically displayed\n• Data Messages - Handled by app\n• Combined Messages - Both notification and data\n\nNotification Channels:\n• Downstream - Server to device\n• Upstream - Device to server\n• Topic messaging - Broadcast to subscribers\n• Device group messaging - Multiple devices\n\nFeatures:\n• Cross-platform (Android, iOS, Web)\n• High-priority messages\n• Topic subscriptions\n• Message targeting\n• Analytics integration\n• Background and foreground handling\n\nMessage Priority:\n• High - Delivered immediately\n• Normal - Respects battery optimization\n\nUse Cases:\n• Push notifications\n• Real-time messaging\n• Sync triggers\n• Silent data updates",
      "explanation": "FCM delivers push notifications and data messages from server to client apps across platforms, supporting notification display, data payloads, topic subscriptions, and priority-based delivery.",
      "difficulty": "Medium",
      "code": "// 1. Add FCM dependencies in build.gradle\nimplementation 'com.google.firebase:firebase-messaging:23.1.2'\nimplementation 'com.google.firebase:firebase-analytics:21.2.2'\n\n// Apply plugin\napply plugin: 'com.google.gms.google-services'\n\n// 2. Add permissions in AndroidManifest.xml\n<uses-permission android:name=\"android.permission.INTERNET\" />\n<uses-permission android:name=\"android.permission.POST_NOTIFICATIONS\" />\n\n// 3. Register FCM service\n<service\n    android:name=\".MyFirebaseMessagingService\"\n    android:exported=\"false\">\n    <intent-filter>\n        <action android:name=\"com.google.firebase.MESSAGING_EVENT\" />\n    </intent-filter>\n</service>\n\n// 4. FirebaseMessagingService implementation\npublic class MyFirebaseMessagingService extends FirebaseMessagingService {\n    private static final String TAG = \"FCM\";\n    \n    @Override\n    public void onNewToken(@NonNull String token) {\n        super.onNewToken(token);\n        Log.d(TAG, \"New token: \" + token);\n        \n        // Send token to your server\n        sendTokenToServer(token);\n        \n        // Save token locally\n        SharedPreferences prefs = getSharedPreferences(\"fcm\", MODE_PRIVATE);\n        prefs.edit().putString(\"token\", token).apply();\n    }\n    \n    @Override\n    public void onMessageReceived(@NonNull RemoteMessage message) {\n        super.onMessageReceived(message);\n        \n        Log.d(TAG, \"From: \" + message.getFrom());\n        \n        // Check if message contains notification\n        if (message.getNotification() != null) {\n            String title = message.getNotification().getTitle();\n            String body = message.getNotification().getBody();\n            \n            Log.d(TAG, \"Notification: \" + title + \" - \" + body);\n            showNotification(title, body);\n        }\n        \n        // Check if message contains data payload\n        if (message.getData().size() > 0) {\n            Map<String, String> data = message.getData();\n            Log.d(TAG, \"Data: \" + data);\n            \n            handleDataMessage(data);\n        }\n    }\n    \n    private void showNotification(String title, String body) {\n        String channelId = \"default_channel\";\n        \n        NotificationCompat.Builder builder = \n            new NotificationCompat.Builder(this, channelId)\n                .setSmallIcon(R.drawable.ic_notification)\n                .setContentTitle(title)\n                .setContentText(body)\n                .setPriority(NotificationCompat.PRIORITY_HIGH)\n                .setAutoCancel(true);\n        \n        NotificationManager manager = \n            (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n        \n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            NotificationChannel channel = new NotificationChannel(\n                channelId,\n                \"Default Channel\",\n                NotificationManager.IMPORTANCE_HIGH\n            );\n            manager.createNotificationChannel(channel);\n        }\n        \n        manager.notify(1, builder.build());\n    }\n    \n    private void handleDataMessage(Map<String, String> data) {\n        String type = data.get(\"type\");\n        String userId = data.get(\"user_id\");\n        \n        // Handle based on type\n        if (\"chat\".equals(type)) {\n            // Show chat notification\n        } else if (\"update\".equals(type)) {\n            // Trigger data sync\n        }\n    }\n    \n    private void sendTokenToServer(String token) {\n        // Send to your backend\n    }\n}\n\n// 5. Get FCM token in Activity\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        // Get FCM token\n        FirebaseMessaging.getInstance().getToken()\n            .addOnCompleteListener(task -> {\n                if (!task.isSuccessful()) {\n                    Log.w(\"FCM\", \"Token fetch failed\", task.getException());\n                    return;\n                }\n                \n                String token = task.getResult();\n                Log.d(\"FCM\", \"Token: \" + token);\n                \n                // Send to server\n                sendTokenToServer(token);\n            });\n    }\n}\n\n// 6. Subscribe to topic\nFirebaseMessaging.getInstance().subscribeToTopic(\"news\")\n    .addOnCompleteListener(task -> {\n        if (task.isSuccessful()) {\n            Log.d(\"FCM\", \"Subscribed to topic\");\n        }\n    });\n\n// Unsubscribe from topic\nFirebaseMessaging.getInstance().unsubscribeFromTopic(\"news\");\n\n// 7. Send message from server (Node.js example)\n/*\nconst admin = require('firebase-admin');\n\nconst message = {\n  notification: {\n    title: 'Hello',\n    body: 'World'\n  },\n  data: {\n    type: 'chat',\n    user_id: '123'\n  },\n  token: 'device_token_here'\n};\n\nadmin.messaging().send(message)\n  .then(response => {\n    console.log('Message sent:', response);\n  })\n  .catch(error => {\n    console.log('Error:', error);\n  });\n*/\n\n// 8. Send to topic\n/*\nconst message = {\n  notification: {\n    title: 'News Update',\n    body: 'Breaking news!'\n  },\n  topic: 'news'\n};\n*/\n\n// 9. High priority message\n/*\nconst message = {\n  android: {\n    priority: 'high'\n  },\n  notification: {\n    title: 'Urgent',\n    body: 'Important message'\n  },\n  token: 'device_token'\n};\n*/"
    },
    {
      "id": 56,
      "question": "What is the difference between Dialog, AlertDialog, and DialogFragment?",
      "answer": "These are different approaches to displaying modal dialogs in Android with varying lifecycle management.\n\nDialog:\n• Basic window class\n• Not lifecycle-aware\n• Manual lifecycle management\n• Can leak if Activity destroyed\n• Simple but outdated approach\n\nAlertDialog:\n• Builder-pattern for common dialogs\n• Predefined layouts (title, message, buttons)\n• Easy to create\n• Still not lifecycle-aware\n• Suitable for simple dialogs\n\nDialogFragment:\n• Fragment-based dialog\n• Lifecycle-aware\n• Survives configuration changes\n• Proper state management\n• Recommended approach\n• Can be dismissed safely\n\nWhen to Use:\n• DialogFragment - Always preferred\n• AlertDialog - Simple quick dialogs (with proper handling)\n• Dialog - Custom complex dialogs in DialogFragment\n\nBest Practices:\n• Always use DialogFragment\n• Avoid showing dialogs after onPause()\n• Handle configuration changes properly\n• Use dismiss() not cancel()",
      "explanation": "Dialog is a basic window class, AlertDialog provides builder-pattern for common dialogs, while DialogFragment is the lifecycle-aware fragment-based approach that's recommended for proper state management.",
      "difficulty": "Medium",
      "code": "// 1. Basic Dialog (Not recommended)\npublic void showBasicDialog() {\n    Dialog dialog = new Dialog(this);\n    dialog.setContentView(R.layout.custom_dialog);\n    dialog.setTitle(\"My Dialog\");\n    \n    Button button = dialog.findViewById(R.id.button);\n    button.setOnClickListener(v -> dialog.dismiss());\n    \n    dialog.show();\n}\n\n// 2. AlertDialog with Builder\npublic void showAlertDialog() {\n    new AlertDialog.Builder(this)\n        .setTitle(\"Confirm Action\")\n        .setMessage(\"Are you sure you want to continue?\")\n        .setPositiveButton(\"Yes\", (dialog, which) -> {\n            // Handle yes\n        })\n        .setNegativeButton(\"No\", (dialog, which) -> {\n            dialog.dismiss();\n        })\n        .setNeutralButton(\"Cancel\", null)\n        .setIcon(R.drawable.ic_warning)\n        .setCancelable(false)\n        .show();\n}\n\n// 3. AlertDialog with list\npublic void showListDialog() {\n    String[] items = {\"Option 1\", \"Option 2\", \"Option 3\"};\n    \n    new AlertDialog.Builder(this)\n        .setTitle(\"Choose Option\")\n        .setItems(items, (dialog, which) -> {\n            Toast.makeText(this, \"Selected: \" + items[which], \n                         Toast.LENGTH_SHORT).show();\n        })\n        .show();\n}\n\n// 4. AlertDialog with single choice\npublic void showSingleChoiceDialog() {\n    String[] items = {\"Red\", \"Green\", \"Blue\"};\n    int checkedItem = 0;\n    \n    new AlertDialog.Builder(this)\n        .setTitle(\"Choose Color\")\n        .setSingleChoiceItems(items, checkedItem, (dialog, which) -> {\n            // Item selected\n        })\n        .setPositiveButton(\"OK\", (dialog, which) -> {\n            // Handle selection\n        })\n        .show();\n}\n\n// 5. AlertDialog with multiple choice\npublic void showMultiChoiceDialog() {\n    String[] items = {\"Feature 1\", \"Feature 2\", \"Feature 3\"};\n    boolean[] checkedItems = {false, true, false};\n    \n    new AlertDialog.Builder(this)\n        .setTitle(\"Select Features\")\n        .setMultiChoiceItems(items, checkedItems, (dialog, which, isChecked) -> {\n            checkedItems[which] = isChecked;\n        })\n        .setPositiveButton(\"OK\", (dialog, which) -> {\n            // Process selections\n        })\n        .show();\n}\n\n// 6. DialogFragment (Recommended)\npublic class MyDialogFragment extends DialogFragment {\n    \n    public interface DialogListener {\n        void onDialogPositiveClick(String input);\n        void onDialogNegativeClick();\n    }\n    \n    private DialogListener listener;\n    \n    @Override\n    public void onAttach(@NonNull Context context) {\n        super.onAttach(context);\n        try {\n            listener = (DialogListener) context;\n        } catch (ClassCastException e) {\n            throw new ClassCastException(context.toString() + \n                \" must implement DialogListener\");\n        }\n    }\n    \n    @NonNull\n    @Override\n    public Dialog onCreateDialog(@Nullable Bundle savedInstanceState) {\n        AlertDialog.Builder builder = new AlertDialog.Builder(requireActivity());\n        \n        LayoutInflater inflater = requireActivity().getLayoutInflater();\n        View view = inflater.inflate(R.layout.dialog_input, null);\n        \n        EditText editText = view.findViewById(R.id.editText);\n        \n        builder.setView(view)\n            .setTitle(\"Enter Name\")\n            .setPositiveButton(\"OK\", (dialog, which) -> {\n                String input = editText.getText().toString();\n                listener.onDialogPositiveClick(input);\n            })\n            .setNegativeButton(\"Cancel\", (dialog, which) -> {\n                listener.onDialogNegativeClick();\n            });\n        \n        return builder.create();\n    }\n}\n\n// Show DialogFragment\npublic void showDialogFragment() {\n    MyDialogFragment dialog = new MyDialogFragment();\n    dialog.show(getSupportFragmentManager(), \"MyDialog\");\n}\n\n// 7. Full-screen DialogFragment\npublic class FullScreenDialogFragment extends DialogFragment {\n    @Override\n    public void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setStyle(DialogFragment.STYLE_NORMAL, R.style.FullScreenDialogStyle);\n    }\n    \n    @Nullable\n    @Override\n    public View onCreateView(@NonNull LayoutInflater inflater,\n                           @Nullable ViewGroup container,\n                           @Nullable Bundle savedInstanceState) {\n        return inflater.inflate(R.layout.fragment_full_dialog, container, false);\n    }\n    \n    @Override\n    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n        \n        view.findViewById(R.id.closeButton).setOnClickListener(v -> dismiss());\n    }\n}\n\n// styles.xml\n/*\n<style name=\"FullScreenDialogStyle\" parent=\"Theme.AppCompat.Dialog\">\n    <item name=\"android:windowNoTitle\">true</item>\n    <item name=\"android:windowFullscreen\">true</item>\n    <item name=\"android:windowIsFloating\">false</item>\n</style>\n*/\n\n// 8. Bottom Sheet Dialog\npublic class MyBottomSheetDialog extends BottomSheetDialogFragment {\n    @Nullable\n    @Override\n    public View onCreateView(@NonNull LayoutInflater inflater,\n                           @Nullable ViewGroup container,\n                           @Nullable Bundle savedInstanceState) {\n        return inflater.inflate(R.layout.bottom_sheet_layout, container, false);\n    }\n}\n\n// Show Bottom Sheet\nMyBottomSheetDialog bottomSheet = new MyBottomSheetDialog();\nbottomSheet.show(getSupportFragmentManager(), \"BottomSheet\");\n\n// 9. Implement DialogListener in Activity\npublic class MainActivity extends AppCompatActivity \n        implements MyDialogFragment.DialogListener {\n    \n    @Override\n    public void onDialogPositiveClick(String input) {\n        Toast.makeText(this, \"Input: \" + input, Toast.LENGTH_SHORT).show();\n    }\n    \n    @Override\n    public void onDialogNegativeClick() {\n        Toast.makeText(this, \"Cancelled\", Toast.LENGTH_SHORT).show();\n    }\n}"
    },
    {
      "id": 57,
      "question": "What is Gradle and how does it work in Android?",
      "answer": "Gradle is a build automation tool that compiles, packages, and manages dependencies for Android projects.\n\nKey Concepts:\n• Build script - build.gradle files\n• Project-level Gradle - Root configuration\n• Module-level Gradle - App-specific configuration\n• Gradle Wrapper - Ensures consistent builds\n• Build variants - Debug/Release configurations\n\nGradle Files:\n• settings.gradle - Project modules\n• build.gradle (Project) - Repository and plugin versions\n• build.gradle (Module) - Dependencies and configuration\n• gradle.properties - Build properties\n\nBuild Process:\n• Compile source code\n• Process resources\n• Generate R class\n• Compile to DEX\n• Package APK/AAB\n• Sign application\n\nDependencies:\n• implementation - Compile and runtime\n• api - Exposed to consumers\n• compileOnly - Compile-time only\n• runtimeOnly - Runtime only\n• testImplementation - Test dependencies\n• androidTestImplementation - Instrumented tests\n\nBuild Variants:\n• Debug - Development build\n• Release - Production build\n• Custom flavors for different versions",
      "explanation": "Gradle automates Android build processes including compilation, resource processing, dependency management, and APK generation through declarative build scripts with support for build variants and flavors.",
      "difficulty": "Medium",
      "code": "// 1. settings.gradle (Project root)\npluginManagement {\n    repositories {\n        google()\n        mavenCentral()\n        gradlePluginPortal()\n    }\n}\n\ndependencyResolutionManagement {\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories {\n        google()\n        mavenCentral()\n    }\n}\n\nrootProject.name = \"MyApp\"\ninclude ':app'\n\n// 2. build.gradle (Project level)\nbuildscript {\n    ext.kotlin_version = '1.8.0'\n    \n    repositories {\n        google()\n        mavenCentral()\n    }\n    \n    dependencies {\n        classpath 'com.android.tools.build:gradle:8.0.0'\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n        classpath 'com.google.gms:google-services:4.3.15'\n    }\n}\n\nallprojects {\n    repositories {\n        google()\n        mavenCentral()\n    }\n}\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n\n// 3. build.gradle (Module/App level)\nplugins {\n    id 'com.android.application'\n    id 'kotlin-android'\n    id 'kotlin-kapt'\n}\n\nandroid {\n    namespace 'com.example.myapp'\n    compileSdk 33\n    \n    defaultConfig {\n        applicationId \"com.example.myapp\"\n        minSdk 21\n        targetSdk 33\n        versionCode 1\n        versionName \"1.0\"\n        \n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n        \n        // Build config fields\n        buildConfigField \"String\", \"API_KEY\", '\"my_api_key\"'\n        buildConfigField \"boolean\", \"DEBUG_MODE\", \"true\"\n    }\n    \n    signingConfigs {\n        release {\n            storeFile file('keystore.jks')\n            storePassword 'password'\n            keyAlias 'key'\n            keyPassword 'password'\n        }\n    }\n    \n    buildTypes {\n        debug {\n            debuggable true\n            minifyEnabled false\n            applicationIdSuffix \".debug\"\n            versionNameSuffix \"-debug\"\n        }\n        \n        release {\n            minifyEnabled true\n            shrinkResources true\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'),\n                         'proguard-rules.pro'\n            signingConfig signingConfigs.release\n        }\n    }\n    \n    flavorDimensions \"version\"\n    productFlavors {\n        free {\n            dimension \"version\"\n            applicationIdSuffix \".free\"\n            versionNameSuffix \"-free\"\n            buildConfigField \"boolean\", \"IS_PAID\", \"false\"\n        }\n        \n        paid {\n            dimension \"version\"\n            applicationIdSuffix \".paid\"\n            versionNameSuffix \"-paid\"\n            buildConfigField \"boolean\", \"IS_PAID\", \"true\"\n        }\n    }\n    \n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n    \n    kotlinOptions {\n        jvmTarget = '1.8'\n    }\n    \n    buildFeatures {\n        viewBinding true\n        dataBinding true\n    }\n    \n    packagingOptions {\n        resources {\n            excludes += '/META-INF/{AL2.0,LGPL2.1}'\n        }\n    }\n}\n\ndependencies {\n    // AndroidX\n    implementation 'androidx.core:core-ktx:1.9.0'\n    implementation 'androidx.appcompat:appcompat:1.6.1'\n    implementation 'com.google.android.material:material:1.9.0'\n    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'\n    \n    // Lifecycle\n    implementation 'androidx.lifecycle:lifecycle-viewmodel-ktx:2.5.1'\n    implementation 'androidx.lifecycle:lifecycle-livedata-ktx:2.5.1'\n    \n    // Room\n    implementation 'androidx.room:room-runtime:2.5.0'\n    kapt 'androidx.room:room-compiler:2.5.0'\n    implementation 'androidx.room:room-ktx:2.5.0'\n    \n    // Retrofit\n    implementation 'com.squareup.retrofit2:retrofit:2.9.0'\n    implementation 'com.squareup.retrofit2:converter-gson:2.9.0'\n    \n    // OkHttp\n    implementation 'com.squareup.okhttp3:okhttp:4.11.0'\n    implementation 'com.squareup.okhttp3:logging-interceptor:4.11.0'\n    \n    // Glide\n    implementation 'com.github.bumptech.glide:glide:4.15.1'\n    kapt 'com.github.bumptech.glide:compiler:4.15.1'\n    \n    // Firebase\n    implementation platform('com.google.firebase:firebase-bom:31.2.0')\n    implementation 'com.google.firebase:firebase-analytics'\n    implementation 'com.google.firebase:firebase-messaging'\n    \n    // Testing\n    testImplementation 'junit:junit:4.13.2'\n    testImplementation 'org.mockito:mockito-core:5.2.0'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.5'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'\n    \n    // Debug only\n    debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.10'\n}\n\napply plugin: 'com.google.gms.google-services'\n\n// 4. gradle.properties\norg.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8\norg.gradle.parallel=true\norg.gradle.caching=true\nandroid.useAndroidX=true\nandroid.enableJetifier=true\nkotlin.code.style=official\n\n// 5. Custom Gradle tasks\ntask printVersionName {\n    doLast {\n        println \"Version Name: ${android.defaultConfig.versionName}\"\n    }\n}\n\n// 6. Accessing BuildConfig in code\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        \n        String apiKey = BuildConfig.API_KEY;\n        boolean isDebug = BuildConfig.DEBUG;\n        boolean isPaid = BuildConfig.IS_PAID;\n        String versionName = BuildConfig.VERSION_NAME;\n        int versionCode = BuildConfig.VERSION_CODE;\n    }\n}\n\n// 7. Gradle commands (Terminal)\n/*\n./gradlew assembleDebug        - Build debug APK\n./gradlew assembleRelease      - Build release APK\n./gradlew installDebug         - Install debug APK\n./gradlew clean                - Clean build\n./gradlew tasks                - List all tasks\n./gradlew dependencies         - Show dependencies\n./gradlew --refresh-dependencies - Refresh dependencies\n*/"
    },
    {
      "id": 58,
      "question": "What is ADB (Android Debug Bridge) and its common commands?",
      "answer": "ADB is a command-line tool that facilitates communication between development machine and Android device/emulator.\n\nKey Functions:\n• Install and uninstall apps\n• Copy files to/from device\n• Execute shell commands\n• View device logs\n• Debug applications\n• Take screenshots and recordings\n\nADB Components:\n• Client - Runs on development machine\n• Daemon (adbd) - Runs on device\n• Server - Manages communication\n\nConnection Types:\n• USB cable connection\n• Wireless connection (TCP/IP)\n• Emulator connection\n\nCommon Uses:\n• App installation and testing\n• Log monitoring (logcat)\n• Performance profiling\n• Device state manipulation\n• File management\n• Network debugging\n\nSecurity:\n• Requires USB debugging enabled\n• Device authorization required\n• Root access for advanced commands\n\nAlternatives:\n• Scrcpy for screen mirroring\n• Android Studio Device Manager\n• Wireless debugging (Android 11+)",
      "explanation": "ADB is a versatile command-line tool enabling developers to communicate with Android devices for installing apps, debugging, file transfers, log viewing, and executing shell commands.",
      "difficulty": "Easy",
      "code": "// Common ADB Commands\n\n// 1. Device Management\nadb devices                    // List connected devices\nadb devices -l                 // List with details\nadb connect <ip>:5555         // Connect over WiFi\nadb disconnect                 // Disconnect WiFi connection\nadb kill-server               // Kill ADB server\nadb start-server              // Start ADB server\n\n// 2. App Installation\nadb install app.apk           // Install APK\nadb install -r app.apk        // Reinstall (keep data)\nadb install -s app.apk        // Install to SD card\nadb uninstall com.package     // Uninstall app\nadb uninstall -k com.package  // Uninstall but keep data\n\n// 3. File Transfer\nadb push local.txt /sdcard/   // Copy file to device\nadb pull /sdcard/file.txt     // Copy file from device\nadb pull /sdcard/ backup/     // Pull entire directory\n\n// 4. Logcat (Logging)\nadb logcat                     // View all logs\nadb logcat -c                  // Clear logs\nadb logcat *:E                 // Show errors only\nadb logcat | grep \"MyApp\"      // Filter by tag\nadb logcat -v time            // Show with timestamp\nadb logcat -d > logs.txt      // Save logs to file\nadb logcat ActivityManager:I *:S  // Specific component\n\n// 5. Shell Commands\nadb shell                      // Enter device shell\nadb shell ls /sdcard/         // List directory\nadb shell pm list packages    // List all packages\nadb shell pm list packages -3 // List third-party apps\nadb shell pm path com.package // Get app path\nadb shell pm clear com.package // Clear app data\nadb shell pm uninstall com.package // Uninstall\n\n// 6. Activity Management\nadb shell am start -n com.package/.MainActivity  // Start Activity\nadb shell am start -a android.intent.action.VIEW -d \"url\"  // Open URL\nadb shell am force-stop com.package  // Force stop app\nadb shell am kill com.package        // Kill app process\n\n// 7. Screenshots and Recording\nadb shell screencap /sdcard/screen.png  // Take screenshot\nadb pull /sdcard/screen.png             // Pull screenshot\nadb shell screenrecord /sdcard/video.mp4  // Record screen\nadb shell screenrecord --time-limit 30 /sdcard/video.mp4  // 30 sec\n\n// 8. Device Information\nadb shell getprop ro.build.version.release  // Android version\nadb shell getprop ro.product.model          // Device model\nadb shell wm size                           // Screen resolution\nadb shell wm density                        // Screen density\nadb shell dumpsys battery                   // Battery info\nadb shell dumpsys meminfo                   // Memory info\nadb shell dumpsys cpuinfo                   // CPU info\n\n// 9. Input Events\nadb shell input text \"Hello\"        // Type text\nadb shell input keyevent 3          // Press Home button\nadb shell input keyevent 4          // Press Back button\nadb shell input keyevent 82         // Press Menu button\nadb shell input tap 500 1000        // Tap at coordinates\nadb shell input swipe 300 300 500 1000  // Swipe gesture\n\n// 10. Network\nadb shell netstat                   // Network statistics\nadb shell ping google.com           // Ping\nadb shell dumpsys wifi              // WiFi info\n\n// 11. Database Operations\nadb shell run-as com.package        // Access app's private data\nadb shell run-as com.package ls databases/  // List databases\nadb pull /data/data/com.package/databases/app.db  // Pull DB (root)\n\n// 12. Permissions\nadb shell pm grant com.package android.permission.CAMERA  // Grant\nadb shell pm revoke com.package android.permission.CAMERA // Revoke\n\n// 13. Backup and Restore\nadb backup -f backup.ab -apk -all  // Backup all apps\nadb restore backup.ab               // Restore backup\n\n// 14. Multiple Devices\nadb -s device_serial_number devices  // Specific device\nadb -d shell                         // USB device\nadb -e shell                         // Emulator\n\n// 15. Performance\nadb shell dumpsys gfxinfo com.package  // Frame stats\nadb shell am profile start com.package /sdcard/profile.trace\nadb shell am profile stop com.package\n\n// 16. Wireless Debugging Setup\nadb tcpip 5555                     // Enable TCP/IP mode\nadb connect 192.168.1.100:5555     // Connect wirelessly\n// (disconnect USB cable now)\nadb devices                        // Verify connection\nadb usb                           // Switch back to USB\n\n// 17. Root Commands (requires root)\nadb root                          // Restart as root\nadb remount                       // Remount system as r/w\n\n// 18. Misc\nadb reboot                        // Reboot device\nadb reboot bootloader            // Reboot to bootloader\nadb reboot recovery              // Reboot to recovery\nadb wait-for-device              // Wait until device ready\n\n// Java code to execute ADB commands\npublic void executeAdbCommand(String command) {\n    try {\n        Process process = Runtime.getRuntime().exec(\"adb \" + command);\n        BufferedReader reader = new BufferedReader(\n            new InputStreamReader(process.getInputStream()));\n        \n        String line;\n        while ((line = reader.readLine()) != null) {\n            Log.d(\"ADB\", line);\n        }\n        \n        process.waitFor();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
      "id": 59,
      "question": "What is ConstraintLayout and why is it preferred over other layouts?",
      "answer": "ConstraintLayout is a flexible layout that positions views using constraints, creating flat view hierarchies for better performance.\n\nKey Features:\n• Relative positioning between views\n• Flat view hierarchy\n• Responsive design\n• Percentage-based dimensions\n• Chains for grouped views\n• Barriers for dynamic layouts\n• Guidelines for alignment\n• Circular positioning\n\nConstraint Types:\n• Relative to parent\n• Relative to other views\n• Baseline alignment\n• Centered positioning\n• Bias for asymmetric positioning\n\nAdvantages:\n• Better performance (flat hierarchy)\n• Reduces nested layouts\n• Visual layout editor\n• Responsive to different screens\n• Powerful constraint system\n• Less code, more visual\n\nConstraint Attributes:\n• layout_constraintTop_toTopOf\n• layout_constraintStart_toEndOf\n• layout_constraintBottom_toBottomOf\n• layout_constraintDimensionRatio\n• layout_constraintHorizontal_bias\n\nWhen to Use:\n• Complex layouts\n• Responsive designs\n• Performance-critical screens\n• All new development",
      "explanation": "ConstraintLayout creates flat, flexible layouts using constraints between views, offering better performance than nested layouts with powerful positioning options like chains, barriers, and guidelines.",
      "difficulty": "Medium",
      "code": "<!-- Basic ConstraintLayout -->\n<androidx.constraintlayout.widget.ConstraintLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    \n    <!-- Center in parent -->\n    <TextView\n        android:id=\"@+id/title\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Title\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n    \n    <!-- Below another view -->\n    <Button\n        android:id=\"@+id/button\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Click Me\"\n        app:layout_constraintTop_toBottomOf=\"@id/title\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        android:layout_marginTop=\"16dp\" />\n    \n    <!-- Horizontal bias (30% from start) -->\n    <ImageView\n        android:id=\"@+id/icon\"\n        android:layout_width=\"48dp\"\n        android:layout_height=\"48dp\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintHorizontal_bias=\"0.3\"\n        android:layout_marginTop=\"16dp\" />\n    \n    <!-- Match constraint (0dp) -->\n    <EditText\n        android:id=\"@+id/editText\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:hint=\"Enter text\"\n        app:layout_constraintTop_toBottomOf=\"@id/button\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        android:layout_margin=\"16dp\" />\n    \n    <!-- Aspect ratio (16:9) -->\n    <ImageView\n        android:id=\"@+id/banner\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:layout_constraintDimensionRatio=\"16:9\"\n        app:layout_constraintTop_toBottomOf=\"@id/editText\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        android:layout_margin=\"16dp\" />\n</androidx.constraintlayout.widget.ConstraintLayout>\n\n<!-- Chains -->\n<androidx.constraintlayout.widget.ConstraintLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    \n    <!-- Horizontal chain with spread style -->\n    <Button\n        android:id=\"@+id/button1\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Button 1\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toStartOf=\"@id/button2\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintHorizontal_chainStyle=\"spread\" />\n    \n    <Button\n        android:id=\"@+id/button2\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Button 2\"\n        app:layout_constraintStart_toEndOf=\"@id/button1\"\n        app:layout_constraintEnd_toStartOf=\"@id/button3\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n    \n    <Button\n        android:id=\"@+id/button3\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Button 3\"\n        app:layout_constraintStart_toEndOf=\"@id/button2\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n</androidx.constraintlayout.widget.ConstraintLayout>\n\n<!-- Guidelines -->\n<androidx.constraintlayout.widget.ConstraintLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    \n    <!-- Vertical guideline at 50% -->\n    <androidx.constraintlayout.widget.Guideline\n        android:id=\"@+id/guideline_vertical\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"vertical\"\n        app:layout_constraintGuide_percent=\"0.5\" />\n    \n    <!-- Horizontal guideline at 100dp -->\n    <androidx.constraintlayout.widget.Guideline\n        android:id=\"@+id/guideline_horizontal\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"horizontal\"\n        app:layout_constraintGuide_begin=\"100dp\" />\n    \n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Aligned to guidelines\"\n        app:layout_constraintStart_toStartOf=\"@id/guideline_vertical\"\n        app:layout_constraintTop_toTopOf=\"@id/guideline_horizontal\" />\n</androidx.constraintlayout.widget.ConstraintLayout>\n\n<!-- Barrier -->\n<androidx.constraintlayout.widget.ConstraintLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    \n    <TextView\n        android:id=\"@+id/label1\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Short\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\" />\n    \n    <TextView\n        android:id=\"@+id/label2\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Very Long Label\"\n        app:layout_constraintTop_toBottomOf=\"@id/label1\"\n        app:layout_constraintStart_toStartOf=\"parent\" />\n    \n    <!-- Barrier after longest view -->\n    <androidx.constraintlayout.widget.Barrier\n        android:id=\"@+id/barrier\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        app:barrierDirection=\"end\"\n        app:constraint_referenced_ids=\"label1,label2\" />\n    \n    <TextView\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Value\"\n        app:layout_constraintStart_toEndOf=\"@id/barrier\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        android:layout_marginStart=\"8dp\" />\n</androidx.constraintlayout.widget.ConstraintLayout>\n\n// Chain Styles:\n// - spread (default): evenly distributed\n// - spread_inside: first/last attached to parent\n// - packed: views packed together"
    },
    {
      "id": 60,
      "question": "What is MotionLayout and how is it used for animations?",
      "answer": "MotionLayout is a subclass of ConstraintLayout that animates layout changes and handles complex motion and gestures.\n\nKey Features:\n• Declarative animations in XML\n• Complex transition animations\n• Touch-based animations\n• KeyFrames for intermediate states\n• Automatic motion handling\n• Swipe gestures integration\n\nComponents:\n• MotionScene - XML file defining transitions\n• ConstraintSet - Start and end states\n• Transition - Animation between states\n• KeyFrameSet - Intermediate animation points\n• OnSwipe - Touch gesture handling\n• OnClick - Click-triggered animations\n\nAnimation Types:\n• Property animations (position, size, rotation)\n• Path animations\n• Custom attributes\n• Arc motion\n• Easing curves\n\nUse Cases:\n• Collapsing headers\n• Swipe-to-dismiss\n• Reveal animations\n• Carousel effects\n• Complex interactive animations\n\nBenefits:\n• Performant (GPU accelerated)\n• Visual animation editor\n• Reusable animation definitions\n• Touch interaction support\n• Complex animations made easy",
      "explanation": "MotionLayout extends ConstraintLayout to create rich motion and gesture-based animations declaratively in XML, supporting complex transitions, KeyFrames, and interactive touch animations.",
      "difficulty": "Hard",
      "code": "// 1. Add MotionLayout to layout\n<androidx.constraintlayout.motion.widget.MotionLayout\n    android:id=\"@+id/motionLayout\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    app:layoutDescription=\"@xml/scene_animation\">\n    \n    <ImageView\n        android:id=\"@+id/image\"\n        android:layout_width=\"100dp\"\n        android:layout_height=\"100dp\"\n        android:src=\"@drawable/image\" />\n    \n    <TextView\n        android:id=\"@+id/text\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Swipe me\" />\n</androidx.constraintlayout.motion.widget.MotionLayout>\n\n// 2. MotionScene (res/xml/scene_animation.xml)\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<MotionScene xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:motion=\"http://schemas.android.com/apk/res-auto\">\n    \n    <!-- Transition definition -->\n    <Transition\n        motion:constraintSetStart=\"@id/start\"\n        motion:constraintSetEnd=\"@id/end\"\n        motion:duration=\"1000\">\n        \n        <!-- Swipe to trigger animation -->\n        <OnSwipe\n            motion:touchAnchorId=\"@id/image\"\n            motion:touchAnchorSide=\"right\"\n            motion:dragDirection=\"dragRight\" />\n        \n        <!-- KeyFrameSet for intermediate states -->\n        <KeyFrameSet>\n            <KeyPosition\n                motion:keyPositionType=\"pathRelative\"\n                motion:percentY=\"0.25\"\n                motion:framePosition=\"50\"\n                motion:target=\"@id/image\" />\n            \n            <KeyAttribute\n                motion:framePosition=\"50\"\n                android:rotation=\"45\"\n                motion:target=\"@id/image\" />\n            \n            <KeyAttribute\n                motion:framePosition=\"50\"\n                android:alpha=\"0.5\"\n                motion:target=\"@id/text\" />\n        </KeyFrameSet>\n    </Transition>\n    \n    <!-- Start ConstraintSet -->\n    <ConstraintSet android:id=\"@+id/start\">\n        <Constraint\n            android:id=\"@id/image\"\n            android:layout_width=\"100dp\"\n            android:layout_height=\"100dp\"\n            motion:layout_constraintStart_toStartOf=\"parent\"\n            motion:layout_constraintTop_toTopOf=\"parent\"\n            android:layout_marginStart=\"16dp\"\n            android:layout_marginTop=\"16dp\" />\n        \n        <Constraint\n            android:id=\"@id/text\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            motion:layout_constraintStart_toStartOf=\"parent\"\n            motion:layout_constraintBottom_toBottomOf=\"parent\"\n            android:layout_margin=\"16dp\"\n            android:alpha=\"1\" />\n    </ConstraintSet>\n    \n    <!-- End ConstraintSet -->\n    <ConstraintSet android:id=\"@+id/end\">\n        <Constraint\n            android:id=\"@id/image\"\n            android:layout_width=\"150dp\"\n            android:layout_height=\"150dp\"\n            motion:layout_constraintEnd_toEndOf=\"parent\"\n            motion:layout_constraintBottom_toBottomOf=\"parent\"\n            android:layout_marginEnd=\"16dp\"\n            android:layout_marginBottom=\"16dp\"\n            android:rotation=\"360\" />\n        \n        <Constraint\n            android:id=\"@id/text\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            motion:layout_constraintEnd_toEndOf=\"parent\"\n            motion:layout_constraintTop_toTopOf=\"parent\"\n            android:layout_margin=\"16dp\"\n            android:alpha=\"0\" />\n    </ConstraintSet>\n</MotionScene>\n\n// 3. Programmatic control in Activity\npublic class MainActivity extends AppCompatActivity {\n    private MotionLayout motionLayout;\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        motionLayout = findViewById(R.id.motionLayout);\n        \n        // Animate to end state\n        findViewById(R.id.animateButton).setOnClickListener(v -> {\n            motionLayout.transitionToEnd();\n        });\n        \n        // Animate to start state\n        findViewById(R.id.resetButton).setOnClickListener(v -> {\n            motionLayout.transitionToStart();\n        });\n        \n        // Set transition listener\n        motionLayout.setTransitionListener(new MotionLayout.TransitionListener() {\n            @Override\n            public void onTransitionStarted(MotionLayout motionLayout, \n                                          int startId, int endId) {\n                Log.d(\"Motion\", \"Transition started\");\n            }\n            \n            @Override\n            public void onTransitionChange(MotionLayout motionLayout, \n                                         int startId, int endId, float progress) {\n                Log.d(\"Motion\", \"Progress: \" + progress);\n            }\n            \n            @Override\n            public void onTransitionCompleted(MotionLayout motionLayout, int currentId) {\n                Log.d(\"Motion\", \"Transition completed\");\n            }\n            \n            @Override\n            public void onTransitionTrigger(MotionLayout motionLayout, \n                                          int triggerId, boolean positive, \n                                          float progress) {\n            }\n        });\n        \n        // Get current progress\n        float progress = motionLayout.getProgress();\n        \n        // Set specific progress\n        motionLayout.setProgress(0.5f); // 50% of animation\n    }\n}\n\n// 4. Click-triggered transition\n<Transition\n    motion:constraintSetStart=\"@id/start\"\n    motion:constraintSetEnd=\"@id/end\">\n    \n    <OnClick\n        motion:targetId=\"@id/image\"\n        motion:clickAction=\"toggle\" />\n</Transition>\n\n// Click Actions:\n// - toggle: Toggle between start and end\n// - transitionToEnd: Animate to end\n// - transitionToStart: Animate to start\n// - jumpToEnd: Jump to end without animation\n// - jumpToStart: Jump to start without animation"
    },
    {
      "id": 61,
      "question": "What is View Binding vs Data Binding in Android?",
      "answer": "View Binding and Data Binding are both techniques for accessing views, but with different capabilities and use cases.\n\nView Binding:\n• Generates binding class for each XML layout\n• Type-safe view references\n• Null-safe\n• Faster compilation than Data Binding\n• No expression language\n• Lighter weight\n• Simple view access only\n\nData Binding:\n• Superset of View Binding\n• Binds UI to data sources\n• Two-way data binding support\n• Expression language in XML\n• Observable data updates\n• More features, slower compilation\n• Binding adapters\n\nView Binding Features:\n• Replace findViewById()\n• Compile-time safety\n• Null safety for nullable views\n• Auto-generated classes\n\nData Binding Features:\n• All View Binding features\n• XML expressions (@{})\n• Observable data\n• Automatic UI updates\n• Custom binding adapters\n\nWhen to Use:\n• View Binding - Simple view access\n• Data Binding - MVVM, observable data, complex binding",
      "explanation": "View Binding provides type-safe view access replacing findViewById(), while Data Binding extends this with XML expressions, observable data, and automatic UI updates for MVVM architecture.",
      "difficulty": "Medium",
      "code": "// 1. Enable View Binding in build.gradle\nandroid {\n    buildFeatures {\n        viewBinding true\n    }\n}\n\n// 2. View Binding in Activity\npublic class MainActivity extends AppCompatActivity {\n    private ActivityMainBinding binding;\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        \n        // Inflate with View Binding\n        binding = ActivityMainBinding.inflate(getLayoutInflater());\n        setContentView(binding.getRoot());\n        \n        // Access views type-safely\n        binding.textView.setText(\"Hello\");\n        binding.button.setOnClickListener(v -> {\n            String text = binding.editText.getText().toString();\n            binding.textView.setText(text);\n        });\n    }\n    \n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        binding = null; // Avoid memory leak\n    }\n}\n\n// 3. View Binding in Fragment\npublic class MyFragment extends Fragment {\n    private FragmentMyBinding binding;\n    \n    @Override\n    public View onCreateView(@NonNull LayoutInflater inflater,\n                           ViewGroup container,\n                           Bundle savedInstanceState) {\n        binding = FragmentMyBinding.inflate(inflater, container, false);\n        return binding.getRoot();\n    }\n    \n    @Override\n    public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n        \n        binding.textView.setText(\"Fragment\");\n        binding.button.setOnClickListener(v -> {\n            // Handle click\n        });\n    }\n    \n    @Override\n    public void onDestroyView() {\n        super.onDestroyView();\n        binding = null;\n    }\n}\n\n// 4. View Binding in RecyclerView Adapter\npublic class UserAdapter extends RecyclerView.Adapter<UserAdapter.ViewHolder> {\n    private List<User> users;\n    \n    public UserAdapter(List<User> users) {\n        this.users = users;\n    }\n    \n    @NonNull\n    @Override\n    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {\n        ItemUserBinding binding = ItemUserBinding.inflate(\n            LayoutInflater.from(parent.getContext()),\n            parent,\n            false\n        );\n        return new ViewHolder(binding);\n    }\n    \n    @Override\n    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {\n        holder.bind(users.get(position));\n    }\n    \n    @Override\n    public int getItemCount() {\n        return users.size();\n    }\n    \n    static class ViewHolder extends RecyclerView.ViewHolder {\n        private ItemUserBinding binding;\n        \n        ViewHolder(ItemUserBinding binding) {\n            super(binding.getRoot());\n            this.binding = binding;\n        }\n        \n        void bind(User user) {\n            binding.nameText.setText(user.getName());\n            binding.emailText.setText(user.getEmail());\n        }\n    }\n}\n\n// 5. Enable Data Binding in build.gradle\nandroid {\n    buildFeatures {\n        dataBinding true\n    }\n}\n\n// 6. Data Binding in XML\n<!-- activity_main.xml -->\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <data>\n        <variable\n            name=\"user\"\n            type=\"com.example.User\" />\n        \n        <variable\n            name=\"viewModel\"\n            type=\"com.example.UserViewModel\" />\n    </data>\n    \n    <LinearLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n        \n        <!-- One-way binding -->\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@{user.name}\" />\n        \n        <!-- Two-way binding -->\n        <EditText\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@={viewModel.searchQuery}\" />\n        \n        <!-- Expression -->\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@{`Name: ` + user.name}\" />\n        \n        <!-- Click handler -->\n        <Button\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Save\"\n            android:onClick=\"@{() -> viewModel.saveUser()}\" />\n    </LinearLayout>\n</layout>\n\n// 7. Data Binding in Activity\npublic class MainActivity extends AppCompatActivity {\n    private ActivityMainBinding binding;\n    private UserViewModel viewModel;\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        \n        binding = DataBindingUtil.setContentView(this, R.layout.activity_main);\n        viewModel = new ViewModelProvider(this).get(UserViewModel.class);\n        \n        // Set variables\n        User user = new User(\"John\", \"john@example.com\");\n        binding.setUser(user);\n        binding.setViewModel(viewModel);\n        \n        // Set lifecycle owner for LiveData\n        binding.setLifecycleOwner(this);\n        \n        // Observe LiveData\n        viewModel.getUserLiveData().observe(this, updatedUser -> {\n            binding.setUser(updatedUser);\n        });\n    }\n}\n\n// 8. Observable User class for Data Binding\npublic class User extends BaseObservable {\n    private String name;\n    private String email;\n    \n    @Bindable\n    public String getName() {\n        return name;\n    }\n    \n    public void setName(String name) {\n        this.name = name;\n        notifyPropertyChanged(BR.name);\n    }\n    \n    @Bindable\n    public String getEmail() {\n        return email;\n    }\n    \n    public void setEmail(String email) {\n        this.email = email;\n        notifyPropertyChanged(BR.email);\n    }\n}\n\n// 9. Using ObservableField (simpler)\npublic class UserViewModel extends ViewModel {\n    public ObservableField<String> name = new ObservableField<>(\"John\");\n    public ObservableField<String> searchQuery = new ObservableField<>(\"\");\n    \n    public void saveUser() {\n        // Save logic\n    }\n}\n\n// 10. Custom Binding Adapter\n@BindingAdapter(\"imageUrl\")\npublic static void loadImage(ImageView view, String url) {\n    Glide.with(view.getContext())\n        .load(url)\n        .into(view);\n}\n\n// Use in XML\n<!-- <ImageView\n    android:layout_width=\"100dp\"\n    android:layout_height=\"100dp\"\n    app:imageUrl=\"@{user.profileUrl}\" /> -->\n\n// Comparison Summary\n/*\nFeature              | View Binding | Data Binding\n---------------------|--------------|-------------\nType Safety          | Yes          | Yes\nNull Safety          | Yes          | Yes\nCompile Time         | Fast         | Slower\nXML Expressions      | No           | Yes\nObservable Data      | No           | Yes\nTwo-way Binding      | No           | Yes\nBinding Adapters     | No           | Yes\nComplexity           | Simple       | Complex\nUse Case             | View access  | MVVM pattern\n*/"
    },
    {
      "id": 62,
      "question": "What is the Android Testing Framework and types of tests?",
      "answer": "Android Testing Framework provides tools and APIs for testing different layers of Android applications.\n\nTest Types:\n• Unit Tests - Test individual components\n• Integration Tests - Test component interactions\n• UI Tests - Test user interface\n• Instrumented Tests - Run on device/emulator\n\nTesting Frameworks:\n• JUnit - Unit testing framework\n• Espresso - UI testing\n• Robolectric - Android unit tests on JVM\n• Mockito - Mocking framework\n• AndroidJUnitRunner - Instrumented test runner\n\nUnit Tests:\n• Test business logic\n• Run on local JVM\n• Fast execution\n• No Android dependencies\n• Located in test/ directory\n\nInstrumented Tests:\n• Test UI and Android APIs\n• Require device/emulator\n• Slower execution\n• Full Android framework access\n• Located in androidTest/ directory\n\nTest Pyramid:\n• 70% Unit tests\n• 20% Integration tests\n• 10% UI tests\n\nBest Practices:\n• Write testable code\n• Use dependency injection\n• Mock external dependencies\n• Test edge cases\n• Maintain test coverage",
      "explanation": "Android Testing Framework supports unit tests for logic on JVM, instrumented tests for Android components on devices, using JUnit, Espresso, Mockito, and Robolectric frameworks.",
      "difficulty": "Medium",
      "code": "// Add testing dependencies in build.gradle\ndependencies {\n    // JUnit for unit tests\n    testImplementation 'junit:junit:4.13.2'\n    \n    // Mockito for mocking\n    testImplementation 'org.mockito:mockito-core:5.2.0'\n    \n    // Robolectric for Android unit tests on JVM\n    testImplementation 'org.robolectric:robolectric:4.9'\n    \n    // AndroidX Test for instrumented tests\n    androidTestImplementation 'androidx.test.ext:junit:1.1.5'\n    androidTestImplementation 'androidx.test:runner:1.5.2'\n    androidTestImplementation 'androidx.test:rules:1.5.0'\n    \n    // Espresso for UI tests\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-intents:3.5.1'\n    \n    // Truth for assertions\n    testImplementation 'com.google.truth:truth:1.1.3'\n}\n\n// 1. Simple Unit Test (test/)\npublic class CalculatorTest {\n    private Calculator calculator;\n    \n    @Before\n    public void setUp() {\n        calculator = new Calculator();\n    }\n    \n    @Test\n    public void addition_isCorrect() {\n        int result = calculator.add(2, 3);\n        assertEquals(5, result);\n    }\n    \n    @Test\n    public void division_isCorrect() {\n        float result = calculator.divide(10, 2);\n        assertEquals(5.0f, result, 0.001f);\n    }\n    \n    @Test(expected = IllegalArgumentException.class)\n    public void division_byZero_throwsException() {\n        calculator.divide(10, 0);\n    }\n}\n\n// 2. Unit Test with Mockito\npublic class UserRepositoryTest {\n    @Mock\n    private ApiService apiService;\n    \n    @Mock\n    private UserDao userDao;\n    \n    private UserRepository repository;\n    \n    @Before\n    public void setUp() {\n        MockitoAnnotations.openMocks(this);\n        repository = new UserRepository(apiService, userDao);\n    }\n    \n    @Test\n    public void getUser_returnsUser() {\n        // Arrange\n        User mockUser = new User(1, \"John\", \"john@example.com\");\n        when(userDao.getUserById(1)).thenReturn(mockUser);\n        \n        // Act\n        User result = repository.getUser(1);\n        \n        // Assert\n        assertNotNull(result);\n        assertEquals(\"John\", result.getName());\n        verify(userDao).getUserById(1);\n    }\n    \n    @Test\n    public void saveUser_callsDao() {\n        User user = new User(1, \"John\", \"john@example.com\");\n        \n        repository.saveUser(user);\n        \n        verify(userDao).insert(user);\n    }\n}\n\n// 3. ViewModel Test with LiveData\npublic class UserViewModelTest {\n    @Rule\n    public InstantTaskExecutorRule instantTaskExecutorRule = \n        new InstantTaskExecutorRule();\n    \n    @Mock\n    private UserRepository repository;\n    \n    private UserViewModel viewModel;\n    \n    @Before\n    public void setUp() {\n        MockitoAnnotations.openMocks(this);\n        viewModel = new UserViewModel(repository);\n    }\n    \n    @Test\n    public void loadUser_updatesLiveData() {\n        // Arrange\n        User mockUser = new User(1, \"John\", \"john@example.com\");\n        when(repository.getUser(1)).thenReturn(mockUser);\n        \n        // Observe LiveData\n        Observer<User> observer = mock(Observer.class);\n        viewModel.getUserLiveData().observeForever(observer);\n        \n        // Act\n        viewModel.loadUser(1);\n        \n        // Assert\n        verify(observer).onChanged(mockUser);\n    }\n}\n\n// 4. Robolectric Test (test/)\n@RunWith(RobolectricTestRunner.class)\npublic class MainActivityTest {\n    private MainActivity activity;\n    \n    @Before\n    public void setUp() {\n        activity = Robolectric.buildActivity(MainActivity.class)\n            .create()\n            .start()\n            .resume()\n            .get();\n    }\n    \n    @Test\n    public void buttonClick_showsToast() {\n        Button button = activity.findViewById(R.id.button);\n        button.performClick();\n        \n        ShadowToast toast = Shadows.shadowOf(Toast.makeText(\n            activity, \"\", Toast.LENGTH_SHORT));\n        assertNotNull(toast);\n    }\n}\n\n// 5. Espresso UI Test (androidTest/)\n@RunWith(AndroidJUnit4.class)\npublic class MainActivityUITest {\n    @Rule\n    public ActivityScenarioRule<MainActivity> activityRule =\n        new ActivityScenarioRule<>(MainActivity.class);\n    \n    @Test\n    public void textView_displaysText() {\n        onView(withId(R.id.textView))\n            .check(matches(withText(\"Hello World\")));\n    }\n    \n    @Test\n    public void button_click_updatesText() {\n        // Type in EditText\n        onView(withId(R.id.editText))\n            .perform(typeText(\"Test\"), closeSoftKeyboard());\n        \n        // Click button\n        onView(withId(R.id.button))\n            .perform(click());\n        \n        // Verify TextView updated\n        onView(withId(R.id.textView))\n            .check(matches(withText(\"Test\")));\n    }\n    \n    @Test\n    public void recyclerView_scrollAndClick() {\n        // Scroll to position\n        onView(withId(R.id.recyclerView))\n            .perform(RecyclerViewActions.scrollToPosition(10));\n        \n        // Click item\n        onView(withId(R.id.recyclerView))\n            .perform(RecyclerViewActions.actionOnItemAtPosition(5, click()));\n    }\n}\n\n// 6. Test RecyclerView Adapter\n@Test\npublic void adapter_bindsData() {\n    List<User> users = Arrays.asList(\n        new User(1, \"John\", \"john@example.com\"),\n        new User(2, \"Jane\", \"jane@example.com\")\n    );\n    \n    UserAdapter adapter = new UserAdapter(users);\n    \n    assertEquals(2, adapter.getItemCount());\n}\n\n// 7. Test Database (androidTest/)\n@RunWith(AndroidJUnit4.class)\npublic class UserDaoTest {\n    private AppDatabase database;\n    private UserDao userDao;\n    \n    @Before\n    public void createDb() {\n        Context context = ApplicationProvider.getApplicationContext();\n        database = Room.inMemoryDatabaseBuilder(context, AppDatabase.class)\n            .build();\n        userDao = database.userDao();\n    }\n    \n    @After\n    public void closeDb() {\n        database.close();\n    }\n    \n    @Test\n    public void insertAndRetrieveUser() {\n        User user = new User(1, \"John\", \"john@example.com\");\n        userDao.insert(user);\n        \n        User retrieved = userDao.getUserById(1);\n        \n        assertNotNull(retrieved);\n        assertEquals(\"John\", retrieved.getName());\n    }\n}\n\n// 8. Run tests with Gradle\n/*\n// Run all tests\n./gradlew test\n\n// Run unit tests only\n./gradlew testDebugUnitTest\n\n// Run instrumented tests\n./gradlew connectedAndroidTest\n\n// Run specific test class\n./gradlew test --tests UserRepositoryTest\n\n// Run with coverage\n./gradlew testDebugUnitTestCoverage\n*/"
    },
    {
      "id": 63,
      "question": "What is MVVM architecture pattern in Android?",
      "answer": "MVVM (Model-View-ViewModel) is an architectural pattern that separates UI from business logic, promoting testability and maintainability.\n\nComponents:\n• Model - Data layer (repositories, databases, APIs)\n• View - UI layer (Activities, Fragments)\n• ViewModel - Presentation logic, manages UI state\n\nViewModel:\n• Holds UI-related data\n• Survives configuration changes\n• No Android dependencies\n• Exposes data via LiveData/StateFlow\n• Handles business logic\n\nModel:\n• Data sources (Room, Retrofit)\n• Business logic\n• Data transformations\n• Repository pattern\n\nView:\n• Displays data\n• Captures user input\n• Observes ViewModel\n• No business logic\n\nData Flow:\n• View observes ViewModel\n• ViewModel requests data from Model\n• Model fetches/processes data\n• ViewModel exposes data to View\n• View updates UI\n\nBenefits:\n• Separation of concerns\n• Testable components\n• Lifecycle awareness\n• No memory leaks\n• Reusable ViewModels\n• Easier maintenance",
      "explanation": "MVVM separates UI (View) from business logic (ViewModel) and data (Model), with ViewModel surviving configuration changes and exposing observable data through LiveData for automatic UI updates.",
      "difficulty": "Medium",
      "code": "// 1. Model - Data class\npublic class User {\n    private int id;\n    private String name;\n    private String email;\n    \n    // Constructor, getters, setters\n}\n\n// 2. Model - Repository\npublic class UserRepository {\n    private ApiService apiService;\n    private UserDao userDao;\n    \n    public UserRepository(ApiService apiService, UserDao userDao) {\n        this.apiService = apiService;\n        this.userDao = userDao;\n    }\n    \n    public LiveData<List<User>> getUsers() {\n        // Return cached data from database\n        LiveData<List<User>> cachedUsers = userDao.getAllUsers();\n        \n        // Fetch fresh data from API in background\n        fetchUsersFromApi();\n        \n        return cachedUsers;\n    }\n    \n    private void fetchUsersFromApi() {\n        apiService.getUsers().enqueue(new Callback<List<User>>() {\n            @Override\n            public void onResponse(Call<List<User>> call, \n                                 Response<List<User>> response) {\n                if (response.isSuccessful() && response.body() != null) {\n                    // Update database\n                    new Thread(() -> {\n                        userDao.insertAll(response.body());\n                    }).start();\n                }\n            }\n            \n            @Override\n            public void onFailure(Call<List<User>> call, Throwable t) {\n                // Handle error\n            }\n        });\n    }\n    \n    public void saveUser(User user) {\n        new Thread(() -> userDao.insert(user)).start();\n    }\n}\n\n// 3. ViewModel\npublic class UserViewModel extends ViewModel {\n    private UserRepository repository;\n    private LiveData<List<User>> usersLiveData;\n    private MutableLiveData<String> errorLiveData = new MutableLiveData<>();\n    private MutableLiveData<Boolean> loadingLiveData = new MutableLiveData<>();\n    \n    public UserViewModel(UserRepository repository) {\n        this.repository = repository;\n        loadUsers();\n    }\n    \n    public LiveData<List<User>> getUsers() {\n        return usersLiveData;\n    }\n    \n    public LiveData<String> getError() {\n        return errorLiveData;\n    }\n    \n    public LiveData<Boolean> getLoading() {\n        return loadingLiveData;\n    }\n    \n    private void loadUsers() {\n        loadingLiveData.setValue(true);\n        usersLiveData = repository.getUsers();\n        loadingLiveData.setValue(false);\n    }\n    \n    public void addUser(String name, String email) {\n        User user = new User(0, name, email);\n        repository.saveUser(user);\n    }\n    \n    public void refreshUsers() {\n        loadUsers();\n    }\n    \n    @Override\n    protected void onCleared() {\n        super.onCleared();\n        // Clean up resources\n    }\n}\n\n// 4. ViewModelFactory\npublic class UserViewModelFactory implements ViewModelProvider.Factory {\n    private UserRepository repository;\n    \n    public UserViewModelFactory(UserRepository repository) {\n        this.repository = repository;\n    }\n    \n    @NonNull\n    @Override\n    public <T extends ViewModel> T create(@NonNull Class<T> modelClass) {\n        if (modelClass.isAssignableFrom(UserViewModel.class)) {\n            return (T) new UserViewModel(repository);\n        }\n        throw new IllegalArgumentException(\"Unknown ViewModel class\");\n    }\n}\n\n// 5. View - Activity\npublic class MainActivity extends AppCompatActivity {\n    private UserViewModel viewModel;\n    private RecyclerView recyclerView;\n    private UserAdapter adapter;\n    private ProgressBar progressBar;\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        // Initialize views\n        recyclerView = findViewById(R.id.recyclerView);\n        progressBar = findViewById(R.id.progressBar);\n        \n        // Setup RecyclerView\n        adapter = new UserAdapter();\n        recyclerView.setLayoutManager(new LinearLayoutManager(this));\n        recyclerView.setAdapter(adapter);\n        \n        // Initialize ViewModel\n        ApiService apiService = RetrofitClient.getApiService();\n        UserDao userDao = AppDatabase.getInstance(this).userDao();\n        UserRepository repository = new UserRepository(apiService, userDao);\n        \n        UserViewModelFactory factory = new UserViewModelFactory(repository);\n        viewModel = new ViewModelProvider(this, factory)\n            .get(UserViewModel.class);\n        \n        // Observe LiveData\n        observeViewModel();\n        \n        // Setup UI interactions\n        findViewById(R.id.addButton).setOnClickListener(v -> {\n            showAddUserDialog();\n        });\n        \n        findViewById(R.id.refreshButton).setOnClickListener(v -> {\n            viewModel.refreshUsers();\n        });\n    }\n    \n    private void observeViewModel() {\n        // Observe users\n        viewModel.getUsers().observe(this, users -> {\n            if (users != null) {\n                adapter.submitList(users);\n            }\n        });\n        \n        // Observe loading state\n        viewModel.getLoading().observe(this, isLoading -> {\n            progressBar.setVisibility(isLoading ? View.VISIBLE : View.GONE);\n        });\n        \n        // Observe errors\n        viewModel.getError().observe(this, error -> {\n            if (error != null) {\n                Toast.makeText(this, error, Toast.LENGTH_SHORT).show();\n            }\n        });\n    }\n    \n    private void showAddUserDialog() {\n        // Show dialog to add user\n        // On confirm:\n        viewModel.addUser(\"John Doe\", \"john@example.com\");\n    }\n}\n\n// 6. Data Binding with MVVM\n<!-- activity_main.xml -->\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <data>\n        <variable\n            name=\"viewModel\"\n            type=\"com.example.UserViewModel\" />\n    </data>\n    \n    <LinearLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n        \n        <ProgressBar\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:visibility=\"@{viewModel.loading ? View.VISIBLE : View.GONE}\" />\n        \n        <androidx.recyclerview.widget.RecyclerView\n            android:id=\"@+id/recyclerView\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\"\n            app:items=\"@{viewModel.users}\" />\n    </LinearLayout>\n</layout>\n\n// With Data Binding\npublic class MainActivity extends AppCompatActivity {\n    private ActivityMainBinding binding;\n    private UserViewModel viewModel;\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        \n        binding = DataBindingUtil.setContentView(this, R.layout.activity_main);\n        \n        viewModel = new ViewModelProvider(this).get(UserViewModel.class);\n        binding.setViewModel(viewModel);\n        binding.setLifecycleOwner(this);\n    }\n}\n\n// MVVM Architecture Diagram:\n/*\n┌─────────────┐\n│    View     │ (Activity/Fragment)\n│  - Observe  │\n│  - Display  │\n└──────┬──────┘\n       │\n       │ observe()\n       ↓\n┌─────────────┐\n│  ViewModel  │\n│ - LiveData  │\n│ - Business  │\n│   Logic     │\n└──────┬──────┘\n       │\n       │ fetch()\n       ↓\n┌─────────────┐\n│   Model     │\n│ - Repository│\n│ - Data      │\n│   Sources   │\n└─────────────┘\n*/"
    },
    {
      "id": 64,
      "question": "What is Coroutines in Android and how do you use them?",
      "answer": "Coroutines are Kotlin's solution for asynchronous programming, providing sequential code that runs asynchronously without blocking threads.\n\nKey Concepts:\n• Suspend functions - Pauseable functions\n• Coroutine scope - Lifecycle management\n• Dispatchers - Thread pools\n• Structured concurrency - Parent-child relationship\n• Job - Handle to coroutine\n\nDispatchers:\n• Dispatchers.Main - UI thread\n• Dispatchers.IO - I/O operations\n• Dispatchers.Default - CPU-intensive work\n• Dispatchers.Unconfined - No thread restriction\n\nScopes:\n• CoroutineScope - Custom scope\n• ViewModelScope - ViewModel lifecycle\n• LifecycleScope - Activity/Fragment lifecycle\n• GlobalScope - Application lifetime (avoid)\n\nBuilders:\n• launch - Fire and forget\n• async - Returns result\n• withContext - Switch dispatcher\n• runBlocking - Blocks thread (tests only)\n\nBenefits:\n• Sequential async code\n• Automatic cancellation\n• Exception handling\n• Lightweight threads\n• Better than callbacks\n\nUse Cases:\n• Network calls\n• Database operations\n• File I/O\n• Any long-running task",
      "explanation": "Coroutines enable writing sequential asynchronous code in Kotlin using suspend functions and dispatchers, with automatic lifecycle management through scopes like viewModelScope and lifecycleScope.",
      "difficulty": "Hard",
      "code": "// Add Coroutines dependencies\nimplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.4'\nimplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.6.4'\nimplementation 'androidx.lifecycle:lifecycle-runtime-ktx:2.5.1'\nimplementation 'androidx.lifecycle:lifecycle-viewmodel-ktx:2.5.1'\n\n// 1. Basic Coroutine launch\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState);\n        \n        // Launch coroutine in lifecycle scope\n        lifecycleScope.launch {\n            // Sequential code\n            val result = fetchDataFromNetwork()\n            updateUI(result)\n        }\n    }\n    \n    private suspend fun fetchDataFromNetwork(): String {\n        return withContext(Dispatchers.IO) {\n            // Network operation on IO dispatcher\n            delay(2000) // Simulates network delay\n            \"Data from network\"\n        }\n    }\n    \n    private fun updateUI(data: String) {\n        // Automatically on Main thread\n        textView.text = data\n    }\n}\n\n// 2. ViewModel with Coroutines\nclass UserViewModel(private val repository: UserRepository) : ViewModel() {\n    private val _users = MutableLiveData<List<User>>()\n    val users: LiveData<List<User>> = _users\n    \n    private val _loading = MutableLiveData<Boolean>()\n    val loading: LiveData<Boolean> = _loading\n    \n    fun loadUsers() {\n        // Launch in viewModelScope\n        viewModelScope.launch {\n            _loading.value = true\n            \n            try {\n                // Suspend function call\n                val result = repository.getUsers()\n                _users.value = result\n            } catch (e: Exception) {\n                // Handle error\n            } finally {\n                _loading.value = false\n            }\n        }\n    }\n}\n\n// 3. Repository with suspend functions\nclass UserRepository(private val apiService: ApiService) {\n    suspend fun getUsers(): List<User> = withContext(Dispatchers.IO) {\n        val response = apiService.getUsers()\n        if (response.isSuccessful) {\n            response.body() ?: emptyList()\n        } else {\n            throw Exception(\"Failed to fetch users\")\n        }\n    }\n    \n    suspend fun saveUser(user: User) = withContext(Dispatchers.IO) {\n        apiService.saveUser(user)\n    }\n}\n\n// 4. Retrofit with Coroutines\ninterface ApiService {\n    @GET(\"users\")\n    suspend fun getUsers(): Response<List<User>>\n    \n    @POST(\"users\")\n    suspend fun saveUser(@Body user: User): Response<User>\n}\n\n// 5. Room with Coroutines\n@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM users\")\n    suspend fun getAllUsers(): List<User>\n    \n    @Insert\n    suspend fun insertUser(user: User)\n    \n    @Query(\"SELECT * FROM users WHERE id = :userId\")\n    fun getUserById(userId: Int): Flow<User>\n}\n\n// 6. Multiple parallel operations with async\nviewModelScope.launch {\n    _loading.value = true\n    \n    try {\n        // Run in parallel\n        val user1 = async { repository.getUser(1) }\n        val user2 = async { repository.getUser(2) }\n        val user3 = async { repository.getUser(3) }\n        \n        // Wait for all results\n        val users = listOf(user1.await(), user2.await(), user3.await())\n        _users.value = users\n    } catch (e: Exception) {\n        // Handle error\n    } finally {\n        _loading.value = false\n    }\n}\n\n// 7. Exception handling\nviewModelScope.launch {\n    try {\n        val data = repository.fetchData()\n        updateUI(data)\n    } catch (e: IOException) {\n        // Network error\n        showError(\"Network error: ${e.message}\")\n    } catch (e: HttpException) {\n        // HTTP error\n        showError(\"HTTP error: ${e.code()}\")\n    } catch (e: Exception) {\n        // Other errors\n        showError(\"Error: ${e.message}\")\n    }\n}\n\n// 8. Cancellation\nclass MainActivity : AppCompatActivity() {\n    private var job: Job? = null\n    \n    fun startLongRunningTask() {\n        job = lifecycleScope.launch {\n            try {\n                repeat(100) { i ->\n                    if (!isActive) return@launch // Check cancellation\n                    \n                    delay(1000)\n                    updateProgress(i)\n                }\n            } catch (e: CancellationException) {\n                // Coroutine was cancelled\n            }\n        }\n    }\n    \n    fun cancelTask() {\n        job?.cancel()\n    }\n}\n\n// 9. Flow for reactive streams\nclass UserRepository {\n    fun getUsersFlow(): Flow<List<User>> = flow {\n        while (true) {\n            val users = fetchUsers()\n            emit(users)\n            delay(5000) // Refresh every 5 seconds\n        }\n    }.flowOn(Dispatchers.IO)\n}\n\nclass UserViewModel(repository: UserRepository) : ViewModel() {\n    val users: LiveData<List<User>> = repository.getUsersFlow()\n        .asLiveData()\n}\n\n// 10. Testing Coroutines\nclass UserViewModelTest {\n    @get:Rule\n    val mainDispatcherRule = MainDispatcherRule()\n    \n    @Test\n    fun loadUsers_success() = runTest {\n        // Arrange\n        val mockRepo = mock<UserRepository>()\n        val mockUsers = listOf(User(1, \"John\"))\n        `when`(mockRepo.getUsers()).thenReturn(mockUsers)\n        \n        val viewModel = UserViewModel(mockRepo)\n        \n        // Act\n        viewModel.loadUsers()\n        advanceUntilIdle() // Wait for coroutines\n        \n        // Assert\n        assertEquals(mockUsers, viewModel.users.value)\n    }\n}\n\n// 11. SupervisorScope for independent children\nviewModelScope.launch {\n    supervisorScope {\n        // If one fails, others continue\n        launch { task1() }\n        launch { task2() }\n        launch { task3() }\n    }\n}\n\n// 12. withTimeout\nviewModelScope.launch {\n    try {\n        withTimeout(5000) { // 5 seconds\n            val data = fetchData()\n            updateUI(data)\n        }\n    } catch (e: TimeoutCancellationException) {\n        showError(\"Operation timed out\")\n    }\n}"
    },
    {
      "id": 65,
      "question": "What is Hilt for Dependency Injection in Android?",
      "answer": "Hilt is a dependency injection library built on top of Dagger, specifically designed for Android to simplify DI setup.\n\nKey Features:\n• Compile-time dependency injection\n• Reduced boilerplate\n• Standard Android components support\n• Predefined components and scopes\n• Testing support\n• Built on Dagger 2\n\nCore Annotations:\n• @HiltAndroidApp - Application class\n• @AndroidEntryPoint - Inject into Android classes\n• @Inject - Constructor injection\n• @Module - Provides dependencies\n• @InstallIn - Module scope\n• @Provides - Factory method\n• @Binds - Interface binding\n\nPredefined Components:\n• SingletonComponent - Application lifetime\n• ActivityComponent - Activity lifetime\n• FragmentComponent - Fragment lifetime\n• ViewModelComponent - ViewModel lifetime\n• ServiceComponent - Service lifetime\n\nBenefits:\n• Less boilerplate than Dagger\n• Standard component hierarchy\n• ViewModel integration\n• Testing utilities\n• Compile-time safety\n\nUse Cases:\n• Repository injection\n• ViewModel dependencies\n• Network clients\n• Database instances\n• Any reusable components",
      "explanation": "Hilt simplifies Dagger dependency injection for Android with predefined components, scopes, and annotations, providing compile-time DI with minimal boilerplate for Activities, Fragments, ViewModels, and Services.",
      "difficulty": "Hard",
      "code": "// Add Hilt dependencies in build.gradle\nplugins {\n    id 'kotlin-kapt'\n    id 'dagger.hilt.android.plugin'\n}\n\ndependencies {\n    implementation 'com.google.dagger:hilt-android:2.45'\n    kapt 'com.google.dagger:hilt-compiler:2.45'\n    \n    // For ViewModel\n    implementation 'androidx.hilt:hilt-lifecycle-viewmodel:1.0.0-alpha03'\n    kapt 'androidx.hilt:hilt-compiler:1.0.0'\n    \n    // For testing\n    androidTestImplementation 'com.google.dagger:hilt-android-testing:2.45'\n    kaptAndroidTest 'com.google.dagger:hilt-compiler:2.45'\n}\n\n// Project-level build.gradle\nbuildscript {\n    dependencies {\n        classpath 'com.google.dagger:hilt-android-gradle-plugin:2.45'\n    }\n}\n\n// 1. Application class\n@HiltAndroidApp\nclass MyApplication : Application()\n\n// 2. Inject into Activity\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    @Inject\n    lateinit var userRepository: UserRepository\n    \n    @Inject\n    lateinit var analytics: Analytics\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        // Dependencies automatically injected\n        userRepository.getUsers()\n    }\n}\n\n// 3. Constructor injection\nclass UserRepository @Inject constructor(\n    private val apiService: ApiService,\n    private val userDao: UserDao\n) {\n    suspend fun getUsers(): List<User> {\n        // Use injected dependencies\n        return apiService.getUsers()\n    }\n}\n\n// 4. Module for providing dependencies\n@Module\n@InstallIn(SingletonComponent::class)\nobject NetworkModule {\n    @Provides\n    @Singleton\n    fun provideOkHttpClient(): OkHttpClient {\n        return OkHttpClient.Builder()\n            .connectTimeout(30, TimeUnit.SECONDS)\n            .build()\n    }\n    \n    @Provides\n    @Singleton\n    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {\n        return Retrofit.Builder()\n            .baseUrl(\"https://api.example.com/\")\n            .client(okHttpClient)\n            .addConverterFactory(GsonConverterFactory.create())\n            .build()\n    }\n    \n    @Provides\n    @Singleton\n    fun provideApiService(retrofit: Retrofit): ApiService {\n        return retrofit.create(ApiService::class.java)\n    }\n}\n\n// 5. Database Module\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n    \n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}\n\n// 6. Binding interfaces\n@Module\n@InstallIn(SingletonComponent::class)\nabstract class RepositoryModule {\n    @Binds\n    @Singleton\n    abstract fun bindUserRepository(\n        userRepositoryImpl: UserRepositoryImpl\n    ): UserRepository\n}\n\ninterface UserRepository {\n    suspend fun getUsers(): List<User>\n}\n\nclass UserRepositoryImpl @Inject constructor(\n    private val apiService: ApiService\n) : UserRepository {\n    override suspend fun getUsers(): List<User> {\n        return apiService.getUsers()\n    }\n}\n\n// 7. ViewModel injection\n@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val repository: UserRepository\n) : ViewModel() {\n    private val _users = MutableLiveData<List<User>>()\n    val users: LiveData<List<User>> = _users\n    \n    fun loadUsers() {\n        viewModelScope.launch {\n            _users.value = repository.getUsers()\n        }\n    }\n}\n\n// In Activity\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    private val viewModel: UserViewModel by viewModels()\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        \n        viewModel.users.observe(this) { users ->\n            // Update UI\n        }\n    }\n}\n\n// 8. Fragment injection\n@AndroidEntryPoint\nclass UserFragment : Fragment() {\n    @Inject\n    lateinit var repository: UserRepository\n    \n    private val viewModel: UserViewModel by viewModels()\n}\n\n// 9. Qualifiers for multiple instances\n@Qualifier\n@Retention(AnnotationRetention.BINARY)\nannotation class AuthInterceptorOkHttpClient\n\n@Qualifier\n@Retention(AnnotationRetention.BINARY)\nannotation class RegularOkHttpClient\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject NetworkModule {\n    @Provides\n    @Singleton\n    @AuthInterceptorOkHttpClient\n    fun provideAuthOkHttpClient(): OkHttpClient {\n        return OkHttpClient.Builder()\n            .addInterceptor(AuthInterceptor())\n            .build()\n    }\n    \n    @Provides\n    @Singleton\n    @RegularOkHttpClient\n    fun provideRegularOkHttpClient(): OkHttpClient {\n        return OkHttpClient.Builder()\n            .build()\n    }\n}\n\n// Use with qualifier\nclass ApiClient @Inject constructor(\n    @AuthInterceptorOkHttpClient private val authClient: OkHttpClient,\n    @RegularOkHttpClient private val regularClient: OkHttpClient\n)\n\n// 10. Testing with Hilt\n@HiltAndroidTest\nclass UserRepositoryTest {\n    @get:Rule\n    var hiltRule = HiltAndroidRule(this)\n    \n    @Inject\n    lateinit var repository: UserRepository\n    \n    @Before\n    fun init() {\n        hiltRule.inject()\n    }\n    \n    @Test\n    fun testGetUsers() = runTest {\n        val users = repository.getUsers()\n        assertNotNull(users)\n    }\n}\n\n// 11. EntryPoint for non-Android classes\n@EntryPoint\n@InstallIn(SingletonComponent::class)\ninterface RepositoryEntryPoint {\n    fun userRepository(): UserRepository\n}\n\n// Access in non-Android class\nclass Worker(context: Context) {\n    private val repository: UserRepository\n    \n    init {\n        val entryPoint = EntryPointAccessors.fromApplication(\n            context,\n            RepositoryEntryPoint::class.java\n        )\n        repository = entryPoint.userRepository()\n    }\n}"
    },
    {
      "id": 66,
      "question": "What is the Android App Bundle (AAB) and how does it differ from APK?",
      "answer": "Android App Bundle (AAB) is Android's modern app publishing format that generates optimized APKs for each device configuration.\n\nAAB Features:\n• Device-specific APKs\n• Smaller download sizes\n• Dynamic feature modules\n• Asset pack delivery\n• Play Feature Delivery\n• Required for Play Store (2021+)\n\nAPK (Android Package):\n• Single universal file\n• Contains all resources\n• Larger file size\n• Manual variants\n• Direct installation\n• Legacy format\n\nAAB Benefits:\n• 15% smaller average download\n• Google Play generates APKs\n• Split APKs by density, ABI, language\n• On-demand features\n• Conditional delivery\n• Better user experience\n\nGenerated Split APKs:\n• Base APK - Core functionality\n• Configuration APKs - Density, language, ABI\n• Dynamic feature APKs - Optional features\n\nPlayFeature Delivery:\n• Install-time delivery\n• On-demand delivery\n• Conditional delivery\n\nLimitations:\n• Requires Google Play\n• Cannot install directly\n• Needs bundletool for testing",
      "explanation": "AAB is Google's publishing format that generates optimized device-specific APKs reducing download size by 15%, supporting dynamic features and conditional delivery, now required for Play Store submissions.",
      "difficulty": "Medium",
      "code": "// 1. Build AAB using Gradle\n// ./gradlew bundleRelease\n\n// Output: app/build/outputs/bundle/release/app-release.aab\n\n// 2. Enable App Bundle in build.gradle\nandroid {\n    bundle {\n        language {\n            // Enable split by language\n            enableSplit = true\n        }\n        density {\n            // Enable split by density\n            enableSplit = true\n        }\n        abi {\n            // Enable split by ABI\n            enableSplit = true\n        }\n    }\n}\n\n// 3. Create Dynamic Feature Module\n// File -> New -> New Module -> Dynamic Feature Module\n\n// Dynamic feature build.gradle\nplugins {\n    id 'com.android.dynamic-feature'\n}\n\nandroid {\n    compileSdk 33\n    \n    defaultConfig {\n        minSdk 21\n    }\n}\n\ndependencies {\n    implementation project(':app')\n}\n\n// 4. App build.gradle with dynamic features\nandroid {\n    dynamicFeatures = [':dynamic_feature']\n}\n\n// 5. Dynamic Feature Manifest\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:dist=\"http://schemas.android.com/apk/distribution\">\n    \n    <dist:module\n        dist:instant=\"false\"\n        dist:title=\"@string/feature_title\">\n        \n        <dist:delivery>\n            <!-- Install-time delivery -->\n            <dist:install-time />\n            \n            <!-- Or on-demand delivery -->\n            <!-- <dist:on-demand /> -->\n            \n            <!-- Or conditional delivery -->\n            <!--\n            <dist:on-demand />\n            <dist:conditions>\n                <dist:min-sdk-version dist:value=\"21\" />\n                <dist:user-countries dist:include=\"false\">\n                    <dist:country dist:code=\"CN\" />\n                </dist:user-countries>\n            </dist:conditions>\n            -->\n        </dist:delivery>\n        \n        <dist:fusing dist:include=\"true\" />\n    </dist:module>\n    \n    <application />\n</manifest>\n\n// 6. Install Dynamic Feature on-demand\nimport com.google.android.play.core.splitinstall.SplitInstallManager\nimport com.google.android.play.core.splitinstall.SplitInstallManagerFactory\nimport com.google.android.play.core.splitinstall.SplitInstallRequest\n\nclass MainActivity : AppCompatActivity() {\n    private lateinit var manager: SplitInstallManager\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        \n        manager = SplitInstallManagerFactory.create(this)\n        \n        // Check if module already installed\n        if (manager.installedModules.contains(\"dynamic_feature\")) {\n            launchFeature()\n        } else {\n            installFeature()\n        }\n    }\n    \n    private fun installFeature() {\n        val request = SplitInstallRequest.newBuilder()\n            .addModule(\"dynamic_feature\")\n            .build()\n        \n        manager.startInstall(request)\n            .addOnSuccessListener { sessionId ->\n                // Installation started\n            }\n            .addOnFailureListener { exception ->\n                // Handle error\n            }\n    }\n    \n    private fun launchFeature() {\n        val intent = Intent()\n        intent.setClassName(\n            packageName,\n            \"com.example.dynamicfeature.FeatureActivity\"\n        )\n        startActivity(intent)\n    }\n}\n\n// 7. Monitor installation progress\nmanager.registerListener { state ->\n    when (state.status()) {\n        SplitInstallSessionStatus.PENDING -> {\n            // Download pending\n        }\n        SplitInstallSessionStatus.DOWNLOADING -> {\n            val progress = (state.bytesDownloaded() * 100 / \n                          state.totalBytesToDownload()).toInt()\n            updateProgressBar(progress)\n        }\n        SplitInstallSessionStatus.INSTALLING -> {\n            // Installing module\n        }\n        SplitInstallSessionStatus.INSTALLED -> {\n            // Module installed successfully\n            launchFeature()\n        }\n        SplitInstallSessionStatus.FAILED -> {\n            // Installation failed\n        }\n        SplitInstallSessionStatus.CANCELED -> {\n            // Installation cancelled\n        }\n    }\n}\n\n// 8. Testing AAB locally with bundletool\n/*\n// Download bundletool from:\n// https://github.com/google/bundletool/releases\n\n// Generate APKs from AAB\njava -jar bundletool.jar build-apks \\\n  --bundle=app-release.aab \\\n  --output=app.apks \\\n  --mode=universal\n\n// Install APKs on connected device\njava -jar bundletool.jar install-apks --apks=app.apks\n\n// Extract universal APK\njava -jar bundletool.jar extract-apks \\\n  --apks=app.apks \\\n  --output-dir=output/ \\\n  --device-spec=device-spec.json\n\n// Get device spec\njava -jar bundletool.jar get-device-spec --output=device-spec.json\n*/\n\n// 9. Asset Packs for large assets\n// In app build.gradle\nassetPack \":my_asset_pack\"\n\n// Asset pack configuration\n// my_asset_pack/build.gradle\nassetPack {\n    packName = \"my_asset_pack\"\n    dynamicDelivery {\n        deliveryType = \"install-time\"\n        // or \"fast-follow\"\n        // or \"on-demand\"\n    }\n}\n\n// 10. AAB Size Comparison\n/*\nExample app comparison:\n\nAPK (Universal):\n- Total size: 50 MB\n- All densities: hdpi, xhdpi, xxhdpi, xxxhdpi\n- All ABIs: armeabi-v7a, arm64-v8a, x86, x86_64\n- All languages: en, es, fr, de, ja, etc.\n\nAAB (Device-specific):\n- Download size: 35 MB (30% smaller)\n- Only xxhdpi (device screen)\n- Only arm64-v8a (device architecture)\n- Only en (device language)\n\nBenefit: User downloads 15 MB less!\n*/"
    },
    {
      "id": 67,
      "question": "What is Sealed Class in Kotlin and its use in Android?",
      "answer": "Sealed classes represent restricted class hierarchies where all subclasses are known at compile time, commonly used for state management.\n\nKey Features:\n• Restricted hierarchy\n• All subclasses known at compile-time\n• Exhaustive when expressions\n• Better than enums for complex states\n• Can have different properties\n• Abstract by default\n\nBenefits:\n• Type-safe state handling\n• Exhaustive when checking\n• No need for else branch\n• Clear state representation\n• Compile-time safety\n\nCommon Uses in Android:\n• UI states (Loading, Success, Error)\n• Network responses\n• Navigation events\n• ViewState management\n• Result wrappers\n\nSealed vs Enum:\n• Sealed - Different properties per subclass\n• Enum - Same properties for all values\n• Sealed - Can be data classes\n• Enum - Simple constant values\n\nSealed Interface:\n• Kotlin 1.5+\n• Similar to sealed classes\n• For interface hierarchies\n• Multiple inheritance support",
      "explanation": "Sealed classes define restricted type hierarchies with compile-time known subclasses, enabling exhaustive when expressions ideal for representing states like Loading, Success, and Error in Android.",
      "difficulty": "Medium",
      "code": "// 1. Basic Sealed Class for UI State\nsealed class UiState {\n    object Loading : UiState()\n    data class Success(val data: List<User>) : UiState()\n    data class Error(val message: String, val exception: Exception? = null) : UiState()\n    object Empty : UiState()\n}\n\n// 2. Using in ViewModel\nclass UserViewModel : ViewModel() {\n    private val _uiState = MutableLiveData<UiState>()\n    val uiState: LiveData<UiState> = _uiState\n    \n    fun loadUsers() {\n        _uiState.value = UiState.Loading\n        \n        viewModelScope.launch {\n            try {\n                val users = repository.getUsers()\n                _uiState.value = if (users.isEmpty()) {\n                    UiState.Empty\n                } else {\n                    UiState.Success(users)\n                }\n            } catch (e: Exception) {\n                _uiState.value = UiState.Error(\n                    \"Failed to load users\",\n                    e\n                )\n            }\n        }\n    }\n}\n\n// 3. Handling in Activity with exhaustive when\nclass MainActivity : AppCompatActivity() {\n    private val viewModel: UserViewModel by viewModels()\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        \n        viewModel.uiState.observe(this) { state ->\n            // Exhaustive when - no else needed\n            when (state) {\n                is UiState.Loading -> {\n                    progressBar.visibility = View.VISIBLE\n                    recyclerView.visibility = View.GONE\n                    errorText.visibility = View.GONE\n                }\n                is UiState.Success -> {\n                    progressBar.visibility = View.GONE\n                    recyclerView.visibility = View.VISIBLE\n                    errorText.visibility = View.GONE\n                    adapter.submitList(state.data)\n                }\n                is UiState.Error -> {\n                    progressBar.visibility = View.GONE\n                    recyclerView.visibility = View.GONE\n                    errorText.visibility = View.VISIBLE\n                    errorText.text = state.message\n                }\n                is UiState.Empty -> {\n                    progressBar.visibility = View.GONE\n                    recyclerView.visibility = View.GONE\n                    errorText.visibility = View.VISIBLE\n                    errorText.text = \"No users found\"\n                }\n            }\n        }\n    }\n}\n\n// 4. Sealed Class for Network Result\nsealed class Result<out T> {\n    data class Success<T>(val data: T) : Result<T>()\n    data class Error(val exception: Exception) : Result<Nothing>()\n    object Loading : Result<Nothing>()\n}\n\n// Usage in Repository\nclass UserRepository {\n    suspend fun getUsers(): Result<List<User>> {\n        return try {\n            val response = apiService.getUsers()\n            if (response.isSuccessful && response.body() != null) {\n                Result.Success(response.body()!!)\n            } else {\n                Result.Error(Exception(\"Failed to fetch users\"))\n            }\n        } catch (e: Exception) {\n            Result.Error(e)\n        }\n    }\n}\n\n// 5. Sealed Class for Navigation Events\nsealed class NavigationEvent {\n    object NavigateBack : NavigationEvent()\n    data class NavigateToDetail(val userId: Int) : NavigationEvent()\n    data class NavigateToUrl(val url: String) : NavigationEvent()\n    data class ShowDialog(val title: String, val message: String) : NavigationEvent()\n}\n\n// In ViewModel\nclass MainViewModel : ViewModel() {\n    private val _navigationEvent = MutableLiveData<NavigationEvent>()\n    val navigationEvent: LiveData<NavigationEvent> = _navigationEvent\n    \n    fun onUserClick(userId: Int) {\n        _navigationEvent.value = NavigationEvent.NavigateToDetail(userId)\n    }\n    \n    fun onBackPressed() {\n        _navigationEvent.value = NavigationEvent.NavigateBack\n    }\n}\n\n// Handle in Activity\nviewModel.navigationEvent.observe(this) { event ->\n    when (event) {\n        is NavigationEvent.NavigateBack -> finish()\n        is NavigationEvent.NavigateToDetail -> {\n            val intent = Intent(this, DetailActivity::class.java)\n            intent.putExtra(\"user_id\", event.userId)\n            startActivity(intent)\n        }\n        is NavigationEvent.NavigateToUrl -> {\n            val browserIntent = Intent(Intent.ACTION_VIEW, Uri.parse(event.url))\n            startActivity(browserIntent)\n        }\n        is NavigationEvent.ShowDialog -> {\n            AlertDialog.Builder(this)\n                .setTitle(event.title)\n                .setMessage(event.message)\n                .show()\n        }\n    }\n}\n\n// 6. Sealed Class for Form Validation\nsealed class ValidationResult {\n    object Valid : ValidationResult()\n    sealed class Invalid : ValidationResult() {\n        object EmptyField : Invalid()\n        object InvalidEmail : Invalid()\n        object PasswordTooShort : Invalid()\n        data class CustomError(val message: String) : Invalid()\n    }\n}\n\nclass FormValidator {\n    fun validateEmail(email: String): ValidationResult {\n        return when {\n            email.isEmpty() -> ValidationResult.Invalid.EmptyField\n            !Patterns.EMAIL_ADDRESS.matcher(email).matches() -> \n                ValidationResult.Invalid.InvalidEmail\n            else -> ValidationResult.Valid\n        }\n    }\n}\n\n// 7. Sealed Interface (Kotlin 1.5+)\nsealed interface DataSource {\n    data class Network(val url: String) : DataSource\n    data class Database(val query: String) : DataSource\n    data class Cache(val key: String) : DataSource\n}\n\n// 8. Comparison with Enum\n// Enum - Limited\nenum class Status {\n    LOADING, SUCCESS, ERROR\n}\n\n// Sealed Class - Flexible\nsealed class Status {\n    object Loading : Status()\n    data class Success(val data: Any) : Status()\n    data class Error(val message: String, val code: Int) : Status()\n}\n\n// 9. Nested Sealed Classes\nsealed class PaymentStatus {\n    object Pending : PaymentStatus()\n    object Processing : PaymentStatus()\n    \n    sealed class Completed : PaymentStatus() {\n        data class Success(val transactionId: String) : Completed()\n        data class Refunded(val refundId: String, val amount: Double) : Completed()\n    }\n    \n    sealed class Failed : PaymentStatus() {\n        object InsufficientFunds : Failed()\n        object NetworkError : Failed()\n        data class Other(val reason: String) : Failed()\n    }\n}\n\n// 10. Real-world example with Flow\nclass UserRepository {\n    fun observeUsers(): Flow<UiState> = flow {\n        emit(UiState.Loading)\n        \n        try {\n            val users = apiService.getUsers()\n            emit(\n                if (users.isEmpty()) UiState.Empty \n                else UiState.Success(users)\n            )\n        } catch (e: Exception) {\n            emit(UiState.Error(e.message ?: \"Unknown error\", e))\n        }\n    }.flowOn(Dispatchers.IO)\n}\n\nclass UserViewModel : ViewModel() {\n    val uiState: StateFlow<UiState> = repository.observeUsers()\n        .stateIn(\n            scope = viewModelScope,\n            started = SharingStarted.WhileSubscribed(5000),\n            initialValue = UiState.Loading\n        )\n}"
    },
    {
      "id": 68,
      "question": "What is Android Security Best Practices?",
      "answer": "Android Security involves protecting user data, preventing unauthorized access, and ensuring app integrity.\n\nData Security:\n• Encrypt sensitive data\n• Use EncryptedSharedPreferences\n• Secure network communications (HTTPS)\n• Implement certificate pinning\n• Use Android Keystore\n\nAuthentication:\n• BiometricPrompt for fingerprint/face\n• Secure token storage\n• OAuth 2.0 implementation\n• Session management\n• Password policies\n\nPermissions:\n• Request minimum necessary permissions\n• Runtime permission checks\n• Explain permission rationale\n• Handle permission denial\n\nCode Security:\n• Enable ProGuard/R8\n• Obfuscate sensitive code\n• Validate all inputs\n• Prevent SQL injection\n• Secure IPC\n\nNetwork Security:\n• Use HTTPS only\n• Certificate pinning\n• Network Security Config\n• Validate SSL certificates\n• Secure WebViews\n\nStorage:\n• Encrypted databases\n• Secure file storage\n• Clear sensitive data\n• Use scoped storage",
      "explanation": "Android Security involves encrypting sensitive data, implementing secure authentication, requesting minimal permissions, using HTTPS with certificate pinning, and protecting stored data through encryption and proper file permissions.",
      "difficulty": "Hard",
      "code": "// 1. EncryptedSharedPreferences\nimport androidx.security.crypto.EncryptedSharedPreferences\nimport androidx.security.crypto.MasterKey\n\nval masterKey = MasterKey.Builder(context)\n    .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)\n    .build()\n\nval sharedPreferences = EncryptedSharedPreferences.create(\n    context,\n    \"secure_prefs\",\n    masterKey,\n    EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,\n    EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM\n)\n\n// Store encrypted data\nsharedPreferences.edit()\n    .putString(\"auth_token\", \"secret_token\")\n    .apply()\n\n// 2. Android Keystore for encryption keys\nimport android.security.keystore.KeyGenParameterSpec\nimport android.security.keystore.KeyProperties\nimport java.security.KeyStore\nimport javax.crypto.KeyGenerator\n\nfun generateKey(): SecretKey {\n    val keyGenerator = KeyGenerator.getInstance(\n        KeyProperties.KEY_ALGORITHM_AES,\n        \"AndroidKeyStore\"\n    )\n    \n    val keyGenParameterSpec = KeyGenParameterSpec.Builder(\n        \"MyKeyAlias\",\n        KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT\n    )\n        .setBlockModes(KeyProperties.BLOCK_MODE_GCM)\n        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)\n        .build()\n    \n    keyGenerator.init(keyGenParameterSpec)\n    return keyGenerator.generateKey()\n}\n\nfun getKey(): SecretKey {\n    val keyStore = KeyStore.getInstance(\"AndroidKeyStore\")\n    keyStore.load(null)\n    return keyStore.getKey(\"MyKeyAlias\", null) as SecretKey\n}\n\n// 3. Encrypt/Decrypt data\nimport javax.crypto.Cipher\nimport javax.crypto.spec.GCMParameterSpec\n\nfun encrypt(data: ByteArray, key: SecretKey): Pair<ByteArray, ByteArray> {\n    val cipher = Cipher.getInstance(\"AES/GCM/NoPadding\")\n    cipher.init(Cipher.ENCRYPT_MODE, key)\n    \n    val iv = cipher.iv\n    val encryptedData = cipher.doFinal(data)\n    \n    return Pair(encryptedData, iv)\n}\n\nfun decrypt(encryptedData: ByteArray, iv: ByteArray, key: SecretKey): ByteArray {\n    val cipher = Cipher.getInstance(\"AES/GCM/NoPadding\")\n    val spec = GCMParameterSpec(128, iv)\n    cipher.init(Cipher.DECRYPT_MODE, key, spec)\n    \n    return cipher.doFinal(encryptedData)\n}\n\n// 4. BiometricPrompt for authentication\nimport androidx.biometric.BiometricPrompt\nimport androidx.core.content.ContextCompat\n\nfun showBiometricPrompt(activity: FragmentActivity) {\n    val executor = ContextCompat.getMainExecutor(activity)\n    \n    val biometricPrompt = BiometricPrompt(activity, executor,\n        object : BiometricPrompt.AuthenticationCallback() {\n            override fun onAuthenticationSucceeded(\n                result: BiometricPrompt.AuthenticationResult\n            ) {\n                super.onAuthenticationSucceeded(result)\n                // User authenticated successfully\n                proceedWithSecureAction()\n            }\n            \n            override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {\n                super.onAuthenticationError(errorCode, errString)\n                // Handle error\n            }\n            \n            override fun onAuthenticationFailed() {\n                super.onAuthenticationFailed()\n                // Authentication failed\n            }\n        }\n    )\n    \n    val promptInfo = BiometricPrompt.PromptInfo.Builder()\n        .setTitle(\"Biometric Authentication\")\n        .setSubtitle(\"Log in using your biometric credential\")\n        .setNegativeButtonText(\"Use password\")\n        .setAllowedAuthenticators(\n            BiometricManager.Authenticators.BIOMETRIC_STRONG or\n            BiometricManager.Authenticators.DEVICE_CREDENTIAL\n        )\n        .build()\n    \n    biometricPrompt.authenticate(promptInfo)\n}\n\n// 5. Network Security Config (res/xml/network_security_config.xml)\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<network-security-config>\n    <!-- Block all cleartext traffic -->\n    <base-config cleartextTrafficPermitted=\"false\">\n        <trust-anchors>\n            <certificates src=\"system\" />\n        </trust-anchors>\n    </base-config>\n    \n    <!-- Certificate Pinning -->\n    <domain-config>\n        <domain includeSubdomains=\"true\">api.example.com</domain>\n        <pin-set expiration=\"2025-01-01\">\n            <pin digest=\"SHA-256\">base64encodedpin==</pin>\n            <pin digest=\"SHA-256\">backuppin==</pin>\n        </pin-set>\n    </domain-config>\n</network-security-config>\n\n// Reference in AndroidManifest.xml\n<application\n    android:networkSecurityConfig=\"@xml/network_security_config\">\n</application>\n\n// 6. Certificate Pinning with OkHttp\nval certificatePinner = CertificatePinner.Builder()\n    .add(\"api.example.com\", \"sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\")\n    .add(\"api.example.com\", \"sha256/BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB=\")\n    .build()\n\nval client = OkHttpClient.Builder()\n    .certificatePinner(certificatePinner)\n    .build()\n\n// 7. Secure SQL queries (prevent injection)\n// BAD - SQL Injection vulnerable\nval query = \"SELECT * FROM users WHERE name = '\" + userInput + \"'\"\ndb.rawQuery(query, null)\n\n// GOOD - Use parameterized queries\nval query = \"SELECT * FROM users WHERE name = ?\"\nval cursor = db.rawQuery(query, arrayOf(userInput))\n\n// Or use Room (automatically safe)\n@Query(\"SELECT * FROM users WHERE name = :name\")\nfun getUserByName(name: String): User\n\n// 8. Secure WebView configuration\nval webView = findViewById<WebView>(R.id.webView)\n\nwebView.settings.apply {\n    // Disable JavaScript if not needed\n    javaScriptEnabled = false\n    \n    // Disable file access\n    allowFileAccess = false\n    allowContentAccess = false\n    \n    // Disable geolocation\n    setGeolocationEnabled(false)\n    \n    // Enable safe browsing\n    safeBrowsingEnabled = true\n}\n\n// Set WebView client for SSL errors\nwebView.webViewClient = object : WebViewClient() {\n    override fun onReceivedSslError(\n        view: WebView,\n        handler: SslErrorHandler,\n        error: SslError\n    ) {\n        // Don't proceed on SSL errors\n        handler.cancel()\n    }\n}\n\n// 9. Input Validation\nfun validateInput(input: String): Boolean {\n    // Validate length\n    if (input.length > 100) return false\n    \n    // Allow only alphanumeric and specific characters\n    val regex = Regex(\"^[a-zA-Z0-9_-]+$\")\n    if (!regex.matches(input)) return false\n    \n    // Additional validation\n    return true\n}\n\n// 10. ProGuard rules for security (proguard-rules.pro)\n# Obfuscate sensitive classes\n-keep class com.example.model.** { *; }\n\n# Remove logging in release\n-assumenosideeffects class android.util.Log {\n    public static *** d(...);\n    public static *** v(...);\n    public static *** i(...);\n}\n\n# Encrypt strings\n-obfuscate\n-repackageclasses\n-allowaccessmodification\n\n// 11. Secure Intent handling\nif (intent != null && intent.action == Intent.ACTION_VIEW) {\n    val uri = intent.data\n    \n    // Validate URI\n    if (uri != null && uri.scheme == \"https\" && \n        uri.host == \"trusted.example.com\") {\n        // Safe to process\n        handleDeepLink(uri)\n    } else {\n        // Reject untrusted URI\n        finish()\n    }\n}\n\n// 12. Secure Background Key Generation\nclass SecurityManager(context: Context) {\n    init {\n        if (!hasValidKey()) {\n            generateKey()\n        }\n    }\n    \n    private fun hasValidKey(): Boolean {\n        return try {\n            val keyStore = KeyStore.getInstance(\"AndroidKeyStore\")\n            keyStore.load(null)\n            keyStore.containsAlias(\"MyKeyAlias\")\n        } catch (e: Exception) {\n            false\n        }\n    }\n}"
    },
    {
      "id": 69,
      "question": "What is Deep Linking and App Links in Android?",
      "answer": "Deep Linking allows users to navigate directly to specific content within an app from external sources like web browsers or other apps.\n\nTypes:\n• Deep Links - Standard URIs (custom or standard)\n• Web Links - HTTP/HTTPS URIs\n• Android App Links - Verified HTTP/HTTPS URIs\n\nDeep Links:\n• Custom URI schemes (myapp://)\n• No verification required\n• Can have multiple handlers\n• User chooses app\n\nAndroid App Links:\n• HTTPS only\n• Domain verification required\n• Direct app opening\n• No disambiguation dialog\n• Instant Apps support\n\nComponents:\n• Intent Filter in Manifest\n• assetlinks.json on web server\n• Digital Asset Links verification\n• URL parameter extraction\n\nUse Cases:\n• Email campaign links\n• Social media sharing\n• Push notification deep links\n• Cross-platform navigation\n• Marketing campaigns\n\nBest Practices:\n• Handle missing data gracefully\n• Validate URI parameters\n• Test all link scenarios\n• Implement fallback logic\n• Track link analytics",
      "explanation": "Deep Linking enables direct navigation to app content via URIs, with Android App Links providing verified HTTPS-based direct opening without disambiguation, requiring domain ownership verification through assetlinks.json.",
      "difficulty": "Medium",
      "code": "// 1. Basic Deep Link in AndroidManifest.xml\n<activity android:name=\".DetailActivity\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.VIEW\" />\n        \n        <category android:name=\"android.intent.category.DEFAULT\" />\n        <category android:name=\"android.intent.category.BROWSABLE\" />\n        \n        <!-- Custom scheme -->\n        <data\n            android:scheme=\"myapp\"\n            android:host=\"product\"\n            android:pathPrefix=\"/detail\" />\n        <!-- Handles: myapp://product/detail?id=123 -->\n    </intent-filter>\n</activity>\n\n// 2. Android App Links (verified)\n<activity android:name=\".DetailActivity\">\n    <intent-filter android:autoVerify=\"true\">\n        <action android:name=\"android.intent.action.VIEW\" />\n        \n        <category android:name=\"android.intent.category.DEFAULT\" />\n        <category android:name=\"android.intent.category.BROWSABLE\" />\n        \n        <!-- HTTPS URLs -->\n        <data\n            android:scheme=\"https\"\n            android:host=\"www.example.com\"\n            android:pathPrefix=\"/products\" />\n        <!-- Handles: https://www.example.com/products/123 -->\n    </intent-filter>\n</activity>\n\n// 3. Handle Deep Link in Activity\nclass DetailActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_detail)\n        \n        handleIntent(intent)\n    }\n    \n    override fun onNewIntent(intent: Intent) {\n        super.onNewIntent(intent)\n        handleIntent(intent)\n    }\n    \n    private fun handleIntent(intent: Intent) {\n        val action = intent.action\n        val data: Uri? = intent.data\n        \n        if (Intent.ACTION_VIEW == action && data != null) {\n            // Extract parameters\n            val productId = data.getQueryParameter(\"id\")\n            val category = data.getQueryParameter(\"category\")\n            \n            // Or from path\n            val pathSegments = data.pathSegments\n            if (pathSegments.size > 1) {\n                val id = pathSegments[1] // products/123\n                loadProduct(id)\n            }\n            \n            // Validate and load data\n            productId?.let {\n                loadProduct(it)\n            }\n        }\n    }\n    \n    private fun loadProduct(productId: String) {\n        // Load product details\n    }\n}\n\n// 4. Digital Asset Links file\n// Place at: https://www.example.com/.well-known/assetlinks.json\n[\n  {\n    \"relation\": [\"delegate_permission/common.handle_all_urls\"],\n    \"target\": {\n      \"namespace\": \"android_app\",\n      \"package_name\": \"com.example.myapp\",\n      \"sha256_cert_fingerprints\": [\n        \"14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5\"\n      ]\n    }\n  }\n]\n\n// Get SHA256 fingerprint:\n// keytool -list -v -keystore my-release-key.keystore\n\n// 5. Navigation Component with Deep Links\n// nav_graph.xml\n<navigation>\n    <fragment\n        android:id=\"@+id/productDetailFragment\"\n        android:name=\"com.example.ProductDetailFragment\">\n        \n        <deepLink\n            app:uri=\"myapp://product/{productId}\"\n            android:autoVerify=\"true\" />\n        \n        <deepLink\n            app:uri=\"https://www.example.com/products/{productId}\"\n            android:autoVerify=\"true\" />\n        \n        <argument\n            android:name=\"productId\"\n            app:argType=\"string\" />\n    </fragment>\n</navigation>\n\n// Handle in Activity\nclass MainActivity : AppCompatActivity() {\n    private lateinit var navController: NavController\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        val navHostFragment = supportFragmentManager\n            .findFragmentById(R.id.nav_host_fragment) as NavHostFragment\n        navController = navHostFragment.navController\n        \n        // Handle deep link\n        navController.handleDeepLink(intent)\n    }\n    \n    override fun onNewIntent(intent: Intent?) {\n        super.onNewIntent(intent)\n        intent?.let { navController.handleDeepLink(it) }\n    }\n}\n\n// 6. Create Deep Link programmatically\nfun createDeepLink(productId: String): Uri {\n    return Uri.parse(\"myapp://product/detail?id=$productId\")\n}\n\n// Trigger deep link\nval intent = Intent(Intent.ACTION_VIEW, createDeepLink(\"123\"))\nstartActivity(intent)\n\n// 7. Pending Intent with Deep Link (for notifications)\nval deepLinkIntent = Intent(\n    Intent.ACTION_VIEW,\n    Uri.parse(\"myapp://product/detail?id=123\"),\n    this,\n    DetailActivity::class.java\n)\n\nval pendingIntent = PendingIntent.getActivity(\n    this,\n    0,\n    deepLinkIntent,\n    PendingIntent.FLAG_IMMUTABLE\n)\n\nval notification = NotificationCompat.Builder(this, CHANNEL_ID)\n    .setContentTitle(\"New Product\")\n    .setContentText(\"Check out this product!\")\n    .setSmallIcon(R.drawable.notification_icon)\n    .setContentIntent(pendingIntent)\n    .setAutoCancel(true)\n    .build()\n\n// 8. Test Deep Links with ADB\n/*\n// Test custom scheme\nadb shell am start -W -a android.intent.action.VIEW \\\n  -d \"myapp://product/detail?id=123\" com.example.myapp\n\n// Test HTTPS link\nadb shell am start -W -a android.intent.action.VIEW \\\n  -d \"https://www.example.com/products/123\" com.example.myapp\n\n// Verify App Links\nadb shell pm get-app-links com.example.myapp\n\n// Reset App Links verification\nadb shell pm set-app-links --package com.example.myapp 0 all\n\n// Manually verify App Links\nadb shell pm verify-app-links --re-verify com.example.myapp\n*/\n\n// 9. Firebase Dynamic Links (alternative)\nimplementation 'com.google.firebase:firebase-dynamic-links:21.1.0'\n\n// Handle Firebase Dynamic Link\nFirebase DynamicLinks.getInstance()\n    .getDynamicLink(intent)\n    .addOnSuccessListener { pendingDynamicLinkData ->\n        var deepLink: Uri? = null\n        if (pendingDynamicLinkData != null) {\n            deepLink = pendingDynamicLinkData.link\n        }\n        \n        // Handle deep link\n        deepLink?.let { uri ->\n            val productId = uri.getQueryParameter(\"id\")\n            navigateToProduct(productId)\n        }\n    }\n\n// 10. Link Validation and Error Handling\nprivate fun handleDeepLink(uri: Uri?) {\n    if (uri == null) {\n        showError(\"Invalid link\")\n        return\n    }\n    \n    // Validate scheme\n    if (uri.scheme !in listOf(\"myapp\", \"https\")) {\n        showError(\"Unsupported link type\")\n        return\n    }\n    \n    // Validate host\n    if (uri.scheme == \"https\" && uri.host != \"www.example.com\") {\n        showError(\"Untrusted domain\")\n        return\n    }\n    \n    // Extract and validate parameters\n    val productId = uri.getQueryParameter(\"id\") ?: run {\n        showError(\"Missing product ID\")\n        return\n    }\n    \n    // Proceed with navigation\n    navigateToProduct(productId)\n}"
    },
    {
      "id": 70,
      "question": "What is Android App Startup optimization techniques?",
      "answer": "App Startup optimization reduces the time from app launch to first interaction, improving user experience and retention.\n\nCold Start:\n• App not in memory\n• Longest startup time\n• System creates process\n• Most critical to optimize\n\nWarm Start:\n• App in memory but not visible\n• Faster than cold start\n• Activity recreated\n\nHot Start:\n• App in memory and visible\n• Fastest startup\n• Activity brought to foreground\n\nOptimization Techniques:\n• Lazy initialization\n• Avoid heavy operations in Application.onCreate()\n• Use content providers wisely\n• Optimize layouts\n• Minimize main thread work\n• Use App Startup library\n• Defer non-critical tasks\n\nTools:\n• Android Profiler\n• Systrace\n• Method tracing\n• Reportfully drawn time\n• Baseline profiles\n\nMeasurement:\n• Time to initial display (TTID)\n• Time to fully drawn (TTFD)\n• Method trace analysis",
      "explanation": "App Startup optimization minimizes launch time through lazy initialization, deferring non-critical work, avoiding heavy Application.onCreate() operations, and using App Startup library for efficient initialization management.",
      "difficulty": "Hard",
      "code": "// 1. App Startup Library\nimplementation 'androidx.startup:startup-runtime:1.1.1'\n\n// Initializer for library initialization\nclass WorkManagerInitializer : Initializer<WorkManager> {\n    override fun create(context: Context): WorkManager {\n        val configuration = Configuration.Builder()\n            .setMinimumLoggingLevel(Log.INFO)\n            .build()\n        WorkManager.initialize(context, configuration)\n        return WorkManager.getInstance(context)\n    }\n    \n    override fun dependencies(): List<Class<out Initializer<*>>> {\n        // Dependencies on other initializers\n        return emptyList()\n    }\n}\n\n// Register in AndroidManifest.xml\n<provider\n    android:name=\"androidx.startup.InitializationProvider\"\n    android:authorities=\"${applicationId}.androidx-startup\"\n    android:exported=\"false\"\n    tools:node=\"merge\">\n    \n    <meta-data\n        android:name=\"com.example.WorkManagerInitializer\"\n        android:value=\"androidx.startup\" />\n</provider>\n\n// 2. Lazy initialization in Application class\nclass MyApplication : Application() {\n    // Lazy initialization\n    val database: AppDatabase by lazy {\n        Room.databaseBuilder(\n            this,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n    \n    val retrofit: Retrofit by lazy {\n        Retrofit.Builder()\n            .baseUrl(\"https://api.example.com/\")\n            .addConverterFactory(GsonConverterFactory.create())\n            .build()\n    }\n    \n    override fun onCreate() {\n        super.onCreate()\n        \n        // Only critical initialization\n        if (BuildConfig.DEBUG) {\n            Timber.plant(Timber.DebugTree())\n        }\n        \n        // Defer non-critical initialization\n        deferredInitialization()\n    }\n    \n    private fun deferredInitialization() {\n        CoroutineScope(Dispatchers.Default).launch {\n            // Initialize non-critical libraries\n            initializeAnalytics()\n            initializeCrashReporting()\n        }\n    }\n    \n    private suspend fun initializeAnalytics() = withContext(Dispatchers.IO) {\n        // Heavy analytics initialization\n        delay(100) // Simulate work\n    }\n    \n    private suspend fun initializeCrashReporting() = withContext(Dispatchers.IO) {\n        // Crash reporting setup\n        delay(100)\n    }\n}\n\n// 3. Optimize Activity creation\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        \n        // Use ViewBinding instead of findViewById\n        val binding = ActivityMainBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n        \n        // Report fully drawn\n        reportFullyDrawn()\n        \n        // Defer heavy operations\n        lifecycleScope.launch {\n            loadData()\n        }\n    }\n    \n    private suspend fun loadData() = withContext(Dispatchers.IO) {\n        // Load data after UI is drawn\n    }\n}\n\n// 4. ViewStub for lazy inflation\n<!-- layout.xml -->\n<ViewStub\n    android:id=\"@+id/heavyViewStub\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:layout=\"@layout/heavy_layout\" />\n\n// Inflate when needed\nval viewStub = findViewById<ViewStub>(R.id.heavyViewStub)\nviewStub.inflate()\n\n// 5. Avoid blocking Content Providers\nclass MyContentProvider : ContentProvider() {\n    override fun onCreate(): Boolean {\n        // Don't perform heavy operations here\n        // They block app startup\n        return true\n    }\n}\n\n// Use WorkManager for initialization instead\nclass InitializationWorker(context: Context, params: WorkerParameters) \n    : Worker(context, params) {\n    \n    override fun doWork(): Result {\n        // Heavy initialization\n        initializeDatabase()\n        return Result.success()\n    }\n}\n\n// 6. Profile-guided optimization (AGP 7.0+)\n// build.gradle\nandroid {\n    defaultConfig {\n        profileInstallEnabled = true\n    }\n}\n\n// Generate baseline profile\n// ./gradlew generateBaselineProfile\n\n// 7. Measure startup time\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        val startTime = System.currentTimeMillis()\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        // Report when first frame is drawn\n        window.decorView.post {\n            val endTime = System.currentTimeMillis()\n            Log.d(\"Startup\", \"Time to first frame: ${endTime - startTime}ms\")\n            reportFullyDrawn()\n        }\n    }\n}\n\n// 8. StrictMode for detecting violations (Debug only)\nif (BuildConfig.DEBUG) {\n    StrictMode.setThreadPolicy(\n        StrictMode.ThreadPolicy.Builder()\n            .detectAll()\n            .penaltyLog()\n            .penaltyFlashScreen()\n            .build()\n    )\n    \n    StrictMode.setVmPolicy(\n        StrictMode.VmPolicy.Builder()\n            .detectAll()\n            .penaltyLog()\n            .build()\n    )\n}\n\n// 9. Tracing startup performance\nimport androidx.tracing.trace\n\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        \n        trace(\"App.onCreate\") {\n            initializeCriticalComponents()\n        }\n    }\n    \n    private fun initializeCriticalComponents() {\n        trace(\"InitTimber\") {\n            Timber.plant(Timber.DebugTree())\n        }\n    }\n}\n\n// View trace with:\n// adb shell am start -n com.example.app/.MainActivity\n// adb shell am trace --dump\n\n// 10. Avoid synchronous initialization\n// BAD\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        \n        // Blocks startup\n        val database = Room.databaseBuilder(this, AppDatabase::class.java, \"db\")\n            .build()\n        database.userDao().getAllUsers() // Blocking!\n    }\n}\n\n// GOOD\nclass MyApplication : Application() {\n    val database by lazy {\n        Room.databaseBuilder(this, AppDatabase::class.java, \"db\")\n            .build()\n    }\n    \n    override fun onCreate() {\n        super.onCreate()\n        // Database created only when first accessed\n    }\n}\n\n// 11. Optimize layout inflation\n// Use ConstraintLayout (flat hierarchy)\n// Avoid nested LinearLayouts\n// Use <merge> tag when possible\n// Use ViewStub for conditional views\n\n// 12. ADB commands to measure startup\n/*\n// Measure cold start\nadb shell am start -S -W com.example.app/.MainActivity\n\n// Output:\n// Starting: Intent { act=android.intent.action.MAIN }\n// Status: ok\n// Activity: com.example.app/.MainActivity\n// ThisTime: 523\n// TotalTime: 523\n// WaitTime: 530\n\n// TotalTime: Time to first frame\n// WaitTime: Time including system overhead\n\n// Profile startup with Systrace\nadb shell am start -n com.example.app/.MainActivity\nsystrace.py --time=10 -o trace.html sched gfx view wm am app\n*/"
    },
    {
      "id": 71,
      "question": "What is Android Storage options and best practices?",
      "answer": "Android provides multiple storage options for persisting data based on size, type, and access requirements.\n\nInternal Storage:\n• Private to app\n• Deleted when app uninstalled\n• Secure by default\n• No permissions needed\n• Limited space\n\nExternal Storage:\n• Shared storage\n• Media and documents\n• Scoped Storage (Android 10+)\n• Requires permissions\n• Survives app uninstall\n\nSharedPreferences:\n• Small key-value data\n• XML file format\n• Synchronous API\n• Good for settings\n\nRoom Database:\n• Structured relational data\n• SQLite abstraction\n• Type-safe queries\n• Migration support\n• Observable queries\n\nDataStore:\n• Replaces SharedPreferences\n• Asynchronous API\n• Type-safe with Proto\n• Transactional\n• Coroutines/Flow support\n\nScoped Storage:\n• MediaStore for media\n• Storage Access Framework\n• App-specific directories\n• Privacy protection",
      "explanation": "Android offers Internal Storage for private app data, External Storage with Scoped Storage for media, Room for structured databases, DataStore for preferences, and SharedPreferences for simple key-value pairs.",
      "difficulty": "Medium",
      "code": "// 1. Internal Storage - Private files\n// Write file\nval filename = \"user_data.txt\"\nval fileContents = \"Hello World!\"\n\ncontext.openFileOutput(filename, Context.MODE_PRIVATE).use { output ->\n    output.write(fileContents.toByteArray())\n}\n\n// Read file\nval text = context.openFileInput(filename).bufferedReader().use { it.readText() }\n\n// Get files directory\nval filesDir = context.filesDir // /data/data/package/files/\nval cacheDir = context.cacheDir // /data/data/package/cache/\n\n// Create subdirectory\nval imagesDir = File(filesDir, \"images\")\nif (!imagesDir.exists()) {\n    imagesDir.mkdirs()\n}\n\n// 2. SharedPreferences\nval sharedPref = context.getSharedPreferences(\"MyPrefs\", Context.MODE_PRIVATE)\n\n// Write\nsharedPref.edit {\n    putString(\"username\", \"John\")\n    putInt(\"age\", 25)\n    putBoolean(\"premium\", true)\n    // Commits synchronously\n}\n\n// Or async commit\nsharedPref.edit()\n    .putString(\"username\", \"John\")\n    .apply() // Asynchronous\n\n// Read\nval username = sharedPref.getString(\"username\", \"default_value\")\nval age = sharedPref.getInt(\"age\", 0)\nval isPremium = sharedPref.getBoolean(\"premium\", false)\n\n// Listen for changes\nval listener = SharedPreferences.OnSharedPreferenceChangeListener { prefs, key ->\n    if (key == \"username\") {\n        val newValue = prefs.getString(key, \"\")\n        // Handle change\n    }\n}\nsharedPref.registerOnSharedPreferenceChangeListener(listener)\n\n// 3. DataStore (Preferences)\nimplementation 'androidx.datastore:datastore-preferences:1.0.0'\n\nval Context.dataStore: DataStore<Preferences> by preferencesDataStore(name = \"settings\")\n\nclass SettingsManager(private val context: Context) {\n    private val USERNAME = stringPreferencesKey(\"username\")\n    private val AGE = intPreferencesKey(\"age\")\n    \n    // Write\n    suspend fun saveUsername(username: String) {\n        context.dataStore.edit { preferences ->\n            preferences[USERNAME] = username\n        }\n    }\n    \n    // Read as Flow\n    val usernameFlow: Flow<String> = context.dataStore.data\n        .map { preferences ->\n            preferences[USERNAME] ?: \"\"\n        }\n    \n    // Read once\n    suspend fun getUsername(): String {\n        val preferences = context.dataStore.data.first()\n        return preferences[USERNAME] ?: \"\"\n    }\n}\n\n// Usage in ViewModel\nclass SettingsViewModel(private val settingsManager: SettingsManager) : ViewModel() {\n    val username: StateFlow<String> = settingsManager.usernameFlow\n        .stateIn(\n            scope = viewModelScope,\n            started = SharingStarted.WhileSubscribed(5000),\n            initialValue = \"\"\n        )\n    \n    fun updateUsername(username: String) {\n        viewModelScope.launch {\n            settingsManager.saveUsername(username)\n        }\n    }\n}\n\n// 4. DataStore (Proto) - Type safe\n// Define proto schema (user_prefs.proto)\nsyntax = \"proto3\";\n\noption java_package = \"com.example\";\noption java_multiple_files = true;\n\nmessage UserPreferences {\n  string username = 1;\n  int32 age = 2;\n  bool premium = 3;\n}\n\n// Serializer\nobject UserPreferencesSerializer : Serializer<UserPreferences> {\n    override val defaultValue: UserPreferences = UserPreferences.getDefaultInstance()\n    \n    override suspend fun readFrom(input: InputStream): UserPreferences {\n        return UserPreferences.parseFrom(input)\n    }\n    \n    override suspend fun writeTo(t: UserPreferences, output: OutputStream) {\n        t.writeTo(output)\n    }\n}\n\n// DataStore instance\nval Context.userPrefsDataStore: DataStore<UserPreferences> by dataStore(\n    fileName = \"user_prefs.pb\",\n    serializer = UserPreferencesSerializer\n)\n\n// Read/Write\nsuspend fun updateUserPrefs(username: String, age: Int) {\n    context.userPrefsDataStore.updateData { preferences ->\n        preferences.toBuilder()\n            .setUsername(username)\n            .setAge(age)\n            .build()\n    }\n}\n\nval userPrefsFlow: Flow<UserPreferences> = context.userPrefsDataStore.data\n\n// 5. External Storage (Scoped Storage - Android 10+)\n// Save image to Pictures\nval resolver = context.contentResolver\nval contentValues = ContentValues().apply {\n    put(MediaStore.Images.Media.DISPLAY_NAME, \"photo.jpg\")\n    put(MediaStore.Images.Media.MIME_TYPE, \"image/jpeg\")\n    put(MediaStore.Images.Media.RELATIVE_PATH, Environment.DIRECTORY_PICTURES)\n}\n\nval imageUri = resolver.insert(\n    MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n    contentValues\n)\n\nimageUri?.let { uri ->\n    resolver.openOutputStream(uri)?.use { outputStream ->\n        // Write image bytes\n        bitmap.compress(Bitmap.CompressFormat.JPEG, 95, outputStream)\n    }\n}\n\n// 6. Query MediaStore\nval projection = arrayOf(\n    MediaStore.Images.Media._ID,\n    MediaStore.Images.Media.DISPLAY_NAME,\n    MediaStore.Images.Media.DATE_ADDED\n)\n\nval sortOrder = \"${MediaStore.Images.Media.DATE_ADDED} DESC\"\n\nval cursor = resolver.query(\n    MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n    projection,\n    null,\n    null,\n    sortOrder\n)\n\nval images = mutableListOf<Image>()\ncursor?.use {\n    val idColumn = it.getColumnIndexOrThrow(MediaStore.Images.Media._ID)\n    val nameColumn = it.getColumnIndexOrThrow(MediaStore.Images.Media.DISPLAY_NAME)\n    \n    while (it.moveToNext()) {\n        val id = it.getLong(idColumn)\n        val name = it.getString(nameColumn)\n        val uri = ContentUris.withAppendedId(\n            MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n            id\n        )\n        images.add(Image(id, name, uri))\n    }\n}\n\n// 7. App-specific directory (No permissions needed)\nval appExternalDir = context.getExternalFilesDir(null)\nval appExternalCacheDir = context.externalCacheDir\n\n// These are deleted when app is uninstalled\nval file = File(appExternalDir, \"my_file.txt\")\nfile.writeText(\"Hello World\")\n\n// 8. Storage Access Framework (SAF)\n// Open document\nval intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply {\n    addCategory(Intent.CATEGORY_OPENABLE)\n    type = \"image/*\"\n}\nstartActivityForResult(intent, OPEN_DOCUMENT_REQUEST_CODE)\n\n// Handle result\noverride fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\n    super.onActivityResult(requestCode, resultCode, data)\n    \n    if (requestCode == OPEN_DOCUMENT_REQUEST_CODE && resultCode == RESULT_OK) {\n        data?.data?.let { uri ->\n            // Read file\n            contentResolver.openInputStream(uri)?.use { inputStream ->\n                val bytes = inputStream.readBytes()\n                // Process file\n            }\n            \n            // Take persistable URI permission\n            val takeFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION or\n                           Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n            contentResolver.takePersistableUriPermission(uri, takeFlags)\n        }\n    }\n}\n\n// 9. Room Database\n@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey val id: Int,\n    val name: String,\n    val email: String\n)\n\n@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM users\")\n    fun getAllUsers(): Flow<List<User>>\n    \n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertUser(user: User)\n    \n    @Delete\n    suspend fun deleteUser(user: User)\n}\n\n@Database(entities = [User::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n    \n    companion object {\n        @Volatile\n        private var INSTANCE: AppDatabase? = null\n        \n        fun getDatabase(context: Context): AppDatabase {\n            return INSTANCE ?: synchronized(this) {\n                val instance = Room.databaseBuilder(\n                    context.applicationContext,\n                    AppDatabase::class.java,\n                    \"app_database\"\n                ).build()\n                INSTANCE = instance\n                instance\n            }\n        }\n    }\n}\n\n// 10. Best Practices\nclass StorageManager(private val context: Context) {\n    // Use appropriate storage\n    fun saveUserToken(token: String) {\n        // Sensitive - use EncryptedSharedPreferences\n    }\n    \n    fun saveLargeFile(data: ByteArray) {\n        // Large - use Internal/External storage\n    }\n    \n    fun saveSettings(key: String, value: String) {\n        // Settings - use DataStore\n    }\n    \n    // Check available space\n    fun hasEnoughSpace(requiredBytes: Long): Boolean {\n        val stat = StatFs(context.filesDir.path)\n        val availableBytes = stat.availableBlocksLong * stat.blockSizeLong\n        return availableBytes >= requiredBytes\n    }\n    \n    // Clear cache periodically\n    fun clearCache() {\n        context.cacheDir.deleteRecursively()\n        context.externalCacheDir?.deleteRecursively()\n    }\n}"
    },
    {
      "id": 72,
      "question": "What is Android Background Processing and WorkManager?",
      "answer": "Background processing allows apps to perform tasks when not actively in use, with WorkManager being the recommended solution for deferrable background work.\n\nBackground Work Types:\n• Immediate - Needs to execute now\n• Long-running - Runs for extended time\n• Deferrable - Can run later\n• Exact - Must run at precise time\n\nWorkManager:\n• Guaranteed execution\n• Battery-friendly\n• Respects Doze mode\n• Survives app restart\n• Supports constraints\n• Chaining support\n\nWork Types:\n• OneTimeWorkRequest - Run once\n• PeriodicWorkRequest - Repeat periodically\n• Constraints - Network, battery, storage\n\nAlternatives:\n• Foreground Service - User-visible work\n• AlarmManager - Exact timing\n• JobScheduler - Android 5.0+ (replaced by WorkManager)\n\nBest Practices:\n• Use WorkManager for deferrable work\n• Add constraints to optimize battery\n• Chain dependent work\n• Handle retries properly\n• Test with Doze mode\n\nConstraints:\n• Network type\n• Battery not low\n• Device charging\n• Storage not low\n• Device idle",
      "explanation": "WorkManager provides guaranteed, battery-efficient execution of deferrable background work with constraint-based scheduling, work chaining, and automatic retry handling that respects Android's battery optimization features.",
      "difficulty": "Medium",
      "code": "// 1. Basic WorkManager setup\nimplementation 'androidx.work:work-runtime-ktx:2.8.1'\n\n// Simple Worker\nclass UploadWorker(context: Context, params: WorkerParameters)\n    : Worker(context, params) {\n    \n    override fun doWork(): Result {\n        return try {\n            // Get input data\n            val imageUri = inputData.getString(\"image_uri\")\n            \n            // Perform upload\n            uploadImage(imageUri)\n            \n            // Set output data\n            val outputData = workDataOf(\"upload_url\" to \"https://...\")\n            Result.success(outputData)\n        } catch (e: Exception) {\n            // Retry if recoverable\n            if (runAttemptCount < 3) {\n                Result.retry()\n            } else {\n                Result.failure()\n            }\n        }\n    }\n    \n    private fun uploadImage(uri: String?) {\n        // Upload logic\n        Thread.sleep(2000) // Simulate work\n    }\n}\n\n// 2. Create and enqueue WorkRequest\nval uploadWorkRequest = OneTimeWorkRequestBuilder<UploadWorker>()\n    .setInputData(workDataOf(\"image_uri\" to \"content://...\"))\n    .setConstraints(\n        Constraints.Builder()\n            .setRequiredNetworkType(NetworkType.CONNECTED)\n            .setRequiresBatteryNotLow(true)\n            .build()\n    )\n    .setBackoffCriteria(\n        BackoffPolicy.EXPONENTIAL,\n        OneTimeWorkRequest.MIN_BACKOFF_MILLIS,\n        TimeUnit.MILLISECONDS\n    )\n    .addTag(\"upload\")\n    .build()\n\n// Enqueue work\nWorkManager.getInstance(context).enqueue(uploadWorkRequest)\n\n// 3. CoroutineWorker for suspend functions\nclass DownloadWorker(context: Context, params: WorkerParameters)\n    : CoroutineWorker(context, params) {\n    \n    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {\n        try {\n            val url = inputData.getString(\"url\") ?: return@withContext Result.failure()\n            \n            // Show progress\n            setProgress(workDataOf(\"progress\" to 0))\n            \n            val data = downloadFile(url) { progress ->\n                // Update progress\n                setProgress(workDataOf(\"progress\" to progress))\n            }\n            \n            Result.success(workDataOf(\"file_path\" to data.path))\n        } catch (e: Exception) {\n            Result.failure(\n                workDataOf(\"error\" to e.message)\n            )\n        }\n    }\n    \n    private suspend fun downloadFile(url: String, onProgress: (Int) -> Unit): File {\n        // Download implementation\n        delay(1000)\n        return File(\"path\")\n    }\n}\n\n// 4. Observe work progress\nval workManager = WorkManager.getInstance(context)\n\nworkManager.getWorkInfoByIdLiveData(uploadWorkRequest.id)\n    .observe(lifecycleOwner) { workInfo ->\n        if (workInfo != null) {\n            when (workInfo.state) {\n                WorkInfo.State.ENQUEUED -> {\n                    // Work is queued\n                }\n                WorkInfo.State.RUNNING -> {\n                    // Work is running\n                    val progress = workInfo.progress.getInt(\"progress\", 0)\n                    updateProgressBar(progress)\n                }\n                WorkInfo.State.SUCCEEDED -> {\n                    // Work completed successfully\n                    val uploadUrl = workInfo.outputData.getString(\"upload_url\")\n                    showSuccess(uploadUrl)\n                }\n                WorkInfo.State.FAILED -> {\n                    // Work failed\n                    val error = workInfo.outputData.getString(\"error\")\n                    showError(error)\n                }\n                WorkInfo.State.BLOCKED -> {\n                    // Work is blocked (constraints not met)\n                }\n                WorkInfo.State.CANCELLED -> {\n                    // Work was cancelled\n                }\n            }\n        }\n    }\n\n// 5. Periodic Work (minimum 15 minutes)\nval periodicWorkRequest = PeriodicWorkRequestBuilder<SyncWorker>(\n    15, TimeUnit.MINUTES,\n    5, TimeUnit.MINUTES // Flex interval\n)\n    .setConstraints(\n        Constraints.Builder()\n            .setRequiredNetworkType(NetworkType.CONNECTED)\n            .build()\n    )\n    .build()\n\nworkManager.enqueueUniquePeriodicWork(\n    \"sync_work\",\n    ExistingPeriodicWorkPolicy.KEEP,\n    periodicWorkRequest\n)\n\n// 6. Work Chaining\nval uploadWork = OneTimeWorkRequestBuilder<UploadWorker>().build()\nval compressWork = OneTimeWorkRequestBuilder<CompressWorker>().build()\nval notifyWork = OneTimeWorkRequestBuilder<NotifyWorker>().build()\n\n// Sequential chain\nworkManager\n    .beginWith(compressWork)\n    .then(uploadWork)\n    .then(notifyWork)\n    .enqueue()\n\n// Parallel work\nval workA = OneTimeWorkRequestBuilder<WorkerA>().build()\nval workB = OneTimeWorkRequestBuilder<WorkerB>().build()\nval workC = OneTimeWorkRequestBuilder<WorkerC>().build()\n\nworkManager\n    .beginWith(listOf(workA, workB)) // Run in parallel\n    .then(workC) // Run after both complete\n    .enqueue()\n\n// 7. Unique Work (prevent duplicates)\nworkManager.enqueueUniqueWork(\n    \"upload_work\",\n    ExistingWorkPolicy.KEEP, // or REPLACE, APPEND, APPEND_OR_REPLACE\n    uploadWorkRequest\n)\n\n// 8. Cancel Work\n// By ID\nworkManager.cancelWorkById(uploadWorkRequest.id)\n\n// By tag\nworkManager.cancelAllWorkByTag(\"upload\")\n\n// By unique name\nworkManager.cancelUniqueWork(\"upload_work\")\n\n// Cancel all\nworkManager.cancelAllWork()\n\n// 9. ForegroundWorker for long-running work\nclass DownloadForegroundWorker(context: Context, params: WorkerParameters)\n    : CoroutineWorker(context, params) {\n    \n    override suspend fun doWork(): Result {\n        // Show foreground notification\n        setForeground(createForegroundInfo())\n        \n        // Perform long-running work\n        downloadLargeFile()\n        \n        return Result.success()\n    }\n    \n    private fun createForegroundInfo(): ForegroundInfo {\n        val notification = NotificationCompat.Builder(\n            applicationContext,\n            CHANNEL_ID\n        )\n            .setContentTitle(\"Downloading\")\n            .setContentText(\"Download in progress\")\n            .setSmallIcon(R.drawable.download_icon)\n            .setOngoing(true)\n            .build()\n        \n        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\n            ForegroundInfo(\n                NOTIFICATION_ID,\n                notification,\n                ServiceInfo.FOREGROUND_SERVICE_TYPE_DATA_SYNC\n            )\n        } else {\n            ForegroundInfo(NOTIFICATION_ID, notification)\n        }\n    }\n    \n    private suspend fun downloadLargeFile() {\n        // Long-running download\n    }\n}\n\n// 10. Testing WorkManager\nclass UploadWorkerTest {\n    private lateinit var context: Context\n    private lateinit var executor: Executor\n    \n    @Before\n    fun setup() {\n        context = ApplicationProvider.getApplicationContext()\n        executor = Executors.newSingleThreadExecutor()\n        \n        // Initialize WorkManager for tests\n        val config = Configuration.Builder()\n            .setMinimumLoggingLevel(Log.DEBUG)\n            .setExecutor(executor)\n            .build()\n        \n        WorkManagerTestInitHelper.initializeTestWorkManager(context, config)\n    }\n    \n    @Test\n    fun testUploadWorker() {\n        // Create request\n        val request = OneTimeWorkRequestBuilder<UploadWorker>()\n            .setInputData(workDataOf(\"image_uri\" to \"test_uri\"))\n            .build()\n        \n        val workManager = WorkManager.getInstance(context)\n        \n        // Enqueue and wait\n        workManager.enqueue(request).result.get()\n        \n        // Get work info\n        val workInfo = workManager.getWorkInfoById(request.id).get()\n        \n        // Assert\n        assertThat(workInfo.state).isEqualTo(WorkInfo.State.SUCCEEDED)\n    }\n    \n    @Test\n    fun testPeriodicWork() {\n        // Use TestDriver\n        val testDriver = WorkManagerTestInitHelper.getTestDriver(context)!!\n        \n        val request = PeriodicWorkRequestBuilder<SyncWorker>(\n            15, TimeUnit.MINUTES\n        ).build()\n        \n        workManager.enqueue(request).result.get()\n        \n        // Simulate periodic interval\n        testDriver.setPeriodDelayMet(request.id)\n        \n        val workInfo = workManager.getWorkInfoById(request.id).get()\n        assertThat(workInfo.state).isEqualTo(WorkInfo.State.ENQUEUED)\n    }\n}"
    },
    {
      "id": 73,
      "question": "What is Android Jetpack Compose?",
      "answer": "Jetpack Compose is Android's modern declarative UI toolkit for building native interfaces using Kotlin.\n\nKey Features:\n• Declarative UI\n• Less boilerplate code\n• Reactive programming\n• Kotlin-based\n• Interoperable with Views\n• Material Design 3 support\n\nCore Concepts:\n• Composable functions\n• State management\n• Recomposition\n• Side effects\n• Modifiers\n• Layouts\n\nBenefits:\n• Faster development\n• Less code\n• Intuitive API\n• Easy animations\n• Better performance\n• Type-safe\n\nState Management:\n• remember - Persist across recomposition\n• mutableStateOf - Observable state\n• rememberSaveable - Survive config changes\n• ViewModel integration\n\nCompose vs Views:\n• Compose - Declarative, less code\n• Views - Imperative, XML layouts\n• Compose - Better performance\n• Views - Mature ecosystem\n\nMigration:\n• Incremental adoption\n• ComposeView in XML\n• AndroidView in Compose\n• Gradual replacement",
      "explanation": "Jetpack Compose is a declarative UI toolkit using Kotlin composable functions for building reactive interfaces with less code, better performance, and seamless Material Design 3 integration, replacing traditional XML layouts.",
      "difficulty": "Hard",
      "code": "// 1. Setup Compose (build.gradle)\nandroid {\n    buildFeatures {\n        compose = true\n    }\n    \n    composeOptions {\n        kotlinCompilerExtensionVersion = \"1.4.3\"\n    }\n}\n\ndependencies {\n    implementation \"androidx.compose.ui:ui:1.4.0\"\n    implementation \"androidx.compose.material3:material3:1.1.0\"\n    implementation \"androidx.compose.ui:ui-tooling-preview:1.4.0\"\n    implementation \"androidx.activity:activity-compose:1.7.0\"\n    implementation \"androidx.lifecycle:lifecycle-viewmodel-compose:2.6.0\"\n    \n    debugImplementation \"androidx.compose.ui:ui-tooling:1.4.0\"\n}\n\n// 2. Basic Composable\n@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\")\n}\n\n// Activity setup\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyAppTheme {\n                Greeting(name = \"Android\")\n            }\n        }\n    }\n}\n\n// 3. State Management\n@Composable\nfun Counter() {\n    // remember - survives recomposition\n    var count by remember { mutableStateOf(0) }\n    \n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(16.dp),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Center\n    ) {\n        Text(\n            text = \"Count: $count\",\n            style = MaterialTheme.typography.headlineMedium\n        )\n        \n        Spacer(modifier = Modifier.height(16.dp))\n        \n        Button(onClick = { count++ }) {\n            Text(\"Increment\")\n        }\n    }\n}\n\n// 4. rememberSaveable - survives configuration changes\n@Composable\nfun TextFieldExample() {\n    var text by rememberSaveable { mutableStateOf(\"\") }\n    \n    TextField(\n        value = text,\n        onValueChange = { text = it },\n        label = { Text(\"Enter text\") }\n    )\n}\n\n// 5. ViewModel integration\nclass UserViewModel : ViewModel() {\n    private val _users = MutableStateFlow<List<User>>(emptyList())\n    val users: StateFlow<List<User>> = _users.asStateFlow()\n    \n    fun loadUsers() {\n        viewModelScope.launch {\n            _users.value = repository.getUsers()\n        }\n    }\n}\n\n@Composable\nfun UserScreen(viewModel: UserViewModel = viewModel()) {\n    val users by viewModel.users.collectAsState()\n    \n    LaunchedEffect(Unit) {\n        viewModel.loadUsers()\n    }\n    \n    LazyColumn {\n        items(users) { user ->\n            UserItem(user)\n        }\n    }\n}\n\n// 6. Layouts\n@Composable\nfun LayoutExamples() {\n    // Column - Vertical\n    Column {\n        Text(\"First\")\n        Text(\"Second\")\n    }\n    \n    // Row - Horizontal\n    Row {\n        Text(\"Left\")\n        Text(\"Right\")\n    }\n    \n    // Box - Stack\n    Box {\n        Image(painter = painterResource(R.drawable.bg), contentDescription = null)\n        Text(\"Overlay Text\")\n    }\n    \n    // LazyColumn - RecyclerView equivalent\n    LazyColumn {\n        items(100) { index ->\n            Text(\"Item $index\")\n        }\n    }\n    \n    // LazyRow - Horizontal scrolling\n    LazyRow {\n        items(items) { item ->\n            ItemCard(item)\n        }\n    }\n}\n\n// 7. Modifiers\n@Composable\nfun ModifierExample() {\n    Text(\n        text = \"Styled Text\",\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(16.dp)\n            .background(Color.Blue)\n            .clickable { /* Handle click */ }\n            .border(2.dp, Color.Black)\n            .clip(RoundedCornerShape(8.dp))\n    )\n}\n\n// 8. Side Effects\n@Composable\nfun SideEffectsExample() {\n    // LaunchedEffect - runs when key changes\n    LaunchedEffect(userId) {\n        loadUserData(userId)\n    }\n    \n    // DisposableEffect - cleanup on leave\n    DisposableEffect(Unit) {\n        val listener = LocationListener { }\n        locationManager.requestUpdates(listener)\n        \n        onDispose {\n            locationManager.removeUpdates(listener)\n        }\n    }\n    \n    // SideEffect - runs on every recomposition\n    SideEffect {\n        analytics.log(\"Screen viewed\")\n    }\n}\n\n// 9. Compose with existing Views\n// ComposeView in XML\n<androidx.compose.ui.platform.ComposeView\n    android:id=\"@+id/composeView\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\" />\n\n// In Activity/Fragment\nval composeView = findViewById<ComposeView>(R.id.composeView)\ncomposeView.setContent {\n    MyAppTheme {\n        Greeting(name = \"World\")\n    }\n}\n\n// AndroidView in Compose\n@Composable\nfun WebViewComposable(url: String) {\n    AndroidView(\n        factory = { context ->\n            WebView(context).apply {\n                settings.javaScriptEnabled = true\n                loadUrl(url)\n            }\n        },\n        update = { webView ->\n            webView.loadUrl(url)\n        }\n    )\n}\n\n// 10. Navigation\nimplementation \"androidx.navigation:navigation-compose:2.5.3\"\n\n@Composable\nfun AppNavigation() {\n    val navController = rememberNavController()\n    \n    NavHost(navController = navController, startDestination = \"home\") {\n        composable(\"home\") {\n            HomeScreen(\n                onNavigateToDetail = { id ->\n                    navController.navigate(\"detail/$id\")\n                }\n            )\n        }\n        \n        composable(\n            \"detail/{userId}\",\n            arguments = listOf(navArgument(\"userId\") { type = NavType.StringType })\n        ) { backStackEntry ->\n            val userId = backStackEntry.arguments?.getString(\"userId\")\n            DetailScreen(userId = userId)\n        }\n    }\n}\n\n// 11. Material Design 3\n@Composable\nfun MaterialDesign3Example() {\n    MaterialTheme(\n        colorScheme = dynamicColorScheme(LocalContext.current),\n        typography = Typography,\n        shapes = Shapes\n    ) {\n        Scaffold(\n            topBar = {\n                TopAppBar(title = { Text(\"My App\") })\n            },\n            floatingActionButton = {\n                FloatingActionButton(onClick = { /* Action */ }) {\n                    Icon(Icons.Default.Add, contentDescription = \"Add\")\n                }\n            }\n        ) { paddingValues ->\n            Content(modifier = Modifier.padding(paddingValues))\n        }\n    }\n}\n\n// 12. Animations\n@Composable\nfun AnimationExample() {\n    var expanded by remember { mutableStateOf(false) }\n    \n    val size by animateDpAsState(\n        targetValue = if (expanded) 200.dp else 100.dp,\n        animationSpec = spring(\n            dampingRatio = Spring.DampingRatioMediumBouncy,\n            stiffness = Spring.StiffnessLow\n        )\n    )\n    \n    Box(\n        modifier = Modifier\n            .size(size)\n            .background(Color.Blue)\n            .clickable { expanded = !expanded }\n    )\n}\n\n// 13. Lists with LazyColumn\n@Composable\nfun UserList(users: List<User>) {\n    LazyColumn {\n        items(\n            items = users,\n            key = { user -> user.id }\n        ) { user ->\n            UserItem(\n                user = user,\n                modifier = Modifier.animateItemPlacement()\n            )\n        }\n    }\n}\n\n@Composable\nfun UserItem(user: User, modifier: Modifier = Modifier) {\n    Row(\n        modifier = modifier\n            .fillMaxWidth()\n            .clickable { /* Handle click */ }\n            .padding(16.dp),\n        verticalAlignment = Alignment.CenterVertically\n    ) {\n        AsyncImage(\n            model = user.avatarUrl,\n            contentDescription = null,\n            modifier = Modifier\n                .size(48.dp)\n                .clip(CircleShape)\n        )\n        \n        Spacer(modifier = Modifier.width(16.dp))\n        \n        Column {\n            Text(\n                text = user.name,\n                style = MaterialTheme.typography.bodyLarge\n            )\n            Text(\n                text = user.email,\n                style = MaterialTheme.typography.bodyMedium\n            )\n        }\n    }\n}"
    },
    {
      "id": 74,
      "question": "What is Android App Performance Optimization?",
      "answer": "Performance optimization ensures smooth, responsive apps through efficient resource usage and optimized code execution.\n\nKey Areas:\n• CPU optimization\n• Memory management\n• Network efficiency\n• Battery optimization\n• Rendering performance\n• Storage I/O\n\nCPU Optimization:\n• Avoid main thread blocking\n• Use background threads\n• Optimize algorithms\n• Reduce computational complexity\n• Profile method execution\n• Cache results\n\nMemory Management:\n• Avoid memory leaks\n• Use weak references\n• Optimize bitmaps\n• Release resources\n• Monitor memory usage\n• Use memory profiler\n\nRendering:\n• Reduce overdraw\n• Flatten view hierarchy\n• Use ConstraintLayout\n• RecyclerView optimization\n• Hardware acceleration\n• Avoid layout inflation\n\nNetwork:\n• Batch requests\n• Compress data\n• Cache responses\n• Use efficient protocols\n• Prefetch data\n• Handle offline scenarios\n\nTools:\n• Android Profiler\n• Layout Inspector\n• LeakCanary\n• StrictMode\n• Systrace\n• Benchmark library",
      "explanation": "Android Performance optimization involves efficient CPU usage through background threading, memory management to prevent leaks, reducing overdraw, network batching with caching, and using profiling tools to identify bottlenecks.",
      "difficulty": "Hard",
      "code": "// 1. Memory Leak Prevention\n// BAD - Memory leak\nclass MainActivity : AppCompatActivity() {\n    private lateinit var handler: Handler\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        \n        handler = Handler(Looper.getMainLooper())\n        handler.postDelayed({\n            // Activity reference held even after destroy\n            updateUI()\n        }, 10000)\n    }\n}\n\n// GOOD - Use weak reference\nclass MainActivity : AppCompatActivity() {\n    private val handler = Handler(Looper.getMainLooper())\n    \n    private val updateRunnable = Runnable {\n        updateUI()\n    }\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        handler.postDelayed(updateRunnable, 10000)\n    }\n    \n    override fun onDestroy() {\n        super.onDestroy()\n        handler.removeCallbacks(updateRunnable)\n    }\n}\n\n// 2. LeakCanary for detecting leaks\nimplementation 'com.squareup.leakcanary:leakcanary-android:2.10'\n\n// Automatically detects leaks in debug builds\n\n// 3. Bitmap optimization\nfun loadOptimizedBitmap(path: String, reqWidth: Int, reqHeight: Int): Bitmap {\n    return BitmapFactory.Options().run {\n        // First decode with inJustDecodeBounds=true\n        inJustDecodeBounds = true\n        BitmapFactory.decodeFile(path, this)\n        \n        // Calculate inSampleSize\n        inSampleSize = calculateInSampleSize(this, reqWidth, reqHeight)\n        \n        // Decode with inSampleSize\n        inJustDecodeBounds = false\n        BitmapFactory.decodeFile(path, this)\n    }\n}\n\nfun calculateInSampleSize(\n    options: BitmapFactory.Options,\n    reqWidth: Int,\n    reqHeight: Int\n): Int {\n    val (height: Int, width: Int) = options.run { outHeight to outWidth }\n    var inSampleSize = 1\n    \n    if (height > reqHeight || width > reqWidth) {\n        val halfHeight: Int = height / 2\n        val halfWidth: Int = width / 2\n        \n        while (halfHeight / inSampleSize >= reqHeight && \n               halfWidth / inSampleSize >= reqWidth) {\n            inSampleSize *= 2\n        }\n    }\n    \n    return inSampleSize\n}\n\n// 4. RecyclerView optimization\nclass MyAdapter : RecyclerView.Adapter<MyViewHolder>() {\n    init {\n        // Enable stable IDs for better performance\n        setHasStableIds(true)\n    }\n    \n    override fun getItemId(position: Int): Long {\n        return items[position].id\n    }\n    \n    override fun onBindViewHolder(holder: MyViewHolder, position: Int) {\n        // Bind data efficiently\n        holder.bind(items[position])\n    }\n}\n\n// ViewHolder with ViewBinding\nclass MyViewHolder(private val binding: ItemBinding) : \n    RecyclerView.ViewHolder(binding.root) {\n    \n    fun bind(item: Item) {\n        binding.apply {\n            title.text = item.title\n            // Use image loading library for efficient loading\n            Glide.with(itemView)\n                .load(item.imageUrl)\n                .placeholder(R.drawable.placeholder)\n                .into(image)\n        }\n    }\n}\n\n// RecyclerView setup\nrecyclerView.apply {\n    // Set fixed size for performance\n    setHasFixedSize(true)\n    \n    // Use appropriate layout manager\n    layoutManager = LinearLayoutManager(context)\n    \n    // Item animator optimization\n    (itemAnimator as SimpleItemAnimator).supportsChangeAnimations = false\n    \n    // RecycledViewPool for nested RecyclerViews\n    val viewPool = RecycledViewPool()\n    setRecycledViewPool(viewPool)\n}\n\n// 5. Network caching with OkHttp\nval cacheSize = 10 * 1024 * 1024 // 10 MB\nval cache = Cache(context.cacheDir, cacheSize.toLong())\n\nval client = OkHttpClient.Builder()\n    .cache(cache)\n    .addNetworkInterceptor { chain ->\n        val response = chain.proceed(chain.request())\n        val cacheControl = CacheControl.Builder()\n            .maxAge(1, TimeUnit.HOURS)\n            .build()\n        response.newBuilder()\n            .header(\"Cache-Control\", cacheControl.toString())\n            .build()\n    }\n    .build()\n\n// 6. Background threading with Coroutines\nclass UserRepository {\n    suspend fun loadUsers(): List<User> = withContext(Dispatchers.IO) {\n        // Network/Database operation\n        api.getUsers()\n    }\n}\n\nclass UserViewModel : ViewModel() {\n    private val _users = MutableLiveData<List<User>>()\n    val users: LiveData<List<User>> = _users\n    \n    fun loadUsers() {\n        viewModelScope.launch {\n            try {\n                val userList = repository.loadUsers()\n                _users.value = userList\n            } catch (e: Exception) {\n                // Handle error\n            }\n        }\n    }\n}\n\n// 7. Database optimization with Room\n@Dao\ninterface UserDao {\n    // Use Flow for reactive updates\n    @Query(\"SELECT * FROM users\")\n    fun getAllUsersFlow(): Flow<List<User>>\n    \n    // Batch insert for better performance\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertAll(users: List<User>)\n    \n    // Use indices for faster queries\n    @Query(\"SELECT * FROM users WHERE email = :email\")\n    suspend fun getUserByEmail(email: String): User?\n}\n\n@Entity(\n    tableName = \"users\",\n    indices = [Index(value = [\"email\"], unique = true)]\n)\ndata class User(\n    @PrimaryKey val id: Int,\n    val name: String,\n    val email: String\n)\n\n// 8. StrictMode for development\nif (BuildConfig.DEBUG) {\n    StrictMode.setThreadPolicy(\n        StrictMode.ThreadPolicy.Builder()\n            .detectDiskReads()\n            .detectDiskWrites()\n            .detectNetwork()\n            .penaltyLog()\n            .penaltyFlashScreen()\n            .build()\n    )\n    \n    StrictMode.setVmPolicy(\n        StrictMode.VmPolicy.Builder()\n            .detectLeakedSqlLiteObjects()\n            .detectLeakedClosableObjects()\n            .detectActivityLeaks()\n            .penaltyLog()\n            .build()\n    )\n}\n\n// 9. Lazy Loading and Pagination\nclass UserPagingSource : PagingSource<Int, User>() {\n    override suspend fun load(params: LoadParams<Int>): LoadResult<Int, User> {\n        return try {\n            val page = params.key ?: 1\n            val response = api.getUsers(page, params.loadSize)\n            \n            LoadResult.Page(\n                data = response.users,\n                prevKey = if (page == 1) null else page - 1,\n                nextKey = if (response.users.isEmpty()) null else page + 1\n            )\n        } catch (e: Exception) {\n            LoadResult.Error(e)\n        }\n    }\n    \n    override fun getRefreshKey(state: PagingState<Int, User>): Int? {\n        return state.anchorPosition\n    }\n}\n\nclass UserViewModel : ViewModel() {\n    val users: Flow<PagingData<User>> = Pager(\n        config = PagingConfig(\n            pageSize = 20,\n            enablePlaceholders = false,\n            prefetchDistance = 5\n        ),\n        pagingSourceFactory = { UserPagingSource() }\n    ).flow.cachedIn(viewModelScope)\n}\n\n// 10. Profiling and Benchmarking\nimplementation 'androidx.benchmark:benchmark-junit4:1.1.1'\n\n@RunWith(AndroidJUnit4::class)\nclass BenchmarkTest {\n    @get:Rule\n    val benchmarkRule = BenchmarkRule()\n    \n    @Test\n    fun benchmarkSort() {\n        val list = List(10000) { Random.nextInt() }\n        \n        benchmarkRule.measureRepeated {\n            list.sorted()\n        }\n    }\n}\n\n// 11. View optimization\n// Use ViewStub for conditional views\n<ViewStub\n    android:id=\"@+id/detailsStub\"\n    android:layout=\"@layout/details\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\" />\n\n// Inflate only when needed\nval viewStub = findViewById<ViewStub>(R.id.detailsStub)\nval inflatedView = viewStub.inflate()\n\n// 12. Reduce overdraw\n// Check overdraw: Developer Options > Debug GPU Overdraw\n// Use opaque backgrounds\nwindow.decorView.setBackgroundColor(Color.WHITE)\n\n// Remove unnecessary backgrounds\n<LinearLayout\n    android:background=\"@null\">\n    \n// 13. Battery optimization\nfun scheduleEfficientWork() {\n    val constraints = Constraints.Builder()\n        .setRequiredNetworkType(NetworkType.CONNECTED)\n        .setRequiresBatteryNotLow(true)\n        .setRequiresDeviceIdle(true) // Only when device idle\n        .build()\n    \n    val workRequest = OneTimeWorkRequestBuilder<SyncWorker>()\n        .setConstraints(constraints)\n        .build()\n    \n    WorkManager.getInstance(context).enqueue(workRequest)\n}"
    },
    {
      "id": 75,
      "question": "What is Android CI/CD and Build Automation?",
      "answer": "CI/CD (Continuous Integration/Continuous Deployment) automates building, testing, and deploying Android apps for faster releases.\n\nKey Components:\n• Build automation\n• Automated testing\n• Code quality checks\n• Artifact generation\n• Deployment automation\n• Release management\n\nPopular Tools:\n• GitHub Actions\n• GitLab CI\n• Jenkins\n• Bitrise\n• CircleCI\n• Fastlane\n\nBuild Process:\n• Code compilation\n• Resource processing\n• DEX conversion\n• APK/AAB generation\n• Signing\n• Alignment\n\nAutomated Testing:\n• Unit tests\n• Integration tests\n• UI tests\n• Lint checks\n• Code coverage\n\nDeployment:\n• Internal testing\n• Alpha/Beta releases\n• Production rollout\n• Play Store publishing\n• Firebase App Distribution\n\nBest Practices:\n• Version control\n• Branch strategies\n• Automated versioning\n• Secure credential storage\n• Build caching\n• Parallel execution",
      "explanation": "Android CI/CD automates the build-test-deploy pipeline using tools like GitHub Actions and Fastlane, enabling automated testing, code quality checks, APK/AAB generation, signing, and Play Store deployment.",
      "difficulty": "Hard",
      "code": "// 1. GitHub Actions workflow (.github/workflows/android.yml)\nname: Android CI\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Set up JDK 17\n      uses: actions/setup-java@v3\n      with:\n        java-version: '17'\n        distribution: 'temurin'\n        cache: gradle\n    \n    - name: Grant execute permission for gradlew\n      run: chmod +x gradlew\n    \n    - name: Run Lint\n      run: ./gradlew lintDebug\n    \n    - name: Run Unit Tests\n      run: ./gradlew testDebugUnitTest\n    \n    - name: Run Instrumentation Tests\n      uses: reactivecircus/android-emulator-runner@v2\n      with:\n        api-level: 29\n        script: ./gradlew connectedDebugAndroidTest\n    \n    - name: Build Debug APK\n      run: ./gradlew assembleDebug\n    \n    - name: Upload APK\n      uses: actions/upload-artifact@v3\n      with:\n        name: app-debug\n        path: app/build/outputs/apk/debug/app-debug.apk\n    \n    - name: Generate Code Coverage\n      run: ./gradlew jacocoTestReport\n    \n    - name: Upload Coverage to Codecov\n      uses: codecov/codecov-action@v3\n      with:\n        files: ./app/build/reports/jacoco/jacocoTestReport/jacocoTestReport.xml\n\n  release:\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'\n    needs: build\n    \n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Set up JDK 17\n      uses: actions/setup-java@v3\n      with:\n        java-version: '17'\n        distribution: 'temurin'\n    \n    - name: Decode Keystore\n      run: |\n        echo \"${{ secrets.KEYSTORE_BASE64 }}\" | base64 --decode > release.keystore\n    \n    - name: Build Release AAB\n      run: ./gradlew bundleRelease\n      env:\n        KEYSTORE_FILE: ../release.keystore\n        KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}\n        KEY_ALIAS: ${{ secrets.KEY_ALIAS }}\n        KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}\n    \n    - name: Upload to Play Store\n      uses: r0adkll/upload-google-play@v1\n      with:\n        serviceAccountJsonPlainText: ${{ secrets.SERVICE_ACCOUNT_JSON }}\n        packageName: com.example.app\n        releaseFiles: app/build/outputs/bundle/release/app-release.aab\n        track: internal\n        status: completed\n\n// 2. Gradle configuration for signing (app/build.gradle)\nandroid {\n    signingConfigs {\n        release {\n            storeFile file(System.getenv(\"KEYSTORE_FILE\") ?: \"release.keystore\")\n            storePassword System.getenv(\"KEYSTORE_PASSWORD\")\n            keyAlias System.getenv(\"KEY_ALIAS\")\n            keyPassword System.getenv(\"KEY_PASSWORD\")\n        }\n    }\n    \n    buildTypes {\n        release {\n            minifyEnabled true\n            shrinkResources true\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n            signingConfig signingConfigs.release\n        }\n    }\n}\n\n// 3. Automated versioning\nandroid {\n    defaultConfig {\n        // Automatic version code from git commits\n        versionCode getVersionCode()\n        // Semantic versioning\n        versionName \"1.0.${getVersionCode()}\"\n    }\n}\n\ndef getVersionCode() {\n    def stdout = new ByteArrayOutputStream()\n    exec {\n        commandLine 'git', 'rev-list', '--count', 'HEAD'\n        standardOutput = stdout\n    }\n    return Integer.parseInt(stdout.toString().trim())\n}\n\n// 4. Fastlane setup (fastlane/Fastfile)\ndefault_platform(:android)\n\nplatform :android do\n  desc \"Build debug and run tests\"\n  lane :test do\n    gradle(task: \"clean\")\n    gradle(task: \"test\")\n    gradle(task: \"lint\")\n  end\n  \n  desc \"Build and deploy to Internal Testing\"\n  lane :internal do\n    gradle(\n      task: \"bundle\",\n      build_type: \"Release\"\n    )\n    \n    upload_to_play_store(\n      track: \"internal\",\n      aab: \"app/build/outputs/bundle/release/app-release.aab\",\n      skip_upload_screenshots: true,\n      skip_upload_images: true\n    )\n  end\n  \n  desc \"Deploy to Beta\"\n  lane :beta do\n    gradle(task: \"bundle\", build_type: \"Release\")\n    \n    upload_to_play_store(\n      track: \"beta\",\n      aab: \"app/build/outputs/bundle/release/app-release.aab\"\n    )\n    \n    # Notify team\n    slack(\n      message: \"New beta version released!\",\n      channel: \"#releases\"\n    )\n  end\n  \n  desc \"Deploy to Production\"\n  lane :production do\n    gradle(task: \"bundle\", build_type: \"Release\")\n    \n    upload_to_play_store(\n      track: \"production\",\n      aab: \"app/build/outputs/bundle/release/app-release.aab\",\n      rollout: \"0.1\" # 10% rollout\n    )\n  end\nend\n\n// 5. GitLab CI (.gitlab-ci.yml)\nimage: openjdk:17-jdk\n\nvariables:\n  ANDROID_COMPILE_SDK: \"33\"\n  ANDROID_BUILD_TOOLS: \"33.0.0\"\n  ANDROID_SDK_TOOLS: \"9477386\"\n\nbefore_script:\n  - apt-get --quiet update --yes\n  - apt-get --quiet install --yes wget unzip\n  - export ANDROID_HOME=\"${PWD}/android-sdk-root\"\n  - wget --quiet --output-document=android-sdk.zip https://dl.google.com/android/repository/commandlinetools-linux-${ANDROID_SDK_TOOLS}_latest.zip\n  - unzip -d $ANDROID_HOME android-sdk.zip\n  - echo y | $ANDROID_HOME/cmdline-tools/bin/sdkmanager --sdk_root=$ANDROID_HOME \"platforms;android-${ANDROID_COMPILE_SDK}\"\n  - echo y | $ANDROID_HOME/cmdline-tools/bin/sdkmanager --sdk_root=$ANDROID_HOME \"build-tools;${ANDROID_BUILD_TOOLS}\"\n  - export PATH=$PATH:$ANDROID_HOME/platform-tools/\n  - chmod +x ./gradlew\n\nstages:\n  - build\n  - test\n  - deploy\n\nbuild:debug:\n  stage: build\n  script:\n    - ./gradlew assembleDebug\n  artifacts:\n    paths:\n      - app/build/outputs/apk/debug/app-debug.apk\n\ntest:unit:\n  stage: test\n  script:\n    - ./gradlew test\n  artifacts:\n    reports:\n      junit: app/build/test-results/test/**/TEST-*.xml\n\nlint:\n  stage: test\n  script:\n    - ./gradlew lintDebug\n  artifacts:\n    paths:\n      - app/build/reports/lint-results-debug.html\n\ndeploy:internal:\n  stage: deploy\n  only:\n    - main\n  script:\n    - echo \"$KEYSTORE_BASE64\" | base64 -d > release.keystore\n    - ./gradlew bundleRelease\n    # Upload to Play Store\n  artifacts:\n    paths:\n      - app/build/outputs/bundle/release/app-release.aab\n\n// 6. Build variants for different environments\nandroid {\n    flavorDimensions \"environment\"\n    \n    productFlavors {\n        dev {\n            dimension \"environment\"\n            applicationIdSuffix \".dev\"\n            versionNameSuffix \"-dev\"\n            buildConfigField \"String\", \"API_URL\", '\"https://dev-api.example.com\"'\n        }\n        \n        staging {\n            dimension \"environment\"\n            applicationIdSuffix \".staging\"\n            versionNameSuffix \"-staging\"\n            buildConfigField \"String\", \"API_URL\", '\"https://staging-api.example.com\"'\n        }\n        \n        production {\n            dimension \"environment\"\n            buildConfigField \"String\", \"API_URL\", '\"https://api.example.com\"'\n        }\n    }\n}\n\n// 7. Firebase App Distribution (build.gradle)\nplugins {\n    id 'com.google.firebase.appdistribution'\n}\n\nfirebaseAppDistribution {\n    releaseNotesFile = \"release-notes.txt\"\n    groups = \"testers\"\n    serviceCredentialsFile = \"firebase-credentials.json\"\n}\n\n// Deploy command\n// ./gradlew assembleRelease appDistributionUploadRelease\n\n// 8. Jacoco code coverage (build.gradle)\napply plugin: 'jacoco'\n\njacoco {\n    toolVersion = \"0.8.8\"\n}\n\ntasks.withType(Test) {\n    jacoco.includeNoLocationClasses = true\n    jacoco.excludes = ['jdk.internal.*']\n}\n\ntask jacocoTestReport(type: JacocoReport, dependsOn: ['testDebugUnitTest']) {\n    reports {\n        xml.required = true\n        html.required = true\n    }\n    \n    def fileFilter = [\n        '**/R.class',\n        '**/R$*.class',\n        '**/BuildConfig.*',\n        '**/Manifest*.*',\n        '**/*Test*.*',\n        'android/**/*.*'\n    ]\n    \n    def debugTree = fileTree(\n        dir: \"${buildDir}/intermediates/javac/debug\",\n        excludes: fileFilter\n    )\n    \n    def mainSrc = \"${project.projectDir}/src/main/java\"\n    \n    sourceDirectories.setFrom(files([mainSrc]))\n    classDirectories.setFrom(files([debugTree]))\n    executionData.setFrom(fileTree(\n        dir: buildDir,\n        includes: ['jacoco/testDebugUnitTest.exec']\n    ))\n}\n\n// 9. Slack notification script\ndef sendSlackNotification(String message) {\n    def webhookUrl = System.getenv(\"SLACK_WEBHOOK_URL\")\n    def payload = JsonOutput.toJson([\n        text: message,\n        username: \"CI Bot\",\n        icon_emoji: \":robot_face:\"\n    ])\n    \n    def connection = new URL(webhookUrl).openConnection()\n    connection.setRequestMethod(\"POST\")\n    connection.setDoOutput(true)\n    connection.setRequestProperty(\"Content-Type\", \"application/json\")\n    connection.outputStream.write(payload.bytes)\n    connection.inputStream.text\n}\n\n// 10. Complete release task\ntask releaseToPlayStore {\n    dependsOn 'clean', 'test', 'lint', 'bundleRelease'\n    \n    doLast {\n        println \"Uploading to Play Store...\"\n        // Upload logic\n        sendSlackNotification(\"New version released to Play Store! 🎉\")\n    }\n}"
    },
    {
      "id": 76,
      "question": "What is Android App Architecture best practices and patterns?",
      "answer": "Android Architecture patterns provide structured ways to organize code for maintainability, testability, and scalability.\n\nCommon Patterns:\n• MVVM (Model-View-ViewModel)\n• MVP (Model-View-Presenter)\n• MVI (Model-View-Intent)\n• Clean Architecture\n• Repository Pattern\n• Use Case Pattern\n\nMVVM Components:\n• Model - Data layer\n• View - UI layer (Activity/Fragment)\n• ViewModel - Business logic and state\n• LiveData/StateFlow - Observable data\n\nArchitecture Principles:\n• Separation of concerns\n• Single responsibility\n• Dependency injection\n• Unidirectional data flow\n• Testable components\n• Reactive programming\n\nLayers:\n• Presentation - UI and ViewModels\n• Domain - Business logic and Use Cases\n• Data - Repositories and Data Sources\n\nBest Practices:\n• No business logic in Activities\n• ViewModel doesn't hold View references\n• Repository as single source of truth\n• Use dependency injection\n• Handle configuration changes\n• Lifecycle awareness",
      "explanation": "Android Architecture patterns like MVVM with Clean Architecture separate concerns into Presentation, Domain, and Data layers, using ViewModels for business logic, Repositories for data management, and dependency injection for testability.",
      "difficulty": "Hard",
      "code": "// 1. Clean Architecture with MVVM - Project Structure\n/*\napp/\n├── data/\n│   ├── repository/\n│   │   └── UserRepositoryImpl.kt\n│   ├── remote/\n│   │   ├── api/\n│   │   │   └── UserApi.kt\n│   │   └── dto/\n│   │       └── UserDto.kt\n│   └── local/\n│       ├── dao/\n│       │   └── UserDao.kt\n│       └── entity/\n│           └── UserEntity.kt\n├── domain/\n│   ├── model/\n│   │   └── User.kt\n│   ├── repository/\n│   │   └── UserRepository.kt\n│   └── usecase/\n│       ├── GetUsersUseCase.kt\n│       └── SaveUserUseCase.kt\n└── presentation/\n    ├── ui/\n    │   ├── users/\n    │   │   ├── UsersFragment.kt\n    │   │   ├── UsersViewModel.kt\n    │   │   └── UsersAdapter.kt\n    │   └── detail/\n    │       ├── DetailFragment.kt\n    │       └── DetailViewModel.kt\n    └── common/\n        └── UiState.kt\n*/\n\n// 2. Domain Layer - Models\ndata class User(\n    val id: Int,\n    val name: String,\n    val email: String,\n    val avatarUrl: String\n)\n\n// 3. Domain Layer - Repository Interface\ninterface UserRepository {\n    suspend fun getUsers(): Result<List<User>>\n    suspend fun getUserById(id: Int): Result<User>\n    suspend fun saveUser(user: User): Result<Unit>\n    fun observeUsers(): Flow<List<User>>\n}\n\n// 4. Domain Layer - Use Cases\nclass GetUsersUseCase @Inject constructor(\n    private val repository: UserRepository\n) {\n    suspend operator fun invoke(): Result<List<User>> {\n        return repository.getUsers()\n    }\n}\n\nclass SaveUserUseCase @Inject constructor(\n    private val repository: UserRepository\n) {\n    suspend operator fun invoke(user: User): Result<Unit> {\n        // Add business logic/validation\n        if (user.name.isBlank()) {\n            return Result.failure(Exception(\"Name cannot be empty\"))\n        }\n        return repository.saveUser(user)\n    }\n}\n\n// 5. Data Layer - DTO (Data Transfer Object)\n@Serializable\ndata class UserDto(\n    @SerialName(\"id\")\n    val id: Int,\n    @SerialName(\"name\")\n    val name: String,\n    @SerialName(\"email\")\n    val email: String,\n    @SerialName(\"avatar\")\n    val avatarUrl: String\n)\n\n// Mapper\nfun UserDto.toDomain() = User(\n    id = id,\n    name = name,\n    email = email,\n    avatarUrl = avatarUrl\n)\n\n// 6. Data Layer - Entity (Database)\n@Entity(tableName = \"users\")\ndata class UserEntity(\n    @PrimaryKey val id: Int,\n    val name: String,\n    val email: String,\n    val avatarUrl: String\n)\n\n// Mapper\nfun UserEntity.toDomain() = User(\n    id = id,\n    name = name,\n    email = email,\n    avatarUrl = avatarUrl\n)\n\nfun User.toEntity() = UserEntity(\n    id = id,\n    name = name,\n    email = email,\n    avatarUrl = avatarUrl\n)\n\n// 7. Data Layer - API\ninterface UserApi {\n    @GET(\"users\")\n    suspend fun getUsers(): Response<List<UserDto>>\n    \n    @GET(\"users/{id}\")\n    suspend fun getUserById(@Path(\"id\") id: Int): Response<UserDto>\n    \n    @POST(\"users\")\n    suspend fun createUser(@Body user: UserDto): Response<UserDto>\n}\n\n// 8. Data Layer - DAO\n@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM users\")\n    fun getAllUsers(): Flow<List<UserEntity>>\n    \n    @Query(\"SELECT * FROM users WHERE id = :id\")\n    suspend fun getUserById(id: Int): UserEntity?\n    \n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertAll(users: List<UserEntity>)\n    \n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insert(user: UserEntity)\n}\n\n// 9. Data Layer - Repository Implementation\nclass UserRepositoryImpl @Inject constructor(\n    private val api: UserApi,\n    private val dao: UserDao,\n    private val ioDispatcher: CoroutineDispatcher = Dispatchers.IO\n) : UserRepository {\n    \n    override suspend fun getUsers(): Result<List<User>> = withContext(ioDispatcher) {\n        try {\n            // Try to fetch from network\n            val response = api.getUsers()\n            if (response.isSuccessful && response.body() != null) {\n                val users = response.body()!!.map { it.toDomain() }\n                \n                // Cache in database\n                dao.insertAll(users.map { it.toEntity() })\n                \n                Result.success(users)\n            } else {\n                // Fallback to cache\n                val cachedUsers = dao.getAllUsers().first().map { it.toDomain() }\n                if (cachedUsers.isNotEmpty()) {\n                    Result.success(cachedUsers)\n                } else {\n                    Result.failure(Exception(\"Failed to fetch users\"))\n                }\n            }\n        } catch (e: Exception) {\n            // Return cached data on error\n            val cachedUsers = dao.getAllUsers().first().map { it.toDomain() }\n            if (cachedUsers.isNotEmpty()) {\n                Result.success(cachedUsers)\n            } else {\n                Result.failure(e)\n            }\n        }\n    }\n    \n    override suspend fun getUserById(id: Int): Result<User> = withContext(ioDispatcher) {\n        try {\n            val response = api.getUserById(id)\n            if (response.isSuccessful && response.body() != null) {\n                val user = response.body()!!.toDomain()\n                dao.insert(user.toEntity())\n                Result.success(user)\n            } else {\n                // Fallback to cache\n                val cachedUser = dao.getUserById(id)?.toDomain()\n                if (cachedUser != null) {\n                    Result.success(cachedUser)\n                } else {\n                    Result.failure(Exception(\"User not found\"))\n                }\n            }\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n    \n    override suspend fun saveUser(user: User): Result<Unit> = withContext(ioDispatcher) {\n        try {\n            val dto = UserDto(\n                id = user.id,\n                name = user.name,\n                email = user.email,\n                avatarUrl = user.avatarUrl\n            )\n            val response = api.createUser(dto)\n            if (response.isSuccessful) {\n                dao.insert(user.toEntity())\n                Result.success(Unit)\n            } else {\n                Result.failure(Exception(\"Failed to save user\"))\n            }\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n    \n    override fun observeUsers(): Flow<List<User>> {\n        return dao.getAllUsers().map { entities ->\n            entities.map { it.toDomain() }\n        }\n    }\n}\n\n// 10. Presentation Layer - UI State\nsealed class UiState<out T> {\n    object Loading : UiState<Nothing>()\n    data class Success<T>(val data: T) : UiState<T>()\n    data class Error(val message: String) : UiState<Nothing>()\n}\n\n// 11. Presentation Layer - ViewModel\n@HiltViewModel\nclass UsersViewModel @Inject constructor(\n    private val getUsersUseCase: GetUsersUseCase,\n    private val saveUserUseCase: SaveUserUseCase\n) : ViewModel() {\n    \n    private val _uiState = MutableStateFlow<UiState<List<User>>>(UiState.Loading)\n    val uiState: StateFlow<UiState<List<User>>> = _uiState.asStateFlow()\n    \n    init {\n        loadUsers()\n    }\n    \n    fun loadUsers() {\n        viewModelScope.launch {\n            _uiState.value = UiState.Loading\n            \n            getUsersUseCase().fold(\n                onSuccess = { users ->\n                    _uiState.value = UiState.Success(users)\n                },\n                onFailure = { exception ->\n                    _uiState.value = UiState.Error(\n                        exception.message ?: \"Unknown error\"\n                    )\n                }\n            )\n        }\n    }\n    \n    fun saveUser(user: User) {\n        viewModelScope.launch {\n            saveUserUseCase(user).fold(\n                onSuccess = {\n                    loadUsers() // Refresh list\n                },\n                onFailure = { exception ->\n                    _uiState.value = UiState.Error(\n                        exception.message ?: \"Failed to save user\"\n                    )\n                }\n            )\n        }\n    }\n}\n\n// 12. Presentation Layer - Fragment\n@AndroidEntryPoint\nclass UsersFragment : Fragment() {\n    \n    private val viewModel: UsersViewModel by viewModels()\n    private var _binding: FragmentUsersBinding? = null\n    private val binding get() = _binding!!\n    private lateinit var adapter: UsersAdapter\n    \n    override fun onCreateView(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentUsersBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n    \n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        \n        setupRecyclerView()\n        observeUiState()\n        \n        binding.swipeRefresh.setOnRefreshListener {\n            viewModel.loadUsers()\n        }\n    }\n    \n    private fun setupRecyclerView() {\n        adapter = UsersAdapter { user ->\n            // Handle user click\n            navigateToDetail(user.id)\n        }\n        \n        binding.recyclerView.apply {\n            layoutManager = LinearLayoutManager(context)\n            adapter = this@UsersFragment.adapter\n        }\n    }\n    \n    private fun observeUiState() {\n        viewLifecycleOwner.lifecycleScope.launch {\n            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {\n                viewModel.uiState.collect { state ->\n                    binding.swipeRefresh.isRefreshing = false\n                    \n                    when (state) {\n                        is UiState.Loading -> {\n                            binding.progressBar.isVisible = true\n                            binding.recyclerView.isVisible = false\n                            binding.errorText.isVisible = false\n                        }\n                        is UiState.Success -> {\n                            binding.progressBar.isVisible = false\n                            binding.recyclerView.isVisible = true\n                            binding.errorText.isVisible = false\n                            adapter.submitList(state.data)\n                        }\n                        is UiState.Error -> {\n                            binding.progressBar.isVisible = false\n                            binding.recyclerView.isVisible = false\n                            binding.errorText.isVisible = true\n                            binding.errorText.text = state.message\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    private fun navigateToDetail(userId: Int) {\n        findNavController().navigate(\n            UsersFragmentDirections.actionUsersToDetail(userId)\n        )\n    }\n    \n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}\n\n// 13. Dependency Injection - Hilt Modules\n@Module\n@InstallIn(SingletonComponent::class)\nobject NetworkModule {\n    \n    @Provides\n    @Singleton\n    fun provideRetrofit(): Retrofit {\n        return Retrofit.Builder()\n            .baseUrl(\"https://api.example.com/\")\n            .addConverterFactory(GsonConverterFactory.create())\n            .build()\n    }\n    \n    @Provides\n    @Singleton\n    fun provideUserApi(retrofit: Retrofit): UserApi {\n        return retrofit.create(UserApi::class.java)\n    }\n}\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n    \n    @Provides\n    @Singleton\n    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n    \n    @Provides\n    fun provideUserDao(database: AppDatabase): UserDao {\n        return database.userDao()\n    }\n}\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject RepositoryModule {\n    \n    @Provides\n    @Singleton\n    fun provideUserRepository(\n        api: UserApi,\n        dao: UserDao\n    ): UserRepository {\n        return UserRepositoryImpl(api, dao)\n    }\n}\n\n// 14. Application class\n@HiltAndroidApp\nclass MyApplication : Application()"
    },
    {
      "id": 77,
      "question": "What is Testing in Android and testing strategies?",
      "answer": "Android Testing ensures app quality through automated verification of functionality, UI, and integration.\n\nTest Types:\n• Unit Tests - Test individual components\n• Integration Tests - Test component interaction\n• UI Tests - Test user interface\n• End-to-End Tests - Test complete flows\n\nTesting Frameworks:\n• JUnit - Unit testing\n• Mockito/MockK - Mocking\n• Espresso - UI testing\n• Robolectric - Android unit tests without emulator\n• Truth - Assertions\n\nTest Structure:\n• Arrange - Setup test data\n• Act - Execute test\n• Assert - Verify results\n\nUnit Testing:\n• Test ViewModels\n• Test Use Cases\n• Test Repositories\n• Fast execution\n• No Android dependencies\n\nInstrumentation Tests:\n• Run on device/emulator\n• Test UI components\n• Test Android framework\n• Slower execution\n\nTest Coverage:\n• Code coverage metrics\n• Branch coverage\n• Line coverage\n• JaCoCo reports\n\nBest Practices:\n• Write testable code\n• Use dependency injection\n• Mock external dependencies\n• Test edge cases\n• Maintain test pyramid",
      "explanation": "Android Testing includes Unit Tests for isolated components using JUnit/Mockito, UI Tests with Espresso for interface verification, and Integration Tests for component interaction, following the test pyramid with dependency injection.",
      "difficulty": "Hard",
      "code": "// 1. Unit Test for ViewModel\nclass UsersViewModelTest {\n    \n    @get:Rule\n    val instantExecutorRule = InstantTaskExecutorRule()\n    \n    @get:Rule\n    val mainCoroutineRule = MainCoroutineRule()\n    \n    private lateinit var viewModel: UsersViewModel\n    private lateinit var getUsersUseCase: GetUsersUseCase\n    private lateinit var repository: UserRepository\n    \n    @Before\n    fun setup() {\n        // Create mock repository\n        repository = mockk()\n        getUsersUseCase = GetUsersUseCase(repository)\n        viewModel = UsersViewModel(getUsersUseCase, mockk())\n    }\n    \n    @Test\n    fun `loadUsers should emit success state when repository returns data`() = \n        runTest {\n        // Arrange\n        val users = listOf(\n            User(1, \"John\", \"john@example.com\", \"avatar1.jpg\"),\n            User(2, \"Jane\", \"jane@example.com\", \"avatar2.jpg\")\n        )\n        coEvery { repository.getUsers() } returns Result.success(users)\n        \n        // Act\n        viewModel.loadUsers()\n        advanceUntilIdle()\n        \n        // Assert\n        val state = viewModel.uiState.value\n        assertTrue(state is UiState.Success)\n        assertEquals(users, (state as UiState.Success).data)\n    }\n    \n    @Test\n    fun `loadUsers should emit error state when repository fails`() = runTest {\n        // Arrange\n        val errorMessage = \"Network error\"\n        coEvery { repository.getUsers() } returns \n            Result.failure(Exception(errorMessage))\n        \n        // Act\n        viewModel.loadUsers()\n        advanceUntilIdle()\n        \n        // Assert\n        val state = viewModel.uiState.value\n        assertTrue(state is UiState.Error)\n        assertEquals(errorMessage, (state as UiState.Error).message)\n    }\n    \n    @Test\n    fun `loadUsers should emit loading state initially`() = runTest {\n        // Arrange\n        coEvery { repository.getUsers() } coAnswers {\n            delay(100)\n            Result.success(emptyList())\n        }\n        \n        // Act\n        viewModel.loadUsers()\n        \n        // Assert - check loading state before completion\n        assertEquals(UiState.Loading, viewModel.uiState.value)\n    }\n}\n\n// 2. Test Rule for Coroutines\nclass MainCoroutineRule(  \n    val testDispatcher: TestDispatcher = StandardTestDispatcher()\n) : TestWatcher() {\n    \n    override fun starting(description: Description) {\n        Dispatchers.setMain(testDispatcher)\n    }\n    \n    override fun finished(description: Description) {\n        Dispatchers.resetMain()\n    }\n}\n\n// 3. Unit Test for Use Case\nclass GetUsersUseCaseTest {\n    \n    private lateinit var useCase: GetUsersUseCase\n    private lateinit var repository: UserRepository\n    \n    @Before\n    fun setup() {\n        repository = mockk()\n        useCase = GetUsersUseCase(repository)\n    }\n    \n    @Test\n    fun `invoke should return users from repository`() = runTest {\n        // Arrange\n        val users = listOf(\n            User(1, \"John\", \"john@example.com\", \"avatar.jpg\")\n        )\n        coEvery { repository.getUsers() } returns Result.success(users)\n        \n        // Act\n        val result = useCase()\n        \n        // Assert\n        assertTrue(result.isSuccess)\n        assertEquals(users, result.getOrNull())\n        coVerify(exactly = 1) { repository.getUsers() }\n    }\n}\n\n// 4. Unit Test for Repository with Fakes\nclass UserRepositoryImplTest {\n    \n    private lateinit var repository: UserRepositoryImpl\n    private lateinit var api: UserApi\n    private lateinit var dao: UserDao\n    private val testDispatcher = StandardTestDispatcher()\n    \n    @Before\n    fun setup() {\n        api = mockk()\n        dao = FakeUserDao()\n        repository = UserRepositoryImpl(api, dao, testDispatcher)\n    }\n    \n    @Test\n    fun `getUsers should fetch from api and cache in database`() = runTest {\n        // Arrange\n        val userDtos = listOf(\n            UserDto(1, \"John\", \"john@example.com\", \"avatar.jpg\")\n        )\n        val response = Response.success(userDtos)\n        coEvery { api.getUsers() } returns response\n        \n        // Act\n        val result = repository.getUsers()\n        advanceUntilIdle()\n        \n        // Assert\n        assertTrue(result.isSuccess)\n        val cachedUsers = dao.getAllUsers().first()\n        assertEquals(1, cachedUsers.size)\n        assertEquals(\"John\", cachedUsers[0].name)\n    }\n    \n    @Test\n    fun `getUsers should return cached data when network fails`() = runTest {\n        // Arrange - populate cache\n        val cachedUser = UserEntity(1, \"John\", \"john@example.com\", \"avatar.jpg\")\n        dao.insert(cachedUser)\n        \n        // Network fails\n        coEvery { api.getUsers() } throws IOException(\"Network error\")\n        \n        // Act\n        val result = repository.getUsers()\n        advanceUntilIdle()\n        \n        // Assert\n        assertTrue(result.isSuccess)\n        val users = result.getOrNull()!!\n        assertEquals(1, users.size)\n        assertEquals(\"John\", users[0].name)\n    }\n}\n\n// 5. Fake DAO for testing\nclass FakeUserDao : UserDao {\n    private val users = mutableListOf<UserEntity>()\n    \n    override fun getAllUsers(): Flow<List<UserEntity>> = flow {\n        emit(users.toList())\n    }\n    \n    override suspend fun getUserById(id: Int): UserEntity? {\n        return users.find { it.id == id }\n    }\n    \n    override suspend fun insertAll(users: List<UserEntity>) {\n        this.users.clear()\n        this.users.addAll(users)\n    }\n    \n    override suspend fun insert(user: UserEntity) {\n        users.removeIf { it.id == user.id }\n        users.add(user)\n    }\n}\n\n// 6. Espresso UI Test\n@RunWith(AndroidJUnit4::class)\nclass UsersFragmentTest {\n    \n    @get:Rule\n    val hiltRule = HiltAndroidRule(this)\n    \n    @Before\n    fun setup() {\n        hiltRule.inject()\n    }\n    \n    @Test\n    fun displayUsers_whenDataLoaded() {\n        // Launch fragment in container\n        launchFragmentInHiltContainer<UsersFragment> {\n            // Fragment is now launched\n        }\n        \n        // Verify RecyclerView is displayed\n        onView(withId(R.id.recyclerView))\n            .check(matches(isDisplayed()))\n        \n        // Verify first item\n        onView(withId(R.id.recyclerView))\n            .perform(RecyclerViewActions.scrollToPosition<RecyclerView.ViewHolder>(0))\n        \n        onView(withText(\"John\"))\n            .check(matches(isDisplayed()))\n    }\n    \n    @Test\n    fun clickUser_navigatesToDetail() {\n        launchFragmentInHiltContainer<UsersFragment> {\n            // Setup navigation mock\n            val navController = mockk<NavController>(relaxed = true)\n            Navigation.setViewNavController(requireView(), navController)\n        }\n        \n        // Click first item\n        onView(withId(R.id.recyclerView))\n            .perform(\n                RecyclerViewActions.actionOnItemAtPosition<RecyclerView.ViewHolder>(\n                    0,\n                    click()\n                )\n            )\n        \n        // Verify navigation\n        verify {\n            navController.navigate(\n                any<NavDirections>()\n            )\n        }\n    }\n}\n\n// 7. Robolectric Test (Unit test with Android framework)\n@RunWith(RobolectricTestRunner::class)\nclass UserItemViewTest {\n    \n    private lateinit var context: Context\n    \n    @Before\n    fun setup() {\n        context = ApplicationProvider.getApplicationContext()\n    }\n    \n    @Test\n    fun userItem_displaysCorrectData() {\n        // Create user\n        val user = User(1, \"John Doe\", \"john@example.com\", \"avatar.jpg\")\n        \n        // Inflate layout\n        val view = LayoutInflater.from(context)\n            .inflate(R.layout.item_user, null, false)\n        \n        // Bind data\n        view.findViewById<TextView>(R.id.nameText).text = user.name\n        view.findViewById<TextView>(R.id.emailText).text = user.email\n        \n        // Assert\n        assertEquals(\"John Doe\", view.findViewById<TextView>(R.id.nameText).text)\n        assertEquals(\"john@example.com\", view.findViewById<TextView>(R.id.emailText).text)\n    }\n}\n\n// 8. Integration Test with In-Memory Database\n@RunWith(AndroidJUnit4::class)\nclass UserDaoTest {\n    \n    private lateinit var database: AppDatabase\n    private lateinit var userDao: UserDao\n    \n    @Before\n    fun setup() {\n        val context = ApplicationProvider.getApplicationContext<Context>()\n        database = Room.inMemoryDatabaseBuilder(\n            context,\n            AppDatabase::class.java\n        ).build()\n        userDao = database.userDao()\n    }\n    \n    @After\n    fun teardown() {\n        database.close()\n    }\n    \n    @Test\n    fun insertAndGetUser() = runTest {\n        // Insert user\n        val user = UserEntity(1, \"John\", \"john@example.com\", \"avatar.jpg\")\n        userDao.insert(user)\n        \n        // Get user\n        val retrieved = userDao.getUserById(1)\n        \n        // Assert\n        assertNotNull(retrieved)\n        assertEquals(\"John\", retrieved?.name)\n    }\n    \n    @Test\n    fun getAllUsers_returnsFlow() = runTest {\n        // Insert users\n        val users = listOf(\n            UserEntity(1, \"John\", \"john@example.com\", \"avatar1.jpg\"),\n            UserEntity(2, \"Jane\", \"jane@example.com\", \"avatar2.jpg\")\n        )\n        userDao.insertAll(users)\n        \n        // Collect flow\n        val result = userDao.getAllUsers().first()\n        \n        // Assert\n        assertEquals(2, result.size)\n        assertTrue(result.any { it.name == \"John\" })\n        assertTrue(result.any { it.name == \"Jane\" })\n    }\n}\n\n// 9. Test build.gradle dependencies\ndependencies {\n    // Unit testing\n    testImplementation 'junit:junit:4.13.2'\n    testImplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.1'\n    testImplementation 'io.mockk:mockk:1.13.5'\n    testImplementation 'com.google.truth:truth:1.1.3'\n    testImplementation 'androidx.arch.core:core-testing:2.2.0'\n    testImplementation 'org.robolectric:robolectric:4.10'\n    \n    // Instrumentation testing\n    androidTestImplementation 'androidx.test.ext:junit:1.1.5'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'\n    androidTestImplementation 'androidx.test:runner:1.5.2'\n    androidTestImplementation 'androidx.test:rules:1.5.0'\n    androidTestImplementation 'com.google.dagger:hilt-android-testing:2.44'\n    kaptAndroidTest 'com.google.dagger:hilt-android-compiler:2.44'\n}\n\n// 10. Custom Espresso Matchers\nfun withRecyclerView(recyclerViewId: Int): RecyclerViewMatcher {\n    return RecyclerViewMatcher(recyclerViewId)\n}\n\nclass RecyclerViewMatcher(private val recyclerViewId: Int) {\n    \n    fun atPosition(position: Int): Matcher<View> {\n        return atPositionOnView(position, -1)\n    }\n    \n    fun atPositionOnView(position: Int, targetViewId: Int): Matcher<View> {\n        return object : TypeSafeMatcher<View>() {\n            var resources: Resources? = null\n            var childView: View? = null\n            \n            override fun describeTo(description: Description) {\n                description.appendText(\"with id: $recyclerViewId at position: $position\")\n            }\n            \n            override fun matchesSafely(view: View): Boolean {\n                resources = view.resources\n                \n                val recyclerView = view.rootView.findViewById<RecyclerView>(recyclerViewId)\n                val viewHolder = recyclerView.findViewHolderForAdapterPosition(position)\n                    ?: return false\n                \n                childView = if (targetViewId == -1) {\n                    viewHolder.itemView\n                } else {\n                    viewHolder.itemView.findViewById(targetViewId)\n                }\n                \n                return view == childView\n            }\n        }\n    }\n}"
    },
    {
      "id": 78,
      "question": "What is Android Kotlin Coroutines and Flow?",
      "answer": "Kotlin Coroutines provide lightweight thread management for asynchronous programming with sequential code style.\n\nCoroutine Benefits:\n• Lightweight threads\n• Sequential async code\n• Structured concurrency\n• Cancellation support\n• Exception handling\n• Memory efficient\n\nCoroutine Builders:\n• launch - Fire and forget\n• async - Returns result (Deferred)\n• runBlocking - Blocks current thread\n• withContext - Switch context\n\nDispatchers:\n• Dispatchers.Main - UI thread\n• Dispatchers.IO - Network/Disk I/O\n• Dispatchers.Default - CPU-intensive\n• Dispatchers.Unconfined - No thread change\n\nFlow:\n• Cold asynchronous stream\n• Multiple emissions\n• Reactive programming\n• Transformation operators\n• Lifecycle aware\n\nFlow Operators:\n• map, filter, transform\n• collect, collectLatest\n• combine, zip, merge\n• debounce, distinctUntilChanged\n• flatMapConcat, flatMapMerge\n\nStateFlow/SharedFlow:\n• Hot streams\n• State holders\n• Multiple collectors\n• Replay capability",
      "explanation": "Kotlin Coroutines enable asynchronous programming with sequential code using suspend functions and Dispatchers for thread management, while Flow provides reactive streams with operators for transforming and collecting data lifecycle-aware.",
      "difficulty": "Hard",
      "code": "// 1. Basic Coroutine\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        \n        // Launch coroutine in lifecycle scope\n        lifecycleScope.launch {\n            val result = fetchData()\n            updateUI(result)\n        }\n    }\n    \n    private suspend fun fetchData(): String = withContext(Dispatchers.IO) {\n        delay(1000)\n        \"Data loaded\"\n    }\n    \n    private fun updateUI(result: String) {\n        textView.text = result\n    }\n}\n\n// 2. Async/Await for parallel execution\nsuspend fun loadUserData() = coroutineScope {\n    val userDeferred = async { fetchUser() }\n    val postsDeferred = async { fetchPosts() }\n    val friendsDeferred = async { fetchFriends() }\n    \n    val user = userDeferred.await()\n    val posts = postsDeferred.await()\n    val friends = friendsDeferred.await()\n    \n    UserData(user, posts, friends)\n}\n\nprivate suspend fun fetchUser(): User = withContext(Dispatchers.IO) {\n    delay(500)\n    User(1, \"John\")\n}\n\nprivate suspend fun fetchPosts(): List<Post> = withContext(Dispatchers.IO) {\n    delay(500)\n    listOf(Post(1, \"Hello\"))\n}\n\nprivate suspend fun fetchFriends(): List<User> = withContext(Dispatchers.IO) {\n    delay(500)\n    emptyList()\n}\n\n// 3. ViewModel with Coroutines\nclass UserViewModel : ViewModel() {\n    private val _users = MutableLiveData<List<User>>()\n    val users: LiveData<List<User>> = _users\n    \n    private val _loading = MutableLiveData(false)\n    val loading: LiveData<Boolean> = _loading\n    \n    fun loadUsers() {\n        viewModelScope.launch {\n            _loading.value = true\n            try {\n                val result = repository.getUsers()\n                _users.value = result\n            } catch (e: Exception) {\n                // Handle error\n            } finally {\n                _loading.value = false\n            }\n        }\n    }\n}\n\n// 4. Flow basics\nfun getUsersFlow(): Flow<User> = flow {\n    val users = listOf(\n        User(1, \"John\"),\n        User(2, \"Jane\"),\n        User(3, \"Bob\")\n    )\n    \n    users.forEach { user ->\n        delay(100) // Simulate delay\n        emit(user)\n    }\n}\n\n// Collect flow\nlifecycleScope.launch {\n    getUsersFlow()\n        .collect { user ->\n            println(\"Received: ${user.name}\")\n        }\n}\n\n// 5. Flow operators\nclass UserRepository {\n    fun searchUsers(query: String): Flow<List<User>> = flow {\n        delay(300) // Simulate network delay\n        val results = database.searchUsers(query)\n        emit(results)\n    }\n}\n\nclass SearchViewModel : ViewModel() {\n    private val searchQuery = MutableStateFlow(\"\")\n    \n    val searchResults: StateFlow<List<User>> = searchQuery\n        .debounce(300) // Wait 300ms after typing stops\n        .filter { it.length >= 2 } // Minimum 2 characters\n        .distinctUntilChanged() // Only when query changes\n        .flatMapLatest { query ->\n            repository.searchUsers(query)\n                .catch { emit(emptyList()) } // Handle errors\n        }\n        .stateIn(\n            scope = viewModelScope,\n            started = SharingStarted.WhileSubscribed(5000),\n            initialValue = emptyList()\n        )\n    \n    fun updateQuery(query: String) {\n        searchQuery.value = query\n    }\n}\n\n// 6. StateFlow and SharedFlow\nclass DataManager {\n    // StateFlow - always has value\n    private val _uiState = MutableStateFlow<UiState>(UiState.Loading)\n    val uiState: StateFlow<UiState> = _uiState.asStateFlow()\n    \n    // SharedFlow - events without state\n    private val _events = MutableSharedFlow<Event>()\n    val events: SharedFlow<Event> = _events.asSharedFlow()\n    \n    suspend fun loadData() {\n        _uiState.value = UiState.Loading\n        \n        try {\n            val data = fetchData()\n            _uiState.value = UiState.Success(data)\n            _events.emit(Event.DataLoaded)\n        } catch (e: Exception) {\n            _uiState.value = UiState.Error(e.message)\n            _events.emit(Event.Error(e))\n        }\n    }\n}\n\n// Collect in Fragment\nclass MyFragment : Fragment() {\n    private val dataManager: DataManager by inject()\n    \n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        \n        // Collect StateFlow\n        viewLifecycleOwner.lifecycleScope.launch {\n            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {\n                dataManager.uiState.collect { state ->\n                    updateUI(state)\n                }\n            }\n        }\n        \n        // Collect SharedFlow\n        viewLifecycleOwner.lifecycleScope.launch {\n            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {\n                dataManager.events.collect { event ->\n                    handleEvent(event)\n                }\n            }\n        }\n    }\n}\n\n// 7. Combining Flows\nclass CombinedViewModel : ViewModel() {\n    private val filter = MutableStateFlow(\"\")\n    private val sortOrder = MutableStateFlow(SortOrder.NAME)\n    \n    val filteredUsers: StateFlow<List<User>> = combine(\n        repository.observeUsers(),\n        filter,\n        sortOrder\n    ) { users, filterText, order ->\n        users\n            .filter { it.name.contains(filterText, ignoreCase = true) }\n            .let { filtered ->\n                when (order) {\n                    SortOrder.NAME -> filtered.sortedBy { it.name }\n                    SortOrder.EMAIL -> filtered.sortedBy { it.email }\n                }\n            }\n    }.stateIn(\n        scope = viewModelScope,\n        started = SharingStarted.WhileSubscribed(5000),\n        initialValue = emptyList()\n    )\n    \n    fun updateFilter(text: String) {\n        filter.value = text\n    }\n    \n    fun updateSortOrder(order: SortOrder) {\n        sortOrder.value = order\n    }\n}\n\n// 8. Flow transformation\nfun fetchPaginatedData(): Flow<PagingData<User>> = flow {\n    var page = 1\n    while (true) {\n        val data = api.getUsers(page)\n        emit(PagingData(data, page))\n        if (data.isEmpty()) break\n        page++\n    }\n}\n    .map { pagingData ->\n        // Transform data\n        pagingData.copy(\n            users = pagingData.users.map { it.toUser() }\n        )\n    }\n    .flowOn(Dispatchers.IO) // Run on IO dispatcher\n\n// 9. Exception handling in coroutines\nfun handleExceptions() {\n    viewModelScope.launch {\n        try {\n            val result = fetchData()\n            processResult(result)\n        } catch (e: IOException) {\n            // Handle network error\n            showError(\"Network error\")\n        } catch (e: Exception) {\n            // Handle other errors\n            showError(\"Unknown error\")\n        }\n    }\n}\n\n// CoroutineExceptionHandler\nval handler = CoroutineExceptionHandler { _, exception ->\n    println(\"Caught $exception\")\n}\n\nlifecycleScope.launch(handler) {\n    throw Exception(\"Error!\")\n}\n\n// supervisorScope - failures don't cancel siblings\nsupervisorScope {\n    launch {\n        throw Exception(\"Child 1 failed\")\n    }\n    launch {\n        delay(1000)\n        println(\"Child 2 still runs\")\n    }\n}\n\n// 10. Testing Coroutines\nclass ViewModelTest {\n    @get:Rule\n    val mainCoroutineRule = MainCoroutineRule()\n    \n    private lateinit var viewModel: UserViewModel\n    \n    @Test\n    fun `loadUsers should emit success state`() = runTest {\n        // Arrange\n        val users = listOf(User(1, \"John\"))\n        coEvery { repository.getUsers() } returns users\n        \n        viewModel = UserViewModel(repository)\n        \n        // Act\n        viewModel.loadUsers()\n        advanceUntilIdle()\n        \n        // Assert\n        assertEquals(users, viewModel.users.value)\n        assertEquals(false, viewModel.loading.value)\n    }\n}\n\n// Testing Flows\n@Test\nfun `searchUsers should debounce queries`() = runTest {\n    val viewModel = SearchViewModel(repository)\n    \n    // Emit multiple queries quickly\n    viewModel.updateQuery(\"J\")\n    viewModel.updateQuery(\"Jo\")\n    viewModel.updateQuery(\"Joh\")\n    viewModel.updateQuery(\"John\")\n    \n    // Advance time past debounce\n    advanceTimeBy(350)\n    \n    // Only last query should be executed\n    coVerify(exactly = 1) {\n        repository.searchUsers(\"John\")\n    }\n}\n\n// 11. Channel for communication\nval channel = Channel<Int>()\n\n// Producer\nlaunch {\n    for (x in 1..5) {\n        channel.send(x * x)\n    }\n    channel.close()\n}\n\n// Consumer\nlaunch {\n    for (y in channel) {\n        println(y)\n    }\n}\n\n// 12. CallbackFlow for callback-based APIs\nfun locationUpdates(): Flow<Location> = callbackFlow {\n    val callback = object : LocationCallback() {\n        override fun onLocationResult(result: LocationResult) {\n            // Send location to flow\n            trySend(result.lastLocation)\n        }\n    }\n    \n    // Request updates\n    locationClient.requestLocationUpdates(\n        locationRequest,\n        callback,\n        Looper.getMainLooper()\n    )\n    \n    // Cleanup when flow is cancelled\n    awaitClose {\n        locationClient.removeLocationUpdates(callback)\n    }\n}.flowOn(Dispatchers.IO)"
    },
    {
      "id": 79,
      "question": "What is Android Room Database advanced features?",
      "answer": "Room is an SQLite ORM providing compile-time query verification, database migrations, and reactive data access.\n\nAdvanced Features:\n• Database migrations\n• Type converters\n• Database views\n• FTS (Full-Text Search)\n• Multi-table queries\n• Database relationships\n\nRelationships:\n• @Relation annotation\n• One-to-One\n• One-to-Many\n• Many-to-Many\n• Embedded objects\n\nType Converters:\n• Custom type mapping\n• Date/Time conversion\n• List/Array conversion\n• Enum conversion\n\nMigrations:\n• Automated migrations\n• Manual migrations\n• Destructive migrations\n• Pre-populated databases\n\nQuery Optimization:\n• Indices for faster queries\n• Compiled queries\n• Paging support\n• Observable queries\n\nTesting:\n• In-memory database\n• Migration testing\n• DAO testing\n• Integration tests",
      "explanation": "Room Database provides advanced features like automated migrations, type converters for custom types, relationship mapping with @Relation, Full-Text Search, database views, and reactive queries with Flow for efficient data management.",
      "difficulty": "Hard",
      "code": "// 1. Database with relationships\n@Database(\n    entities = [\n        User::class,\n        Post::class,\n        Comment::class\n    ],\n    version = 2,\n    exportSchema = true\n)\n@TypeConverters(Converters::class)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n    abstract fun postDao(): PostDao\n    abstract fun commentDao(): CommentDao\n    \n    companion object {\n        @Volatile\n        private var INSTANCE: AppDatabase? = null\n        \n        fun getDatabase(context: Context): AppDatabase {\n            return INSTANCE ?: synchronized(this) {\n                val instance = Room.databaseBuilder(\n                    context.applicationContext,\n                    AppDatabase::class.java,\n                    \"app_database\"\n                )\n                    .addMigrations(MIGRATION_1_2)\n                    .addCallback(DatabaseCallback())\n                    .build()\n                INSTANCE = instance\n                instance\n            }\n        }\n    }\n}\n\n// 2. Entities with relationships\n@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey val id: Int,\n    val name: String,\n    val email: String,\n    @ColumnInfo(name = \"created_at\") val createdAt: Date\n)\n\n@Entity(\n    tableName = \"posts\",\n    foreignKeys = [\n        ForeignKey(\n            entity = User::class,\n            parentColumns = [\"id\"],\n            childColumns = [\"user_id\"],\n            onDelete = ForeignKey.CASCADE\n        )\n    ],\n    indices = [Index(\"user_id\")]\n)\ndata class Post(\n    @PrimaryKey val id: Int,\n    @ColumnInfo(name = \"user_id\") val userId: Int,\n    val title: String,\n    val content: String,\n    @ColumnInfo(name = \"created_at\") val createdAt: Date\n)\n\n@Entity(\n    tableName = \"comments\",\n    foreignKeys = [\n        ForeignKey(\n            entity = Post::class,\n            parentColumns = [\"id\"],\n            childColumns = [\"post_id\"],\n            onDelete = ForeignKey.CASCADE\n        )\n    ],\n    indices = [Index(\"post_id\")]\n)\ndata class Comment(\n    @PrimaryKey val id: Int,\n    @ColumnInfo(name = \"post_id\") val postId: Int,\n    val text: String,\n    @ColumnInfo(name = \"created_at\") val createdAt: Date\n)\n\n// 3. One-to-Many relationship\ndata class UserWithPosts(\n    @Embedded val user: User,\n    @Relation(\n        parentColumn = \"id\",\n        entityColumn = \"user_id\"\n    )\n    val posts: List<Post>\n)\n\n@Dao\ninterface UserDao {\n    @Transaction\n    @Query(\"SELECT * FROM users WHERE id = :userId\")\n    fun getUserWithPosts(userId: Int): Flow<UserWithPosts>\n    \n    @Transaction\n    @Query(\"SELECT * FROM users\")\n    fun getAllUsersWithPosts(): Flow<List<UserWithPosts>>\n}\n\n// 4. Many-to-Many relationship\n@Entity(\n    tableName = \"user_tag\",\n    primaryKeys = [\"user_id\", \"tag_id\"],\n    foreignKeys = [\n        ForeignKey(\n            entity = User::class,\n            parentColumns = [\"id\"],\n            childColumns = [\"user_id\"],\n            onDelete = ForeignKey.CASCADE\n        ),\n        ForeignKey(\n            entity = Tag::class,\n            parentColumns = [\"id\"],\n            childColumns = [\"tag_id\"],\n            onDelete = ForeignKey.CASCADE\n        )\n    ],\n    indices = [Index(\"user_id\"), Index(\"tag_id\")]\n)\ndata class UserTagCrossRef(\n    @ColumnInfo(name = \"user_id\") val userId: Int,\n    @ColumnInfo(name = \"tag_id\") val tagId: Int\n)\n\n@Entity(tableName = \"tags\")\ndata class Tag(\n    @PrimaryKey val id: Int,\n    val name: String\n)\n\ndata class UserWithTags(\n    @Embedded val user: User,\n    @Relation(\n        parentColumn = \"id\",\n        entityColumn = \"id\",\n        associateBy = Junction(\n            UserTagCrossRef::class,\n            parentColumn = \"user_id\",\n            entityColumn = \"tag_id\"\n        )\n    )\n    val tags: List<Tag>\n)\n\n// 5. Type Converters\nclass Converters {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? {\n        return value?.let { Date(it) }\n    }\n    \n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? {\n        return date?.time\n    }\n    \n    @TypeConverter\n    fun fromStringList(value: String?): List<String>? {\n        return value?.split(\",\")?.map { it.trim() }\n    }\n    \n    @TypeConverter\n    fun toStringList(list: List<String>?): String? {\n        return list?.joinToString(\",\")\n    }\n    \n    @TypeConverter\n    fun fromStatus(value: Status): String {\n        return value.name\n    }\n    \n    @TypeConverter\n    fun toStatus(value: String): Status {\n        return Status.valueOf(value)\n    }\n}\n\nenum class Status {\n    ACTIVE, INACTIVE, PENDING\n}\n\n// 6. Database Migrations\nval MIGRATION_1_2 = object : Migration(1, 2) {\n    override fun migrate(database: SupportSQLiteDatabase) {\n        // Add new column\n        database.execSQL(\n            \"ALTER TABLE users ADD COLUMN age INTEGER DEFAULT 0 NOT NULL\"\n        )\n        \n        // Create new table\n        database.execSQL(\n            \"\"\"CREATE TABLE IF NOT EXISTS comments (\n                id INTEGER PRIMARY KEY NOT NULL,\n                post_id INTEGER NOT NULL,\n                text TEXT NOT NULL,\n                created_at INTEGER NOT NULL,\n                FOREIGN KEY(post_id) REFERENCES posts(id) ON DELETE CASCADE\n            )\"\"\"\n        )\n        \n        // Create index\n        database.execSQL(\n            \"CREATE INDEX index_comments_post_id ON comments(post_id)\"\n        )\n    }\n}\n\n// 7. Database Views\n@DatabaseView(\n    \"SELECT users.id, users.name, COUNT(posts.id) as post_count \" +\n    \"FROM users LEFT JOIN posts ON users.id = posts.user_id \" +\n    \"GROUP BY users.id\"\n)\ndata class UserPostCount(\n    @ColumnInfo(name = \"id\") val userId: Int,\n    val name: String,\n    @ColumnInfo(name = \"post_count\") val postCount: Int\n)\n\n@Dao\ninterface StatsDao {\n    @Query(\"SELECT * FROM UserPostCount ORDER BY post_count DESC\")\n    fun getUserPostCounts(): Flow<List<UserPostCount>>\n}\n\n// 8. Full-Text Search (FTS)\n@Entity(tableName = \"posts_fts\")\n@Fts4(contentEntity = Post::class)\ndata class PostFts(\n    @ColumnInfo(name = \"rowid\") @PrimaryKey val rowId: Int,\n    val title: String,\n    val content: String\n)\n\n@Dao\ninterface PostDao {\n    @Query(\n        \"SELECT posts.* FROM posts \" +\n        \"JOIN posts_fts ON posts.id = posts_fts.rowid \" +\n        \"WHERE posts_fts MATCH :query\"\n    )\n    fun searchPosts(query: String): Flow<List<Post>>\n}\n\n// 9. Paging with Room\n@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM users ORDER BY name ASC\")\n    fun getAllUsersPaged(): PagingSource<Int, User>\n}\n\nclass UserRepository(private val userDao: UserDao) {\n    fun getUsersPaged(): Flow<PagingData<User>> {\n        return Pager(\n            config = PagingConfig(\n                pageSize = 20,\n                enablePlaceholders = false\n            ),\n            pagingSourceFactory = { userDao.getAllUsersPaged() }\n        ).flow\n    }\n}\n\n// 10. Complex queries\n@Dao\ninterface PostDao {\n    // Multi-table join\n    @Query(\n        \"\"\"SELECT posts.*, users.name as author_name,\n           COUNT(comments.id) as comment_count\n           FROM posts\n           INNER JOIN users ON posts.user_id = users.id\n           LEFT JOIN comments ON posts.id = comments.post_id\n           WHERE posts.created_at > :since\n           GROUP BY posts.id\n           ORDER BY posts.created_at DESC\"\"\"\n    )\n    fun getPostsWithDetails(since: Date): Flow<List<PostWithDetails>>\n    \n    // Subquery\n    @Query(\n        \"\"\"SELECT * FROM posts\n           WHERE user_id IN (\n               SELECT id FROM users WHERE email LIKE :emailPattern\n           )\"\"\"\n    )\n    fun getPostsByUserEmail(emailPattern: String): Flow<List<Post>>\n    \n    // Aggregate function\n    @Query(\n        \"\"\"SELECT users.id, users.name, COUNT(posts.id) as total_posts,\n           AVG(LENGTH(posts.content)) as avg_post_length\n           FROM users\n           LEFT JOIN posts ON users.id = posts.user_id\n           GROUP BY users.id\n           HAVING total_posts > :minPosts\"\"\"\n    )\n    fun getUserStats(minPosts: Int): Flow<List<UserStats>>\n}\n\ndata class PostWithDetails(\n    @Embedded val post: Post,\n    @ColumnInfo(name = \"author_name\") val authorName: String,\n    @ColumnInfo(name = \"comment_count\") val commentCount: Int\n)\n\ndata class UserStats(\n    @Embedded val user: User,\n    @ColumnInfo(name = \"total_posts\") val totalPosts: Int,\n    @ColumnInfo(name = \"avg_post_length\") val avgPostLength: Double\n)\n\n// 11. Database Callback\nclass DatabaseCallback : RoomDatabase.Callback() {\n    override fun onCreate(db: SupportSQLiteDatabase) {\n        super.onCreate(db)\n        // Pre-populate database\n        CoroutineScope(Dispatchers.IO).launch {\n            populateDatabase()\n        }\n    }\n    \n    override fun onOpen(db: SupportSQLiteDatabase) {\n        super.onOpen(db)\n        // Database opened\n    }\n    \n    private suspend fun populateDatabase() {\n        // Insert initial data\n    }\n}\n\n// 12. Testing Room\n@RunWith(AndroidJUnit4::class)\nclass UserDaoTest {\n    private lateinit var database: AppDatabase\n    private lateinit var userDao: UserDao\n    \n    @Before\n    fun setup() {\n        val context = ApplicationProvider.getApplicationContext<Context>()\n        database = Room.inMemoryDatabaseBuilder(\n            context,\n            AppDatabase::class.java\n        )\n            .allowMainThreadQueries()\n            .build()\n        userDao = database.userDao()\n    }\n    \n    @After\n    fun teardown() {\n        database.close()\n    }\n    \n    @Test\n    fun insertAndRetrieveUser() = runTest {\n        val user = User(1, \"John\", \"john@example.com\", Date())\n        userDao.insert(user)\n        \n        val retrieved = userDao.getUserById(1).first()\n        assertEquals(user.name, retrieved.name)\n    }\n}\n\n// Testing migrations\n@RunWith(AndroidJUnit4::class)\nclass MigrationTest {\n    @get:Rule\n    val helper: MigrationTestHelper = MigrationTestHelper(\n        InstrumentationRegistry.getInstrumentation(),\n        AppDatabase::class.java\n    )\n    \n    @Test\n    fun migrate1To2() {\n        // Create database version 1\n        helper.createDatabase(TEST_DB, 1).apply {\n            execSQL(\"INSERT INTO users (id, name, email) VALUES (1, 'John', 'john@test.com')\")\n            close()\n        }\n        \n        // Migrate to version 2\n        helper.runMigrationsAndValidate(TEST_DB, 2, true, MIGRATION_1_2)\n        \n        // Verify migration\n        helper.runMigrationsAndValidate(TEST_DB, 2, true)\n    }\n}"
    },
    {
      "id": 80,
      "question": "What is Android Custom Views and Canvas Drawing?",
      "answer": "Custom Views enable creating reusable UI components with custom rendering, measurement, and interaction handling.\n\nCreating Custom Views:\n• Extend View or ViewGroup\n• Override onDraw for rendering\n• Override onMeasure for sizing\n• Handle touch events\n• Define custom attributes\n\nCanvas Drawing:\n• Paint for styling\n• Path for complex shapes\n• drawText, drawRect, drawCircle\n• Transformations (rotate, scale)\n• Layers and clipping\n\nMeasurement:\n• onMeasure callback\n• MeasureSpec modes\n• setMeasuredDimension\n• Layout parameters\n\nTouch Handling:\n• onTouchEvent\n• GestureDetector\n• Velocity tracker\n• Touch delegations\n\nPerformance:\n• Minimize allocations in onDraw\n• Use hardware acceleration\n• Cache bitmaps\n• Invalidate smartly\n• Clip rendering\n\nCustom Attributes:\n• attrs.xml definition\n• TypedArray for reading\n• Default values\n• Style support",
      "explanation": "Custom Views involve extending View with custom onDraw() for Canvas rendering using Paint/Path, onMeasure() for sizing with MeasureSpec, defining custom XML attributes, and handling touch events for interactions.",
      "difficulty": "Hard",
      "code": "// 1. Basic Custom View\nclass CircleView @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : View(context, attrs, defStyleAttr) {\n    \n    private val paint = Paint(Paint.ANTI_ALIAS_FLAG).apply {\n        color = Color.BLUE\n        style = Paint.Style.FILL\n    }\n    \n    private var radius = 100f\n    \n    init {\n        // Read custom attributes\n        context.theme.obtainStyledAttributes(\n            attrs,\n            R.styleable.CircleView,\n            0, 0\n        ).apply {\n            try {\n                radius = getDimension(R.styleable.CircleView_radius, 100f)\n                paint.color = getColor(R.styleable.CircleView_circleColor, Color.BLUE)\n            } finally {\n                recycle()\n            }\n        }\n    }\n    \n    override fun onDraw(canvas: Canvas) {\n        super.onDraw(canvas)\n        \n        val centerX = width / 2f\n        val centerY = height / 2f\n        \n        canvas.drawCircle(centerX, centerY, radius, paint)\n    }\n    \n    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {\n        val desiredSize = (radius * 2).toInt() + paddingLeft + paddingRight\n        \n        val width = resolveSize(desiredSize, widthMeasureSpec)\n        val height = resolveSize(desiredSize, heightMeasureSpec)\n        \n        setMeasuredDimension(width, height)\n    }\n    \n    // Public API\n    fun setRadius(newRadius: Float) {\n        radius = newRadius\n        invalidate() // Redraw\n    }\n}\n\n// 2. Custom attributes (res/values/attrs.xml)\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <declare-styleable name=\"CircleView\">\n        <attr name=\"radius\" format=\"dimension\" />\n        <attr name=\"circleColor\" format=\"color\" />\n    </declare-styleable>\n    \n    <declare-styleable name=\"ChartView\">\n        <attr name=\"maxValue\" format=\"float\" />\n        <attr name=\"barColor\" format=\"color\" />\n        <attr name=\"labelTextSize\" format=\"dimension\" />\n        <attr name=\"showLabels\" format=\"boolean\" />\n    </declare-styleable>\n</resources>\n\n// Usage in XML\n<com.example.CircleView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    app:radius=\"50dp\"\n    app:circleColor=\"#FF0000\" />\n\n// 3. Advanced Canvas Drawing\nclass ChartView @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : View(context, attrs, defStyleAttr) {\n    \n    private val barPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {\n        style = Paint.Style.FILL\n    }\n    \n    private val textPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {\n        textSize = 40f\n        textAlign = Paint.Align.CENTER\n    }\n    \n    private val linePaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {\n        color = Color.GRAY\n        strokeWidth = 2f\n        style = Paint.Style.STROKE\n    }\n    \n    private var data: List<Float> = emptyList()\n    private var maxValue = 100f\n    private val barWidth = 80f\n    private val barSpacing = 20f\n    \n    fun setData(newData: List<Float>) {\n        data = newData\n        invalidate()\n    }\n    \n    override fun onDraw(canvas: Canvas) {\n        super.onDraw(canvas)\n        \n        if (data.isEmpty()) return\n        \n        val chartHeight = height - paddingTop - paddingBottom\n        val chartWidth = width - paddingLeft - paddingRight\n        \n        // Draw grid lines\n        for (i in 0..5) {\n            val y = paddingTop + (chartHeight * i / 5f)\n            canvas.drawLine(\n                paddingLeft.toFloat(),\n                y,\n                (width - paddingRight).toFloat(),\n                y,\n                linePaint\n            )\n        }\n        \n        // Draw bars\n        data.forEachIndexed { index, value ->\n            val x = paddingLeft + (barWidth + barSpacing) * index + barSpacing\n            val barHeight = (value / maxValue) * chartHeight\n            val top = paddingTop + chartHeight - barHeight\n            \n            // Draw bar\n            barPaint.color = getColorForValue(value)\n            canvas.drawRect(\n                x,\n                top,\n                x + barWidth,\n                (height - paddingBottom).toFloat(),\n                barPaint\n            )\n            \n            // Draw label\n            canvas.drawText(\n                value.toInt().toString(),\n                x + barWidth / 2,\n                top - 10f,\n                textPaint\n            )\n        }\n    }\n    \n    private fun getColorForValue(value: Float): Int {\n        return when {\n            value >= maxValue * 0.7f -> Color.RED\n            value >= maxValue * 0.4f -> Color.YELLOW\n            else -> Color.GREEN\n        }\n    }\n    \n    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {\n        val desiredWidth = ((barWidth + barSpacing) * data.size + barSpacing).toInt() +\n                          paddingLeft + paddingRight\n        val desiredHeight = 400 + paddingTop + paddingBottom\n        \n        val width = resolveSize(desiredWidth, widthMeasureSpec)\n        val height = resolveSize(desiredHeight, heightMeasureSpec)\n        \n        setMeasuredDimension(width, height)\n    }\n}\n\n// 4. Path and Complex Shapes\nclass WaveView @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null\n) : View(context, attrs) {\n    \n    private val wavePaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {\n        color = Color.BLUE\n        style = Paint.Style.FILL\n        alpha = 150\n    }\n    \n    private val path = Path()\n    private var phase = 0f\n    private val animator = ValueAnimator.ofFloat(0f, 2 * Math.PI.toFloat())\n    \n    init {\n        animator.apply {\n            duration = 2000\n            repeatCount = ValueAnimator.INFINITE\n            addUpdateListener {\n                phase = it.animatedValue as Float\n                invalidate()\n            }\n            start()\n        }\n    }\n    \n    override fun onDraw(canvas: Canvas) {\n        super.onDraw(canvas)\n        \n        path.reset()\n        path.moveTo(0f, height / 2f)\n        \n        // Create wave using sine function\n        for (x in 0..width step 5) {\n            val y = height / 2f + 100f * Math.sin(\n                (x.toDouble() / width * 4 * Math.PI + phase)\n            ).toFloat()\n            path.lineTo(x.toFloat(), y)\n        }\n        \n        // Close path\n        path.lineTo(width.toFloat(), height.toFloat())\n        path.lineTo(0f, height.toFloat())\n        path.close()\n        \n        canvas.drawPath(path, wavePaint)\n    }\n}\n\n// 5. Touch Interaction\nclass DraggableView @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null\n) : View(context, attrs) {\n    \n    private val paint = Paint(Paint.ANTI_ALIAS_FLAG).apply {\n        color = Color.RED\n    }\n    \n    private var circleX = 0f\n    private var circleY = 0f\n    private val circleRadius = 50f\n    \n    private var isDragging = false\n    private val gestureDetector = GestureDetector(\n        context,\n        object : GestureDetector.SimpleOnGestureListener() {\n            override fun onDown(e: MotionEvent): Boolean {\n                return true\n            }\n            \n            override fun onSingleTapConfirmed(e: MotionEvent): Boolean {\n                // Handle tap\n                return true\n            }\n            \n            override fun onDoubleTap(e: MotionEvent): Boolean {\n                // Handle double tap\n                return true\n            }\n        }\n    )\n    \n    override fun onTouchEvent(event: MotionEvent): Boolean {\n        gestureDetector.onTouchEvent(event)\n        \n        when (event.action) {\n            MotionEvent.ACTION_DOWN -> {\n                val distance = Math.hypot(\n                    (event.x - circleX).toDouble(),\n                    (event.y - circleY).toDouble()\n                ).toFloat()\n                \n                if (distance <= circleRadius) {\n                    isDragging = true\n                    return true\n                }\n            }\n            \n            MotionEvent.ACTION_MOVE -> {\n                if (isDragging) {\n                    circleX = event.x\n                    circleY = event.y\n                    invalidate()\n                    return true\n                }\n            }\n            \n            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {\n                isDragging = false\n            }\n        }\n        \n        return super.onTouchEvent(event)\n    }\n    \n    override fun onDraw(canvas: Canvas) {\n        super.onDraw(canvas)\n        canvas.drawCircle(circleX, circleY, circleRadius, paint)\n    }\n    \n    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {\n        super.onSizeChanged(w, h, oldw, oldh)\n        circleX = w / 2f\n        circleY = h / 2f\n    }\n}\n\n// 6. Custom ViewGroup\nclass CustomLayout @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null\n) : ViewGroup(context, attrs) {\n    \n    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {\n        var maxWidth = 0\n        var maxHeight = 0\n        \n        // Measure children\n        for (i in 0 until childCount) {\n            val child = getChildAt(i)\n            if (child.visibility != GONE) {\n                measureChild(child, widthMeasureSpec, heightMeasureSpec)\n                maxWidth = Math.max(maxWidth, child.measuredWidth)\n                maxHeight = Math.max(maxHeight, child.measuredHeight)\n            }\n        }\n        \n        // Add padding\n        maxWidth += paddingLeft + paddingRight\n        maxHeight += paddingTop + paddingBottom\n        \n        // Resolve size\n        val width = resolveSize(maxWidth, widthMeasureSpec)\n        val height = resolveSize(maxHeight, heightMeasureSpec)\n        \n        setMeasuredDimension(width, height)\n    }\n    \n    override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) {\n        // Layout children\n        var currentX = paddingLeft\n        var currentY = paddingTop\n        \n        for (i in 0 until childCount) {\n            val child = getChildAt(i)\n            if (child.visibility != GONE) {\n                val childWidth = child.measuredWidth\n                val childHeight = child.measuredHeight\n                \n                child.layout(\n                    currentX,\n                    currentY,\n                    currentX + childWidth,\n                    currentY + childHeight\n                )\n                \n                currentX += childWidth + 10 // Add spacing\n                \n                // Wrap to next line if needed\n                if (currentX + childWidth > width - paddingRight) {\n                    currentX = paddingLeft\n                    currentY += childHeight + 10\n                }\n            }\n        }\n    }\n}"
    },
    {
      "id": 81,
      "question": "What is Android Animations and Transitions?",
      "answer": "Android Animations enhance user experience through visual feedback, motion, and smooth transitions between UI states.\n\nAnimation Types:\n• View Animation (deprecated)\n• Property Animation\n• Drawable Animation\n• MotionLayout\n• Transition Framework\n• Physics-based animations\n\nProperty Animation:\n• ObjectAnimator\n• ValueAnimator\n• AnimatorSet\n• Interpolators\n• Duration and delay\n\nView Properties:\n• Translation (x, y, z)\n• Rotation\n• Scale\n• Alpha (opacity)\n\nTransition Framework:\n• Scene transitions\n• Shared element transitions\n• Activity transitions\n• Fragment transitions\n\nMotionLayout:\n• Complex animations\n• Touch-driven motion\n• Keyframe animations\n• ConstraintSet transitions\n\nBest Practices:\n• Use hardware acceleration\n• Animate efficiently\n• Consider performance\n• Material Motion guidelines\n• Provide feedback",
      "explanation": "Android Animations use Property Animation with ObjectAnimator/ValueAnimator for view properties, Transition Framework for scene changes, MotionLayout for complex choreography, and physics-based animations for realistic motion.",
      "difficulty": "Hard",
      "code": "// 1. Basic Property Animation\nval view = findViewById<View>(R.id.myView)\n\n// Fade animation\nval fadeIn = ObjectAnimator.ofFloat(view, \"alpha\", 0f, 1f)\nfadeIn.duration = 500\nfadeIn.start()\n\n// Move animation\nval moveX = ObjectAnimator.ofFloat(view, \"translationX\", 0f, 200f)\nmoveX.duration = 1000\nmoveX.start()\n\n// Rotation animation\nval rotate = ObjectAnimator.ofFloat(view, \"rotation\", 0f, 360f)\nrotate.duration = 1000\nrotate.repeatCount = ValueAnimator.INFINITE\nrotate.start()\n\n// 2. AnimatorSet for combined animations\nval animatorSet = AnimatorSet().apply {\n    playTogether(\n        ObjectAnimator.ofFloat(view, \"scaleX\", 1f, 1.5f, 1f),\n        ObjectAnimator.ofFloat(view, \"scaleY\", 1f, 1.5f, 1f),\n        ObjectAnimator.ofFloat(view, \"alpha\", 1f, 0.5f, 1f)\n    )\n    duration = 1000\n    interpolator = AccelerateDecelerateInterpolator()\n    start()\n}\n\n// Sequential animations\nAnimatorSet().apply {\n    playSequentially(\n        ObjectAnimator.ofFloat(view, \"translationX\", 0f, 100f),\n        ObjectAnimator.ofFloat(view, \"translationY\", 0f, 100f),\n        ObjectAnimator.ofFloat(view, \"alpha\", 1f, 0f)\n    )\n    duration = 500\n    start()\n}\n\n// 3. ViewPropertyAnimator (simpler API)\nview.animate()\n    .alpha(0.5f)\n    .translationX(200f)\n    .translationY(100f)\n    .scaleX(1.5f)\n    .scaleY(1.5f)\n    .rotation(45f)\n    .setDuration(1000)\n    .setInterpolator(OvershootInterpolator())\n    .setListener(object : AnimatorListenerAdapter() {\n        override fun onAnimationEnd(animation: Animator) {\n            // Animation completed\n        }\n    })\n    .start()\n\n// 4. ValueAnimator for custom properties\nval colorAnimator = ValueAnimator.ofArgb(Color.RED, Color.BLUE)\ncolorAnimator.addUpdateListener { animator ->\n    val color = animator.animatedValue as Int\n    view.setBackgroundColor(color)\n}\ncolorAnimator.duration = 1000\ncolorAnimator.start()\n\n// Animate custom property\nval radiusAnimator = ValueAnimator.ofFloat(0f, 100f)\nradiusAnimator.addUpdateListener { animator ->\n    val radius = animator.animatedValue as Float\n    customView.setRadius(radius)\n}\nradiusAnimator.duration = 500\nradiusAnimator.start()\n\n// 5. Interpolators\nval interpolators = listOf(\n    LinearInterpolator(),\n    AccelerateInterpolator(),\n    DecelerateInterpolator(),\n    AccelerateDecelerateInterpolator(),\n    BounceInterpolator(),\n    OvershootInterpolator(),\n    AnticipateInterpolator(),\n    AnticipateOvershootInterpolator()\n)\n\nObjectAnimator.ofFloat(view, \"translationY\", 0f, 300f).apply {\n    duration = 1000\n    interpolator = BounceInterpolator()\n    start()\n}\n\n// 6. Activity Transitions\n// In Activity A\nval intent = Intent(this, ActivityB::class.java)\nval options = ActivityOptions.makeSceneTransitionAnimation(\n    this,\n    Pair(imageView, \"shared_image\"),\n    Pair(textView, \"shared_text\")\n)\nstartActivity(intent, options.toBundle())\n\n// In ActivityB\nclass ActivityB : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        \n        // Enable window content transitions\n        window.requestFeature(Window.FEATURE_CONTENT_TRANSITIONS)\n        \n        // Set transitions\n        window.enterTransition = Slide(Gravity.END)\n        window.exitTransition = Fade()\n        window.reenterTransition = Slide(Gravity.START)\n        window.returnTransition = Fade()\n        \n        setContentView(R.layout.activity_b)\n        \n        // Setup shared element transition\n        ViewCompat.setTransitionName(imageView, \"shared_image\")\n        ViewCompat.setTransitionName(textView, \"shared_text\")\n    }\n}\n\n// Programmatic shared element transition\nval sharedElements = arrayOf(\n    Pair<View, String>(imageView, \"shared_image\"),\n    Pair<View, String>(textView, \"shared_text\")\n)\nval options = ActivityOptions.makeSceneTransitionAnimation(this, *sharedElements)\n\n// 7. Fragment Transitions\nclass FragmentA : Fragment() {\n    fun navigateToFragmentB() {\n        val fragmentB = FragmentB()\n        \n        // Set exit transition for FragmentA\n        exitTransition = Fade()\n        \n        // Set enter transition for FragmentB\n        fragmentB.enterTransition = Slide(Gravity.END)\n        fragmentB.returnTransition = Slide(Gravity.START)\n        \n        // Shared element transition\n        fragmentB.sharedElementEnterTransition = TransitionInflater.from(context)\n            .inflateTransition(android.R.transition.move)\n        \n        parentFragmentManager.beginTransaction()\n            .replace(R.id.container, fragmentB)\n            .addSharedElement(imageView, \"shared_image\")\n            .addToBackStack(null)\n            .commit()\n    }\n}\n\n// 8. MotionLayout (XML)\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.motion.widget.MotionLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    app:layoutDescription=\"@xml/scene\">\n    \n    <ImageView\n        android:id=\"@+id/image\"\n        android:layout_width=\"100dp\"\n        android:layout_height=\"100dp\"\n        android:src=\"@drawable/ic_launcher\" />\n    \n</androidx.constraintlayout.motion.widget.MotionLayout>\n\n// MotionScene (res/xml/scene.xml)\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<MotionScene xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:motion=\"http://schemas.android.com/apk/res-auto\">\n    \n    <Transition\n        motion:constraintSetStart=\"@id/start\"\n        motion:constraintSetEnd=\"@id/end\"\n        motion:duration=\"1000\">\n        \n        <OnSwipe\n            motion:touchAnchorId=\"@id/image\"\n            motion:touchAnchorSide=\"right\"\n            motion:dragDirection=\"dragRight\" />\n        \n        <KeyFrameSet>\n            <KeyAttribute\n                motion:motionTarget=\"@id/image\"\n                motion:framePosition=\"50\"\n                android:rotation=\"180\" />\n        </KeyFrameSet>\n    </Transition>\n    \n    <ConstraintSet android:id=\"@+id/start\">\n        <Constraint\n            android:id=\"@id/image\"\n            android:layout_width=\"100dp\"\n            android:layout_height=\"100dp\"\n            motion:layout_constraintStart_toStartOf=\"parent\"\n            motion:layout_constraintTop_toTopOf=\"parent\" />\n    </ConstraintSet>\n    \n    <ConstraintSet android:id=\"@+id/end\">\n        <Constraint\n            android:id=\"@id/image\"\n            android:layout_width=\"200dp\"\n            android:layout_height=\"200dp\"\n            motion:layout_constraintEnd_toEndOf=\"parent\"\n            motion:layout_constraintBottom_toBottomOf=\"parent\" />\n    </ConstraintSet>\n    \n</MotionScene>\n\n// 9. Programmatic MotionLayout control\nval motionLayout = findViewById<MotionLayout>(R.id.motionLayout)\n\n// Trigger transition\nmotionLayout.transitionToEnd()\nmotionLayout.transitionToStart()\n\n// Set progress\nmotionLayout.progress = 0.5f // 50% of transition\n\n// Listen to transition changes\nmotionLayout.setTransitionListener(object : MotionLayout.TransitionListener {\n    override fun onTransitionStarted(motionLayout: MotionLayout, startId: Int, endId: Int) {\n        // Transition started\n    }\n    \n    override fun onTransitionChange(motionLayout: MotionLayout, startId: Int, endId: Int, progress: Float) {\n        // Transition progress changed\n    }\n    \n    override fun onTransitionCompleted(motionLayout: MotionLayout, currentId: Int) {\n        // Transition completed\n    }\n    \n    override fun onTransitionTrigger(motionLayout: MotionLayout, triggerId: Int, positive: Boolean, progress: Float) {\n        // Trigger activated\n    }\n})\n\n// 10. Physics-based animations\nimplementation 'androidx.dynamicanimation:dynamicanimation:1.0.0'\n\n// Spring animation\nval springAnim = SpringAnimation(view, DynamicAnimation.TRANSLATION_Y, 0f)\nspringAnim.spring.apply {\n    dampingRatio = SpringForce.DAMPING_RATIO_MEDIUM_BOUNCY\n    stiffness = SpringForce.STIFFNESS_LOW\n}\nspringAnim.start()\n\n// Fling animation\nval fling = FlingAnimation(view, DynamicAnimation.TRANSLATION_X)\nfling.setStartVelocity(5000f)\nfling.friction = 1.5f\nfling.start()\n\n// 11. Circular Reveal animation\nval cx = view.width / 2\nval cy = view.height / 2\nval finalRadius = Math.hypot(cx.toDouble(), cy.toDouble()).toFloat()\n\nval anim = ViewAnimationUtils.createCircularReveal(\n    view,\n    cx,\n    cy,\n    0f,\n    finalRadius\n)\nanim.duration = 500\nanim.start()\n\n// 12. RecyclerView Item Animations\nclass CustomItemAnimator : DefaultItemAnimator() {\n    override fun animateAdd(holder: RecyclerView.ViewHolder): Boolean {\n        holder.itemView.alpha = 0f\n        holder.itemView.animate()\n            .alpha(1f)\n            .setDuration(300)\n            .setListener(null)\n            .start()\n        return true\n    }\n    \n    override fun animateRemove(holder: RecyclerView.ViewHolder): Boolean {\n        holder.itemView.animate()\n            .alpha(0f)\n            .translationX(holder.itemView.width.toFloat())\n            .setDuration(300)\n            .setListener(object : AnimatorListenerAdapter() {\n                override fun onAnimationEnd(animation: Animator) {\n                    dispatchRemoveFinished(holder)\n                }\n            })\n            .start()\n        return true\n    }\n}\n\nrecyclerView.itemAnimator = CustomItemAnimator()\n\n// 13. Animated Vector Drawables\n// res/drawable/animated_check.xml\n<animated-vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:drawable=\"@drawable/ic_check\">\n    <target\n        android:name=\"check\"\n        android:animation=\"@animator/check_animation\" />\n</animated-vector>\n\n// res/animator/check_animation.xml\n<objectAnimator xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:duration=\"300\"\n    android:propertyName=\"trimPathEnd\"\n    android:valueFrom=\"0\"\n    android:valueTo=\"1\"\n    android:valueType=\"floatType\" />\n\n// Animate in code\nval drawable = imageView.drawable as AnimatedVectorDrawable\ndrawable.start()\n\n// 14. Custom Animation Listener\nclass SimpleAnimationListener(\n    private val onStart: (() -> Unit)? = null,\n    private val onEnd: (() -> Unit)? = null\n) : AnimatorListenerAdapter() {\n    \n    override fun onAnimationStart(animation: Animator) {\n        onStart?.invoke()\n    }\n    \n    override fun onAnimationEnd(animation: Animator) {\n        onEnd?.invoke()\n    }\n}\n\n// Usage\nview.animate()\n    .alpha(0f)\n    .setDuration(500)\n    .setListener(SimpleAnimationListener(\n        onStart = { println(\"Animation started\") },\n        onEnd = { println(\"Animation ended\") }\n    ))\n    .start()"
    },
    {
      "id": 82,
      "question": "What is Android Accessibility and how to implement it?",
      "answer": "Android Accessibility ensures apps are usable by people with disabilities through screen readers, voice control, and alternative input methods.\n\nAccessibility Services:\n• TalkBack (screen reader)\n• Voice Access\n• Switch Access\n• Magnification\n• Caption preferences\n\nImplementation:\n• Content descriptions\n• Heading semantics\n• Action labels\n• Live regions\n• Touch target sizes\n• Color contrast\n\nTalkBack Support:\n• contentDescription for images\n• android:importantForAccessibility\n• Announcement events\n• Custom actions\n• Traverse order\n\nTouch Targets:\n• Minimum 48dp x 48dp\n• Sufficient spacing\n• Clear visual feedback\n• Tap highlighting\n\nTesting:\n• Accessibility Scanner\n• TalkBack testing\n• Color contrast tools\n• Switch Access testing\n\nBest Practices:\n• Descriptive labels\n• Logical focus order\n• Support multiple inputs\n• Avoid timing constraints\n• Provide alternatives",
      "explanation": "Android Accessibility involves adding contentDescription for UI elements, ensuring 48dp minimum touch targets, supporting TalkBack with proper semantics, providing sufficient color contrast, and testing with Accessibility Scanner.",
      "difficulty": "Medium",
      "code": "// 1. Content Descriptions\n// In XML\n<ImageView\n    android:id=\"@+id/profileImage\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:src=\"@drawable/profile\"\n    android:contentDescription=\"@string/profile_picture\" />\n\n<ImageButton\n    android:id=\"@+id/shareButton\"\n    android:layout_width=\"48dp\"\n    android:layout_height=\"48dp\"\n    android:src=\"@drawable/ic_share\"\n    android:contentDescription=\"@string/share_content\" />\n\n// Decorative images (not announced by TalkBack)\n<ImageView\n    android:src=\"@drawable/decoration\"\n    android:importantForAccessibility=\"no\" />\n\n// In code\nimageView.contentDescription = \"User profile picture\"\nbutton.contentDescription = getString(R.string.submit_form)\n\n// 2. Dynamic Content Descriptions\nfun updatePlayButton(isPlaying: Boolean) {\n    playButton.apply {\n        if (isPlaying) {\n            setImageResource(R.drawable.ic_pause)\n            contentDescription = \"Pause music\"\n        } else {\n            setImageResource(R.drawable.ic_play)\n            contentDescription = \"Play music\"\n        }\n    }\n}\n\n// 3. Custom Accessibility Actions\nclass CustomView : View {\n    init {\n        ViewCompat.setAccessibilityDelegate(\n            this,\n            object : AccessibilityDelegateCompat() {\n                override fun onInitializeAccessibilityNodeInfo(\n                    host: View,\n                    info: AccessibilityNodeInfoCompat\n                ) {\n                    super.onInitializeAccessibilityNodeInfo(host, info)\n                    \n                    // Add custom action\n                    val customAction = AccessibilityNodeInfoCompat.AccessibilityActionCompat(\n                        R.id.action_custom,\n                        \"Custom action\"\n                    )\n                    info.addAction(customAction)\n                }\n                \n                override fun performAccessibilityAction(\n                    host: View,\n                    action: Int,\n                    args: Bundle?\n                ): Boolean {\n                    return when (action) {\n                        R.id.action_custom -> {\n                            performCustomAction()\n                            true\n                        }\n                        else -> super.performAccessibilityAction(host, action, args)\n                    }\n                }\n            }\n        )\n    }\n}\n\n// 4. Accessibility Announcements\nfun announceMessage(view: View, message: String) {\n    view.announceForAccessibility(message)\n}\n\n// Announce changes\nfun updateItemCount(count: Int) {\n    val message = resources.getQuantityString(\n        R.plurals.items_count,\n        count,\n        count\n    )\n    recyclerView.announceForAccessibility(message)\n}\n\n// 5. Live Regions for dynamic content\n<TextView\n    android:id=\"@+id/statusText\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:accessibilityLiveRegion=\"polite\" />\n\n// accessibilityLiveRegion values:\n// - \"none\" (default): No announcements\n// - \"polite\": Announce when user is idle\n// - \"assertive\": Interrupt and announce immediately\n\n// In code\nViewCompat.setAccessibilityLiveRegion(\n    statusText,\n    ViewCompat.ACCESSIBILITY_LIVE_REGION_POLITE\n)\n\n// 6. Headings for Screen Readers\n<TextView\n    android:id=\"@+id/sectionTitle\"\n    android:text=\"Settings\"\n    android:accessibilityHeading=\"true\" />\n\n// In code\nViewCompat.setAccessibilityHeading(titleView, true)\n\n// 7. Focus Order\n<LinearLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\">\n    \n    <EditText\n        android:id=\"@+id/usernameField\"\n        android:nextFocusForward=\"@id/passwordField\" />\n    \n    <EditText\n        android:id=\"@+id/passwordField\"\n        android:nextFocusForward=\"@id/submitButton\" />\n    \n    <Button\n        android:id=\"@+id/submitButton\"\n        android:text=\"Submit\" />\n</LinearLayout>\n\n// Programmatic focus control\nfun moveFocusToField() {\n    usernameField.requestFocus()\n    usernameField.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_FOCUSED)\n}\n\n// 8. Touch Target Size\n// Minimum 48dp x 48dp\n<Button\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:minWidth=\"48dp\"\n    android:minHeight=\"48dp\" />\n\n// Increase touch area programmatically\nfun increaseTouchArea(view: View, extraSpace: Int) {\n    val parent = view.parent as View\n    parent.post {\n        val rect = Rect()\n        view.getHitRect(rect)\n        rect.top -= extraSpace\n        rect.left -= extraSpace\n        rect.bottom += extraSpace\n        rect.right += extraSpace\n        parent.touchDelegate = TouchDelegate(rect, view)\n    }\n}\n\n// 9. Group Related Content\n<LinearLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:screenReaderFocusable=\"true\"\n    android:contentDescription=\"User information: John Doe, john@example.com\">\n    \n    <TextView\n        android:text=\"John Doe\"\n        android:importantForAccessibility=\"no\" />\n    \n    <TextView\n        android:text=\"john@example.com\"\n        android:importantForAccessibility=\"no\" />\n</LinearLayout>\n\n// 10. Check Accessibility Enabled\nfun isAccessibilityEnabled(context: Context): Boolean {\n    val am = context.getSystemService(Context.ACCESSIBILITY_SERVICE) as AccessibilityManager\n    return am.isEnabled\n}\n\nfun isTalkBackEnabled(context: Context): Boolean {\n    val am = context.getSystemService(Context.ACCESSIBILITY_SERVICE) as AccessibilityManager\n    val enabledServices = am.getEnabledAccessibilityServiceList(\n        AccessibilityServiceInfo.FEEDBACK_SPOKEN\n    )\n    return enabledServices.isNotEmpty()\n}\n\n// 11. Custom Accessibility Service\nclass MyAccessibilityService : AccessibilityService() {\n    \n    override fun onAccessibilityEvent(event: AccessibilityEvent) {\n        when (event.eventType) {\n            AccessibilityEvent.TYPE_VIEW_CLICKED -> {\n                // View was clicked\n            }\n            AccessibilityEvent.TYPE_VIEW_FOCUSED -> {\n                // View gained focus\n            }\n            AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED -> {\n                // Window state changed\n            }\n        }\n    }\n    \n    override fun onInterrupt() {\n        // Service interrupted\n    }\n    \n    override fun onServiceConnected() {\n        val info = AccessibilityServiceInfo().apply {\n            eventTypes = AccessibilityEvent.TYPES_ALL_MASK\n            feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC\n            notificationTimeout = 100\n        }\n        serviceInfo = info\n    }\n}\n\n// AndroidManifest.xml\n<service\n    android:name=\".MyAccessibilityService\"\n    android:permission=\"android.permission.BIND_ACCESSIBILITY_SERVICE\">\n    <intent-filter>\n        <action android:name=\"android.accessibilityservice.AccessibilityService\" />\n    </intent-filter>\n    <meta-data\n        android:name=\"android.accessibilityservice\"\n        android:resource=\"@xml/accessibility_service_config\" />\n</service>\n\n// 12. Testing Accessibility\nclass AccessibilityTestActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        \n        if (BuildConfig.DEBUG) {\n            checkAccessibility()\n        }\n    }\n    \n    private fun checkAccessibility() {\n        val rootView = findViewById<ViewGroup>(android.R.id.content)\n        checkViewAccessibility(rootView)\n    }\n    \n    private fun checkViewAccessibility(view: View) {\n        if (view is ImageView || view is ImageButton) {\n            val contentDesc = view.contentDescription\n            if (contentDesc.isNullOrEmpty() && \n                view.importantForAccessibility != View.IMPORTANT_FOR_ACCESSIBILITY_NO) {\n                Log.w(\"Accessibility\", \"Image missing content description: ${view.id}\")\n            }\n        }\n        \n        // Check touch target size\n        if (view.isClickable) {\n            val minSize = (48 * resources.displayMetrics.density).toInt()\n            if (view.width < minSize || view.height < minSize) {\n                Log.w(\"Accessibility\", \"Touch target too small: ${view.id}\")\n            }\n        }\n        \n        if (view is ViewGroup) {\n            for (i in 0 until view.childCount) {\n                checkViewAccessibility(view.getChildAt(i))\n            }\n        }\n    }\n}\n\n// 13. Espresso Accessibility Testing\n@RunWith(AndroidJUnit4::class)\nclass AccessibilityTest {\n    \n    @get:Rule\n    val activityRule = ActivityScenarioRule(MainActivity::class.java)\n    \n    @Test\n    fun testAccessibility() {\n        onView(withId(R.id.shareButton))\n            .check(matches(hasContentDescription()))\n        \n        onView(withId(R.id.shareButton))\n            .check(matches(hasSizeThat(\n                greaterThanOrEqualTo(48 * density.toInt())\n            )))\n    }\n}\n\n// 14. Color Contrast\n// Ensure sufficient contrast ratio\n// WCAG AA: 4.5:1 for normal text, 3:1 for large text\n// WCAG AAA: 7:1 for normal text, 4.5:1 for large text\n\n<TextView\n    android:text=\"Important Text\"\n    android:textColor=\"#000000\"\n    android:background=\"#FFFFFF\" />\n\n// Check contrast programmatically\nfun hasGoodContrast(foreground: Int, background: Int): Boolean {\n    val contrastRatio = ColorUtils.calculateContrast(foreground, background)\n    return contrastRatio >= 4.5 // WCAG AA for normal text\n}"
    },
    {
      "id": 83,
      "question": "What is Android Notifications and how to implement them?",
      "answer": "Android Notifications inform users about events, messages, and updates through system notification tray.\n\nNotification Types:\n• Basic notifications\n• Expandable notifications\n• Action notifications\n• Progress notifications\n• Media notifications\n• Message notifications\n\nNotification Channels:\n• Required Android 8.0+\n• Categorize notifications\n• User-controlled settings\n• Importance levels\n• Sound, vibration, badges\n\nImportance Levels:\n• IMPORTANCE_HIGH - Shows heads-up\n• IMPORTANCE_DEFAULT - Normal notification\n• IMPORTANCE_LOW - No sound\n• IMPORTANCE_MIN - Minimal, no status bar\n\nComponents:\n• NotificationManager\n• NotificationCompat.Builder\n• PendingIntent\n• NotificationChannel\n• Action buttons\n\nBest Practices:\n• Create channels\n• Set appropriate importance\n• Provide actions\n• Group related notifications\n• Update not replace\n• Clear when done",
      "explanation": "Android Notifications use NotificationCompat.Builder with NotificationChannels (Android 8.0+) to display alerts with customizable importance, actions, expandable layouts, and PendingIntents for user interaction.",
      "difficulty": "Medium",
      "code": "// 1. Basic Notification Setup\nclass NotificationHelper(private val context: Context) {\n    \n    companion object {\n        const val CHANNEL_ID = \"default_channel\"\n        const val CHANNEL_NAME = \"Default Channel\"\n        const val NOTIFICATION_ID = 1\n    }\n    \n    private val notificationManager = context.getSystemService(\n        Context.NOTIFICATION_SERVICE\n    ) as NotificationManager\n    \n    init {\n        createNotificationChannel()\n    }\n    \n    private fun createNotificationChannel() {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            val channel = NotificationChannel(\n                CHANNEL_ID,\n                CHANNEL_NAME,\n                NotificationManager.IMPORTANCE_DEFAULT\n            ).apply {\n                description = \"Default notification channel\"\n                enableLights(true)\n                lightColor = Color.BLUE\n                enableVibration(true)\n                vibrationPattern = longArrayOf(100, 200, 300, 400)\n                setShowBadge(true)\n            }\n            notificationManager.createNotificationChannel(channel)\n        }\n    }\n    \n    fun showBasicNotification(\n        title: String,\n        message: String,\n        icon: Int = R.drawable.ic_notification\n    ) {\n        val intent = Intent(context, MainActivity::class.java).apply {\n            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK\n        }\n        \n        val pendingIntent = PendingIntent.getActivity(\n            context,\n            0,\n            intent,\n            PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT\n        )\n        \n        val notification = NotificationCompat.Builder(context, CHANNEL_ID)\n            .setSmallIcon(icon)\n            .setContentTitle(title)\n            .setContentText(message)\n            .setContentIntent(pendingIntent)\n            .setPriority(NotificationCompat.PRIORITY_DEFAULT)\n            .setAutoCancel(true)\n            .build()\n        \n        notificationManager.notify(NOTIFICATION_ID, notification)\n    }\n}\n\n// 2. Expandable Notification\nfun showExpandableNotification() {\n    val bigTextStyle = NotificationCompat.BigTextStyle()\n        .bigText(\"This is a long text that will be expanded when user expands the notification. \" +\n                \"It can contain multiple lines and more detailed information.\")\n        .setBigContentTitle(\"Expanded Title\")\n        .setSummaryText(\"Summary Text\")\n    \n    val notification = NotificationCompat.Builder(context, CHANNEL_ID)\n        .setSmallIcon(R.drawable.ic_notification)\n        .setContentTitle(\"Expandable Notification\")\n        .setContentText(\"This will expand\")\n        .setStyle(bigTextStyle)\n        .build()\n    \n    notificationManager.notify(1, notification)\n}\n\n// 3. Notification with Actions\nfun showNotificationWithActions() {\n    // Action 1: Reply\n    val replyIntent = Intent(context, ReplyReceiver::class.java)\n    val replyPendingIntent = PendingIntent.getBroadcast(\n        context,\n        0,\n        replyIntent,\n        PendingIntent.FLAG_IMMUTABLE\n    )\n    \n    // Action 2: Dismiss\n    val dismissIntent = Intent(context, DismissReceiver::class.java)\n    val dismissPendingIntent = PendingIntent.getBroadcast(\n        context,\n        1,\n        dismissIntent,\n        PendingIntent.FLAG_IMMUTABLE\n    )\n    \n    val notification = NotificationCompat.Builder(context, CHANNEL_ID)\n        .setSmallIcon(R.drawable.ic_notification)\n        .setContentTitle(\"New Message\")\n        .setContentText(\"You have a new message\")\n        .addAction(\n            R.drawable.ic_reply,\n            \"Reply\",\n            replyPendingIntent\n        )\n        .addAction(\n            R.drawable.ic_dismiss,\n            \"Dismiss\",\n            dismissPendingIntent\n        )\n        .build()\n    \n    notificationManager.notify(2, notification)\n}\n\n// 4. Progress Notification\nfun showProgressNotification() {\n    val builder = NotificationCompat.Builder(context, CHANNEL_ID)\n        .setSmallIcon(R.drawable.ic_download)\n        .setContentTitle(\"Downloading\")\n        .setContentText(\"Download in progress\")\n        .setPriority(NotificationCompat.PRIORITY_LOW)\n        .setOngoing(true)\n    \n    val maxProgress = 100\n    \n    // Show progress\n    GlobalScope.launch {\n        for (progress in 0..maxProgress step 10) {\n            builder.setProgress(maxProgress, progress, false)\n            notificationManager.notify(3, builder.build())\n            delay(500)\n        }\n        \n        // Download complete\n        builder.setContentText(\"Download complete\")\n            .setProgress(0, 0, false)\n            .setOngoing(false)\n            .setAutoCancel(true)\n        notificationManager.notify(3, builder.build())\n    }\n}\n\n// Indeterminate progress\nfun showIndeterminateProgress() {\n    val notification = NotificationCompat.Builder(context, CHANNEL_ID)\n        .setSmallIcon(R.drawable.ic_sync)\n        .setContentTitle(\"Syncing\")\n        .setContentText(\"Please wait...\")\n        .setProgress(0, 0, true) // Indeterminate\n        .setOngoing(true)\n        .build()\n    \n    notificationManager.notify(4, notification)\n}\n\n// 5. Big Picture Notification\nfun showBigPictureNotification(bitmap: Bitmap) {\n    val bigPictureStyle = NotificationCompat.BigPictureStyle()\n        .bigPicture(bitmap)\n        .bigLargeIcon(null as Bitmap?) // Hide large icon when expanded\n    \n    val notification = NotificationCompat.Builder(context, CHANNEL_ID)\n        .setSmallIcon(R.drawable.ic_notification)\n        .setContentTitle(\"New Photo\")\n        .setContentText(\"Check out this photo\")\n        .setLargeIcon(bitmap)\n        .setStyle(bigPictureStyle)\n        .build()\n    \n    notificationManager.notify(5, notification)\n}\n\n// 6. Inbox Style Notification\nfun showInboxStyleNotification(messages: List<String>) {\n    val inboxStyle = NotificationCompat.InboxStyle()\n        .setBigContentTitle(\"${messages.size} new messages\")\n        .setSummaryText(\"from various senders\")\n    \n    messages.forEach { message ->\n        inboxStyle.addLine(message)\n    }\n    \n    val notification = NotificationCompat.Builder(context, CHANNEL_ID)\n        .setSmallIcon(R.drawable.ic_message)\n        .setContentTitle(\"New Messages\")\n        .setContentText(\"You have ${messages.size} new messages\")\n        .setStyle(inboxStyle)\n        .setNumber(messages.size)\n        .build()\n    \n    notificationManager.notify(6, notification)\n}\n\n// 7. Message Notification with Reply\nfun showMessageNotification() {\n    val replyLabel = \"Reply\"\n    val remoteInput = RemoteInput.Builder(KEY_TEXT_REPLY)\n        .setLabel(replyLabel)\n        .build()\n    \n    val replyIntent = Intent(context, ReplyReceiver::class.java)\n    val replyPendingIntent = PendingIntent.getBroadcast(\n        context,\n        0,\n        replyIntent,\n        PendingIntent.FLAG_MUTABLE\n    )\n    \n    val replyAction = NotificationCompat.Action.Builder(\n        R.drawable.ic_reply,\n        replyLabel,\n        replyPendingIntent\n    )\n        .addRemoteInput(remoteInput)\n        .build()\n    \n    val messagingStyle = NotificationCompat.MessagingStyle(\"Me\")\n        .setConversationTitle(\"Chat with John\")\n        .addMessage(\"Hello!\", System.currentTimeMillis(), \"John\")\n        .addMessage(\"How are you?\", System.currentTimeMillis(), \"John\")\n    \n    val notification = NotificationCompat.Builder(context, CHANNEL_ID)\n        .setSmallIcon(R.drawable.ic_message)\n        .setStyle(messagingStyle)\n        .addAction(replyAction)\n        .build()\n    \n    notificationManager.notify(7, notification)\n}\n\n// Handle reply\nclass ReplyReceiver : BroadcastReceiver() {\n    override fun onReceive(context: Context, intent: Intent) {\n        val remoteInput = RemoteInput.getResultsFromIntent(intent)\n        if (remoteInput != null) {\n            val replyText = remoteInput.getCharSequence(KEY_TEXT_REPLY)\n            // Process reply\n            sendMessage(replyText.toString())\n        }\n    }\n}\n\ncompanion object {\n    const val KEY_TEXT_REPLY = \"key_text_reply\"\n}\n\n// 8. Grouped Notifications\nfun showGroupedNotifications(messages: List<Message>) {\n    val groupKey = \"message_group\"\n    \n    // Individual notifications\n    messages.forEachIndexed { index, message ->\n        val notification = NotificationCompat.Builder(context, CHANNEL_ID)\n            .setSmallIcon(R.drawable.ic_message)\n            .setContentTitle(message.sender)\n            .setContentText(message.text)\n            .setGroup(groupKey)\n            .build()\n        \n        notificationManager.notify(index, notification)\n    }\n    \n    // Summary notification\n    val summaryNotification = NotificationCompat.Builder(context, CHANNEL_ID)\n        .setSmallIcon(R.drawable.ic_message)\n        .setContentTitle(\"${messages.size} new messages\")\n        .setContentText(\"From multiple senders\")\n        .setGroup(groupKey)\n        .setGroupSummary(true)\n        .build()\n    \n    notificationManager.notify(SUMMARY_ID, summaryNotification)\n}\n\n// 9. Foreground Service Notification\nclass MusicService : Service() {\n    \n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\n        val notification = createNotification(\"Playing\", \"Song Title\")\n        startForeground(FOREGROUND_SERVICE_ID, notification)\n        return START_STICKY\n    }\n    \n    private fun createNotification(title: String, text: String): Notification {\n        val playPauseIntent = Intent(this, PlayPauseReceiver::class.java)\n        val playPausePendingIntent = PendingIntent.getBroadcast(\n            this,\n            0,\n            playPauseIntent,\n            PendingIntent.FLAG_IMMUTABLE\n        )\n        \n        return NotificationCompat.Builder(this, CHANNEL_ID)\n            .setSmallIcon(R.drawable.ic_music)\n            .setContentTitle(title)\n            .setContentText(text)\n            .addAction(\n                R.drawable.ic_play_pause,\n                \"Play/Pause\",\n                playPausePendingIntent\n            )\n            .setOngoing(true)\n            .build()\n    }\n    \n    override fun onBind(intent: Intent?): IBinder? = null\n}\n\n// 10. Update Notification\nfun updateNotification(notificationId: Int, newText: String) {\n    val notification = NotificationCompat.Builder(context, CHANNEL_ID)\n        .setSmallIcon(R.drawable.ic_notification)\n        .setContentTitle(\"Updated\")\n        .setContentText(newText)\n        .build()\n    \n    notificationManager.notify(notificationId, notification)\n}\n\n// Cancel notification\nfun cancelNotification(notificationId: Int) {\n    notificationManager.cancel(notificationId)\n}\n\n// Cancel all notifications\nfun cancelAllNotifications() {\n    notificationManager.cancelAll()\n}"
    },
    {
      "id": 84,
      "question": "What is Android App Links and Universal Links?",
      "answer": "App Links enable seamless integration between web content and Android apps through verified HTTPS URLs that open directly in the app.\n\nTypes of Links:\n• Deep Links - Custom URI schemes\n• Web Links - Standard HTTP/HTTPS URLs\n• Android App Links - Verified HTTPS URLs\n\nApp Links Benefits:\n• Instant app opening\n• No disambiguation dialog\n• Verified ownership\n• Better user experience\n• SEO benefits\n\nVerification Process:\n• Create assetlinks.json\n• Host on web domain\n• Add intent filters\n• Enable autoVerify\n• Test verification\n\nAssetlinks.json:\n• Digital Asset Links file\n• Hosted at .well-known/assetlinks.json\n• Contains app package and signing certificate\n• Verifies domain ownership\n\nIntent Filters:\n• android:autoVerify=\"true\"\n• HTTPS scheme required\n• Specific host declaration\n• Path patterns\n\nBest Practices:\n• Use HTTPS only\n• Verify all domains\n• Handle fallbacks\n• Test thoroughly\n• Monitor verification status",
      "explanation": "Android App Links use verified HTTPS URLs with autoVerify intent filters and assetlinks.json hosted on web domains to enable direct app opening without disambiguation, verified through Digital Asset Links.",
      "difficulty": "Hard",
      "code": "// 1. AndroidManifest.xml - App Links Intent Filter\n<activity android:name=\".ProductDetailActivity\">\n    <intent-filter android:autoVerify=\"true\">\n        <action android:name=\"android.intent.action.VIEW\" />\n        \n        <category android:name=\"android.intent.category.DEFAULT\" />\n        <category android:name=\"android.intent.category.BROWSABLE\" />\n        \n        <!-- HTTPS only for App Links -->\n        <data\n            android:scheme=\"https\"\n            android:host=\"www.example.com\"\n            android:pathPrefix=\"/products\" />\n        \n        <!-- Handles: https://www.example.com/products/123 -->\n    </intent-filter>\n    \n    <!-- Multiple paths -->\n    <intent-filter android:autoVerify=\"true\">\n        <action android:name=\"android.intent.action.VIEW\" />\n        \n        <category android:name=\"android.intent.category.DEFAULT\" />\n        <category android:name=\"android.intent.category.BROWSABLE\" />\n        \n        <data android:scheme=\"https\" />\n        <data android:host=\"www.example.com\" />\n        <data android:host=\"shop.example.com\" />\n        <data android:pathPrefix=\"/products\" />\n        <data android:pathPrefix=\"/items\" />\n    </intent-filter>\n</activity>\n\n// 2. Handle App Link in Activity\nclass ProductDetailActivity : AppCompatActivity() {\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_product_detail)\n        \n        handleAppLink(intent)\n    }\n    \n    override fun onNewIntent(intent: Intent) {\n        super.onNewIntent(intent)\n        handleAppLink(intent)\n    }\n    \n    private fun handleAppLink(intent: Intent) {\n        val action = intent.action\n        val data: Uri? = intent.data\n        \n        if (Intent.ACTION_VIEW == action && data != null) {\n            when {\n                data.path?.startsWith(\"/products\") == true -> {\n                    handleProductLink(data)\n                }\n                data.path?.startsWith(\"/items\") == true -> {\n                    handleItemLink(data)\n                }\n                else -> {\n                    // Unknown path\n                    showHome()\n                }\n            }\n        }\n    }\n    \n    private fun handleProductLink(uri: Uri) {\n        // Extract product ID from path\n        // URL: https://www.example.com/products/123\n        val productId = uri.pathSegments.getOrNull(1)\n        \n        // Extract query parameters\n        // URL: https://www.example.com/products?id=123&category=electronics\n        val id = uri.getQueryParameter(\"id\")\n        val category = uri.getQueryParameter(\"category\")\n        \n        productId?.let {\n            loadProductDetails(it)\n        } ?: run {\n            showError(\"Invalid product ID\")\n        }\n    }\n    \n    private fun loadProductDetails(productId: String) {\n        // Load product\n        viewModel.loadProduct(productId)\n    }\n    \n    private fun showHome() {\n        val intent = Intent(this, MainActivity::class.java)\n        startActivity(intent)\n        finish()\n    }\n}\n\n// 3. Digital Asset Links file\n// Place at: https://www.example.com/.well-known/assetlinks.json\n[\n  {\n    \"relation\": [\"delegate_permission/common.handle_all_urls\"],\n    \"target\": {\n      \"namespace\": \"android_app\",\n      \"package_name\": \"com.example.myapp\",\n      \"sha256_cert_fingerprints\": [\n        \"14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5\"\n      ]\n    }\n  }\n]\n\n// Get SHA256 fingerprint:\n// For debug keystore:\n// keytool -list -v -keystore ~/.android/debug.keystore -alias androiddebugkey -storepass android -keypass android\n\n// For release keystore:\n// keytool -list -v -keystore my-release-key.keystore\n\n// 4. Verify App Links\n/*\nADB commands to verify:\n\n// Check App Links verification status\nadb shell pm get-app-links com.example.myapp\n\n// Output:\ncom.example.myapp:\n  ID: xxx\n  Signatures: [xxx]\n  Domain verification state:\n    www.example.com: verified\n    shop.example.com: verified\n\n// Reset verification state (for testing)\nadb shell pm set-app-links --package com.example.myapp 0 all\n\n// Manually verify\nadb shell pm verify-app-links --re-verify com.example.myapp\n\n// Test App Link\nadb shell am start -W -a android.intent.action.VIEW \\\n  -d \"https://www.example.com/products/123\" com.example.myapp\n*/\n\n// 5. Create App Link programmatically\nfun createAppLink(productId: String): String {\n    return \"https://www.example.com/products/$productId\"\n}\n\n// Share App Link\nfun shareProduct(productId: String) {\n    val appLink = createAppLink(productId)\n    \n    val shareIntent = Intent(Intent.ACTION_SEND).apply {\n        type = \"text/plain\"\n        putExtra(Intent.EXTRA_TEXT, \"Check out this product: $appLink\")\n    }\n    \n    startActivity(Intent.createChooser(shareIntent, \"Share Product\"))\n}\n\n// 6. Firebase Dynamic Links alternative\nimplementation 'com.google.firebase:firebase-dynamic-links:21.1.0'\n\n// Create Dynamic Link\nfun createDynamicLink(productId: String) {\n    Firebase.dynamicLinks.shortLinkAsync {\n        link = Uri.parse(\"https://www.example.com/products/$productId\")\n        domainUriPrefix = \"https://example.page.link\"\n        \n        // Android parameters\n        androidParameters {\n            build()\n        }\n        \n        // iOS parameters\n        iosParameters(\"com.example.ios\") {\n            appStoreId = \"123456789\"\n            build()\n        }\n        \n        // Social meta tags\n        socialMetaTagParameters {\n            title = \"Product Title\"\n            description = \"Product Description\"\n            imageUrl = Uri.parse(\"https://example.com/image.jpg\")\n            build()\n        }\n    }.addOnSuccessListener { result ->\n        val shortLink = result.shortLink\n        val flowchartLink = result.previewLink\n        \n        shareLink(shortLink.toString())\n    }\n}\n\n// Handle Dynamic Link\nFirebase.dynamicLinks\n    .getDynamicLink(intent)\n    .addOnSuccessListener { pendingDynamicLinkData ->\n        var deepLink: Uri? = null\n        if (pendingDynamicLinkData != null) {\n            deepLink = pendingDynamicLinkData.link\n        }\n        \n        deepLink?.let { uri ->\n            // Handle the deep link\n            handleDeepLink(uri)\n        }\n    }\n\n// 7. Navigation Component with App Links\n// nav_graph.xml\n<navigation>\n    <fragment\n        android:id=\"@+id/productDetailFragment\"\n        android:name=\"com.example.ProductDetailFragment\">\n        \n        <deepLink\n            app:uri=\"https://www.example.com/products/{productId}\"\n            android:autoVerify=\"true\" />\n        \n        <argument\n            android:name=\"productId\"\n            app:argType=\"string\" />\n    </fragment>\n</navigation>\n\n// MainActivity handles navigation automatically\nclass MainActivity : AppCompatActivity() {\n    private lateinit var navController: NavController\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        val navHostFragment = supportFragmentManager\n            .findFragmentById(R.id.nav_host_fragment) as NavHostFragment\n        navController = navHostFragment.navController\n        \n        // Automatically handles deep links\n        navController.handleDeepLink(intent)\n    }\n    \n    override fun onNewIntent(intent: Intent?) {\n        super.onNewIntent(intent)\n        intent?.let { navController.handleDeepLink(it) }\n    }\n}\n\n// 8. Test App Links locally\n// Use Charles Proxy or similar to redirect requests\n// Or use adb reverse for local testing\n/*\n// Forward device requests to local server\nadb reverse tcp:8080 tcp:8080\n\n// Now device can access http://localhost:8080\n// Serve assetlinks.json at http://localhost:8080/.well-known/assetlinks.json\n*/\n\n// 9. Handle verification failure\nclass AppLinkHandler(private val context: Context) {\n    \n    fun checkVerificationStatus() {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {\n            val domainVerificationManager = context.getSystemService(\n                DomainVerificationManager::class.java\n            )\n            \n            val userState = domainVerificationManager.getDomainVerificationUserState(\n                context.packageName\n            )\n            \n            val hostToStateMap = userState?.hostToStateMap\n            hostToStateMap?.forEach { (domain, state) ->\n                when (state) {\n                    DomainVerificationUserState.DOMAIN_STATE_VERIFIED -> {\n                        Log.d(\"AppLinks\", \"$domain: Verified\")\n                    }\n                    DomainVerificationUserState.DOMAIN_STATE_SELECTED -> {\n                        Log.d(\"AppLinks\", \"$domain: Selected by user\")\n                    }\n                    DomainVerificationUserState.DOMAIN_STATE_NONE -> {\n                        Log.w(\"AppLinks\", \"$domain: Not verified\")\n                    }\n                }\n            }\n        }\n    }\n    \n    fun openAppSettings() {\n        val intent = Intent(\n            Settings.ACTION_APP_OPEN_BY_DEFAULT_SETTINGS,\n            Uri.parse(\"package:${context.packageName}\")\n        )\n        context.startActivity(intent)\n    }\n}\n\n// 10. App Link Utilities\nobject AppLinkUtils {\n    \n    fun parseProductId(uri: Uri): String? {\n        // Parse different URL formats\n        return when {\n            uri.pathSegments.size > 1 && uri.pathSegments[0] == \"products\" -> {\n                uri.pathSegments[1]\n            }\n            uri.getQueryParameter(\"id\") != null -> {\n                uri.getQueryParameter(\"id\")\n            }\n            else -> null\n        }\n    }\n    \n    fun isAppLink(intent: Intent): Boolean {\n        return intent.action == Intent.ACTION_VIEW && \n               intent.data?.scheme == \"https\"\n    }\n    \n    fun logAppLink(uri: Uri) {\n        Log.d(\"AppLink\", \"Opened: ${uri}\")\n        Log.d(\"AppLink\", \"Scheme: ${uri.scheme}\")\n        Log.d(\"AppLink\", \"Host: ${uri.host}\")\n        Log.d(\"AppLink\", \"Path: ${uri.path}\")\n        Log.d(\"AppLink\", \"Query: ${uri.query}\")\n    }\n}"
    },
    {
      "id": 85,
      "question": "What is Android Modularization and Multi-Module Architecture?",
      "answer": "Modularization divides an app into independent modules for better organization, build times, code reuse, and team scalability.\n\nBenefits:\n• Faster build times\n• Better code organization\n• Parallel development\n• Code reuse\n• Feature isolation\n• Dynamic feature modules\n\nModule Types:\n• App module - Main application\n• Library modules - Reusable code\n• Feature modules - Specific features\n• Dynamic feature modules - On-demand\n• Core modules - Shared functionality\n\nModule Organization:\n• Layered architecture\n• Feature-based modules\n• Clean architecture layers\n• Shared modules\n• Domain-specific modules\n\nDependency Management:\n• Implementation vs API\n• Version catalogs\n• Dependency injection\n• Module dependencies\n• Avoid circular dependencies\n\nBest Practices:\n• Single responsibility\n• Minimize dependencies\n• Use dependency inversion\n• Define clear interfaces\n• Test modules independently",
      "explanation": "Android Modularization splits apps into independent Gradle modules (app, library, feature, dynamic) organized by layers or features, improving build performance, enabling parallel development, and supporting code reuse.",
      "difficulty": "Hard",
      "code": "// 1. Multi-Module Project Structure\n/*\nMyApp/\n├── app/                        (Application module)\n├── core/\n│   ├── common/                 (Common utilities)\n│   ├── data/                   (Data layer)\n│   ├── domain/                 (Domain models)\n│   └── ui/                     (UI components)\n├── feature/\n│   ├── home/                   (Home feature)\n│   ├── profile/                (Profile feature)\n│   ├── search/                 (Search feature)\n│   └── settings/               (Settings feature)\n├── libs/\n│   ├── analytics/              (Analytics library)\n│   └── network/                (Network library)\n└── buildSrc/                   (Build configuration)\n*/\n\n// 2. Root build.gradle.kts\nbuildscript {\n    repositories {\n        google()\n        mavenCentral()\n    }\n    dependencies {\n        classpath(\"com.android.tools.build:gradle:8.0.2\")\n        classpath(\"org.jetbrains.kotlin:kotlin-gradle-plugin:1.8.20\")\n        classpath(\"com.google.dagger:hilt-android-gradle-plugin:2.46\")\n    }\n}\n\nallprojects {\n    repositories {\n        google()\n        mavenCentral()\n    }\n}\n\ntasks.register(\"clean\", Delete::class) {\n    delete(rootProject.buildDir)\n}\n\n// 3. Version Catalog (gradle/libs.versions.toml)\n[versions]\nandroid-gradle-plugin = \"8.0.2\"\nkotlin = \"1.8.20\"\ncompose = \"1.4.3\"\nhilt = \"2.46\"\nretrofit = \"2.9.0\"\nroom = \"2.5.2\"\n\n[libraries]\nandroidx-core = { group = \"androidx.core\", name = \"core-ktx\", version = \"1.10.1\" }\nandroidx-lifecycle-viewmodel = { group = \"androidx.lifecycle\", name = \"lifecycle-viewmodel-ktx\", version = \"2.6.1\" }\ncompose-ui = { group = \"androidx.compose.ui\", name = \"ui\", version.ref = \"compose\" }\ncompose-material3 = { group = \"androidx.compose.material3\", name = \"material3\", version = \"1.1.0\" }\nhilt-android = { group = \"com.google.dagger\", name = \"hilt-android\", version.ref = \"hilt\" }\nhilt-compiler = { group = \"com.google.dagger\", name = \"hilt-compiler\", version.ref = \"hilt\" }\nretrofit = { group = \"com.squareup.retrofit2\", name = \"retrofit\", version.ref = \"retrofit\" }\nroom-runtime = { group = \"androidx.room\", name = \"room-runtime\", version.ref = \"room\" }\nroom-compiler = { group = \"androidx.room\", name = \"room-compiler\", version.ref = \"room\" }\n\n[plugins]\nandroid-application = { id = \"com.android.application\", version.ref = \"android-gradle-plugin\" }\nandroid-library = { id = \"com.android.library\", version.ref = \"android-gradle-plugin\" }\nkotlin-android = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\nhilt-android = { id = \"com.google.dagger.hilt.android\", version.ref = \"hilt\" }\n\n// 4. App Module (app/build.gradle.kts)\nplugins {\n    alias(libs.plugins.android.application)\n    alias(libs.plugins.kotlin.android)\n    alias(libs.plugins.hilt.android)\n    kotlin(\"kapt\")\n}\n\nandroid {\n    namespace = \"com.example.myapp\"\n    compileSdk = 33\n    \n    defaultConfig {\n        applicationId = \"com.example.myapp\"\n        minSdk = 24\n        targetSdk = 33\n        versionCode = 1\n        versionName = \"1.0\"\n    }\n    \n    buildFeatures {\n        compose = true\n    }\n    \n    composeOptions {\n        kotlinCompilerExtensionVersion = libs.versions.compose.get()\n    }\n}\n\ndependencies {\n    // Core modules\n    implementation(project(\":core:common\"))\n    implementation(project(\":core:data\"))\n    implementation(project(\":core:domain\"))\n    implementation(project(\":core:ui\"))\n    \n    // Feature modules\n    implementation(project(\":feature:home\"))\n    implementation(project(\":feature:profile\"))\n    implementation(project(\":feature:search\"))\n    implementation(project(\":feature:settings\"))\n    \n    // Libraries\n    implementation(project(\":libs:analytics\"))\n    implementation(project(\":libs:network\"))\n    \n    // Hilt\n    implementation(libs.hilt.android)\n    kapt(libs.hilt.compiler)\n    \n    // Compose\n    implementation(libs.compose.ui)\n    implementation(libs.compose.material3)\n}\n\n// 5. Library Module (core/common/build.gradle.kts)\nplugins {\n    alias(libs.plugins.android.library)\n    alias(libs.plugins.kotlin.android)\n}\n\nandroid {\n    namespace = \"com.example.core.common\"\n    compileSdk = 33\n    \n    defaultConfig {\n        minSdk = 24\n    }\n}\n\ndependencies {\n    implementation(libs.androidxcore)\n    implementation(libs.androidx.lifecycle.viewmodel)\n    \n    // Only expose necessary dependencies with 'api'\n    api(libs.kotlin.coroutines)\n}\n\n// 6. Feature Module (feature/home/build.gradle.kts)\nplugins {\n    alias(libs.plugins.android.library)\n    alias(libs.plugins.kotlin.android)\n    alias(libs.plugins.hilt.android)\n    kotlin(\"kapt\")\n}\n\nandroid {\n    namespace = \"com.example.feature.home\"\n    compileSdk = 33\n    \n    defaultConfig {\n        minSdk = 24\n    }\n    \n    buildFeatures {\n        compose = true\n    }\n    \n    composeOptions {\n        kotlinCompilerExtensionVersion = libs.versions.compose.get()\n    }\n}\n\ndependencies {\n    // Core modules\n    implementation(project(\":core:common\"))\n    implementation(project(\":core:domain\"))\n    implementation(project(\":core:ui\"))\n    \n    // Hilt\n    implementation(libs.hilt.android)\n    kapt(libs.hilt.compiler)\n    \n    // Compose\n    implementation(libs.compose.ui)\n    implementation(libs.compose.material3)\n}\n\n// 7. Dynamic Feature Module (features/premium/build.gradle.kts)\nplugins {\n    id(\"com.android.dynamic-feature\")\n    kotlin(\"android\")\n}\n\nandroid {\n    namespace = \"com.example.feature.premium\"\n    compileSdk = 33\n    \n    defaultConfig {\n        minSdk = 24\n    }\n}\n\ndependencies {\n    implementation(project(\":app\"))\n    implementation(project(\":core:common\"))\n}\n\n// In app build.gradle.kts, declare dynamic feature\nandroid {\n    dynamicFeatures = mutableSetOf(\":features:premium\")\n}\n\n// 8. Module Interface (core/domain/src/main/java/repository/UserRepository.kt)\npackage com.example.core.domain.repository\n\ninterface UserRepository {\n    suspend fun getUsers(): Result<List<User>>\n    suspend fun getUserById(id: String): Result<User>\n}\n\n// Implementation in data module (core/data/src/main/java/repository/UserRepositoryImpl.kt)\npackage com.example.core.data.repository\n\nimport com.example.core.domain.repository.UserRepository\nimport javax.inject.Inject\n\nclass UserRepositoryImpl @Inject constructor(\n    private val api: UserApi,\n    private val dao: UserDao\n) : UserRepository {\n    \n    override suspend fun getUsers(): Result<List<User>> {\n        // Implementation\n    }\n    \n    override suspend fun getUserById(id: String): Result<User> {\n        // Implementation\n    }\n}\n\n// 9. Dependency Injection with Hilt across modules\n// In core/data module\n@Module\n@InstallIn(SingletonComponent::class)\nobject DataModule {\n    \n    @Provides\n    @Singleton\n    fun provideUserRepository(\n        api: UserApi,\n        dao: UserDao\n    ): UserRepository {\n        return UserRepositoryImpl(api, dao)\n    }\n}\n\n// In feature/home module\n@HiltViewModel\nclass HomeViewModel @Inject constructor(\n    private val userRepository: UserRepository\n) : ViewModel() {\n    // ViewModel implementation\n}\n\n// 10. buildSrc for shared build logic (buildSrc/src/main/kotlin/Dependencies.kt)\nobject Versions {\n    const val compileSdk = 33\n    const val minSdk = 24\n    const val targetSdk = 33\n    const val versionCode = 1\n    const val versionName = \"1.0.0\"\n}\n\nobject Libs {\n    const val kotlinStdLib = \"org.jetbrains.kotlin:kotlin-stdlib:1.8.20\"\n    const val androidxCore = \"androidx.core:core-ktx:1.10.1\"\n}\n\n// Use in modules\nimport Versions\nimport Libs\n\nandroid {\n    compileSdk = Versions.compileSdk\n    \n    defaultConfig {\n        minSdk = Versions.minSdk\n        targetSdk = Versions.targetSdk\n    }\n}\n\n// 11. Composite Build (settings.gradle.kts)\nincludeBuild(\"libs/analytics\") {\n    dependencySubstitution {\n        substitute(module(\"com.example:analytics\"))\n            .using(project(\":\"))\n    }\n}\n\n// 12. Navigation between feature modules\n// Define navigation interface in core module\ninterface FeatureNavigator {\n    fun navigateToHome()\n    fun navigateToProfile(userId: String)\n    fun navigateToSearch()\n}\n\n// Implement in app module\nclass FeatureNavigatorImpl(\n    private val navController: NavController\n) : FeatureNavigator {\n    \n    override fun navigateToHome() {\n        navController.navigate(\"home\")\n    }\n    \n    override fun navigateToProfile(userId: String) {\n        navController.navigate(\"profile/$userId\")\n    }\n    \n    override fun navigateToSearch() {\n        navController.navigate(\"search\")\n    }\n}\n\n// 13. Module Testing\n// Test feature module independently\n@RunWith(AndroidJUnit4::class)\nclass HomeViewModelTest {\n    \n    @get:Rule\n    val hiltRule = HiltAndroidRule(this)\n    \n    @Inject\n    lateinit var repository: UserRepository\n    \n    @Before\n    fun setup() {\n        hiltRule.inject()\n    }\n    \n    @Test\n    fun testViewModel() {\n        val viewModel = HomeViewModel(repository)\n        // Test\n    }\n}"
    },
    {
      "id": 86,
      "question": "What is Android Memory Management and Garbage Collection?",
      "answer": "Android Memory Management involves efficient allocation, usage, and cleanup of app memory to prevent leaks and ensure optimal performance.\n\nMemory Components:\n• Heap memory - Object allocation\n• Stack memory - Method calls\n• Native memory - JNI allocations\n• Graphics memory - Bitmaps, textures\n\nGarbage Collection:\n• Automatic memory cleanup\n• Mark and sweep\n• Generational GC\n• Concurrent GC\n• GC pauses affect performance\n\nMemory Leaks:\n• Unreleased references\n• Static references\n• Inner class references\n• Handler leaks\n• Listener leaks\n\nPrevention:\n• Use WeakReference\n• Remove listeners\n• Clear callbacks\n• Avoid static contexts\n• Use LeakCanary\n\nMemory Tools:\n• Memory Profiler\n• Heap dump analysis\n• LeakCanary\n• MAT (Memory Analyzer Tool)\n• Android Studio Profiler\n\nBest Practices:\n• Minimize object creation\n• Release resources\n• Use object pools\n• Optimize bitmaps\n• Monitor memory usage",
      "explanation": "Android Memory Management uses automatic Garbage Collection for heap cleanup, requiring prevention of memory leaks through WeakReference, proper listener cleanup, avoiding static contexts, and using tools like LeakCanary.",
      "difficulty": "Hard",
      "code": "// 1. Common Memory Leak - Static Context\n// BAD - Memory Leak\nclass MainActivity : AppCompatActivity() {\n    companion object {\n        private var sContext: Context? = null // Don't do this!\n    }\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        sContext = this // Activity cannot be garbage collected\n    }\n}\n\n// GOOD - Use Application Context\nclass MyApp : Application() {\n    companion object {\n        private lateinit var instance: MyApp\n        \n        fun getAppContext(): Context {\n            return instance.applicationContext\n        }\n    }\n    \n    override fun onCreate() {\n        super.onCreate()\n        instance = this\n    }\n}\n\n// 2. Memory Leak - Inner Class\n// BAD - Inner class holds reference to outer class\nclass MainActivity : AppCompatActivity() {\n    private val handler = Handler(Looper.getMainLooper())\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        \n        // Anonymous inner class\n        handler.postDelayed(object : Runnable {\n            override fun run() {\n                // Holds reference to Activity\n                updateUI()\n            }\n        }, 10000)\n    }\n    \n    private fun updateUI() {\n        // Update UI\n    }\n}\n\n// GOOD - Use static inner class or weak reference\nclass MainActivity : AppCompatActivity() {\n    private val handler = Handler(Looper.getMainLooper())\n    private val updateRunnable = UpdateRunnable(this)\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        handler.postDelayed(updateRunnable, 10000)\n    }\n    \n    override fun onDestroy() {\n        super.onDestroy()\n        handler.removeCallbacks(updateRunnable)\n    }\n    \n    private fun updateUI() {\n        // Update UI\n    }\n    \n    private class UpdateRunnable(\n        activity: MainActivity\n    ) : Runnable {\n        private val activityRef = WeakReference(activity)\n        \n        override fun run() {\n            val activity = activityRef.get()\n            activity?.updateUI()\n        }\n    }\n}\n\n// 3. Memory Leak - Listeners\n// BAD - Listener not removed\nclass MyFragment : Fragment() {\n    private lateinit var eventBus: EventBus\n    \n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        eventBus = EventBus.getDefault()\n        eventBus.register(this)\n    }\n    \n    @Subscribe\n    fun onEvent(event: MyEvent) {\n        // Handle event\n    }\n}\n\n// GOOD - Unregister listener\nclass MyFragment : Fragment() {\n    private lateinit var eventBus: EventBus\n    \n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        eventBus = EventBus.getDefault()\n        eventBus.register(this)\n    }\n    \n    override fun onDestroyView() {\n        super.onDestroyView()\n        eventBus.unregister(this)\n    }\n    \n    @Subscribe\n    fun onEvent(event: MyEvent) {\n        // Handle event\n    }\n}\n\n// 4. WeakReference for Caching\nclass ImageCache {\n    private val cache = WeakHashMap<String, Bitmap>()\n    \n    fun put(key: String, bitmap: Bitmap) {\n        cache[key] = bitmap\n    }\n    \n    fun get(key: String): Bitmap? {\n        return cache[key]\n    }\n    \n    fun clear() {\n        cache.clear()\n    }\n}\n\n// SoftReference for memory-sensitive cache\nclass MemorySensitiveCache {\n    private val cache = HashMap<String, SoftReference<Bitmap>>()\n    \n    fun put(key: String, bitmap: Bitmap) {\n        cache[key] = SoftReference(bitmap)\n    }\n    \n    fun get(key: String): Bitmap? {\n        return cache[key]?.get()\n    }\n}\n\n// 5. LRU Cache for efficient memory management\nclass BitmapCache {\n    private val maxMemory = (Runtime.getRuntime().maxMemory() / 1024).toInt()\n    private val cacheSize = maxMemory / 8 // Use 1/8 of available memory\n    \n    private val memoryCache = object : LruCache<String, Bitmap>(cacheSize) {\n        override fun sizeOf(key: String, bitmap: Bitmap): Int {\n            // Size in KB\n            return bitmap.byteCount / 1024\n        }\n        \n        override fun entryRemoved(\n            evicted: Boolean,\n            key: String,\n            oldValue: Bitmap,\n            newValue: Bitmap?\n        ) {\n            // Cleanup when entry removed\n            if (evicted && oldValue != newValue) {\n                oldValue.recycle()\n            }\n        }\n    }\n    \n    fun put(key: String, bitmap: Bitmap) {\n        memoryCache.put(key, bitmap)\n    }\n    \n    fun get(key: String): Bitmap? {\n        return memoryCache.get(key)\n    }\n    \n    fun clear() {\n        memoryCache.evictAll()\n    }\n}\n\n// 6. Monitor Memory Usage\nclass MemoryMonitor(private val context: Context) {\n    \n    fun logMemoryInfo() {\n        val activityManager = context.getSystemService(\n            Context.ACTIVITY_SERVICE\n        ) as ActivityManager\n        \n        // Get memory info\n        val memInfo = ActivityManager.MemoryInfo()\n        activityManager.getMemoryInfo(memInfo)\n        \n        Log.d(\"Memory\", \"Available: ${memInfo.availMem / 1024 / 1024} MB\")\n        Log.d(\"Memory\", \"Total: ${memInfo.totalMem / 1024 / 1024} MB\")\n        Log.d(\"Memory\", \"Low Memory: ${memInfo.lowMemory}\")\n        \n        // Get runtime memory\n        val runtime = Runtime.getRuntime()\n        val usedMemory = (runtime.totalMemory() - runtime.freeMemory()) / 1024 / 1024\n        val maxMemory = runtime.maxMemory() / 1024 / 1024\n        val availableMemory = maxMemory - usedMemory\n        \n        Log.d(\"Memory\", \"Used: $usedMemory MB\")\n        Log.d(\"Memory\", \"Max: $maxMemory MB\")\n        Log.d(\"Memory\", \"Available: $availableMemory MB\")\n    }\n    \n    fun isLowMemory(): Boolean {\n        val activityManager = context.getSystemService(\n            Context.ACTIVITY_SERVICE\n        ) as ActivityManager\n        val memInfo = ActivityManager.MemoryInfo()\n        activityManager.getMemoryInfo(memInfo)\n        return memInfo.lowMemory\n    }\n    \n    fun getMemoryClass(): Int {\n        val activityManager = context.getSystemService(\n            Context.ACTIVITY_SERVICE\n        ) as ActivityManager\n        return activityManager.memoryClass // In MB\n    }\n}\n\n// 7. Handle Low Memory\nclass MyActivity : AppCompatActivity() {\n    private lateinit var imageCache: BitmapCache\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        imageCache = BitmapCache()\n    }\n    \n    override fun onTrimMemory(level: Int) {\n        super.onTrimMemory(level)\n        \n        when (level) {\n            ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL,\n            ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW -> {\n                // App is running but system is low on memory\n                imageCache.clear()\n            }\n            ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN -> {\n                // App UI is hidden (background)\n                // Good time to release UI resources\n            }\n            ComponentCallbacks2.TRIM_MEMORY_BACKGROUND,\n            ComponentCallbacks2.TRIM_MEMORY_MODERATE,\n            ComponentCallbacks2.TRIM_MEMORY_COMPLETE -> {\n                // App is in background\n                imageCache.clear()\n                releaseHeavyResources()\n            }\n        }\n    }\n    \n    override fun onLowMemory() {\n        super.onLowMemory()\n        // Critical memory situation\n        imageCache.clear()\n        releaseHeavyResources()\n        System.gc() // Hint to run GC\n    }\n    \n    private fun releaseHeavyResources() {\n        // Release resources\n    }\n}\n\n// 8. Bitmap Memory Management\nclass BitmapManager {\n    \n    fun decodeBitmapFromResource(\n        res: Resources,\n        resId: Int,\n        reqWidth: Int,\n        reqHeight: Int\n    ): Bitmap {\n        return BitmapFactory.Options().run {\n            // First decode with inJustDecodeBounds=true\n            inJustDecodeBounds = true\n            BitmapFactory.decodeResource(res, resId, this)\n            \n            // Calculate inSampleSize\n            inSampleSize = calculateInSampleSize(this, reqWidth, reqHeight)\n            \n            // Decode with inSampleSize\n            inJustDecodeBounds = false\n            inPreferredConfig = Bitmap.Config.RGB_565 // Use less memory\n            BitmapFactory.decodeResource(res, resId, this)\n        }\n    }\n    \n    private fun calculateInSampleSize(\n        options: BitmapFactory.Options,\n        reqWidth: Int,\n        reqHeight: Int\n    ): Int {\n        val (height, width) = options.run { outHeight to outWidth }\n        var inSampleSize = 1\n        \n        if (height > reqHeight || width > reqWidth) {\n            val halfHeight = height / 2\n            val halfWidth = width / 2\n            \n            while ((halfHeight / inSampleSize) >= reqHeight &&\n                   (halfWidth / inSampleSize) >= reqWidth) {\n                inSampleSize *= 2\n            }\n        }\n        \n        return inSampleSize\n    }\n    \n    fun recycleBitmap(bitmap: Bitmap?) {\n        bitmap?.let {\n            if (!it.isRecycled) {\n                it.recycle()\n            }\n        }\n    }\n}\n\n// 9. Object Pool Pattern\nclass ObjectPool<T>(private val factory: () -> T) {\n    private val pool = LinkedList<T>()\n    private val maxSize = 10\n    \n    fun acquire(): T {\n        return if (pool.isEmpty()) {\n            factory()\n        } else {\n            pool.removeFirst()\n        }\n    }\n    \n    fun release(obj: T) {\n        if (pool.size < maxSize) {\n            pool.add(obj)\n        }\n    }\n    \n    fun clear() {\n        pool.clear()\n    }\n}\n\n// Usage\nval bitmapPool = ObjectPool {\n    Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888)\n}\n\nval bitmap = bitmapPool.acquire()\n// Use bitmap\nbitmapPool.release(bitmap)\n\n// 10. LeakCanary Setup\nimplementation 'com.squareup.leakcanary:leakcanary-android:2.12'\n\n// Automatically detects memory leaks in debug builds\n// No code needed, just add dependency\n\n// Custom leak detection\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        \n        if (BuildConfig.DEBUG) {\n            // LeakCanary is automatically initialized\n            // Custom configuration\n            AppWatcher.config = AppWatcher.config.copy(\n                watchDurationMillis = 5000\n            )\n        }\n    }\n}\n\n// 11. Memory Profiling in Code\nclass MemoryProfiler {\n    \n    fun dumpHeap(fileName: String) {\n        try {\n            val file = File(\n                Environment.getExternalStorageDirectory(),\n                fileName\n            )\n            Debug.dumpHprofData(file.absolutePath)\n            Log.d(\"Memory\", \"Heap dump saved: ${file.absolutePath}\")\n        } catch (e: IOException) {\n            Log.e(\"Memory\", \"Failed to dump heap\", e)\n        }\n    }\n    \n    fun logAllocationStats() {\n        val allocated = Debug.getNativeHeapAllocatedSize()\n        val available = Debug.getNativeHeapSize()\n        val free = Debug.getNativeHeapFreeSize()\n        \n        Log.d(\"Memory\", \"Allocated: ${allocated / 1024 / 1024} MB\")\n        Log.d(\"Memory\", \"Available: ${available / 1024 / 1024} MB\")\n        Log.d(\"Memory\", \"Free: ${free / 1024 / 1024} MB\")\n    }\n    \n    fun trackAllocation(block: () -> Unit) {\n        val before = Debug.getNativeHeapAllocatedSize()\n        block()\n        val after = Debug.getNativeHeapAllocatedSize()\n        val allocated = after - before\n        \n        Log.d(\"Memory\", \"Allocated: ${allocated / 1024} KB\")\n    }\n}\n\n// 12. Prevent Context Leaks in ViewModels\n// BAD - Holding Context in ViewModel\nclass BadViewModel(private val context: Context) : ViewModel() {\n    // Context can leak!\n}\n\n// GOOD - Use Application Context\nclass GoodViewModel(\n    private val application: Application\n) : AndroidViewModel(application) {\n    // Application context is safe\n    \n    private val context: Context\n        get() = getApplication<Application>().applicationContext\n}\n\n// Or use Hilt for dependency injection\n@HiltViewModel\nclass MyViewModel @Inject constructor(\n    @ApplicationContext private val context: Context\n) : ViewModel() {\n    // Safe Application context\n}\n\n// 13. Custom Reference Queue\nclass ResourceManager {\n    private val referenceQueue = ReferenceQueue<Resource>()\n    private val resources = mutableListOf<WeakReference<Resource>>()\n    \n    fun addResource(resource: Resource) {\n        val ref = WeakReference(resource, referenceQueue)\n        resources.add(ref)\n    }\n    \n    fun cleanupReleasedResources() {\n        var ref = referenceQueue.poll()\n        while (ref != null) {\n            resources.remove(ref)\n            ref = referenceQueue.poll()\n        }\n    }\n}\n\nclass Resource {\n    // Heavy resource\n}"
    },
    {
      "id": 87,
      "question": "What is Android Best Practices for Production Apps?",
      "answer": "Production-ready Android apps require following industry best practices for quality, performance, security, and maintainability.\n\nCode Quality:\n• Follow SOLID principles\n• Use design patterns\n• Write clean code\n• Code reviews\n• Static analysis tools\n• Consistent naming\n\nArchitecture:\n• MVVM or MVI pattern\n• Clean Architecture\n• Dependency Injection\n• Repository pattern\n• Single source of truth\n\nTesting:\n• Unit tests (70%)\n• Integration tests (20%)\n• UI tests (10%)\n• Test coverage > 80%\n• CI/CD pipeline\n\nPerformance:\n• Optimize startup time\n• Minimize main thread work\n• Lazy loading\n• Image optimization\n• Database indexing\n• Profile regularly\n\nSecurity:\n• Encrypt sensitive data\n• Certificate pinning\n• ProGuard/R8 enabled\n• No hardcoded secrets\n• Secure communication\n\nUser Experience:\n• Material Design\n• Accessibility support\n• Error handling\n• Offline support\n• Loading states\n• Smooth animations",
      "explanation": "Production Android apps follow SOLID principles with Clean Architecture, comprehensive testing (80% coverage), performance optimization through profiling, security via encryption and ProGuard, and excellent UX with Material Design.",
      "difficulty": "Hard",
      "code": "// 1. Project Structure\n/*\napp/\n├── src/\n│   ├── main/\n│   │   ├── java/com/example/app/\n│   │   │   ├── di/              (Dependency Injection)\n│   │   │   ├── data/\n│   │   │   │   ├── local/       (Room, SharedPrefs)\n│   │   │   │   ├── remote/      (Retrofit, API)\n│   │   │   │   └── repository/  (Repository implementations)\n│   │   │   ├── domain/\n│   │   │   │   ├── model/       (Domain models)\n│   │   │   │   ├── repository/  (Repository interfaces)\n│   │   │   │   └── usecase/     (Use cases)\n│   │   │   ├── presentation/\n│   │   │   │   ├── ui/\n│   │   │   │   │   ├── home/\n│   │   │   │   │   ├── profile/\n│   │   │   │   │   └── common/\n│   │   │   │   └── viewmodel/\n│   │   │   └── util/            (Utilities)\n│   │   ├── res/\n│   │   └── AndroidManifest.xml\n│   ├── test/                     (Unit tests)\n│   └── androidTest/              (Integration tests)\n*/\n\n// 2. Build Configuration (app/build.gradle.kts)\nplugins {\n    id(\"com.android.application\")\n    kotlin(\"android\")\n    kotlin(\"kapt\")\n    id(\"dagger.hilt.android.plugin\")\n    id(\"kotlin-parcelize\")\n}\n\nandroid {\n    namespace = \"com.example.app\"\n    compileSdk = 33\n    \n    defaultConfig {\n        applicationId = \"com.example.app\"\n        minSdk = 24\n        targetSdk = 33\n        versionCode = getVersionCode()\n        versionName = getVersionName()\n        \n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n        \n        // Build config fields\n        buildConfigField(\"String\", \"API_URL\", '\"https://api.example.com\"')\n    }\n    \n    buildTypes {\n        release {\n            isMinifyEnabled = true\n            isShrinkResources = true\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n            \n            // Signing configuration\n            signingConfig = signingConfigs.getByName(\"release\")\n        }\n        \n        debug {\n            isDebuggable = true\n            applicationIdSuffix = \".debug\"\n            versionNameSuffix = \"-debug\"\n        }\n    }\n    \n    flavorDimensions += \"environment\"\n    productFlavors {\n        create(\"dev\") {\n            dimension = \"environment\"\n            applicationIdSuffix = \".dev\"\n            versionNameSuffix = \"-dev\"\n            buildConfigField(\"String\", \"API_URL\", '\"https://dev-api.example.com\"')\n        }\n        \n        create(\"staging\") {\n            dimension = \"environment\"\n            applicationIdSuffix = \".staging\"\n            versionNameSuffix = \"-staging\"\n            buildConfigField(\"String\", \"API_URL\", '\"https://staging-api.example.com\"')\n        }\n        \n        create(\"production\") {\n            dimension = \"environment\"\n            buildConfigField(\"String\", \"API_URL\", '\"https://api.example.com\"')\n        }\n    }\n    \n    buildFeatures {\n        buildConfig = true\n        viewBinding = true\n    }\n    \n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_17\n        targetCompatibility = JavaVersion.VERSION_17\n    }\n    \n    kotlinOptions {\n        jvmTarget = \"17\"\n        freeCompilerArgs += listOf(\n            \"-opt-in=kotlinx.coroutines.ExperimentalCoroutinesApi\",\n            \"-opt-in=kotlin.RequiresOptIn\"\n        )\n    }\n    \n    testOptions {\n        unitTests {\n            isIncludeAndroidResources = true\n            isReturnDefaultValues = true\n        }\n    }\n}\n\nfun getVersionCode(): Int {\n    val stdout = ByteArrayOutputStream()\n    exec {\n        commandLine(\"git\", \"rev-list\", \"--count\", \"HEAD\")\n        standardOutput = stdout\n    }\n    return stdout.toString().trim().toInt()\n}\n\nfun getVersionName(): String {\n    return \"1.0.${getVersionCode()}\"\n}\n\n// 3. Dependency Management\ndependencies {\n    // Core\n    implementation(\"androidx.core:core-ktx:1.10.1\")\n    implementation(\"androidx.appcompat:appcompat:1.6.1\")\n    implementation(\"com.google.android.material:material:1.9.0\")\n    \n    // Lifecycle\n    implementation(\"androidx.lifecycle:lifecycle-runtime-ktx:2.6.1\")\n    implementation(\"androidx.lifecycle:lifecycle-viewmodel-ktx:2.6.1\")\n    \n    // Coroutines\n    implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.1\")\n    \n    // Hilt\n    implementation(\"com.google.dagger:hilt-android:2.46\")\n    kapt(\"com.google.dagger:hilt-compiler:2.46\")\n    \n    // Retrofit\n    implementation(\"com.squareup.retrofit2:retrofit:2.9.0\")\n    implementation(\"com.squareup.retrofit2:converter-gson:2.9.0\")\n    implementation(\"com.squareup.okhttp3:logging-interceptor:4.11.0\")\n    \n    // Room\n    implementation(\"androidx.room:room-runtime:2.5.2\")\n    implementation(\"androidx.room:room-ktx:2.5.2\")\n    kapt(\"androidx.room:room-compiler:2.5.2\")\n    \n    // Testing\n    testImplementation(\"junit:junit:4.13.2\")\n    testImplementation(\"org.mockito:mockito-core:5.3.1\")\n    testImplementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.1\")\n    testImplementation(\"androidx.arch.core:core-testing:2.2.0\")\n    \n    androidTestImplementation(\"androidx.test.ext:junit:1.1.5\")\n    androidTestImplementation(\"androidx.test.espresso:espresso-core:3.5.1\")\n    \n    // Debug tools\n    debugImplementation(\"com.squareup.leakcanary:leakcanary-android:2.12\")\n}\n\n// 4. ProGuard Rules (proguard-rules.pro)\n# Keep application class\n-keep public class com.example.app.MyApplication\n\n# Keep models\n-keep class com.example.app.data.model.** { *; }\n\n# Retrofit\n-keepattributes Signature\n-keepattributes Exceptions\n-keep class retrofit2.** { *; }\n\n# OkHttp\n-dontwarn okhttp3.**\n-dontwarn okio.**\n\n# Gson\n-keep class com.google.gson.** { *; }\n-keepclassmembers enum * { *; }\n\n# Remove logging\n-assumenosideeffects class android.util.Log {\n    public static *** d(...);\n    public static *** v(...);\n    public static *** i(...);\n}\n\n# Keep line numbers for debugging\n-keepattributes SourceFile,LineNumberTable\n\n// 5. Application Class\n@HiltAndroidApp\nclass MyApplication : Application() {\n    \n    override fun onCreate() {\n        super.onCreate()\n        \n        // Initialize libraries\n        initializeLibraries()\n        \n        // Setup crash reporting\n        setupCrashReporting()\n        \n        // Setup analytics\n        setupAnalytics()\n        \n        // Setup strict mode (debug only)\n        if (BuildConfig.DEBUG) {\n            setupStrictMode()\n        }\n    }\n    \n    private fun initializeLibraries() {\n        // Initialize Timber for logging\n        if (BuildConfig.DEBUG) {\n            Timber.plant(Timber.DebugTree())\n        } else {\n            Timber.plant(CrashReportingTree())\n        }\n    }\n    \n    private fun setupCrashReporting() {\n        // Setup Firebase Crashlytics or similar\n    }\n    \n    private fun setupAnalytics() {\n        // Setup analytics\n    }\n    \n    private fun setupStrictMode() {\n        StrictMode.setThreadPolicy(\n            StrictMode.ThreadPolicy.Builder()\n                .detectAll()\n                .penaltyLog()\n                .build()\n        )\n        \n        StrictMode.setVmPolicy(\n            StrictMode.VmPolicy.Builder()\n                .detectAll()\n                .penaltyLog()\n                .build()\n        )\n    }\n    \n    override fun onLowMemory() {\n        super.onLowMemory()\n        // Clear caches\n        clearCaches()\n    }\n    \n    private fun clearCaches() {\n        // Clear image caches, etc.\n    }\n}\n\n// Custom Timber tree for production\nclass CrashReportingTree : Timber.Tree() {\n    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {\n        if (priority == Log.ERROR || priority == Log.WARN) {\n            // Send to crash reporting service\n            t?.let {\n                // FirebaseCrashlytics.getInstance().recordException(it)\n            }\n        }\n    }\n}\n\n// 6. Error Handling\nsealed class Result<out T> {\n    data class Success<T>(val data: T) : Result<T>()\n    data class Error(val exception: Exception) : Result<Nothing>()\n    object Loading : Result<Nothing>()\n}\n\nclass ErrorHandler {\n    fun handleError(exception: Exception): String {\n        return when (exception) {\n            is IOException -> \"Network error. Please check your connection.\"\n            is HttpException -> handleHttpError(exception)\n            else -> \"An unexpected error occurred.\"\n        }\n    }\n    \n    private fun handleHttpError(exception: HttpException): String {\n        return when (exception.code()) {\n            401 -> \"Unauthorized. Please login again.\"\n            404 -> \"Resource not found.\"\n            500 -> \"Server error. Please try again later.\"\n            else -> \"Error: ${exception.message()}\"\n        }\n    }\n}\n\n// 7. Network Configuration\n@Module\n@InstallIn(SingletonComponent::class)\nobject NetworkModule {\n    \n    @Provides\n    @Singleton\n    fun provideOkHttpClient(): OkHttpClient {\n        return OkHttpClient.Builder()\n            .connectTimeout(30, TimeUnit.SECONDS)\n            .readTimeout(30, TimeUnit.SECONDS)\n            .writeTimeout(30, TimeUnit.SECONDS)\n            .addInterceptor(createLoggingInterceptor())\n            .addInterceptor(createAuthInterceptor())\n            .certificatePinner(createCertificatePinner())\n            .build()\n    }\n    \n    private fun createLoggingInterceptor(): HttpLoggingInterceptor {\n        return HttpLoggingInterceptor().apply {\n            level = if (BuildConfig.DEBUG) {\n                HttpLoggingInterceptor.Level.BODY\n            } else {\n                HttpLoggingInterceptor.Level.NONE\n            }\n        }\n    }\n    \n    private fun createAuthInterceptor(): Interceptor {\n        return Interceptor { chain ->\n            val original = chain.request()\n            val request = original.newBuilder()\n                .header(\"Authorization\", \"Bearer ${getAuthToken()}\")\n                .header(\"User-Agent\", \"MyApp/${BuildConfig.VERSION_NAME}\")\n                .build()\n            chain.proceed(request)\n        }\n    }\n    \n    private fun createCertificatePinner(): CertificatePinner {\n        return CertificatePinner.Builder()\n            .add(\"api.example.com\", \"sha256/AAAA...\")\n            .build()\n    }\n    \n    private fun getAuthToken(): String {\n        // Retrieve auth token from secure storage\n        return \"\"\n    }\n    \n    @Provides\n    @Singleton\n    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {\n        return Retrofit.Builder()\n            .baseUrl(BuildConfig.API_URL)\n            .client(okHttpClient)\n            .addConverterFactory(GsonConverterFactory.create())\n            .build()\n    }\n}\n\n// 8. Logging Strategy\nobject AppLogger {\n    fun d(tag: String, message: String) {\n        if (BuildConfig.DEBUG) {\n            Timber.tag(tag).d(message)\n        }\n    }\n    \n    fun e(tag: String, message: String, throwable: Throwable? = null) {\n        Timber.tag(tag).e(throwable, message)\n        // Send to crash reporting in production\n    }\n    \n    fun logEvent(event: String, params: Map<String, Any> = emptyMap()) {\n        // Log analytics event\n    }\n}\n\n// 9. Database Migration\n@Database(\n    entities = [User::class],\n    version = 2,\n    exportSchema = true\n)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n    \n    companion object {\n        val MIGRATION_1_2 = object : Migration(1, 2) {\n            override fun migrate(database: SupportSQLiteDatabase) {\n                database.execSQL(\n                    \"ALTER TABLE users ADD COLUMN age INTEGER DEFAULT 0 NOT NULL\"\n                )\n            }\n        }\n    }\n}\n\n// 10. CI/CD Configuration (.github/workflows/android.yml)\n/*\nname: Android CI\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Set up JDK 17\n      uses: actions/setup-java@v3\n      with:\n        java-version: '17'\n        distribution: 'temurin'\n    \n    - name: Grant execute permission for gradlew\n      run: chmod +x gradlew\n    \n    - name: Run unit tests\n      run: ./gradlew test\n    \n    - name: Run lint\n      run: ./gradlew lint\n    \n    - name: Build debug APK\n      run: ./gradlew assembleDebug\n    \n    - name: Upload APK\n      uses: actions/upload-artifact@v3\n      with:\n        name: app-debug\n        path: app/build/outputs/apk/debug/app-debug.apk\n*/"
    },
    {
      "id": 88,
      "question": "What are Android Context types and their usage?",
      "answer": "Context provides access to application-specific resources, classes, and application environment information.\n\nContext Types:\n• Application Context\n• Activity Context\n• Service Context\n• BroadcastReceiver Context\n\nApplication Context:\n• Singleton instance\n• Lives throughout app lifetime\n• Use for non-UI operations\n• Avoid memory leaks\n• Access via applicationContext\n\nActivity Context:\n• Tied to Activity lifecycle\n• Use for UI operations\n• Theme-aware\n• Dialog creation\n• Destroyed with Activity\n\nService Context:\n• Tied to Service lifecycle\n• Background operations\n• No UI operations\n\nWhen to Use:\n• Application Context - Singletons, repositories\n• Activity Context - Dialogs, views, themes\n• Base Context - Wrapped contexts\n\nBest Practices:\n• Use Application Context when possible\n• Avoid static Activity references\n• Use ContextWrapper for wrapping\n• Inject Context via DI",
      "explanation": "Android Context provides environment access with Application Context for long-lived operations, Activity Context for UI and theme-aware operations, Service Context for background work, avoiding memory leaks through proper lifecycle management.",
      "difficulty": "Medium",
      "code": "// 1. Application Context\nclass MyApplication : Application() {\n    companion object {\n        private lateinit var instance: MyApplication\n        \n        fun getAppContext(): Context {\n            return instance.applicationContext\n        }\n    }\n    \n    override fun onCreate() {\n        super.onCreate()\n        instance = this\n    }\n}\n\n// Using Application Context\nclass DatabaseHelper {\n    companion object {\n        fun getInstance(context: Context): AppDatabase {\n            return Room.databaseBuilder(\n                context.applicationContext, // Use Application Context\n                AppDatabase::class.java,\n                \"app_database\"\n            ).build()\n        }\n    }\n}\n\n// 2. Activity Context\nclass MainActivity : AppCompatActivity() {\n    \n    fun showDialog() {\n        // Use Activity Context for Dialog\n        AlertDialog.Builder(this) // 'this' is Activity Context\n            .setTitle(\"Title\")\n            .setMessage(\"Message\")\n            .setPositiveButton(\"OK\", null)\n            .show()\n    }\n    \n    fun createView() {\n        // Use Activity Context for View inflation\n        val view = LayoutInflater.from(this)\n            .inflate(R.layout.custom_view, null)\n    }\n    \n    fun applyTheme() {\n        // Activity Context is theme-aware\n        val typedValue = TypedValue()\n        theme.resolveAttribute(\n            R.attr.colorPrimary,\n            typedValue,\n            true\n        )\n        val color = typedValue.data\n    }\n}\n\n// 3. Context Types Comparison\nclass ContextExamples {\n    \n    fun demonstrateContextTypes(activity: Activity) {\n        // Activity Context\n        val activityContext: Context = activity\n        \n        // Application Context\n        val applicationContext: Context = activity.applicationContext\n        \n        // Base Context (wrapped)\n        val baseContext: Context = activity.baseContext\n        \n        // Activity as Context (this)\n        // val context: Context = this // Inside Activity\n    }\n    \n    fun compareContexts(activity: Activity) {\n        // Activity Context is Activity-specific\n        val activityContext = activity\n        \n        // Application Context is app-wide\n        val appContext = activity.applicationContext\n        \n        println(\"Same? ${activityContext === appContext}\") // false\n        println(\"App context class: ${appContext.javaClass}\")\n        println(\"Activity context class: ${activityContext.javaClass}\")\n    }\n}\n\n// 4. Context in ViewModels (WRONG vs RIGHT)\n// WRONG - Don't hold Activity Context in ViewModel\nclass WrongViewModel(private val context: Context) : ViewModel() {\n    // Activity context will leak!\n    fun doSomething() {\n        // Using context...\n    }\n}\n\n// RIGHT - Use Application Context or AndroidViewModel\nclass RightViewModel(\n    application: Application\n) : AndroidViewModel(application) {\n    \n    private val context: Context\n        get() = getApplication<Application>().applicationContext\n    \n    fun doSomething() {\n        // Safe to use Application Context\n        val appName = context.getString(R.string.app_name)\n    }\n}\n\n// With Hilt dependency injection\n@HiltViewModel\nclass InjectedViewModel @Inject constructor(\n    @ApplicationContext private val context: Context\n) : ViewModel() {\n    // Safe - injected Application Context\n}\n\n// 5. ContextWrapper\nclass CustomContextWrapper(base: Context) : ContextWrapper(base) {\n    \n    companion object {\n        fun wrap(context: Context, locale: Locale): ContextWrapper {\n            var newContext = context\n            \n            val config = Configuration(context.resources.configuration)\n            config.setLocale(locale)\n            \n            newContext = context.createConfigurationContext(config)\n            \n            return CustomContextWrapper(newContext)\n        }\n    }\n}\n\n// Usage in Activity\nclass LocaleAwareActivity : AppCompatActivity() {\n    override fun attachBaseContext(newBase: Context) {\n        val locale = Locale(\"es\") // Spanish\n        val context = CustomContextWrapper.wrap(newBase, locale)\n        super.attachBaseContext(context)\n    }\n}\n\n// 6. Context in Services\nclass MyService : Service() {\n    \n    override fun onCreate() {\n        super.onCreate()\n        \n        // Service Context\n        val serviceContext: Context = this\n        \n        // Application Context (preferred)\n        val appContext = applicationContext\n        \n        // Use for non-UI operations\n        startForegroundWork(appContext)\n    }\n    \n    private fun startForegroundWork(context: Context) {\n        // Create notification\n        val notification = createNotification(context)\n        startForeground(1, notification)\n    }\n    \n    private fun createNotification(context: Context): Notification {\n        return NotificationCompat.Builder(context, CHANNEL_ID)\n            .setContentTitle(\"Service Running\")\n            .setSmallIcon(R.drawable.ic_notification)\n            .build()\n    }\n    \n    override fun onBind(intent: Intent?): IBinder? = null\n}\n\n// 7. Context in BroadcastReceiver\nclass MyBroadcastReceiver : BroadcastReceiver() {\n    \n    override fun onReceive(context: Context, intent: Intent) {\n        // BroadcastReceiver Context\n        // Short-lived, suitable for quick operations\n        \n        when (intent.action) {\n            Intent.ACTION_BOOT_COMPLETED -> {\n                // Schedule work\n                scheduleWork(context.applicationContext)\n            }\n            \"CUSTOM_ACTION\" -> {\n                // Handle custom action\n                val data = intent.getStringExtra(\"data\")\n                processData(context, data)\n            }\n        }\n    }\n    \n    private fun scheduleWork(context: Context) {\n        // Use Application Context for WorkManager\n        val workRequest = OneTimeWorkRequestBuilder<MyWorker>().build()\n        WorkManager.getInstance(context).enqueue(workRequest)\n    }\n    \n    private fun processData(context: Context, data: String?) {\n        // Quick processing\n    }\n}\n\n// 8. Context Best Practices\nclass ContextBestPractices {\n    \n    // Use Application Context for long-lived objects\n    class ImageCache private constructor(context: Context) {\n        private val appContext = context.applicationContext\n        \n        companion object {\n            @Volatile\n            private var instance: ImageCache? = null\n            \n            fun getInstance(context: Context): ImageCache {\n                return instance ?: synchronized(this) {\n                    instance ?: ImageCache(context).also { instance = it }\n                }\n            }\n        }\n    }\n    \n    // Avoid storing Activity Context\n    class BadSingleton private constructor(context: Context) {\n        // Don't do this!\n        private val activityContext = context\n        \n        companion object {\n            private var instance: BadSingleton? = null\n            \n            fun getInstance(context: Context): BadSingleton {\n                return instance ?: BadSingleton(context).also { instance = it }\n            }\n        }\n    }\n}\n\n// 9. Context in Fragments\nclass MyFragment : Fragment() {\n    \n    private lateinit var fragmentContext: Context\n    \n    override fun onAttach(context: Context) {\n        super.onAttach(context)\n        fragmentContext = context\n    }\n    \n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        \n        // Use requireContext() for guaranteed non-null Context\n        val context = requireContext()\n        \n        // Or activity if needed\n        val activityContext = requireActivity()\n        \n        // Application Context\n        val appContext = requireContext().applicationContext\n        \n        showToast(context, \"Fragment created\")\n    }\n    \n    private fun showToast(context: Context, message: String) {\n        Toast.makeText(context, message, Toast.LENGTH_SHORT).show()\n    }\n}\n\n// 10. Dependency Injection with Context\n@Module\n@InstallIn(SingletonComponent::class)\nobject AppModule {\n    \n    @Provides\n    @Singleton\n    @ApplicationContext\n    fun provideApplicationContext(\n        application: Application\n    ): Context {\n        return application.applicationContext\n    }\n    \n    @Provides\n    @Singleton\n    fun provideDatabase(\n        @ApplicationContext context: Context\n    ): AppDatabase {\n        return Room.databaseBuilder(\n            context,\n            AppDatabase::class.java,\n            \"app_database\"\n        ).build()\n    }\n    \n    @Provides\n    @Singleton\n    fun provideSharedPreferences(\n        @ApplicationContext context: Context\n    ): SharedPreferences {\n        return context.getSharedPreferences(\n            \"app_prefs\",\n            Context.MODE_PRIVATE\n        )\n    }\n}\n\n// Inject in classes\nclass UserRepository @Inject constructor(\n    @ApplicationContext private val context: Context,\n    private val database: AppDatabase\n) {\n    fun getUserName(): String {\n        return context.getString(R.string.default_username)\n    }\n}\n\n// 11. Context Utilities\nobject ContextUtils {\n    \n    fun isActivityContext(context: Context): Boolean {\n        return context is Activity\n    }\n    \n    fun getActivity(context: Context): Activity? {\n        return when (context) {\n            is Activity -> context\n            is ContextWrapper -> getActivity(context.baseContext)\n            else -> null\n        }\n    }\n    \n    fun requireActivity(context: Context): Activity {\n        return getActivity(context) ?: throw IllegalStateException(\n            \"Context is not an Activity context\"\n        )\n    }\n}\n\n// 12. Context in Custom Views\nclass CustomView @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : View(context, attrs, defStyleAttr) {\n    \n    init {\n        // Context is available throughout View lifecycle\n        // Use for resources, theme, etc.\n        \n        // Get resources\n        val padding = context.resources.getDimensionPixelSize(\n            R.dimen.default_padding\n        )\n        setPadding(padding, padding, padding, padding)\n        \n        // Read attributes\n        context.theme.obtainStyledAttributes(\n            attrs,\n            R.styleable.CustomView,\n            0, 0\n        ).apply {\n            try {\n                // Read styled attributes\n            } finally {\n                recycle()\n            }\n        }\n    }\n}"
    },
    {
      "id": 89,
      "question": "What is Android ConstraintLayout and its features?",
      "answer": "ConstraintLayout is a flexible layout manager that creates flat view hierarchies with complex layouts using constraints between views.\n\nKey Features:\n• Flat hierarchy\n• Relative positioning\n• Chains\n• Barriers\n• Guidelines\n• Groups\n• Flow layouts\n\nConstraint Types:\n• Relative constraints\n• Margin constraints\n• Centering\n• Bias\n• Dimensions (0dp for MATCH_CONSTRAINT)\n• Aspect ratio\n\nChains:\n• Spread chain (default)\n• Spread inside\n• Packed chain\n• Weighted chain\n\nBarriers:\n• Dynamic positioning\n• Multiple view references\n• Direction-based\n\nGuidelines:\n• Vertical/Horizontal\n• Fixed position\n• Percentage position\n• Beginning/End offset\n\nBenefits:\n• Better performance\n• Responsive design\n• Less nesting\n• Visual editor support\n• MotionLayout base",
      "explanation": "ConstraintLayout creates flat, complex layouts using relative positioning with constraints, chains for view distribution, barriers for dynamic boundaries, guidelines for alignment, and bias for precise positioning.",
      "difficulty": "Medium",
      "code": "// 1. Basic ConstraintLayout\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    \n    <!-- Center a view -->\n    <TextView\n        android:id=\"@+id/textView\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Centered\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n    \n    <!-- Positioned relative to another view -->\n    <Button\n        android:id=\"@+id/button\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Button\"\n        app:layout_constraintTop_toBottomOf=\"@id/textView\"\n        app:layout_constraintStart_toStartOf=\"@id/textView\"\n        app:layout_constraintEnd_toEndOf=\"@id/textView\"\n        android:layout_marginTop=\"16dp\" />\n    \n</androidx.constraintlayout.widget.ConstraintLayout>\n\n// 2. Bias for precise positioning\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"25% from start\"\n    app:layout_constraintTop_toTopOf=\"parent\"\n    app:layout_constraintBottom_toBottomOf=\"parent\"\n    app:layout_constraintStart_toStartOf=\"parent\"\n    app:layout_constraintEnd_toEndOf=\"parent\"\n    app:layout_constraintHorizontal_bias=\"0.25\"\n    app:layout_constraintVertical_bias=\"0.75\" />\n\n// 3. Aspect Ratio\n<ImageView\n    android:id=\"@+id/imageView\"\n    android:layout_width=\"0dp\"\n    android:layout_height=\"0dp\"\n    android:scaleType=\"centerCrop\"\n    app:layout_constraintDimensionRatio=\"16:9\"\n    app:layout_constraintTop_toTopOf=\"parent\"\n    app:layout_constraintStart_toStartOf=\"parent\"\n    app:layout_constraintEnd_toEndOf=\"parent\" />\n\n// Width/Height ratio\n<View\n    android:layout_width=\"100dp\"\n    android:layout_height=\"0dp\"\n    app:layout_constraintDimensionRatio=\"1:1\" />\n\n// 4. Chains\n<!-- Horizontal Spread Chain (default) -->\n<Button\n    android:id=\"@+id/button1\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    app:layout_constraintStart_toStartOf=\"parent\"\n    app:layout_constraintEnd_toStartOf=\"@id/button2\"\n    app:layout_constraintTop_toTopOf=\"parent\"\n    app:layout_constraintHorizontal_chainStyle=\"spread\" />\n\n<Button\n    android:id=\"@+id/button2\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    app:layout_constraintStart_toEndOf=\"@id/button1\"\n    app:layout_constraintEnd_toStartOf=\"@id/button3\"\n    app:layout_constraintTop_toTopOf=\"parent\" />\n\n<Button\n    android:id=\"@+id/button3\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    app:layout_constraintStart_toEndOf=\"@id/button2\"\n    app:layout_constraintEnd_toEndOf=\"parent\"\n    app:layout_constraintTop_toTopOf=\"parent\" />\n\n// Chain styles:\n// - spread (default): evenly distributed\n// - spread_inside: first and last stick to edges\n// - packed: grouped together\n\n// Weighted Chain\n<Button\n    android:id=\"@+id/button1\"\n    android:layout_width=\"0dp\"\n    android:layout_height=\"wrap_content\"\n    app:layout_constraintWidth_percent=\"0.3\"\n    app:layout_constraintStart_toStartOf=\"parent\"\n    app:layout_constraintEnd_toStartOf=\"@id/button2\" />\n\n<Button\n    android:id=\"@+id/button2\"\n    android:layout_width=\"0dp\"\n    android:layout_height=\"wrap_content\"\n    app:layout_constraintWidth_percent=\"0.7\"\n    app:layout_constraintStart_toEndOf=\"@id/button1\"\n    app:layout_constraintEnd_toEndOf=\"parent\" />\n\n// 5. Guidelines\n<!-- Vertical Guideline at 30% -->\n<androidx.constraintlayout.widget.Guideline\n    android:id=\"@+id/guideline\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"vertical\"\n    app:layout_constraintGuide_percent=\"0.3\" />\n\n<!-- Horizontal Guideline at fixed position -->\n<androidx.constraintlayout.widget.Guideline\n    android:id=\"@+id/guidelineHorizontal\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"horizontal\"\n    app:layout_constraintGuide_begin=\"100dp\" />\n\n<!-- Constrain views to guideline -->\n<TextView\n    android:layout_width=\"0dp\"\n    android:layout_height=\"wrap_content\"\n    app:layout_constraintStart_toStartOf=\"parent\"\n    app:layout_constraintEnd_toStartOf=\"@id/guideline\" />\n\n// 6. Barriers\n<androidx.constraintlayout.widget.Barrier\n    android:id=\"@+id/barrier\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    app:barrierDirection=\"end\"\n    app:constraint_referenced_ids=\"textView1,textView2,textView3\" />\n\n<TextView\n    android:id=\"@+id/textView1\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Short\" />\n\n<TextView\n    android:id=\"@+id/textView2\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Medium text\" />\n\n<TextView\n    android:id=\"@+id/textView3\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Very long text here\" />\n\n<!-- View positioned after longest text -->\n<Button\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    app:layout_constraintStart_toEndOf=\"@id/barrier\"\n    android:layout_marginStart=\"16dp\" />\n\n// 7. Groups\n<androidx.constraintlayout.widget.Group\n    android:id=\"@+id/group\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    app:constraint_referenced_ids=\"view1,view2,view3\"\n    android:visibility=\"gone\" />\n\n// Programmatically control group\nval group = findViewById<Group>(R.id.group)\ngroup.visibility = View.VISIBLE // Show all views in group\ngroup.visibility = View.GONE // Hide all views in group\n\n// 8. Circular Positioning\n<ImageView\n    android:id=\"@+id/centerImage\"\n    android:layout_width=\"100dp\"\n    android:layout_height=\"100dp\"\n    app:layout_constraintTop_toTopOf=\"parent\"\n    app:layout_constraintBottom_toBottomOf=\"parent\"\n    app:layout_constraintStart_toStartOf=\"parent\"\n    app:layout_constraintEnd_toEndOf=\"parent\" />\n\n<ImageView\n    android:layout_width=\"50dp\"\n    android:layout_height=\"50dp\"\n    app:layout_constraintCircle=\"@id/centerImage\"\n    app:layout_constraintCircleRadius=\"150dp\"\n    app:layout_constraintCircleAngle=\"45\" />\n\n// 9. Flow (Virtual Layout)\n<androidx.constraintlayout.helper.widget.Flow\n    android:layout_width=\"0dp\"\n    android:layout_height=\"wrap_content\"\n    app:layout_constraintStart_toStartOf=\"parent\"\n    app:layout_constraintEnd_toEndOf=\"parent\"\n    app:layout_constraintTop_toTopOf=\"parent\"\n    app:flow_wrapMode=\"chain\"\n    app:flow_horizontalGap=\"8dp\"\n    app:flow_verticalGap=\"8dp\"\n    app:constraint_referenced_ids=\"view1,view2,view3,view4,view5\" />\n\n// 10. Programmatic Constraints\nclass ConstraintLayoutExample : AppCompatActivity() {\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        \n        val constraintLayout = ConstraintLayout(this)\n        setContentView(constraintLayout)\n        \n        val button = Button(this).apply {\n            id = View.generateViewId()\n            text = \"Button\"\n        }\n        constraintLayout.addView(button)\n        \n        val constraintSet = ConstraintSet()\n        constraintSet.clone(constraintLayout)\n        \n        // Center button\n        constraintSet.connect(\n            button.id,\n            ConstraintSet.TOP,\n            ConstraintSet.PARENT_ID,\n            ConstraintSet.TOP\n        )\n        constraintSet.connect(\n            button.id,\n            ConstraintSet.BOTTOM,\n            ConstraintSet.PARENT_ID,\n            ConstraintSet.BOTTOM\n        )\n        constraintSet.connect(\n            button.id,\n            ConstraintSet.START,\n            ConstraintSet.PARENT_ID,\n            ConstraintSet.START\n        )\n        constraintSet.connect(\n            button.id,\n            ConstraintSet.END,\n            ConstraintSet.PARENT_ID,\n            ConstraintSet.END\n        )\n        \n        constraintSet.applyTo(constraintLayout)\n    }\n}\n\n// 11. Animate Constraints\nfun animateConstraints(layout: ConstraintLayout, view: View) {\n    val constraintSet = ConstraintSet()\n    constraintSet.clone(layout)\n    \n    // Modify constraints\n    constraintSet.connect(\n        view.id,\n        ConstraintSet.END,\n        ConstraintSet.PARENT_ID,\n        ConstraintSet.END\n    )\n    \n    // Animate\n    TransitionManager.beginDelayedTransition(layout)\n    constraintSet.applyTo(layout)\n}\n\n// 12. ConstraintLayout DSL (Kotlin)\nfun createConstraintLayout(context: Context): ConstraintLayout {\n    return ConstraintLayout(context).apply {\n        val button = Button(context).apply {\n            id = View.generateViewId()\n            text = \"Click Me\"\n        }\n        addView(button)\n        \n        ConstraintSet().apply {\n            constrainWidth(button.id, ConstraintSet.WRAP_CONTENT)\n            constrainHeight(button.id, ConstraintSet.WRAP_CONTENT)\n            connect(\n                button.id, ConstraintSet.TOP,\n                ConstraintSet.PARENT_ID, ConstraintSet.TOP,\n                16\n            )\n            applyTo(this@apply)\n        }\n    }\n}"
    },
    {
      "id": 90,
      "question": "What is Android Build Variants and Product Flavors?",
      "answer": "Build Variants combine Build Types and Product Flavors to create different app versions from a single codebase.\n\nBuild Types:\n• Debug - Development builds\n• Release - Production builds\n• Custom - Staging, QA, etc.\n\nProduct Flavors:\n• Free vs Paid\n• Development vs Production\n• Different app variants\n• Regional variants\n\nBuild Variants:\n• Combination of type + flavor\n• freeDebug, freeRelease\n• paidDebug, paidRelease\n\nFlavor Dimensions:\n• Multiple flavor categories\n• Environment (dev, staging, prod)\n• Version (free, paid, premium)\n\nFeatures:\n• Different application IDs\n• Different resources\n• Different code\n• Different dependencies\n• Different signing configs\n\nBest Practices:\n• Minimize flavor-specific code\n• Use BuildConfig fields\n• Resource overriding\n• Dependency management\n• Testing all variants",
      "explanation": "Build Variants combine Build Types (debug/release) with Product Flavors (free/paid, dev/prod) creating unique app versions with different applicationIds, resources, code, and dependencies from one codebase.",
      "difficulty": "Medium",
      "code": "// 1. Basic Build Types and Product Flavors\nandroid {\n    namespace = \"com.example.app\"\n    compileSdk = 33\n    \n    defaultConfig {\n        applicationId = \"com.example.app\"\n        minSdk = 24\n        targetSdk = 33\n        versionCode = 1\n        versionName = \"1.0\"\n    }\n    \n    // Build Types\n    buildTypes {\n        debug {\n            applicationIdSuffix = \".debug\"\n            versionNameSuffix = \"-debug\"\n            isDebuggable = true\n            isMinifyEnabled = false\n        }\n        \n        release {\n            isMinifyEnabled = true\n            isShrinkResources = true\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n            signingConfig = signingConfigs.getByName(\"release\")\n        }\n        \n        create(\"staging\") {\n            initWith(getByName(\"debug\"))\n            applicationIdSuffix = \".staging\"\n            versionNameSuffix = \"-staging\"\n            isDebuggable = true\n        }\n    }\n    \n    // Product Flavors\n    flavorDimensions += listOf(\"version\", \"environment\")\n    \n    productFlavors {\n        create(\"free\") {\n            dimension = \"version\"\n            applicationIdSuffix = \".free\"\n            versionNameSuffix = \"-free\"\n        }\n        \n        create(\"paid\") {\n            dimension = \"version\"\n            applicationIdSuffix = \".paid\"\n            versionNameSuffix = \"-paid\"\n        }\n        \n        create(\"dev\") {\n            dimension = \"environment\"\n            applicationIdSuffix = \".dev\"\n            buildConfigField(\"String\", \"API_URL\", '\"https://dev-api.example.com\"')\n            resValue(\"string\", \"app_name\", \"MyApp Dev\")\n        }\n        \n        create(\"prod\") {\n            dimension = \"environment\"\n            buildConfigField(\"String\", \"API_URL\", '\"https://api.example.com\"')\n            resValue(\"string\", \"app_name\", \"MyApp\")\n        }\n    }\n}\n\n// Generated variants:\n// freeDevDebug, freeDevRelease, freeDevStaging\n// freeProdDebug, freeProdRelease, freeProdStaging\n// paidDevDebug, paidDevRelease, paidDevStaging\n// paidProdDebug, paidProdRelease, paidProdStaging\n\n// 2. BuildConfig Fields\nandroid {\n    defaultConfig {\n        buildConfigField(\"String\", \"API_KEY\", '\"default_key\"')\n        buildConfigField(\"boolean\", \"ENABLE_LOGGING\", \"true\")\n        buildConfigField(\"int\", \"MAX_ITEMS\", \"100\")\n    }\n    \n    buildTypes {\n        debug {\n            buildConfigField(\"boolean\", \"ENABLE_LOGGING\", \"true\")\n            buildConfigField(\"String\", \"API_KEY\", '\"debug_key\"')\n        }\n        \n        release {\n            buildConfigField(\"boolean\", \"ENABLE_LOGGING\", \"false\")\n            buildConfigField(\"String\", \"API_KEY\", '\"prod_key\"')\n        }\n    }\n    \n    productFlavors {\n        create(\"free\") {\n            buildConfigField(\"boolean\", \"IS_PRO_VERSION\", \"false\")\n            buildConfigField(\"int\", \"MAX_ITEMS\", \"10\")\n        }\n        \n        create(\"paid\") {\n            buildConfigField(\"boolean\", \"IS_PRO_VERSION\", \"true\")\n            buildConfigField(\"int\", \"MAX_ITEMS\", \"1000\")\n        }\n    }\n}\n\n// Access in code\nif (BuildConfig.ENABLE_LOGGING) {\n    Log.d(\"TAG\", \"Debug info\")\n}\n\nval apiUrl = BuildConfig.API_URL\nval isPro = BuildConfig.IS_PRO_VERSION\n\n// 3. Source Sets\n/*\nProject Structure:\napp/\n├── src/\n│   ├── main/              (Common code)\n│   │   ├── java/\n│   │   └── res/\n│   ├── debug/             (Debug-specific)\n│   │   ├── java/\n│   │   └── res/\n│   ├── release/           (Release-specific)\n│   │   └── res/\n│   ├── free/              (Free version)\n│   │   ├── java/\n│   │   └── res/\n│   ├── paid/              (Paid version)\n│   │   ├── java/\n│   │   └── res/\n│   ├── freeDebug/         (Specific variant)\n│   │   └── res/\n│   └── paidRelease/       (Specific variant)\n│       └── res/\n*/\n\n// 4. Flavor-Specific Code\n// src/main/java/com/example/app/FeatureManager.kt\ninterface FeatureManager {\n    fun isFeatureEnabled(feature: String): Boolean\n}\n\n// src/free/java/com/example/app/FeatureManagerImpl.kt\nclass FeatureManagerImpl : FeatureManager {\n    override fun isFeatureEnabled(feature: String): Boolean {\n        return false // Free version - limited features\n    }\n}\n\n// src/paid/java/com/example/app/FeatureManagerImpl.kt\nclass FeatureManagerImpl : FeatureManager {\n    override fun isFeatureEnabled(feature: String): Boolean {\n        return true // Paid version - all features\n    }\n}\n\n// 5. Resource Overriding\n// src/main/res/values/strings.xml\n<resources>\n    <string name=\"app_name\">MyApp</string>\n    <string name=\"welcome_message\">Welcome</string>\n</resources>\n\n// src/free/res/values/strings.xml\n<resources>\n    <string name=\"app_name\">MyApp Free</string>\n    <string name=\"upgrade_message\">Upgrade to Pro</string>\n</resources>\n\n// src/paid/res/values/strings.xml\n<resources>\n    <string name=\"app_name\">MyApp Pro</string>\n</resources>\n\n// src/debug/res/values/colors.xml\n<resources>\n    <color name=\"colorPrimary\">#FF6200EE</color>\n</resources>\n\n// src/release/res/values/colors.xml\n<resources>\n    <color name=\"colorPrimary\">#FF3700B3</color>\n</resources>\n\n// 6. Variant-Specific Dependencies\ndependencies {\n    // Common dependencies\n    implementation(\"androidx.core:core-ktx:1.10.1\")\n    \n    // Debug-only dependencies\n    debugImplementation(\"com.squareup.leakcanary:leakcanary-android:2.12\")\n    debugImplementation(\"com.facebook.flipper:flipper:0.201.0\")\n    \n    // Release-only dependencies\n    releaseImplementation(\"com.google.firebase:firebase-crashlytics:18.4.0\")\n    \n    // Flavor-specific dependencies\n    \"freeImplementation\"(\"com.google.android.gms:play-services-ads:22.2.0\")\n    \"paidImplementation\"(\"com.android.billingclient:billing:6.0.1\")\n}\n\n// 7. Signing Configs\nandroid {\n    signingConfigs {\n        create(\"release\") {\n            storeFile = file(\"release.keystore\")\n            storePassword = System.getenv(\"KEYSTORE_PASSWORD\")\n            keyAlias = System.getenv(\"KEY_ALIAS\")\n            keyPassword = System.getenv(\"KEY_PASSWORD\")\n        }\n        \n        create(\"staging\") {\n            storeFile = file(\"debug.keystore\")\n            storePassword = \"android\"\n            keyAlias = \"androiddebugkey\"\n            keyPassword = \"android\"\n        }\n    }\n    \n    buildTypes {\n        release {\n            signingConfig = signingConfigs.getByName(\"release\")\n        }\n        \n        getByName(\"staging\") {\n            signingConfig = signingConfigs.getByName(\"staging\")\n        }\n    }\n}\n\n// 8. Variant-Aware Configuration\n// Apply configuration based on variant\nandroid.applicationVariants.all {\n    val variant = this\n    \n    // Change output file name\n    variant.outputs.all {\n        val output = this as com.android.build.gradle.internal.api.BaseVariantOutputImpl\n        val fileName = \"MyApp-${variant.name}-${variant.versionName}.apk\"\n        output.outputFileName = fileName\n    }\n    \n    // Add custom tasks\n    val buildTypeName = variant.buildType.name\n    val flavorName = variant.flavorName\n    \n    if (buildTypeName == \"release\") {\n        // Add release-specific tasks\n    }\n}\n\n// 9. Variant Filtering\nandroid {\n    variantFilter {\n        // Ignore certain variants\n        if (buildType.name == \"release\" && flavors[0].name == \"dev\") {\n            // Don't build devRelease\n            ignore = true\n        }\n    }\n}\n\n// 10. Testing Variants\n// Unit tests can test specific variants\nclass FeatureManagerTest {\n    \n    @Test\n    fun testFreeVersion() {\n        val manager = FeatureManagerImpl()\n        assertFalse(manager.isFeatureEnabled(\"pro_feature\"))\n    }\n}\n\n// Run tests for specific variant:\n// ./gradlew testFreeDebugUnitTest\n// ./gradlew testPaidReleaseUnitTest\n\n// 11. Manifest Placeholders\nandroid {\n    defaultConfig {\n        manifestPlaceholders[\"hostName\"] = \"www.example.com\"\n    }\n    \n    productFlavors {\n        create(\"dev\") {\n            manifestPlaceholders[\"hostName\"] = \"dev.example.com\"\n        }\n        \n        create(\"prod\") {\n            manifestPlaceholders[\"hostName\"] = \"www.example.com\"\n        }\n    }\n}\n\n// In AndroidManifest.xml\n<activity android:name=\".WebViewActivity\">\n    <intent-filter>\n        <data\n            android:scheme=\"https\"\n            android:host=\"${hostName}\" />\n    </intent-filter>\n</activity>\n\n// 12. Build from Command Line\n/*\n// List all variants\n./gradlew tasks --all | grep assemble\n\n// Build specific variant\n./gradlew assembleFreeDebug\n./gradlew assemblePaidRelease\n\n// Build all variants\n./gradlew assemble\n\n// Install specific variant\n./gradlew installFreeDebug\n\n// Uninstall\n./gradlew uninstallFreeDebug\n*/"
    },
    {
      "id": 91,
      "question": "What is Android Services and their types?",
      "answer": "Services are background components that perform long-running operations without a user interface.\n\nService Types:\n• Foreground Services - Visible to user\n• Background Services - Not visible\n• Bound Services - Client-server interface\n\nForeground Services:\n• Persistent notification required\n• User-aware operations\n• Music playback\n• Location tracking\n• File downloads\n\nBackground Services:\n• No user interaction\n• Limited by Android restrictions\n• Use WorkManager instead\n\nBound Services:\n• Provide client-server interface\n• Multiple clients can bind\n• IBinder communication\n• Local or remote binding\n\nService Lifecycle:\n• onCreate()\n• onStartCommand() - Started service\n• onBind() - Bound service\n• onDestroy()\n\nBest Practices:\n• Use WorkManager for deferrable work\n• Foreground service for user-visible work\n• Stop service when done\n• Handle system kills\n• Respect battery life",
      "explanation": "Android Services handle background operations with Foreground Services showing notifications for user-visible tasks, Background Services for invisible work (deprecated), and Bound Services for client-server IPC communication.",
      "difficulty": "Medium",
      "code": "// 1. Started Service (Background)\nclass MyBackgroundService : Service() {\n    \n    override fun onCreate() {\n        super.onCreate()\n        Log.d(\"Service\", \"Service created\")\n    }\n    \n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\n        // Perform background work\n        performTask()\n        \n        // Return values:\n        // START_NOT_STICKY: Don't recreate if killed\n        // START_STICKY: Recreate with null intent\n        // START_REDELIVER_INTENT: Recreate with last intent\n        return START_NOT_STICKY\n    }\n    \n    private fun performTask() {\n        Thread {\n            // Long-running task\n            Thread.sleep(5000)\n            \n            // Stop service when done\n            stopSelf()\n        }.start()\n    }\n    \n    override fun onBind(intent: Intent?): IBinder? {\n        return null // Not a bound service\n    }\n    \n    override fun onDestroy() {\n        super.onDestroy()\n        Log.d(\"Service\", \"Service destroyed\")\n    }\n}\n\n// Start service\nval intent = Intent(this, MyBackgroundService::class.java)\nstartService(intent)\n\n// Stop service\nstopService(intent)\n\n// AndroidManifest.xml\n<service\n    android:name=\".MyBackgroundService\"\n    android:enabled=\"true\"\n    android:exported=\"false\" />\n\n// 2. Foreground Service\nclass MusicPlayerService : Service() {\n    \n    companion object {\n        const val CHANNEL_ID = \"music_channel\"\n        const val NOTIFICATION_ID = 1\n        const val ACTION_PLAY = \"com.example.PLAY\"\n        const val ACTION_PAUSE = \"com.example.PAUSE\"\n        const val ACTION_STOP = \"com.example.STOP\"\n    }\n    \n    private lateinit var mediaPlayer: MediaPlayer\n    \n    override fun onCreate() {\n        super.onCreate()\n        createNotificationChannel()\n        mediaPlayer = MediaPlayer()\n    }\n    \n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\n        when (intent?.action) {\n            ACTION_PLAY -> {\n                startForeground(NOTIFICATION_ID, createNotification(\"Playing\"))\n                playMusic()\n            }\n            ACTION_PAUSE -> {\n                pauseMusic()\n                startForeground(NOTIFICATION_ID, createNotification(\"Paused\"))\n            }\n            ACTION_STOP -> {\n                stopMusic()\n                stopForeground(STOP_FOREGROUND_REMOVE)\n                stopSelf()\n            }\n        }\n        return START_STICKY\n    }\n    \n    private fun createNotificationChannel() {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            val channel = NotificationChannel(\n                CHANNEL_ID,\n                \"Music Player\",\n                NotificationManager.IMPORTANCE_LOW\n            )\n            val manager = getSystemService(NotificationManager::class.java)\n            manager.createNotificationChannel(channel)\n        }\n    }\n    \n    private fun createNotification(status: String): Notification {\n        val playPauseIntent = Intent(this, MusicPlayerService::class.java).apply {\n            action = if (status == \"Playing\") ACTION_PAUSE else ACTION_PLAY\n        }\n        val playPausePendingIntent = PendingIntent.getService(\n            this, 0, playPauseIntent, PendingIntent.FLAG_IMMUTABLE\n        )\n        \n        val stopIntent = Intent(this, MusicPlayerService::class.java).apply {\n            action = ACTION_STOP\n        }\n        val stopPendingIntent = PendingIntent.getService(\n            this, 1, stopIntent, PendingIntent.FLAG_IMMUTABLE\n        )\n        \n        return NotificationCompat.Builder(this, CHANNEL_ID)\n            .setContentTitle(\"Music Player\")\n            .setContentText(status)\n            .setSmallIcon(R.drawable.ic_music)\n            .addAction(\n                R.drawable.ic_play_pause,\n                if (status == \"Playing\") \"Pause\" else \"Play\",\n                playPausePendingIntent\n            )\n            .addAction(R.drawable.ic_stop, \"Stop\", stopPendingIntent)\n            .setOngoing(true)\n            .build()\n    }\n    \n    private fun playMusic() {\n        // Play music\n        mediaPlayer.start()\n    }\n    \n    private fun pauseMusic() {\n        mediaPlayer.pause()\n    }\n    \n    private fun stopMusic() {\n        mediaPlayer.stop()\n        mediaPlayer.release()\n    }\n    \n    override fun onBind(intent: Intent?): IBinder? = null\n}\n\n// Start foreground service (Android 8.0+)\nval intent = Intent(this, MusicPlayerService::class.java).apply {\n    action = MusicPlayerService.ACTION_PLAY\n}\n\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n    startForegroundService(intent)\n} else {\n    startService(intent)\n}\n\n// Manifest (Android 9.0+)\n<uses-permission android:name=\"android.permission.FOREGROUND_SERVICE\" />\n\n// Android 14+ requires service type\n<uses-permission android:name=\"android.permission.FOREGROUND_SERVICE_MEDIA_PLAYBACK\" />\n\n<service\n    android:name=\".MusicPlayerService\"\n    android:foregroundServiceType=\"mediaPlayback\" />\n\n// 3. Bound Service with Binder\nclass LocalBoundService : Service() {\n    \n    private val binder = LocalBinder()\n    private var randomNumber = 0\n    \n    inner class LocalBinder : Binder() {\n        fun getService(): LocalBoundService = this@LocalBoundService\n    }\n    \n    override fun onBind(intent: Intent?): IBinder {\n        return binder\n    }\n    \n    fun getRandomNumber(): Int {\n        randomNumber = (0..100).random()\n        return randomNumber\n    }\n    \n    fun performTask(callback: (String) -> Unit) {\n        Thread {\n            Thread.sleep(2000)\n            callback(\"Task completed\")\n        }.start()\n    }\n}\n\n// Bind to service in Activity\nclass MainActivity : AppCompatActivity() {\n    private var service: LocalBoundService? = null\n    private var isBound = false\n    \n    private val connection = object : ServiceConnection {\n        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {\n            val binder = service as LocalBoundService.LocalBinder\n            this@MainActivity.service = binder.getService()\n            isBound = true\n            \n            // Use service\n            val number = this@MainActivity.service?.getRandomNumber()\n            Log.d(\"Service\", \"Random number: $number\")\n        }\n        \n        override fun onServiceDisconnected(name: ComponentName?) {\n            isBound = false\n            service = null\n        }\n    }\n    \n    override fun onStart() {\n        super.onStart()\n        Intent(this, LocalBoundService::class.java).also { intent ->\n            bindService(intent, connection, Context.BIND_AUTO_CREATE)\n        }\n    }\n    \n    override fun onStop() {\n        super.onStop()\n        if (isBound) {\n            unbindService(connection)\n            isBound = false\n        }\n    }\n    \n    fun callService() {\n        service?.performTask { result ->\n            runOnUiThread {\n                Toast.makeText(this, result, Toast.LENGTH_SHORT).show()\n            }\n        }\n    }\n}\n\n// 4. AIDL (Remote Bound Service)\n// Create IRemoteService.aidl\npackage com.example.app\n\ninterface IRemoteService {\n    int getPid();\n    void basicTypes(int anInt, long aLong, boolean aBoolean,\n                    float aFloat, double aDouble, String aString);\n}\n\n// Implement service\nclass RemoteService : Service() {\n    \n    private val binder = object : IRemoteService.Stub() {\n        override fun getPid(): Int {\n            return Process.myPid()\n        }\n        \n        override fun basicTypes(\n            anInt: Int,\n            aLong: Long,\n            aBoolean: Boolean,\n            aFloat: Float,\n            aDouble: Double,\n            aString: String\n        ) {\n            // Implementation\n        }\n    }\n    \n    override fun onBind(intent: Intent?): IBinder {\n        return binder\n    }\n}\n\n// Client binding to AIDL service\nclass ClientActivity : AppCompatActivity() {\n    private var remoteService: IRemoteService? = null\n    \n    private val connection = object : ServiceConnection {\n        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {\n            remoteService = IRemoteService.Stub.asInterface(service)\n            \n            try {\n                val pid = remoteService?.pid\n                Log.d(\"Service\", \"Remote PID: $pid\")\n            } catch (e: RemoteException) {\n                Log.e(\"Service\", \"Error\", e)\n            }\n        }\n        \n        override fun onServiceDisconnected(name: ComponentName?) {\n            remoteService = null\n        }\n    }\n    \n    override fun onStart() {\n        super.onStart()\n        val intent = Intent(this, RemoteService::class.java)\n        bindService(intent, connection, Context.BIND_AUTO_CREATE)\n    }\n    \n    override fun onStop() {\n        super.onStop()\n        unbindService(connection)\n    }\n}\n\n// 5. IntentService (Deprecated - Use WorkManager)\nclass DownloadService : IntentService(\"DownloadService\") {\n    \n    override fun onHandleIntent(intent: Intent?) {\n        // Runs on background thread automatically\n        val url = intent?.getStringExtra(\"url\")\n        url?.let {\n            downloadFile(it)\n        }\n        // Service stops automatically when done\n    }\n    \n    private fun downloadFile(url: String) {\n        // Download logic\n        Thread.sleep(3000)\n    }\n}\n\n// 6. JobIntentService (for compatibility)\nclass MyJobIntentService : JobIntentService() {\n    \n    companion object {\n        private const val JOB_ID = 1000\n        \n        fun enqueueWork(context: Context, work: Intent) {\n            enqueueWork(\n                context,\n                MyJobIntentService::class.java,\n                JOB_ID,\n                work\n            )\n        }\n    }\n    \n    override fun onHandleWork(intent: Intent) {\n        // Perform work\n        val data = intent.getStringExtra(\"data\")\n        processData(data)\n    }\n    \n    private fun processData(data: String?) {\n        // Process\n    }\n}\n\n// Usage\nval intent = Intent().apply {\n    putExtra(\"data\", \"some data\")\n}\nMyJobIntentService.enqueueWork(context, intent)\n\n// 7. Service with Coroutines\nclass CoroutineService : Service() {\n    \n    private val job = SupervisorJob()\n    private val scope = CoroutineScope(Dispatchers.IO + job)\n    \n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\n        scope.launch {\n            try {\n                performWork()\n            } finally {\n                stopSelf(startId)\n            }\n        }\n        return START_NOT_STICKY\n    }\n    \n    private suspend fun performWork() = withContext(Dispatchers.IO) {\n        // Suspend function work\n        delay(5000)\n    }\n    \n    override fun onBind(intent: Intent?): IBinder? = null\n    \n    override fun onDestroy() {\n        super.onDestroy()\n        job.cancel()\n    }\n}\n\n// 8. Service Communication with BroadcastReceiver\nclass DataService : Service() {\n    \n    companion object {\n        const val ACTION_DATA_PROCESSED = \"com.example.DATA_PROCESSED\"\n        const val EXTRA_RESULT = \"result\"\n    }\n    \n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\n        processData { result ->\n            // Send broadcast\n            val resultIntent = Intent(ACTION_DATA_PROCESSED).apply {\n                putExtra(EXTRA_RESULT, result)\n            }\n            sendBroadcast(resultIntent)\n            stopSelf(startId)\n        }\n        return START_NOT_STICKY\n    }\n    \n    private fun processData(callback: (String) -> Unit) {\n        Thread {\n            Thread.sleep(2000)\n            callback(\"Processed data\")\n        }.start()\n    }\n    \n    override fun onBind(intent: Intent?): IBinder? = null\n}\n\n// Receive in Activity\nclass MainActivity : AppCompatActivity() {\n    \n    private val receiver = object : BroadcastReceiver() {\n        override fun onReceive(context: Context?, intent: Intent?) {\n            val result = intent?.getStringExtra(DataService.EXTRA_RESULT)\n            Toast.makeText(context, result, Toast.LENGTH_SHORT).show()\n        }\n    }\n    \n    override fun onStart() {\n        super.onStart()\n        val filter = IntentFilter(DataService.ACTION_DATA_PROCESSED)\n        registerReceiver(receiver, filter, RECEIVER_NOT_EXPORTED)\n    }\n    \n    override fun onStop() {\n        super.onStop()\n        unregisterReceiver(receiver)\n    }\n}\n\n// 9. Service with LiveData\nclass LocationService : Service() {\n    \n    companion object {\n        private val _location = MutableLiveData<Location>()\n        val location: LiveData<Location> = _location\n    }\n    \n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\n        startLocationUpdates()\n        return START_STICKY\n    }\n    \n    private fun startLocationUpdates() {\n        // Get location updates\n        // Post to LiveData\n        _location.postValue(Location(\"provider\"))\n    }\n    \n    override fun onBind(intent: Intent?): IBinder? = null\n}\n\n// Observe in Activity\nLocationService.location.observe(this) { location ->\n    updateUI(location)\n}\n\n// 10. Testing Services\n@RunWith(AndroidJUnit4::class)\nclass ServiceTest {\n    \n    @get:Rule\n    val serviceRule = ServiceTestRule()\n    \n    @Test\n    fun testBoundService() {\n        val serviceIntent = Intent(\n            ApplicationProvider.getApplicationContext(),\n            LocalBoundService::class.java\n        )\n        \n        val binder = serviceRule.bindService(serviceIntent)\n        val service = (binder as LocalBoundService.LocalBinder).getService()\n        \n        val number = service.getRandomNumber()\n        assertTrue(number in 0..100)\n    }\n}"
    },
    {
      "id": 92,
      "question": "What is Android Package Manager and App Installation?",
      "answer": "Package Manager provides information about installed packages and manages app installation, updates, and permissions.\n\nKey Features:\n• Query installed apps\n• Get app info\n• Check permissions\n• Install/uninstall apps\n• Verify signatures\n• Component information\n\nPackage Info:\n• Application metadata\n• Version information\n• Permissions\n• Activities, Services\n• Signing certificates\n\nApp Installation:\n• APK installation\n• Split APKs\n• App bundles\n• Session-based installation\n• Package installer\n\nPermissions:\n• Query granted permissions\n• Request permissions\n• Check permission status\n• Permission groups\n\nUse Cases:\n• Launch other apps\n• Check if app installed\n• Get app version\n• Share data between apps\n• Deep linking\n• Query intent handlers\n\nBest Practices:\n• Handle missing apps\n• Version compatibility\n• Permission checks\n• Secure app launching",
      "explanation": "Package Manager manages app metadata, querying installed packages, checking permissions, handling APK installation via session-based API, and providing component information for inter-app communication and app launching.",
      "difficulty": "Medium",
      "code": "// 1. Get PackageManager\nval packageManager = context.packageManager\n\n// 2. Query Installed Apps\nfun getInstalledApps(context: Context): List<ApplicationInfo> {\n    val pm = context.packageManager\n    \n    return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n        pm.getInstalledApplications(\n            PackageManager.ApplicationInfoFlags.of(0)\n        )\n    } else {\n        @Suppress(\"DEPRECATION\")\n        pm.getInstalledApplications(0)\n    }\n}\n\n// Filter user apps only\nfun getUserInstalledApps(context: Context): List<ApplicationInfo> {\n    return getInstalledApps(context).filter { appInfo ->\n        (appInfo.flags and ApplicationInfo.FLAG_SYSTEM) == 0\n    }\n}\n\n// Get app names\nfun getAppNames(context: Context): List<String> {\n    val pm = context.packageManager\n    return getInstalledApps(context).map { appInfo ->\n        pm.getApplicationLabel(appInfo).toString()\n    }\n}\n\n// 3. Check if App Installed\nfun isAppInstalled(context: Context, packageName: String): Boolean {\n    return try {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            context.packageManager.getPackageInfo(\n                packageName,\n                PackageManager.PackageInfoFlags.of(0)\n            )\n        } else {\n            @Suppress(\"DEPRECATION\")\n            context.packageManager.getPackageInfo(packageName, 0)\n        }\n        true\n    } catch (e: PackageManager.NameNotFoundException) {\n        false\n    }\n}\n\n// 4. Get Package Info\nfun getPackageInfo(context: Context, packageName: String): PackageInfo? {\n    return try {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            context.packageManager.getPackageInfo(\n                packageName,\n                PackageManager.PackageInfoFlags.of(\n                    PackageManager.GET_PERMISSIONS.toLong()\n                )\n            )\n        } else {\n            @Suppress(\"DEPRECATION\")\n            context.packageManager.getPackageInfo(\n                packageName,\n                PackageManager.GET_PERMISSIONS\n            )\n        }\n    } catch (e: PackageManager.NameNotFoundException) {\n        null\n    }\n}\n\n// Get app version\nfun getAppVersion(context: Context, packageName: String): String? {\n    val packageInfo = getPackageInfo(context, packageName)\n    return packageInfo?.versionName\n}\n\nfun getAppVersionCode(context: Context, packageName: String): Long? {\n    val packageInfo = getPackageInfo(context, packageName)\n    return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {\n        packageInfo?.longVersionCode\n    } else {\n        @Suppress(\"DEPRECATION\")\n        packageInfo?.versionCode?.toLong()\n    }\n}\n\n// 5. Get App Icon and Name\nfun getAppIcon(context: Context, packageName: String): Drawable? {\n    return try {\n        context.packageManager.getApplicationIcon(packageName)\n    } catch (e: PackageManager.NameNotFoundException) {\n        null\n    }\n}\n\nfun getAppName(context: Context, packageName: String): String? {\n    return try {\n        val appInfo = context.packageManager.getApplicationInfo(packageName, 0)\n        context.packageManager.getApplicationLabel(appInfo).toString()\n    } catch (e: PackageManager.NameNotFoundException) {\n        null\n    }\n}\n\n// 6. Launch Another App\nfun launchApp(context: Context, packageName: String): Boolean {\n    val intent = context.packageManager.getLaunchIntentForPackage(packageName)\n    return if (intent != null) {\n        context.startActivity(intent)\n        true\n    } else {\n        false\n    }\n}\n\n// Launch with custom intent\nfun launchAppWithData(context: Context, packageName: String, data: String) {\n    val intent = Intent().apply {\n        setPackage(packageName)\n        action = Intent.ACTION_SEND\n        type = \"text/plain\"\n        putExtra(Intent.EXTRA_TEXT, data)\n    }\n    \n    if (intent.resolveActivity(context.packageManager) != null) {\n        context.startActivity(intent)\n    } else {\n        // App not installed or cannot handle intent\n    }\n}\n\n// 7. Query Intent Handlers\nfun getIntentHandlers(context: Context, intent: Intent): List<ResolveInfo> {\n    val pm = context.packageManager\n    \n    return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n        pm.queryIntentActivities(\n            intent,\n            PackageManager.ResolveInfoFlags.of(\n                PackageManager.MATCH_DEFAULT_ONLY.toLong()\n            )\n        )\n    } else {\n        @Suppress(\"DEPRECATION\")\n        pm.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY)\n    }\n}\n\n// Check if intent can be handled\nfun canHandleIntent(context: Context, intent: Intent): Boolean {\n    return getIntentHandlers(context, intent).isNotEmpty()\n}\n\n// Show app chooser\nfun shareText(context: Context, text: String) {\n    val sendIntent = Intent().apply {\n        action = Intent.ACTION_SEND\n        putExtra(Intent.EXTRA_TEXT, text)\n        type = \"text/plain\"\n    }\n    \n    val chooserIntent = Intent.createChooser(sendIntent, \"Share via\")\n    context.startActivity(chooserIntent)\n}\n\n// 8. Check Permissions\nfun getAppPermissions(context: Context, packageName: String): List<String> {\n    val packageInfo = getPackageInfo(context, packageName)\n    return packageInfo?.requestedPermissions?.toList() ?: emptyList()\n}\n\nfun hasPermission(context: Context, packageName: String, permission: String): Boolean {\n    val pm = context.packageManager\n    return pm.checkPermission(permission, packageName) == PackageManager.PERMISSION_GRANTED\n}\n\n// 9. App Installation (Session-based)\nfun installApk(context: Context, apkUri: Uri) {\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n        val packageInstaller = context.packageManager.packageInstaller\n        val params = PackageInstaller.SessionParams(\n            PackageInstaller.SessionParams.MODE_FULL_INSTALL\n        )\n        \n        val sessionId = packageInstaller.createSession(params)\n        val session = packageInstaller.openSession(sessionId)\n        \n        // Write APK to session\n        context.contentResolver.openInputStream(apkUri)?.use { input ->\n            session.openWrite(\"package\", 0, -1).use { output ->\n                input.copyTo(output)\n                session.fsync(output)\n            }\n        }\n        \n        // Commit session\n        val intent = Intent(context, InstallReceiver::class.java)\n        val pendingIntent = PendingIntent.getBroadcast(\n            context,\n            0,\n            intent,\n            PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT\n        )\n        \n        session.commit(pendingIntent.intentSender)\n        session.close()\n    } else {\n        // Old method\n        val intent = Intent(Intent.ACTION_VIEW).apply {\n            setDataAndType(apkUri, \"application/vnd.android.package-archive\")\n            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_GRANT_READ_URI_PERMISSION\n        }\n        context.startActivity(intent)\n    }\n}\n\n// Installation receiver\nclass InstallReceiver : BroadcastReceiver() {\n    override fun onReceive(context: Context, intent: Intent) {\n        when (val status = intent.getIntExtra(PackageInstaller.EXTRA_STATUS, -1)) {\n            PackageInstaller.STATUS_PENDING_USER_ACTION -> {\n                val confirmIntent = intent.getParcelableExtra<Intent>(\n                    Intent.EXTRA_INTENT\n                )\n                confirmIntent?.let { context.startActivity(it.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)) }\n            }\n            PackageInstaller.STATUS_SUCCESS -> {\n                Log.d(\"Install\", \"Installation succeeded\")\n            }\n            PackageInstaller.STATUS_FAILURE,\n            PackageInstaller.STATUS_FAILURE_ABORTED,\n            PackageInstaller.STATUS_FAILURE_BLOCKED,\n            PackageInstaller.STATUS_FAILURE_CONFLICT,\n            PackageInstaller.STATUS_FAILURE_INCOMPATIBLE,\n            PackageInstaller.STATUS_FAILURE_INVALID,\n            PackageInstaller.STATUS_FAILURE_STORAGE -> {\n                val message = intent.getStringExtra(PackageInstaller.EXTRA_STATUS_MESSAGE)\n                Log.e(\"Install\", \"Installation failed: $message\")\n            }\n        }\n    }\n}\n\n// Permissions for installation\n<uses-permission android:name=\"android.permission.REQUEST_INSTALL_PACKAGES\" />\n\n// 10. Uninstall App\nfun uninstallApp(context: Context, packageName: String) {\n    val intent = Intent(Intent.ACTION_DELETE).apply {\n        data = Uri.parse(\"package:$packageName\")\n    }\n    context.startActivity(intent)\n}\n\n// 11. Get Signing Certificate\nfun getAppSignature(context: Context, packageName: String): String? {\n    return try {\n        val packageInfo = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            context.packageManager.getPackageInfo(\n                packageName,\n                PackageManager.PackageInfoFlags.of(\n                    PackageManager.GET_SIGNING_CERTIFICATES.toLong()\n                )\n            )\n        } else {\n            @Suppress(\"DEPRECATION\")\n            context.packageManager.getPackageInfo(\n                packageName,\n                PackageManager.GET_SIGNATURES\n            )\n        }\n        \n        val signature = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {\n            packageInfo.signingInfo?.apkContentsSigners?.firstOrNull()\n        } else {\n            @Suppress(\"DEPRECATION\")\n            packageInfo.signatures?.firstOrNull()\n        }\n        \n        signature?.let {\n            val md = MessageDigest.getInstance(\"SHA-256\")\n            md.update(it.toByteArray())\n            Base64.encodeToString(md.digest(), Base64.NO_WRAP)\n        }\n    } catch (e: Exception) {\n        null\n    }\n}\n\n// 12. Open App in Play Store\nfun openAppInPlayStore(context: Context, packageName: String) {\n    try {\n        // Try to open in Play Store app\n        val intent = Intent(Intent.ACTION_VIEW).apply {\n            data = Uri.parse(\"market://details?id=$packageName\")\n        }\n        context.startActivity(intent)\n    } catch (e: ActivityNotFoundException) {\n        // Open in browser\n        val intent = Intent(Intent.ACTION_VIEW).apply {\n            data = Uri.parse(\"https://play.google.com/store/apps/details?id=$packageName\")\n        }\n        context.startActivity(intent)\n    }\n}\n\n// 13. Query Package Components\nfun getActivities(context: Context, packageName: String): List<ActivityInfo> {\n    return try {\n        val packageInfo = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            context.packageManager.getPackageInfo(\n                packageName,\n                PackageManager.PackageInfoFlags.of(\n                    PackageManager.GET_ACTIVITIES.toLong()\n                )\n            )\n        } else {\n            @Suppress(\"DEPRECATION\")\n            context.packageManager.getPackageInfo(\n                packageName,\n                PackageManager.GET_ACTIVITIES\n            )\n        }\n        packageInfo.activities?.toList() ?: emptyList()\n    } catch (e: PackageManager.NameNotFoundException) {\n        emptyList()\n    }\n}\n\nfun getServices(context: Context, packageName: String): List<ServiceInfo> {\n    return try {\n        val packageInfo = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            context.packageManager.getPackageInfo(\n                packageName,\n                PackageManager.PackageInfoFlags.of(\n                    PackageManager.GET_SERVICES.toLong()\n                )\n            )\n        } else {\n            @Suppress(\"DEPRECATION\")\n            context.packageManager.getPackageInfo(\n                packageName,\n                PackageManager.GET_SERVICES\n            )\n        }\n        packageInfo.services?.toList() ?: emptyList()\n    } catch (e: PackageManager.NameNotFoundException) {\n        emptyList()\n    }\n}"
    },
    {
      "id": 93,
      "question": "What is Android Lint and Static Analysis?",
      "answer": "Android Lint is a static code analysis tool that detects potential bugs, performance issues, and code quality problems.\n\nLint Checks:\n• Correctness issues\n• Security vulnerabilities\n• Performance problems\n• Accessibility issues\n• Internationalization\n• Unused resources\n\nSeverity Levels:\n• Error - Must fix\n• Warning - Should fix\n• Information - Good to know\n• Ignore - Suppressed\n\nCommon Issues:\n• Hardcoded text\n• Missing translations\n• Unused resources\n• Layout performance\n• API version compatibility\n• Security vulnerabilities\n\nConfiguration:\n• lint.xml for custom rules\n• Suppress warnings\n• Baseline file\n• Custom severity\n• Enable/disable checks\n\nBest Practices:\n• Run lint regularly\n• Fix errors first\n• Address warnings\n• Create baselines\n• Integrate into CI/CD\n• Custom lint rules\n\nOther Tools:\n• Detekt (Kotlin)\n• ktlint\n• SonarQube\n• Checkstyle",
      "explanation": "Android Lint performs static code analysis detecting bugs, security issues, performance problems, and code quality issues with configurable rules, severity levels, suppression options, and CI/CD integration.",
      "difficulty": "Medium",
      "code": "// 1. Run Lint\n// From command line:\n// ./gradlew lint\n// ./gradlew lintDebug\n// ./gradlew lintRelease\n\n// Results: app/build/reports/lint-results.html\n\n// 2. Gradle Configuration\nandroid {\n    lint {\n        // Abort build on lint errors\n        abortOnError = true\n        \n        // Don't abort on warnings\n        warningAsErrors = false\n        \n        // Check all warnings\n        checkAllWarnings = true\n        \n        // Ignore warnings in generated code\n        checkGeneratedSources = false\n        \n        // Check dependencies\n        checkDependencies = true\n        \n        // Use baseline file\n        baseline = file(\"lint-baseline.xml\")\n        \n        // Disable specific checks\n        disable += setOf(\n            \"MissingTranslation\",\n            \"ExtraTranslation\"\n        )\n        \n        // Enable specific checks\n        enable += setOf(\n            \"RtlHardcoded\",\n            \"RtlCompat\"\n        )\n        \n        // Set check severity\n        error += \"StopShip\"\n        warning += \"InvalidPackage\"\n        \n        // Generate reports\n        htmlReport = true\n        htmlOutput = file(\"$buildDir/reports/lint/lint-report.html\")\n        \n        xmlReport = true\n        xmlOutput = file(\"$buildDir/reports/lint/lint-report.xml\")\n        \n        textReport = true\n        textOutput = file(\"$buildDir/reports/lint/lint-report.txt\")\n    }\n}\n\n// 3. lint.xml Configuration\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<lint>\n    <!-- Disable specific issues -->\n    <issue id=\"IconMissingDensityFolder\" severity=\"ignore\" />\n    \n    <!-- Change severity -->\n    <issue id=\"HardcodedText\" severity=\"error\" />\n    \n    <!-- Ignore in specific paths -->\n    <issue id=\"UnusedResources\">\n        <ignore path=\"src/test/**\" />\n        <ignore path=\"**/build/**\" />\n    </issue>\n    \n    <!-- Ignore specific resources -->\n    <issue id=\"UnusedResources\">\n        <ignore regexp=\".*_test\" />\n    </issue>\n</lint>\n\n// 4. Suppress Warnings in Code\n// Suppress specific lint check\n@SuppressLint(\"SetTextI18n\")\nfun setCustomText() {\n    textView.text = \"Hello World\" // Hardcoded text ignored\n}\n\n// Suppress multiple checks\n@SuppressLint(\"SetTextI18n\", \"HardcodedText\")\nclass MyActivity : AppCompatActivity() {\n    // ...\n}\n\n// Suppress for entire file\n@file:SuppressLint(\"UnusedImport\")\n\npackage com.example.app\n\n// XML suppression\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Hello\"\n    tools:ignore=\"HardcodedText\" />\n\n// 5. Common Lint Issues\n\n// Issue: Hardcoded text\n// BAD\n<TextView\n    android:text=\"Hello World\" />\n\n// GOOD\n<TextView\n    android:text=\"@string/hello_world\" />\n\n// Issue: Missing content description\n// BAD\n<ImageView\n    android:src=\"@drawable/icon\" />\n\n// GOOD\n<ImageView\n    android:src=\"@drawable/icon\"\n    android:contentDescription=\"@string/icon_description\" />\n\n// Issue: Overdraw\n// BAD - Background set in theme and layout\n<LinearLayout\n    android:background=\"@color/white\">\n    <!-- Content -->\n</LinearLayout>\n\n// GOOD - Only one background\n<LinearLayout>\n    <!-- Content -->\n</LinearLayout>\n\n// Issue: Nested weights\n// BAD\n<LinearLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:weightSum=\"1\">\n    \n    <LinearLayout\n        android:layout_width=\"0dp\"\n        android:layout_height=\"match_parent\"\n        android:layout_weight=\"0.5\"\n        android:weightSum=\"1\">\n        <!-- Nested weights - performance issue -->\n    </LinearLayout>\n</LinearLayout>\n\n// GOOD - Use ConstraintLayout\n<androidx.constraintlayout.widget.ConstraintLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <!-- Better performance -->\n</androidx.constraintlayout.widget.ConstraintLayout>\n\n// 6. Baseline File\n// Generate baseline (ignores existing issues)\n// ./gradlew lintDebug -Dlint.baseline.continue=true\n\n// lint-baseline.xml (generated)\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<issues format=\"6\" by=\"lint 7.4.0\">\n    <issue\n        id=\"HardcodedText\"\n        message=\"Hardcoded string, should use `@string` resource\"\n        errorLine1=\"    android:text='Hello World'\"\n        file=\"src/main/res/layout/activity_main.xml\"\n        line=\"10\"\n        column=\"9\" />\n</issues>\n\n// Use baseline\nandroid {\n    lint {\n        baseline = file(\"lint-baseline.xml\")\n    }\n}\n\n// 7. Custom Lint Rules\n// Create custom detector\nimplementation \"com.android.tools.lint:lint-api:30.4.0\"\nimplementation \"com.android.tools.lint:lint-checks:30.4.0\"\n\nclass MyDetector : Detector(), SourceCodeScanner {\n    \n    companion object {\n        val ISSUE = Issue.create(\n            id = \"MyCustomCheck\",\n            briefDescription = \"Custom lint check\",\n            explanation = \"Detailed explanation\",\n            category = Category.CORRECTNESS,\n            priority = 6,\n            severity = Severity.WARNING,\n            implementation = Implementation(\n                MyDetector::class.java,\n                Scope.JAVA_FILE_SCOPE\n            )\n        )\n    }\n    \n    override fun getApplicableMethodNames(): List<String> {\n        return listOf(\"dangerousMethod\")\n    }\n    \n    override fun visitMethodCall(\n        context: JavaContext,\n        node: UCallExpression,\n        method: PsiMethod\n    ) {\n        context.report(\n            ISSUE,\n            node,\n            context.getLocation(node),\n            \"Avoid using dangerousMethod()\"\n        )\n    }\n}\n\n// Register detector\nclass MyIssueRegistry : IssueRegistry() {\n    override val issues: List<Issue>\n        get() = listOf(MyDetector.ISSUE)\n    \n    override val api: Int = CURRENT_API\n}\n\n// 8. Lint in CI/CD\n// GitHub Actions\n- name: Run Lint\n  run: ./gradlew lintDebug\n\n- name: Upload Lint Results\n  uses: actions/upload-artifact@v3\n  with:\n    name: lint-results\n    path: app/build/reports/lint-results-debug.html\n\n- name: Annotate Lint Issues\n  uses: yutailang0119/action-android-lint@v3\n  with:\n    report-path: app/build/reports/lint-results-debug.xml\n\n// Fail build on errors\nandroid {\n    lint {\n        abortOnError = true\n    }\n}\n\n// 9. Detekt (Kotlin static analysis)\n// build.gradle.kts\nplugins {\n    id(\"io.gitlab.arturbosch.detekt\") version \"1.23.0\"\n}\n\ndetekt {\n    buildUponDefaultConfig = true\n    allRules = false\n    config = files(\"$projectDir/config/detekt.yml\")\n    baseline = file(\"$projectDir/config/baseline.xml\")\n}\n\ndependencies {\n    detektPlugins(\"io.gitlab.arturbosch.detekt:detekt-formatting:1.23.0\")\n}\n\n// Run detekt\n// ./gradlew detekt\n\n// detekt.yml\nstyle:\n  MaxLineLength:\n    maxLineLength: 120\n  MagicNumber:\n    ignoreNumbers: [-1, 0, 1, 2]\n\ncomplexity:\n  LongMethod:\n    threshold: 60\n  ComplexMethod:\n    threshold: 15\n\n// 10. ktlint (Kotlin code style)\n// build.gradle.kts\nplugins {\n    id(\"org.jlleitschuh.gradle.ktlint\") version \"11.3.2\"\n}\n\nktlint {\n    android.set(true)\n    ignoreFailures.set(false)\n    reporters {\n        reporter(ReporterType.PLAIN)\n        reporter(ReporterType.CHECKSTYLE)\n    }\n}\n\n// Run ktlint\n// ./gradlew ktlintCheck\n// ./gradlew ktlintFormat\n\n// 11. Analyze Lint Results\nfun analyzeLintResults(xmlFile: File) {\n    val issues = mutableMapOf<String, Int>()\n    \n    val doc = DocumentBuilderFactory.newInstance()\n        .newDocumentBuilder()\n        .parse(xmlFile)\n    \n    val nodeList = doc.getElementsByTagName(\"issue\")\n    \n    for (i in 0 until nodeList.length) {\n        val node = nodeList.item(i) as Element\n        val id = node.getAttribute(\"id\")\n        val severity = node.getAttribute(\"severity\")\n        \n        val key = \"$severity:$id\"\n        issues[key] = issues.getOrDefault(key, 0) + 1\n    }\n    \n    println(\"Lint Issues:\")\n    issues.entries\n        .sortedByDescending { it.value }\n        .forEach { (key, count) ->\n            println(\"$key: $count\")\n        }\n}\n\n// 12. Pre-commit Hook\n// .git/hooks/pre-commit\n#!/bin/sh\n\necho \"Running lint checks...\"\n./gradlew lintDebug --daemon\n\nif [ $? -ne 0 ]; then\n    echo \"Lint checks failed. Please fix the issues.\"\n    exit 1\nfi\n\necho \"Lint checks passed!\"\nexit 0"
    },
    {
      "id": 94,
      "question": "What is Android Battery Optimization and Doze Mode?",
      "answer": "Battery Optimization restricts app background activity to extend battery life through Doze Mode and App Standby.\n\nDoze Mode:\n• Device idle and stationary\n• Screen off\n• Not charging\n• Periodic maintenance windows\n• Network and job restrictions\n\nApp Standby:\n• App not used recently\n• No foreground services\n• No notifications\n• Network and job restrictions\n\nRestrictions:\n• No network access\n• Jobs and syncs deferred\n• Alarms delayed\n• Wakele wakelocks ignored\n• GPS/Wi-Fi scans stopped\n\nWhitelisting:\n• Request ignore optimization\n• Valid use cases only\n• User must approve\n• Settings access\n\nAdaptive Battery:\n• Machine learning\n• App usage patterns\n• Background restrictions\n• App standby buckets\n\nBest Practices:\n• Use WorkManager\n• Respect restrictions\n• Handle network unavailability\n• Test with Doze\n• Minimize wakelocks",
      "explanation": "Battery Optimization uses Doze Mode when device is idle and App Standby for unused apps, restricting network, jobs, and alarms with periodic maintenance windows, requiring whitelist approval for exemption.",
      "difficulty": "Hard",
      "code": "// 1. Check Battery Optimization Status\nfun isIgnoringBatteryOptimizations(context: Context): Boolean {\n    val pm = context.getSystemService(Context.POWER_SERVICE) as PowerManager\n    return pm.isIgnoringBatteryOptimizations(context.packageName)\n}\n\n// 2. Request Battery Optimization Exemption\nfun requestIgnoreBatteryOptimization(context: Context) {\n    if (!isIgnoringBatteryOptimizations(context)) {\n        val intent = Intent().apply {\n            action = Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS\n            data = Uri.parse(\"package:${context.packageName}\")\n        }\n        \n        if (intent.resolveActivity(context.packageManager) != null) {\n            context.startActivity(intent)\n        }\n    }\n}\n\n// Permission required\n<uses-permission android:name=\"android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS\" />\n\n// Open battery optimization settings\nfun openBatteryOptimizationSettings(context: Context) {\n    val intent = Intent(Settings.ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS)\n    context.startActivity(intent)\n}\n\n// 3. Detect Doze Mode\nfun isDeviceInDozeMode(context: Context): Boolean {\n    val pm = context.getSystemService(Context.POWER_SERVICE) as PowerManager\n    return pm.isDeviceIdleMode\n}\n\n// Monitor Doze mode changes\nclass DozeModeBroadcastReceiver : BroadcastReceiver() {\n    override fun onReceive(context: Context, intent: Intent) {\n        val pm = context.getSystemService(Context.POWER_SERVICE) as PowerManager\n        \n        when (intent.action) {\n            PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED -> {\n                if (pm.isDeviceIdleMode) {\n                    // Device entered Doze mode\n                    onDozeMode()\n                } else {\n                    // Device exited Doze mode\n                    onActiveMode()\n                }\n            }\n        }\n    }\n    \n    private fun onDozeMode() {\n        // Handle Doze mode restrictions\n        Log.d(\"Doze\", \"Entered Doze mode\")\n    }\n    \n    private fun onActiveMode() {\n        // Resume normal operations\n        Log.d(\"Doze\", \"Exited Doze mode\")\n    }\n}\n\n// Register receiver\nval receiver = DozeModeBroadcastReceiver()\nval filter = IntentFilter(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED)\nregisterReceiver(receiver, filter)\n\n// 4. App Standby Buckets\nfun getAppStandbyBucket(context: Context): Int {\n    val usageStatsManager = context.getSystemService(\n        Context.USAGE_STATS_SERVICE\n    ) as UsageStatsManager\n    \n    return usageStatsManager.appStandbyBucket\n}\n\nfun getStandbyBucketName(bucket: Int): String {\n    return when (bucket) {\n        UsageStatsManager.STANDBY_BUCKET_ACTIVE -> \"Active\"\n        UsageStatsManager.STANDBY_BUCKET_WORKING_SET -> \"Working Set\"\n        UsageStatsManager.STANDBY_BUCKET_FREQUENT -> \"Frequent\"\n        UsageStatsManager.STANDBY_BUCKET_RARE -> \"Rare\"\n        UsageStatsManager.STANDBY_BUCKET_RESTRICTED -> \"Restricted\"\n        else -> \"Unknown\"\n    }\n}\n\n// Permission required\n<uses-permission android:name=\"android.permission.PACKAGE_USAGE_STATS\" />\n\n// Request usage stats permission\nfun requestUsageStatsPermission(context: Context) {\n    val intent = Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS)\n    context.startActivity(intent)\n}\n\n// 5. Alarms in Doze Mode\n// Use setExactAndAllowWhileIdle() for critical alarms\nval alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager\n\nval triggerTime = System.currentTimeMillis() + 60000 // 1 minute\n\nval intent = Intent(context, AlarmReceiver::class.java)\nval pendingIntent = PendingIntent.getBroadcast(\n    context,\n    0,\n    intent,\n    PendingIntent.FLAG_IMMUTABLE\n)\n\n// Exact alarm that fires even in Doze\nalarmManager.setExactAndAllowWhileIdle(\n    AlarmManager.RTC_WAKEUP,\n    triggerTime,\n    pendingIntent\n)\n\n// Or use setAndAllowWhileIdle() for inexact\nalarmManager.setAndAllowWhileIdle(\n    AlarmManager.RTC_WAKEUP,\n    triggerTime,\n    pendingIntent\n)\n\n// Permissions for exact alarms (Android 12+)\n<uses-permission android:name=\"android.permission.SCHEDULE_EXACT_ALARM\" />\n<uses-permission android:name=\"android.permission.USE_EXACT_ALARM\" />\n\n// 6. Network Access in Doze\n// Use Firebase Cloud Messaging (FCM) for high-priority messages\nclass MyFirebaseMessagingService : FirebaseMessagingService() {\n    \n    override fun onMessageReceived(remoteMessage: RemoteMessage) {\n        // High-priority FCM messages wake device from Doze\n        if (remoteMessage.priority == RemoteMessage.PRIORITY_HIGH) {\n            handleUrgentMessage(remoteMessage)\n        }\n    }\n    \n    private fun handleUrgentMessage(message: RemoteMessage) {\n        // Process message\n    }\n}\n\n// Send high-priority FCM message\n{\n  \"to\": \"device_token\",\n  \"priority\": \"high\",\n  \"data\": {\n    \"message\": \"Urgent notification\"\n  }\n}\n\n// 7. WakeLocks (Use Sparingly)\n// Acquire wake lock\nval pm = context.getSystemService(Context.POWER_SERVICE) as PowerManager\nval wakeLock = pm.newWakeLock(\n    PowerManager.PARTIAL_WAKE_LOCK,\n    \"MyApp::MyWakeLock\"\n)\n\n// Set timeout to prevent battery drain\nwakeLock.acquire(10 * 60 * 1000L) // 10 minutes\n\ntry {\n    // Perform work\n    performCriticalWork()\n} finally {\n    // Always release\n    if (wakeLock.isHeld) {\n        wakeLock.release()\n    }\n}\n\n// Permission required\n<uses-permission android:name=\"android.permission.WAKE_LOCK\" />\n\n// 8. Testing Doze Mode\n/*\nADB commands to test Doze mode:\n\n// Force device into Doze mode\nadb shell dumpsys deviceidle force-idle\n\n// Exit Doze mode\nadb shell dumpsys deviceidle unforce\n\n// Step through Doze phases\nadb shell dumpsys deviceidle step [light|deep]\n\n// Check Doze state\nadb shell dumpsys deviceidle get [light|deep|force|screen|charging|network]\n\n// Enable Doze while charging (for testing)\nadb shell dumpsys battery unplug\nadb shell dumpsys deviceidle enable\n\n// Whitelist app (for testing)\nadb shell dumpsys deviceidle whitelist +com.example.app\n\n// Remove from whitelist\nadb shell dumpsys deviceidle whitelist -com.example.app\n\n// Reset battery stats\nadb shell dumpsys batterystats --reset\n*/\n\n// 9. WorkManager with Doze\n// WorkManager respects Doze automatically\nval constraints = Constraints.Builder()\n    .setRequiredNetworkType(NetworkType.CONNECTED)\n    .setRequiresBatteryNotLow(true)\n    .build()\n\nval workRequest = OneTimeWorkRequestBuilder<SyncWorker>()\n    .setConstraints(constraints)\n    .setBackoffCriteria(\n        BackoffPolicy.EXPONENTIAL,\n        OneTimeWorkRequest.MIN_BACKOFF_MILLIS,\n        TimeUnit.MILLISECONDS\n    )\n    .build()\n\nWorkManager.getInstance(context).enqueue(workRequest)\n\n// WorkManager will automatically schedule work during maintenance windows\n\n// 10. Battery Optimization Best Practices\nclass BatteryOptimizedService : Service() {\n    \n    private val handler = Handler(Looper.getMainLooper())\n    private val syncRunnable = object : Runnable {\n        override fun run() {\n            if (!isDeviceInDozeMode(this@BatteryOptimizedService)) {\n                performSync()\n            }\n            \n            // Schedule next sync\n            val delay = getNextSyncDelay()\n            handler.postDelayed(this, delay)\n        }\n    }\n    \n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\n        // Start syncing\n        handler.post(syncRunnable)\n        return START_STICKY\n    }\n    \n    private fun performSync() {\n        // Sync data\n    }\n    \n    private fun getNextSyncDelay(): Long {\n        val bucket = getAppStandbyBucket(this)\n        \n        return when (bucket) {\n            UsageStatsManager.STANDBY_BUCKET_ACTIVE -> 15 * 60 * 1000L // 15 min\n            UsageStatsManager.STANDBY_BUCKET_WORKING_SET -> 30 * 60 * 1000L // 30 min\n            UsageStatsManager.STANDBY_BUCKET_FREQUENT -> 60 * 60 * 1000L // 1 hour\n            UsageStatsManager.STANDBY_BUCKET_RARE -> 24 * 60 * 60 * 1000L // 24 hours\n            else -> 60 * 60 * 1000L // 1 hour default\n        }\n    }\n    \n    override fun onDestroy() {\n        super.onDestroy()\n        handler.removeCallbacks(syncRunnable)\n    }\n    \n    override fun onBind(intent: Intent?): IBinder? = null\n}\n\n// 11. Monitor Battery Status\nclass BatteryMonitor(private val context: Context) {\n    \n    fun getBatteryInfo(): BatteryInfo {\n        val batteryManager = context.getSystemService(\n            Context.BATTERY_SERVICE\n        ) as BatteryManager\n        \n        val level = batteryManager.getIntProperty(\n            BatteryManager.BATTERY_PROPERTY_CAPACITY\n        )\n        \n        val isCharging = batteryManager.isCharging\n        \n        return BatteryInfo(level, isCharging)\n    }\n    \n    fun registerBatteryReceiver(callback: (BatteryInfo) -> Unit) {\n        val filter = IntentFilter(Intent.ACTION_BATTERY_CHANGED)\n        \n        context.registerReceiver(\n            object : BroadcastReceiver() {\n                override fun onReceive(context: Context, intent: Intent) {\n                    val level = intent.getIntExtra(\n                        BatteryManager.EXTRA_LEVEL,\n                        -1\n                    )\n                    val scale = intent.getIntExtra(\n                        BatteryManager.EXTRA_SCALE,\n                        -1\n                    )\n                    val percentage = (level * 100 / scale.toFloat()).toInt()\n                    \n                    val status = intent.getIntExtra(\n                        BatteryManager.EXTRA_STATUS,\n                        -1\n                    )\n                    val isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING ||\n                                    status == BatteryManager.BATTERY_STATUS_FULL\n                    \n                    callback(BatteryInfo(percentage, isCharging))\n                }\n            },\n            filter\n        )\n    }\n}\n\ndata class BatteryInfo(val level: Int, val isCharging: Boolean)\n\n// 12. Respect Battery Saver Mode\nfun isPowerSaveMode(context: Context): Boolean {\n    val pm = context.getSystemService(Context.POWER_SERVICE) as PowerManager\n    return pm.isPowerSaveMode\n}\n\n// Listen for battery saver mode changes\nval receiver = object : BroadcastReceiver() {\n    override fun onReceive(context: Context, intent: Intent) {\n        val pm = context.getSystemService(Context.POWER_SERVICE) as PowerManager\n        \n        if (pm.isPowerSaveMode) {\n            // Reduce app activity\n            reduceBackgroundActivity()\n        } else {\n            // Resume normal activity\n            resumeNormalActivity()\n        }\n    }\n}\n\nval filter = IntentFilter(PowerManager.ACTION_POWER_SAVE_MODE_CHANGED)\nregisterReceiver(receiver, filter)"
    },
    {
      "id": 95,
      "question": "What is Android Splash Screen API and App Startup?",
      "answer": "Splash Screen API provides consistent splash screen experience across Android versions with customizable branding.\n\nCore Splash Screen:\n• Android 12+ native API\n• Animated app icon\n• Customizable background\n• Exit animation\n• Smooth transition\n\nBackward Compatibility:\n• SplashScreen compat library\n• Works on all Android versions\n• Consistent behavior\n• Migration path\n\nCustomization:\n• Window background color\n• Icon (adaptive or static)\n• Icon background\n• Branding image\n• Animation duration\n\nImplementation:\n• Theme-based configuration\n• SplashScreen.installSplashScreen()\n• OnExitAnimationListener\n• Keep splash screen longer\n\nApp Startup Library:\n• Lazy initialization\n• Automatic discovery\n• Dependency ordering\n• Better performance\n\nBest Practices:\n• Minimize splash duration\n• Use default transition\n• Load data in background\n• Handle configuration changes\n• Test on all devices",
      "explanation": "Splash Screen API (Android 12+) provides animated branded splash with customizable icon/background using theme configuration, installSplashScreen() setup, and SplashScreen compat library for backward compatibility.",
      "difficulty": "Medium",
      "code": "// 1. Dependencies\nimplementation 'androidx.core:core-splashscreen:1.0.1'\n\n// 2. Create Splash Screen Theme (res/values/themes.xml)\n<style name=\"Theme.App.Starting\" parent=\"Theme.SplashScreen\">\n    <!-- Set splash screen background, icon, and icon background-->\n    <item name=\"windowSplashScreenBackground\">@color/splash_background</item>\n    <item name=\"windowSplashScreenAnimatedIcon\">@drawable/ic_launcher</item>\n    <item name=\"windowSplashScreenAnimationDuration\">1000</item>\n    \n    <!-- Optional: Icon background -->\n    <item name=\"windowSplashScreenIconBackgroundColor\">@color/icon_background</item>\n    \n    <!-- Optional: Branding image (Android 12+) -->\n    <item name=\"android:windowSplashScreenBrandingImage\">@drawable/branding</item>\n    \n    <!-- Post-splash screen theme -->\n    <item name=\"postSplashScreenTheme\">@style/Theme.App</item>\n</style>\n\n// 3. Update AndroidManifest.xml\n<application\n    android:theme=\"@style/Theme.App.Starting\">\n    \n    <activity\n        android:name=\".MainActivity\"\n        android:exported=\"true\"\n        android:theme=\"@style/Theme.App.Starting\">\n        <intent-filter>\n            <action android:name=\"android.intent.action.MAIN\" />\n            <category android:name=\"android.intent.category.LAUNCHER\" />\n        </intent-filter>\n    </activity>\n</application>\n\n// 4. Install Splash Screen in Activity\nclass MainActivity : AppCompatActivity() {\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        // Install splash screen\n        val splashScreen = installSplashScreen()\n        \n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        // Customize splash screen\n        customizeSplashScreen(splashScreen)\n    }\n    \n    private fun customizeSplashScreen(splashScreen: SplashScreen) {\n        // Keep splash screen visible while loading data\n        var isReady = false\n        \n        splashScreen.setKeepOnScreenCondition {\n            !isReady\n        }\n        \n        // Load data\n        loadData {\n            isReady = true\n        }\n    }\n    \n    private fun loadData(onComplete: () -> Unit) {\n        // Simulate data loading\n        lifecycleScope.launch {\n            delay(2000)\n            onComplete()\n        }\n    }\n}\n\n// 5. Custom Exit Animation\nclass MainActivity : AppCompatActivity() {\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        val splashScreen = installSplashScreen()\n        \n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        // Custom exit animation\n        splashScreen.setOnExitAnimationListener { splashScreenView ->\n            // Create custom animation\n            val slideUp = ObjectAnimator.ofFloat(\n                splashScreenView.view,\n                View.TRANSLATION_Y,\n                0f,\n                -splashScreenView.view.height.toFloat()\n            )\n            \n            slideUp.interpolator = AccelerateInterpolator()\n            slideUp.duration = 500L\n            \n            // Remove splash screen when animation ends\n            slideUp.doOnEnd {\n                splashScreenView.remove()\n            }\n            \n            slideUp.start()\n        }\n    }\n}\n\n// 6. Animated Icon\n// Create animated vector drawable (res/drawable/animated_splash_icon.xml)\n<animated-vector\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:aapt=\"http://schemas.android.com/aapt\">\n    \n    <aapt:attr name=\"android:drawable\">\n        <vector\n            android:width=\"108dp\"\n            android:height=\"108dp\"\n            android:viewportWidth=\"108\"\n            android:viewportHeight=\"108\">\n            <path\n                android:name=\"path\"\n                android:fillColor=\"@color/ic_launcher_background\"\n                android:pathData=\"M0,0 L108,0 L108,108 L0,108 Z\" />\n        </vector>\n    </aapt:attr>\n    \n    <target android:name=\"path\">\n        <aapt:attr name=\"android:animation\">\n            <objectAnimator\n                android:duration=\"1000\"\n                android:propertyName=\"fillColor\"\n                android:valueFrom=\"@color/splash_start\"\n                android:valueTo=\"@color/splash_end\"\n                android:valueType=\"colorType\" />\n        </aapt:attr>\n    </target>\n</animated-vector>\n\n// Use in theme\n<item name=\"windowSplashScreenAnimatedIcon\">@drawable/animated_splash_icon</item>\n\n// 7. App Startup Library\nimplementation 'androidx.startup:startup-runtime:1.1.1'\n\n// Create initializer\nclass TimberInitializer : Initializer<Unit> {\n    \n    override fun create(context: Context) {\n        if (BuildConfig.DEBUG) {\n            Timber.plant(Timber.DebugTree())\n        }\n    }\n    \n    override fun dependencies(): List<Class<out Initializer<*>>> {\n        return emptyList()\n    }\n}\n\n// Register in AndroidManifest.xml\n<provider\n    android:name=\"androidx.startup.InitializationProvider\"\n    android:authorities=\"${applicationId}.androidx-startup\"\n    android:exported=\"false\"\n    tools:node=\"merge\">\n    \n    <meta-data\n        android:name=\"com.example.TimberInitializer\"\n        android:value=\"androidx.startup\" />\n</provider>\n\n// 8. Manual Initialization (if needed)\nclass MyApplication : Application() {\n    \n    override fun onCreate() {\n        super.onCreate()\n        \n        // Manual initialization\n        AppInitializer.getInstance(this)\n            .initializeComponent(TimberInitializer::class.java)\n    }\n}\n\n// Disable automatic initialization\n<provider\n    android:name=\"androidx.startup.InitializationProvider\"\n    android:authorities=\"${applicationId}.androidx-startup\"\n    tools:node=\"remove\" />\n\n// 9. Splash Screen for Older Versions\n// Create splash activity for pre-Android 12\nclass SplashActivity : AppCompatActivity() {\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        \n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {\n            // Use new splash screen API\n            startMainActivity()\n        } else {\n            // Custom splash screen\n            setContentView(R.layout.activity_splash)\n            \n            // Load data then navigate\n            lifecycleScope.launch {\n                loadAppData()\n                startMainActivity()\n                finish()\n            }\n        }\n    }\n    \n    private suspend fun loadAppData() = withContext(Dispatchers.IO) {\n        delay(2000) // Simulate loading\n    }\n    \n    private fun startMainActivity() {\n        startActivity(Intent(this, MainActivity::class.java))\n        finish()\n    }\n}\n\n// 10. Testing Splash Screen\n@RunWith(AndroidJUnit4::class)\nclass SplashScreenTest {\n    \n    @get:Rule\n    val activityRule = ActivityScenarioRule(MainActivity::class.java)\n    \n    @Test\n    fun testSplashScreenDisplayed() {\n        // Wait for splash to finish\n        Thread.sleep(2000)\n        \n        // Verify main content is visible\n        onView(withId(R.id.main_content))\n            .check(matches(isDisplayed()))\n    }\n}\n\n// 11. Splash Screen with ViewModel\nclass MainActivity : AppCompatActivity() {\n    \n    private val viewModel: MainViewModel by viewModels()\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        val splashScreen = installSplashScreen()\n        \n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        // Keep splash until data loaded\n        splashScreen.setKeepOnScreenCondition {\n            viewModel.isLoading.value == true\n        }\n        \n        // Observe loading state\n        viewModel.isLoading.observe(this) { isLoading ->\n            if (!isLoading) {\n                // Data loaded, splash will dismiss\n            }\n        }\n        \n        // Start loading\n        viewModel.loadInitialData()\n    }\n}\n\nclass MainViewModel : ViewModel() {\n    private val _isLoading = MutableLiveData(true)\n    val isLoading: LiveData<Boolean> = _isLoading\n    \n    fun loadInitialData() {\n        viewModelScope.launch {\n            try {\n                // Load data\n                delay(2000)\n                _isLoading.value = false\n            } catch (e: Exception) {\n                _isLoading.value = false\n            }\n        }\n    }\n}\n\n// 12. Adaptive Icon for Splash\n// res/mipmap-anydpi-v26/ic_launcher.xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<adaptive-icon xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <background android:drawable=\"@color/ic_launcher_background\" />\n    <foreground android:drawable=\"@drawable/ic_launcher_foreground\" />\n</adaptive-icon>\n\n// Use adaptive icon in splash\n<item name=\"windowSplashScreenAnimatedIcon\">@mipmap/ic_launcher</item>\n\n// 13. Complete Example\nclass MainActivity : AppCompatActivity() {\n    \n    private val viewModel: SplashViewModel by viewModels()\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        // Install and customize splash\n        val splashScreen = installSplashScreen()\n        setupSplashScreen(splashScreen)\n        \n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        // Start initialization\n        viewModel.initialize()\n        \n        // Observe initialization\n        observeInitialization()\n    }\n    \n    private fun setupSplashScreen(splashScreen: SplashScreen) {\n        // Keep on screen while loading\n        splashScreen.setKeepOnScreenCondition {\n            !viewModel.isInitialized.value!!\n        }\n        \n        // Custom exit animation\n        splashScreen.setOnExitAnimationListener { splashScreenView ->\n            val fadeOut = ObjectAnimator.ofFloat(\n                splashScreenView.view,\n                View.ALPHA,\n                1f,\n                0f\n            )\n            fadeOut.duration = 300L\n            fadeOut.doOnEnd { splashScreenView.remove() }\n            fadeOut.start()\n        }\n    }\n    \n    private fun observeInitialization() {\n        viewModel.isInitialized.observe(this) { initialized ->\n            if (initialized) {\n                // App is ready\n                showMainContent()\n            }\n        }\n        \n        viewModel.error.observe(this) { error ->\n            error?.let {\n                showError(it)\n            }\n        }\n    }\n    \n    private fun showMainContent() {\n        // Display main UI\n    }\n    \n    private fun showError(message: String) {\n        Toast.makeText(this, message, Toast.LENGTH_LONG).show()\n    }\n}\n\nclass SplashViewModel : ViewModel() {\n    private val _isInitialized = MutableLiveData(false)\n    val isInitialized: LiveData<Boolean> = _isInitialized\n    \n    private val _error = MutableLiveData<String?>()\n    val error: LiveData<String?> = _error\n    \n    fun initialize() {\n        viewModelScope.launch {\n            try {\n                // Initialize app components\n                initializeDatabase()\n                loadUserPreferences()\n                fetchRemoteConfig()\n                \n                _isInitialized.value = true\n            } catch (e: Exception) {\n                _error.value = \"Initialization failed: ${e.message}\"\n                _isInitialized.value = true\n            }\n        }\n    }\n    \n    private suspend fun initializeDatabase() = withContext(Dispatchers.IO) {\n        delay(500)\n    }\n    \n    private suspend fun loadUserPreferences() = withContext(Dispatchers.IO) {\n        delay(500)\n    }\n    \n    private suspend fun fetchRemoteConfig() = withContext(Dispatchers.IO) {\n        delay(1000)\n    }\n}"
    },
    {
      "id": 96,
      "question": "What is Android WebView and JavaScript integration?",
      "answer": "WebView displays web content within Android apps, enabling web and native code interaction through JavaScript interfaces.\n\nWebView Features:\n• Display web pages\n• Execute JavaScript\n• Handle cookies\n• Custom URL loading\n• File uploads\n• Geolocation\n\nJavaScript Bridge:\n• @JavascriptInterface\n• Call native from JS\n• Call JS from native\n• Data passing\n• Asynchronous calls\n\nSecurity:\n• Disable JavaScript (default)\n• Content Security Policy\n• SSL error handling\n• Safe browsing\n• Mixed content\n\nWebView Settings:\n• JavaScript enabled\n• DOM storage\n• File access\n• Zoom controls\n• Cache mode\n• User agent\n\nBest Practices:\n• Enable JavaScript carefully\n• Validate input\n• Handle SSL errors properly\n• Use HTTPS only\n• Test thoroughly\n• Handle back button",
      "explanation": "WebView displays web content with JavaScript integration via @JavascriptInterface allowing bidirectional native-web communication, requiring security measures like SSL validation, safe browsing, and careful JavaScript enablement.",
      "difficulty": "Medium",
      "code": "// 1. Basic WebView Setup\nclass WebViewActivity : AppCompatActivity() {\n    \n    private lateinit var webView: WebView\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_webview)\n        \n        webView = findViewById(R.id.webView)\n        setupWebView()\n        \n        // Load URL\n        webView.loadUrl(\"https://www.example.com\")\n    }\n    \n    private fun setupWebView() {\n        webView.settings.apply {\n            // Enable JavaScript\n            javaScriptEnabled = true\n            \n            // Enable DOM storage\n            domStorageEnabled = true\n            \n            // Allow file access\n            allowFileAccess = false\n            allowContentAccess = false\n            \n            // Enable zooming\n            builtInZoomControls = true\n            displayZoomControls = false\n            \n            // Cache settings\n            cacheMode = WebSettings.LOAD_DEFAULT\n            \n            // Mixed content (HTTPS + HTTP)\n            mixedContentMode = WebSettings.MIXED_CONTENT_NEVER_ALLOW\n            \n            // Safe browsing\n            safeBrowsingEnabled = true\n        }\n        \n        // Set WebView client\n        webView.webViewClient = MyWebViewClient()\n        \n        // Set WebChrome client\n        webView.webChromeClient = MyWebChromeClient()\n    }\n    \n    override fun onBackPressed() {\n        if (webView.canGoBack()) {\n            webView.goBack()\n        } else {\n            super.onBackPressed()\n        }\n    }\n}\n\n// Layout XML\n<WebView\n    android:id=\"@+id/webView\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\" />\n\n// Permissions\n<uses-permission android:name=\"android.permission.INTERNET\" />\n\n// 2. WebViewClient\nclass MyWebViewClient : WebViewClient() {\n    \n    override fun shouldOverrideUrlLoading(\n        view: WebView?,\n        request: WebResourceRequest?\n    ): Boolean {\n        val url = request?.url?.toString() ?: return false\n        \n        return when {\n            url.startsWith(\"https://www.example.com\") -> {\n                // Load in WebView\n                false\n            }\n            url.startsWith(\"https://\") -> {\n                // Open in browser\n                val intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))\n                view?.context?.startActivity(intent)\n                true\n            }\n            else -> true\n        }\n    }\n    \n    override fun onPageStarted(view: WebView?, url: String?, favicon: Bitmap?) {\n        super.onPageStarted(view, url, favicon)\n        // Show loading indicator\n    }\n    \n    override fun onPageFinished(view: WebView?, url: String?) {\n        super.onPageFinished(view, url)\n        // Hide loading indicator\n    }\n    \n    override fun onReceivedError(\n        view: WebView?,\n        request: WebResourceRequest?,\n        error: WebResourceError?\n    ) {\n        super.onReceivedError(view, request, error)\n        // Handle error\n    }\n    \n    override fun onReceivedSslError(\n        view: WebView?,\n        handler: SslErrorHandler?,\n        error: SslError?\n    ) {\n        // Don't proceed on SSL errors\n        handler?.cancel()\n    }\n}\n\n// 3. WebChromeClient\nclass MyWebChromeClient : WebChromeClient() {\n    \n    override fun onProgressChanged(view: WebView?, newProgress: Int) {\n        super.onProgressChanged(view, newProgress)\n        // Update progress bar\n    }\n    \n    override fun onReceivedTitle(view: WebView?, title: String?) {\n        super.onReceivedTitle(view, title)\n        // Update activity title\n    }\n    \n    override fun onJsAlert(\n        view: WebView?,\n        url: String?,\n        message: String?,\n        result: JsResult?\n    ): Boolean {\n        // Handle JavaScript alert\n        AlertDialog.Builder(view?.context!!)\n            .setMessage(message)\n            .setPositiveButton(\"OK\") { _, _ ->\n                result?.confirm()\n            }\n            .setOnCancelListener {\n                result?.cancel()\n            }\n            .show()\n        return true\n    }\n    \n    override fun onJsConfirm(\n        view: WebView?,\n        url: String?,\n        message: String?,\n        result: JsResult?\n    ): Boolean {\n        // Handle JavaScript confirm\n        AlertDialog.Builder(view?.context!!)\n            .setMessage(message)\n            .setPositiveButton(\"OK\") { _, _ ->\n                result?.confirm()\n            }\n            .setNegativeButton(\"Cancel\") { _, _ ->\n                result?.cancel()\n            }\n            .show()\n        return true\n    }\n    \n    override fun onGeolocationPermissionsShowPrompt(\n        origin: String?,\n        callback: GeolocationPermissions.Callback?\n    ) {\n        // Handle geolocation permission request\n        callback?.invoke(origin, true, false)\n    }\n}\n\n// 4. JavaScript Interface\nclass WebAppInterface(private val context: Context) {\n    \n    @JavascriptInterface\n    fun showToast(message: String) {\n        Toast.makeText(context, message, Toast.LENGTH_SHORT).show()\n    }\n    \n    @JavascriptInterface\n    fun getUserData(): String {\n        // Return user data as JSON\n        return \"\"\"{\"name\": \"John\", \"email\": \"john@example.com\"}\"\"\"\n    }\n    \n    @JavascriptInterface\n    fun saveData(data: String) {\n        // Save data from JavaScript\n        val prefs = context.getSharedPreferences(\"WebData\", Context.MODE_PRIVATE)\n        prefs.edit().putString(\"data\", data).apply()\n    }\n    \n    @JavascriptInterface\n    fun openCamera() {\n        // Launch camera\n        val intent = Intent(MediaStore.ACTION_IMAGE_CAPTURE)\n        (context as? Activity)?.startActivityForResult(intent, 100)\n    }\n}\n\n// Add interface to WebView\nwebView.addJavascriptInterface(WebAppInterface(this), \"Android\")\n\n// Call from JavaScript\n<script>\n    function callNative() {\n        Android.showToast(\"Hello from JavaScript!\");\n    }\n    \n    function getUserInfo() {\n        var userData = Android.getUserData();\n        var user = JSON.parse(userData);\n        console.log(user.name);\n    }\n</script>\n\n// 5. Call JavaScript from Native\n// Execute JavaScript\nfun executeJavaScript(script: String) {\n    webView.evaluateJavascript(script) { result ->\n        // Result from JavaScript\n        Log.d(\"WebView\", \"Result: $result\")\n    }\n}\n\n// Example: Call JS function\nexecuteJavaScript(\"myJsFunction('param1', 'param2')\")\n\n// Example: Get value from JS\nexecuteJavaScript(\"document.getElementById('username').value\") { value ->\n    Log.d(\"WebView\", \"Username: $value\")\n}\n\n// Example: Inject JavaScript\nval script = \"\"\"\n    (function() {\n        var element = document.getElementById('myElement');\n        element.style.backgroundColor = 'red';\n    })();\n\"\"\"\nexecuteJavaScript(script)\n\n// 6. Load Local HTML\n// Load from assets\nwebView.loadUrl(\"file:///android_asset/index.html\")\n\n// Load HTML string\nval htmlContent = \"\"\"\n    <html>\n    <head>\n        <style>\n            body { font-family: sans-serif; padding: 20px; }\n        </style>\n    </head>\n    <body>\n        <h1>Hello WebView</h1>\n        <button onclick=\"Android.showToast('Button clicked')\">Click Me</button>\n    </body>\n    </html>\n\"\"\"\n\nwebView.loadData(htmlContent, \"text/html\", \"UTF-8\")\n\n// Or with base URL\nwebView.loadDataWithBaseURL(\n    \"https://example.com\",\n    htmlContent,\n    \"text/html\",\n    \"UTF-8\",\n    null\n)\n\n// 7. File Upload\nclass WebViewActivity : AppCompatActivity() {\n    \n    private var fileUploadCallback: ValueCallback<Array<Uri>>? = null\n    \n    private val fileChooserLauncher = registerForActivityResult(\n        ActivityResultContracts.GetMultipleContents()\n    ) { uris ->\n        fileUploadCallback?.onReceiveValue(uris.toTypedArray())\n        fileUploadCallback = null\n    }\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        \n        webView.webChromeClient = object : WebChromeClient() {\n            override fun onShowFileChooser(\n                webView: WebView?,\n                filePathCallback: ValueCallback<Array<Uri>>?,\n                fileChooserParams: FileChooserParams?\n            ): Boolean {\n                fileUploadCallback = filePathCallback\n                fileChooserLauncher.launch(\"image/*\")\n                return true\n            }\n        }\n    }\n}\n\n// 8. Cookies Management\n// Enable cookies\nval cookieManager = CookieManager.getInstance()\ncookieManager.setAcceptCookie(true)\ncookieManager.setAcceptThirdPartyCookies(webView, true)\n\n// Set cookie\nval url = \"https://www.example.com\"\nval cookie = \"sessionid=abc123; path=/\"\ncookieManager.setCookie(url, cookie)\n\n// Get cookies\nval cookies = cookieManager.getCookie(url)\n\n// Remove cookies\ncookieManager.removeAllCookies { success ->\n    if (success) {\n        Log.d(\"WebView\", \"Cookies removed\")\n    }\n}\n\n// 9. Download Handler\nwebView.setDownloadListener { url, userAgent, contentDisposition, mimeType, contentLength ->\n    // Handle download\n    val request = DownloadManager.Request(Uri.parse(url))\n    request.setMimeType(mimeType)\n    request.addRequestHeader(\"User-Agent\", userAgent)\n    request.setDescription(\"Downloading file...\")\n    request.setTitle(\"Download\")\n    request.setNotificationVisibility(\n        DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED\n    )\n    \n    val dm = getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager\n    dm.enqueue(request)\n}\n\n// 10. WebView Cache Management\n// Clear cache\nwebView.clearCache(true)\n\n// Clear form data\nwebView.clearFormData()\n\n// Clear history\nwebView.clearHistory()\n\n// Clear SSL preferences\nwebView.clearSslPreferences()\n\n// Set cache mode\nwebView.settings.cacheMode = WebSettings.LOAD_NO_CACHE // No cache\n// Or\nwebView.settings.cacheMode = WebSettings.LOAD_CACHE_ELSE_NETWORK // Cache first\n// Or\nwebView.settings.cacheMode = WebSettings.LOAD_CACHE_ONLY // Cache only\n\n// 11. Handle Deep Links in WebView\nclass MyWebViewClient : WebViewClient() {\n    \n    override fun shouldOverrideUrlLoading(\n        view: WebView?,\n        request: WebResourceRequest?\n    ): Boolean {\n        val url = request?.url ?: return false\n        \n        return when {\n            url.scheme == \"myapp\" -> {\n                // Handle deep link\n                handleDeepLink(url)\n                true\n            }\n            url.scheme == \"tel\" -> {\n                // Handle phone call\n                val intent = Intent(Intent.ACTION_DIAL, url)\n                view?.context?.startActivity(intent)\n                true\n            }\n            url.scheme == \"mailto\" -> {\n                // Handle email\n                val intent = Intent(Intent.ACTION_SENDTO, url)\n                view?.context?.startActivity(intent)\n                true\n            }\n            else -> false\n        }\n    }\n    \n    private fun handleDeepLink(uri: Uri) {\n        // Parse and handle deep link\n    }\n}\n\n// 12. WebView Debugging\n// Enable debugging (Chrome DevTools)\nif (BuildConfig.DEBUG) {\n    WebView.setWebContentsDebuggingEnabled(true)\n}\n\n// Access via chrome://inspect on desktop Chrome\n\n// 13. Lifecycle Management\noverride fun onResume() {\n    super.onResume()\n    webView.onResume()\n    webView.resumeTimers()\n}\n\noverride fun onPause() {\n    super.onPause()\n    webView.onPause()\n    webView.pauseTimers()\n}\n\noverride fun onDestroy() {\n    super.onDestroy()\n    webView.destroy()\n}"
    },
    {
      "id": 97,
      "question": "What is Android Camera X and Image Capture?",
      "answer": "CameraX is a Jetpack library that simplifies camera development with consistent API across devices and Android versions.\n\nKey Features:\n• Lifecycle-aware\n• Preview use case\n• Image capture\n• Video capture\n• Image analysis\n• Device compatibility\n\nUse Cases:\n• Preview - Display camera feed\n• ImageCapture - Take photos\n• VideoCapture - Record videos\n• ImageAnalysis - Process frames\n\nBenefits:\n• Consistent behavior\n• Automatic aspect ratio\n• Rotation handling\n• Device quirks handled\n• Extension support\n\nConfiguration:\n• CameraSelector\n• PreviewView\n• ImageCapture\n• Executor\n• Output options\n\nBest Practices:\n• Request permissions\n• Handle lifecycle\n• Use appropriate executor\n• Error handling\n• Test on devices\n• Respect privacy",
      "explanation": "CameraX provides lifecycle-aware camera functionality with use cases for preview, image capture, video recording, and frame analysis, handling device compatibility, rotation, and aspect ratio automatically.",
      "difficulty": "Medium",
      "code": "// 1. Dependencies\nimplementation 'androidx.camera:camera-core:1.2.3'\nimplementation 'androidx.camera:camera-camera2:1.2.3'\nimplementation 'androidx.camera:camera-lifecycle:1.2.3'\nimplementation 'androidx.camera:camera-view:1.2.3'\n\n// 2. Permissions\n<uses-feature android:name=\"android.hardware.camera.any\" />\n<uses-permission android:name=\"android.permission.CAMERA\" />\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"\n    android:maxSdkVersion=\"28\" />\n\n// 3. Basic Camera Setup\nclass CameraActivity : AppCompatActivity() {\n    \n    private lateinit var binding: ActivityCameraBinding\n    private var imageCapture: ImageCapture? = null\n    private lateinit var cameraExecutor: ExecutorService\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityCameraBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n        \n        // Request camera permissions\n        if (allPermissionsGranted()) {\n            startCamera()\n        } else {\n            requestPermissions()\n        }\n        \n        // Set up click listeners\n        binding.captureButton.setOnClickListener { takePhoto() }\n        \n        cameraExecutor = Executors.newSingleThreadExecutor()\n    }\n    \n    private fun startCamera() {\n        val cameraProviderFuture = ProcessCameraProvider.getInstance(this)\n        \n        cameraProviderFuture.addListener({\n            val cameraProvider = cameraProviderFuture.get()\n            \n            // Preview use case\n            val preview = Preview.Builder()\n                .build()\n                .also {\n                    it.setSurfaceProvider(binding.previewView.surfaceProvider)\n                }\n            \n            // Image capture use case\n            imageCapture = ImageCapture.Builder()\n                .setCaptureMode(ImageCapture.CAPTURE_MODE_MINIMIZE_LATENCY)\n                .build()\n            \n            // Camera selector (back camera)\n            val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA\n            \n            try {\n                // Unbind all use cases\n                cameraProvider.unbindAll()\n                \n                // Bind use cases to camera\n                cameraProvider.bindToLifecycle(\n                    this,\n                    cameraSelector,\n                    preview,\n                    imageCapture\n                )\n            } catch (e: Exception) {\n                Log.e(\"CameraX\", \"Use case binding failed\", e)\n            }\n        }, ContextCompat.getMainExecutor(this))\n    }\n    \n    private fun takePhoto() {\n        val imageCapture = imageCapture ?: return\n        \n        // Create output file\n        val photoFile = File(\n            outputDirectory,\n            SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss-SSS\", Locale.US)\n                .format(System.currentTimeMillis()) + \".jpg\"\n        )\n        \n        val outputOptions = ImageCapture.OutputFileOptions.Builder(photoFile).build()\n        \n        // Take photo\n        imageCapture.takePicture(\n            outputOptions,\n            ContextCompat.getMainExecutor(this),\n            object : ImageCapture.OnImageSavedCallback {\n                override fun onImageSaved(output: ImageCapture.OutputFileResults) {\n                    val msg = \"Photo saved: ${output.savedUri}\"\n                    Toast.makeText(baseContext, msg, Toast.LENGTH_SHORT).show()\n                }\n                \n                override fun onError(exc: ImageCaptureException) {\n                    Log.e(\"CameraX\", \"Photo capture failed: ${exc.message}\", exc)\n                }\n            }\n        )\n    }\n    \n    private fun allPermissionsGranted() = REQUIRED_PERMISSIONS.all {\n        ContextCompat.checkSelfPermission(baseContext, it) == PackageManager.PERMISSION_GRANTED\n    }\n    \n    override fun onDestroy() {\n        super.onDestroy()\n        cameraExecutor.shutdown()\n    }\n    \n    companion object {\n        private val REQUIRED_PERMISSIONS = arrayOf(Manifest.permission.CAMERA)\n    }\n}\n\n// Layout XML\n<androidx.camera.view.PreviewView\n    android:id=\"@+id/previewView\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\" />\n\n<Button\n    android:id=\"@+id/captureButton\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Take Photo\" />\n\n// 4. Image Analysis\nval imageAnalyzer = ImageAnalysis.Builder()\n    .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)\n    .build()\n    .also {\n        it.setAnalyzer(cameraExecutor, object : ImageAnalysis.Analyzer {\n            override fun analyze(image: ImageProxy) {\n                // Process image\n                val rotationDegrees = image.imageInfo.rotationDegrees\n                \n                // Access image buffer\n                val buffer = image.planes[0].buffer\n                val data = buffer.toByteArray()\n                \n                // Process data...\n                \n                // Close image\n                image.close()\n            }\n        })\n    }\n\n// Bind image analysis\ncameraProvider.bindToLifecycle(\n    this,\n    cameraSelector,\n    preview,\n    imageCapture,\n    imageAnalyzer\n)\n\n// 5. Video Capture\nval videoCapture = VideoCapture.Builder()\n    .setVideoFrameRate(30)\n    .setBitRate(3 * 1024 * 1024) // 3 Mbps\n    .build()\n\n// Start recording\nprivate var recording: Recording? = null\n\nfun startRecording() {\n    val videoFile = File(\n        outputDirectory,\n        SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss-SSS\", Locale.US)\n            .format(System.currentTimeMillis()) + \".mp4\"\n    )\n    \n    val outputOptions = FileOutputOptions.Builder(videoFile).build()\n    \n    recording = videoCapture.output\n        .prepareRecording(this, outputOptions)\n        .withAudioEnabled()\n        .start(ContextCompat.getMainExecutor(this)) { event ->\n            when (event) {\n                is VideoRecordEvent.Start -> {\n                    // Recording started\n                }\n                is VideoRecordEvent.Finalize -> {\n                    if (event.hasError()) {\n                        Log.e(\"Video\", \"Recording error: ${event.error}\")\n                    } else {\n                        Toast.makeText(this, \"Video saved\", Toast.LENGTH_SHORT).show()\n                    }\n                }\n            }\n        }\n}\n\nfun stopRecording() {\n    recording?.stop()\n    recording = null\n}\n\n// 6. Switch Camera (Front/Back)\nprivate var lensFacing = CameraSelector.LENS_FACING_BACK\n\nfun switchCamera() {\n    lensFacing = if (lensFacing == CameraSelector.LENS_FACING_BACK) {\n        CameraSelector.LENS_FACING_FRONT\n    } else {\n        CameraSelector.LENS_FACING_BACK\n    }\n    \n    startCamera()\n}\n\n// Camera selector\nval cameraSelector = CameraSelector.Builder()\n    .requireLensFacing(lensFacing)\n    .build()\n\n// 7. Flash Control\nval camera = cameraProvider.bindToLifecycle(...)\n\nif (camera.cameraInfo.hasFlashUnit()) {\n    camera.cameraControl.enableTorch(true) // Turn on\n    camera.cameraControl.enableTorch(false) // Turn off\n}\n\n// Flash mode for image capture\nimageCapture = ImageCapture.Builder()\n    .setFlashMode(ImageCapture.FLASH_MODE_AUTO)\n    .build()\n\n// 8. Zoom Control\nval camera = cameraProvider.bindToLifecycle(...)\n\n// Get zoom state\nval zoomState = camera.cameraInfo.zoomState.value\nval currentZoom = zoomState?.zoomRatio\nval minZoom = zoomState?.minZoomRatio\nval maxZoom = zoomState?.maxZoomRatio\n\n// Set zoom\ncamera.cameraControl.setZoomRatio(2.0f) // 2x zoom\n\n// Linear zoom\ncamera.cameraControl.setLinearZoom(0.5f) // 50%\n\n// 9. Focus and Exposure\nval camera = cameraProvider.bindToLifecycle(...)\n\n// Tap to focus\npreviewView.setOnTouchListener { _, event ->\n    if (event.action == MotionEvent.ACTION_DOWN) {\n        val factory = previewView.meteringPointFactory\n        val point = factory.createPoint(event.x, event.y)\n        \n        val action = FocusMeteringAction.Builder(point)\n            .setAutoCancelDuration(3, TimeUnit.SECONDS)\n            .build()\n        \n        camera.cameraControl.startFocusAndMetering(action)\n    }\n    true\n}\n\n// 10. Capture in Memory\nfun captureToMemory() {\n    imageCapture?.takePicture(\n        ContextCompat.getMainExecutor(this),\n        object : ImageCapture.OnImageCapturedCallback() {\n            override fun onCaptureSuccess(image: ImageProxy) {\n                // Convert to Bitmap\n                val bitmap = image.toBitmap()\n                \n                // Process bitmap\n                processBitmap(bitmap)\n                \n                image.close()\n            }\n            \n            override fun onError(exception: ImageCaptureException) {\n                Log.e(\"Camera\", \"Capture failed\", exception)\n            }\n        }\n    )\n}\n\nfun ImageProxy.toBitmap(): Bitmap {\n    val buffer = planes[0].buffer\n    val bytes = ByteArray(buffer.remaining())\n    buffer.get(bytes)\n    return BitmapFactory.decodeByteArray(bytes, 0, bytes.size)\n}\n\n// 11. Camera Extensions\n// Check if extension available\nval extensionsManager = ExtensionsManager.getInstanceAsync(\n    this,\n    cameraProvider\n).await()\n\nif (extensionsManager.isExtensionAvailable(\n    cameraSelector,\n    ExtensionMode.BOKEH\n)) {\n    val cameraSelector = extensionsManager.getExtensionEnabledCameraSelector(\n        cameraSelector,\n        ExtensionMode.BOKEH\n    )\n    // Use this selector\n}\n\n// 12. Testing CameraX\n@RunWith(AndroidJUnit4::class)\nclass CameraTest {\n    \n    @get:Rule\n    val activityRule = ActivityScenarioRule(CameraActivity::class.java)\n    \n    @Test\n    fun testCameraPermission() {\n        val context = ApplicationProvider.getApplicationContext<Context>()\n        val hasPermission = ContextCompat.checkSelfPermission(\n            context,\n            Manifest.permission.CAMERA\n        ) == PackageManager.PERMISSION_GRANTED\n        \n        assertTrue(hasPermission)\n    }\n}"
    },
    {
      "id": 98,
      "question": "What is Android MediaPlayer and ExoPlayer?",
      "answer": "MediaPlayer and ExoPlayer provide audio and video playback capabilities with different features and complexity levels.\n\nMediaPlayer:\n• Simple API\n• Basic playback\n• Audio and video\n• State machine based\n• Limited formats\n• Synchronous operations\n\nExoPlayer:\n• Advanced features\n• Adaptive streaming\n• More formats\n• Customizable\n• Better performance\n• Production-ready\n\nMediaPlayer States:\n• Idle, Initialized\n• Prepared, Started\n• Paused, Stopped\n• PlaybackCompleted\n• Error, End\n\nExoPlayer Features:\n• DASH, HLS, SmoothStreaming\n• Custom renderers\n• Track selection\n• DRM support\n• Offline playback\n• Picture-in-Picture\n\nBest Practices:\n• Release resources\n• Handle lifecycle\n• Background playback\n• Error handling\n• Network conditions\n• Battery optimization",
      "explanation": "MediaPlayer provides basic audio/video playback with simple state-machine API, while ExoPlayer offers advanced features like adaptive streaming (DASH/HLS), DRM, custom renderers, and better format support for production apps.",
      "difficulty": "Medium",
      "code": "// 1. Basic MediaPlayer\nclass AudioPlayerActivity : AppCompatActivity() {\n    \n    private var mediaPlayer: MediaPlayer? = null\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        \n        // Initialize MediaPlayer\n        mediaPlayer = MediaPlayer().apply {\n            setDataSource(\"https://example.com/audio.mp3\")\n            prepareAsync()\n            \n            setOnPreparedListener {\n                // Ready to play\n                start()\n            }\n            \n            setOnCompletionListener {\n                // Playback completed\n            }\n            \n            setOnErrorListener { _, what, extra ->\n                Log.e(\"MediaPlayer\", \"Error: $what, $extra\")\n                true\n            }\n        }\n    }\n    \n    fun playPause() {\n        mediaPlayer?.let {\n            if (it.isPlaying) {\n                it.pause()\n            } else {\n                it.start()\n            }\n        }\n    }\n    \n    fun seekTo(position: Int) {\n        mediaPlayer?.seekTo(position)\n    }\n    \n    override fun onDestroy() {\n        super.onDestroy()\n        mediaPlayer?.release()\n        mediaPlayer = null\n    }\n}\n\n// 2. MediaPlayer from Resources\n// Play from raw resources\nmediaPlayer = MediaPlayer.create(this, R.raw.audio_file)\nmediaPlayer?.start()\n\n// Play from assets\nval afd = assets.openFd(\"audio.mp3\")\nmediaPlayer = MediaPlayer().apply {\n    setDataSource(afd.fileDescriptor, afd.startOffset, afd.length)\n    prepare()\n    start()\n}\nafd.close()\n\n// 3. MediaPlayer States\nfun demonstrateStates() {\n    val mediaPlayer = MediaPlayer()\n    \n    // Idle -> Initialized\n    mediaPlayer.setDataSource(\"url\")\n    \n    // Initialized -> Preparing\n    mediaPlayer.prepareAsync()\n    \n    // Preparing -> Prepared (in callback)\n    mediaPlayer.setOnPreparedListener {\n        // Prepared -> Started\n        mediaPlayer.start()\n        \n        // Started -> Paused\n        mediaPlayer.pause()\n        \n        // Paused -> Started\n        mediaPlayer.start()\n        \n        // Started -> Stopped\n        mediaPlayer.stop()\n        \n        // Stopped -> Prepared (must call prepare again)\n        mediaPlayer.prepare()\n    }\n}\n\n// 4. Background Audio Service\nclass AudioService : Service() {\n    \n    private var mediaPlayer: MediaPlayer? = null\n    private val binder = AudioBinder()\n    \n    inner class AudioBinder : Binder() {\n        fun getService(): AudioService = this@AudioService\n    }\n    \n    override fun onBind(intent: Intent?): IBinder = binder\n    \n    override fun onCreate() {\n        super.onCreate()\n        createMediaPlayer()\n    }\n    \n    private fun createMediaPlayer() {\n        mediaPlayer = MediaPlayer().apply {\n            setAudioAttributes(\n                AudioAttributes.Builder()\n                    .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)\n                    .setUsage(AudioAttributes.USAGE_MEDIA)\n                    .build()\n            )\n        }\n    }\n    \n    fun play(url: String) {\n        mediaPlayer?.apply {\n            reset()\n            setDataSource(url)\n            prepareAsync()\n            setOnPreparedListener { start() }\n        }\n    }\n    \n    fun pause() {\n        mediaPlayer?.pause()\n    }\n    \n    fun resume() {\n        mediaPlayer?.start()\n    }\n    \n    override fun onDestroy() {\n        super.onDestroy()\n        mediaPlayer?.release()\n        mediaPlayer = null\n    }\n}\n\n// 5. ExoPlayer Setup\nimplementation 'com.google.android.exoplayer:exoplayer:2.19.1'\n\nclass VideoPlayerActivity : AppCompatActivity() {\n    \n    private lateinit var player: ExoPlayer\n    private lateinit var binding: ActivityVideoPlayerBinding\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityVideoPlayerBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n        \n        initializePlayer()\n    }\n    \n    private fun initializePlayer() {\n        player = ExoPlayer.Builder(this)\n            .build()\n            .also { exoPlayer ->\n                binding.playerView.player = exoPlayer\n                \n                // Create media item\n                val mediaItem = MediaItem.fromUri(\"https://example.com/video.mp4\")\n                exoPlayer.setMediaItem(mediaItem)\n                \n                // Prepare and play\n                exoPlayer.prepare()\n                exoPlayer.playWhenReady = true\n            }\n    }\n    \n    override fun onStart() {\n        super.onStart()\n        if (Build.VERSION.SDK_INT > 23) {\n            initializePlayer()\n        }\n    }\n    \n    override fun onResume() {\n        super.onResume()\n        if (Build.VERSION.SDK_INT <= 23) {\n            initializePlayer()\n        }\n    }\n    \n    override fun onPause() {\n        super.onPause()\n        if (Build.VERSION.SDK_INT <= 23) {\n            releasePlayer()\n        }\n    }\n    \n    override fun onStop() {\n        super.onStop()\n        if (Build.VERSION.SDK_INT > 23) {\n            releasePlayer()\n        }\n    }\n    \n    private fun releasePlayer() {\n        player.release()\n    }\n}\n\n// Layout XML\n<com.google.android.exoplayer2.ui.StyledPlayerView\n    android:id=\"@+id/playerView\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\" />\n\n// 6. ExoPlayer with Playlist\nval mediaItems = listOf(\n    MediaItem.fromUri(\"https://example.com/video1.mp4\"),\n    MediaItem.fromUri(\"https://example.com/video2.mp4\"),\n    MediaItem.fromUri(\"https://example.com/video3.mp4\")\n)\n\nplayer.setMediaItems(mediaItems)\nplayer.prepare()\n\n// 7. ExoPlayer Listener\nplayer.addListener(object : Player.Listener {\n    override fun onPlaybackStateChanged(state: Int) {\n        when (state) {\n            Player.STATE_IDLE -> {\n                // Player idle\n            }\n            Player.STATE_BUFFERING -> {\n                // Buffering\n                showLoading()\n            }\n            Player.STATE_READY -> {\n                // Ready to play\n                hideLoading()\n            }\n            Player.STATE_ENDED -> {\n                // Playback ended\n            }\n        }\n    }\n    \n    override fun onPlayerError(error: PlaybackException) {\n        // Handle error\n        Log.e(\"ExoPlayer\", \"Error\", error)\n    }\n    \n    override fun onIsPlayingChanged(isPlaying: Boolean) {\n        // Playing state changed\n    }\n})\n\n// 8. Adaptive Streaming (DASH, HLS)\n// DASH\nval dashUri = \"https://example.com/video.mpd\"\nval dashMediaItem = MediaItem.Builder()\n    .setUri(dashUri)\n    .setMimeType(MimeTypes.APPLICATION_MPD)\n    .build()\n\n// HLS\nval hlsUri = \"https://example.com/video.m3u8\"\nval hlsMediaItem = MediaItem.Builder()\n    .setUri(hlsUri)\n    .setMimeType(MimeTypes.APPLICATION_M3U8)\n    .build()\n\nplayer.setMediaItem(dashMediaItem)\nplayer.prepare()\n\n// 9. Picture-in-Picture\nclass PipVideoActivity : AppCompatActivity() {\n    \n    override fun onUserLeaveHint() {\n        super.onUserLeaveHint()\n        enterPictureInPictureMode()\n    }\n    \n    private fun enterPictureInPictureMode() {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            val params = PictureInPictureParams.Builder()\n                .setAspectRatio(Rational(16, 9))\n                .build()\n            enterPictureInPictureMode(params)\n        }\n    }\n    \n    override fun onPictureInPictureModeChanged(\n        isInPictureInPictureMode: Boolean,\n        newConfig: Configuration\n    ) {\n        super.onPictureInPictureModeChanged(isInPictureInPictureMode, newConfig)\n        \n        if (isInPictureInPictureMode) {\n            // Hide controls\n            binding.playerView.hideController()\n        } else {\n            // Show controls\n            binding.playerView.showController()\n        }\n    }\n}\n\n// Manifest\n<activity\n    android:name=\".PipVideoActivity\"\n    android:supportsPictureInPicture=\"true\"\n    android:configChanges=\"screenSize|smallestScreenSize|screenLayout|orientation\" />\n\n// 10. Audio Focus\nclass AudioFocusHelper(context: Context) {\n    private val audioManager = context.getSystemService(Context.AUDIO_SERVICE) as AudioManager\n    \n    private val audioFocusRequest = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n        AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN)\n            .setOnAudioFocusChangeListener(audioFocusChangeListener)\n            .build()\n    } else {\n        null\n    }\n    \n    private val audioFocusChangeListener = AudioManager.OnAudioFocusChangeListener { focusChange ->\n        when (focusChange) {\n            AudioManager.AUDIOFOCUS_GAIN -> {\n                // Resume playback\n                mediaPlayer?.setVolume(1.0f, 1.0f)\n                mediaPlayer?.start()\n            }\n            AudioManager.AUDIOFOCUS_LOSS -> {\n                // Permanent loss - stop\n                mediaPlayer?.stop()\n            }\n            AudioManager.AUDIOFOCUS_LOSS_TRANSIENT -> {\n                // Temporary loss - pause\n                mediaPlayer?.pause()\n            }\n            AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK -> {\n                // Duck volume\n                mediaPlayer?.setVolume(0.2f, 0.2f)\n            }\n        }\n    }\n    \n    fun requestAudioFocus(): Boolean {\n        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            audioManager.requestAudioFocus(audioFocusRequest!!) == AudioManager.AUDIOFOCUS_REQUEST_GRANTED\n        } else {\n            @Suppress(\"DEPRECATION\")\n            audioManager.requestAudioFocus(\n                audioFocusChangeListener,\n                AudioManager.STREAM_MUSIC,\n                AudioManager.AUDIOFOCUS_GAIN\n            ) == AudioManager.AUDIOFOCUS_REQUEST_GRANTED\n        }\n    }\n    \n    fun abandonAudioFocus() {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            audioManager.abandonAudioFocusRequest(audioFocusRequest!!)\n        } else {\n            @Suppress(\"DEPRECATION\")\n            audioManager.abandonAudioFocus(audioFocusChangeListener)\n        }\n    }\n}"
    },
    {
      "id": 99,
      "question": "What is Android Firebase Integration?",
      "answer": "Firebase provides backend services for mobile apps including authentication, database, storage, messaging, and analytics.\n\nCore Services:\n• Firebase Authentication\n• Cloud Firestore\n• Realtime Database\n• Cloud Storage\n• Cloud Messaging (FCM)\n• Analytics\n• Crashlytics\n\nFirebase Auth:\n• Email/Password\n• Phone authentication\n• Social providers (Google, Facebook)\n• Anonymous auth\n• Custom auth\n\nCloud Firestore:\n• NoSQL database\n• Real-time sync\n• Offline support\n• Structured data\n• Powerful queries\n• Security rules\n\nCloud Messaging:\n• Push notifications\n• Topic messaging\n• Data messages\n• Background handling\n• High priority\n\nBest Practices:\n• Security rules\n• Data modeling\n• Batch operations\n• Index optimization\n• Error handling\n• Test mode",
      "explanation": "Firebase provides backend services including Authentication for user management, Cloud Firestore for real-time NoSQL database, Cloud Storage for files, FCM for push notifications, and Analytics for usage tracking.",
      "difficulty": "Medium",
      "code": "// 1. Firebase Setup (build.gradle)\nbuildscript {\n    dependencies {\n        classpath 'com.google.gms:google-services:4.3.15'\n    }\n}\n\n// App build.gradle\nplugins {\n    id 'com.google.gms.google-services'\n}\n\ndependencies {\n    // Firebase BOM\n    implementation platform('com.google.firebase:firebase-bom:32.2.0')\n    \n    // Firebase services\n    implementation 'com.google.firebase:firebase-auth-ktx'\n    implementation 'com.google.firebase:firebase-firestore-ktx'\n    implementation 'com.google.firebase:firebase-storage-ktx'\n    implementation 'com.google.firebase:firebase-messaging-ktx'\n    implementation 'com.google.firebase:firebase-analytics-ktx'\n    implementation 'com.google.firebase:firebase-crashlytics-ktx'\n}\n\n// Add google-services.json to app/\n\n// 2. Firebase Authentication\nclass AuthRepository {\n    private val auth = Firebase.auth\n    \n    // Sign up with email\n    suspend fun signUp(email: String, password: String): Result<FirebaseUser> {\n        return try {\n            val result = auth.createUserWithEmailAndPassword(email, password).await()\n            Result.success(result.user!!)\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n    \n    // Sign in with email\n    suspend fun signIn(email: String, password: String): Result<FirebaseUser> {\n        return try {\n            val result = auth.signInWithEmailAndPassword(email, password).await()\n            Result.success(result.user!!)\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n    \n    // Sign in with Google\n    suspend fun signInWithGoogle(idToken: String): Result<FirebaseUser> {\n        val credential = GoogleAuthProvider.getCredential(idToken, null)\n        return try {\n            val result = auth.signInWithCredential(credential).await()\n            Result.success(result.user!!)\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n    \n    // Sign out\n    fun signOut() {\n        auth.signOut()\n    }\n    \n    // Current user\n    fun getCurrentUser(): FirebaseUser? = auth.currentUser\n    \n    // Reset password\n    suspend fun resetPassword(email: String): Result<Unit> {\n        return try {\n            auth.sendPasswordResetEmail(email).await()\n            Result.success(Unit)\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n}\n\n// 3. Cloud Firestore\ndata class User(\n    val id: String = \"\",\n    val name: String = \"\",\n    val email: String = \"\",\n    val createdAt: Timestamp = Timestamp.now()\n)\n\nclass UserRepository {\n    private val firestore = Firebase.firestore\n    private val usersCollection = firestore.collection(\"users\")\n    \n    // Add user\n    suspend fun addUser(user: User): Result<String> {\n        return try {\n            val docRef = usersCollection.add(user).await()\n            Result.success(docRef.id)\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n    \n    // Get user\n    suspend fun getUser(userId: String): Result<User> {\n        return try {\n            val snapshot = usersCollection.document(userId).get().await()\n            val user = snapshot.toObject(User::class.java)!!\n            Result.success(user)\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n    \n    // Get all users\n    suspend fun getAllUsers(): Result<List<User>> {\n        return try {\n            val snapshot = usersCollection.get().await()\n            val users = snapshot.toObjects(User::class.java)\n            Result.success(users)\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n    \n    // Real-time updates\n    fun observeUsers(): Flow<List<User>> = callbackFlow {\n        val listener = usersCollection.addSnapshotListener { snapshot, error ->\n            if (error != null) {\n                close(error)\n                return@addSnapshotListener\n            }\n            \n            val users = snapshot?.toObjects(User::class.java) ?: emptyList()\n            trySend(users)\n        }\n        \n        awaitClose { listener.remove() }\n    }\n    \n    // Query users\n    suspend fun searchUsers(query: String): Result<List<User>> {\n        return try {\n            val snapshot = usersCollection\n                .whereGreaterThanOrEqualTo(\"name\", query)\n                .whereLessThan(\"name\", query + \"\\uf8ff\")\n                .get()\n                .await()\n            val users = snapshot.toObjects(User::class.java)\n            Result.success(users)\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n    \n    // Update user\n    suspend fun updateUser(userId: String, updates: Map<String, Any>): Result<Unit> {\n        return try {\n            usersCollection.document(userId).update(updates).await()\n            Result.success(Unit)\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n    \n    // Delete user\n    suspend fun deleteUser(userId: String): Result<Unit> {\n        return try {\n            usersCollection.document(userId).delete().await()\n            Result.success(Unit)\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n    \n    // Batch write\n    suspend fun batchAddUsers(users: List<User>): Result<Unit> {\n        return try {\n            val batch = firestore.batch()\n            users.forEach { user ->\n                val docRef = usersCollection.document()\n                batch.set(docRef, user)\n            }\n            batch.commit().await()\n            Result.success(Unit)\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n}\n\n// 4. Cloud Storage\nclass StorageRepository {\n    private val storage = Firebase.storage\n    private val storageRef = storage.reference\n    \n    // Upload file\n    suspend fun uploadImage(uri: Uri, path: String): Result<String> {\n        return try {\n            val imageRef = storageRef.child(path)\n            imageRef.putFile(uri).await()\n            val downloadUrl = imageRef.downloadUrl.await()\n            Result.success(downloadUrl.toString())\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n    \n    // Upload with progress\n    fun uploadWithProgress(uri: Uri, path: String): Flow<UploadState> = callbackFlow {\n        val imageRef = storageRef.child(path)\n        val uploadTask = imageRef.putFile(uri)\n        \n        uploadTask.addOnProgressListener { snapshot ->\n            val progress = (100.0 * snapshot.bytesTransferred / snapshot.totalByteCount).toInt()\n            trySend(UploadState.Progress(progress))\n        }.addOnSuccessListener {\n            trySend(UploadState.Success(it.metadata?.path ?: \"\"))\n            close()\n        }.addOnFailureListener { exception ->\n            trySend(UploadState.Error(exception))\n            close(exception)\n        }\n        \n        awaitClose()\n    }\n    \n    // Download file\n    suspend fun downloadImage(path: String): Result<ByteArray> {\n        return try {\n            val imageRef = storageRef.child(path)\n            val bytes = imageRef.getBytes(Long.MAX_VALUE).await()\n            Result.success(bytes)\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n    \n    // Delete file\n    suspend fun deleteImage(path: String): Result<Unit> {\n        return try {\n            storageRef.child(path).delete().await()\n            Result.success(Unit)\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n}\n\nsealed class UploadState {\n    data class Progress(val progress: Int) : UploadState()\n    data class Success(val path: String) : UploadState()\n    data class Error(val exception: Exception) : UploadState()\n}\n\n// 5. Firebase Cloud Messaging\nclass MyFirebaseMessagingService : FirebaseMessagingService() {\n    \n    override fun onMessageReceived(remoteMessage: RemoteMessage) {\n        // Handle data payload\n        remoteMessage.data.isNotEmpty().let {\n            handleDataMessage(remoteMessage.data)\n        }\n        \n        // Handle notification payload\n        remoteMessage.notification?.let {\n            showNotification(it.title, it.body)\n        }\n    }\n    \n    override fun onNewToken(token: String) {\n        // Send token to server\n        sendTokenToServer(token)\n    }\n    \n    private fun handleDataMessage(data: Map<String, String>) {\n        val message = data[\"message\"]\n        val type = data[\"type\"]\n        // Handle custom data\n    }\n    \n    private fun showNotification(title: String?, body: String?) {\n        val intent = Intent(this, MainActivity::class.java)\n        val pendingIntent = PendingIntent.getActivity(\n            this, 0, intent, PendingIntent.FLAG_IMMUTABLE\n        )\n        \n        val notification = NotificationCompat.Builder(this, CHANNEL_ID)\n            .setContentTitle(title)\n            .setContentText(body)\n            .setSmallIcon(R.drawable.notification_icon)\n            .setContentIntent(pendingIntent)\n            .setAutoCancel(true)\n            .build()\n        \n        val notificationManager = getSystemService(\n            Context.NOTIFICATION_SERVICE\n        ) as NotificationManager\n        notificationManager.notify(0, notification)\n    }\n    \n    private fun sendTokenToServer(token: String) {\n        // Send FCM token to your server\n    }\n}\n\n// Manifest\n<service\n    android:name=\".MyFirebaseMessagingService\"\n    android:exported=\"false\">\n    <intent-filter>\n        <action android:name=\"com.google.firebase.MESSAGING_EVENT\" />\n    </intent-filter>\n</service>\n\n// Get FCM token\nFirebaseMessaging.getInstance().token.addOnCompleteListener { task ->\n    if (task.isSuccessful) {\n        val token = task.result\n        Log.d(\"FCM\", \"Token: $token\")\n    }\n}"
    },
    {
      "id": 100,
      "question": "What are Latest Android Features and Modern Development Practices?",
      "answer": "Modern Android development embraces latest features, libraries, and best practices for efficient, maintainable apps.\n\nModern Stack:\n• Kotlin coroutines and Flow\n• Jetpack Compose UI\n• Material Design 3\n• Architecture Components\n• Hilt dependency injection\n• Room database\n\nAndroid 13+ Features:\n• Themed app icons\n• Per-app language\n• Notification permissions\n• Photo picker\n• Predictive back gesture\n• Spatial audio\n\nJetpack Libraries:\n• Navigation Component\n• Paging 3\n• WorkManager\n• CameraX\n• DataStore\n• Startup\n\nDevelopment Tools:\n• Android Studio\n• Gradle Version Catalogs\n• Kotlin DSL\n• Build Analyzer\n• Layout Inspector\n• Profiler\n\nBest Practices:\n• Single Activity architecture\n• Unidirectional data flow\n• Repository pattern\n• Dependency injection\n• Comprehensive testing\n• CI/CD pipeline\n\nPerformance:\n• Baseline Profiles\n• App Startup optimization\n• R8 optimization\n• Lazy loading\n• Efficient layouts\n• Background work",
      "explanation": "Modern Android development uses Kotlin with Coroutines/Flow, Jetpack Compose for UI, Material Design 3, Architecture Components (ViewModel/LiveData), Hilt DI, Room database, and follows Single Activity architecture with comprehensive testing.",
      "difficulty": "Hard",
      "code": "// 1. Modern Project Setup (build.gradle.kts)\nplugins {\n    id(\"com.android.application\")\n    id(\"org.jetbrains.kotlin.android\")\n    id(\"com.google.devtools.ksp\") version \"1.8.20-1.0.11\"\n    id(\"dagger.hilt.android.plugin\")\n}\n\nandroid {\n    namespace = \"com.example.modernapp\"\n    compileSdk = 34\n    \n    defaultConfig {\n        applicationId = \"com.example.modernapp\"\n        minSdk = 24\n        targetSdk = 34\n        versionCode = 1\n        versionName = \"1.0\"\n    }\n    \n    buildFeatures {\n        compose = true\n        buildConfig = true\n    }\n    \n    composeOptions {\n        kotlinCompilerExtensionVersion = \"1.4.6\"\n    }\n    \n    kotlinOptions {\n        jvmTarget = \"17\"\n        freeCompilerArgs += listOf(\n            \"-opt-in=androidx.compose.material3.ExperimentalMaterial3Api\",\n            \"-opt-in=kotlinx.coroutines.ExperimentalCoroutinesApi\"\n        )\n    }\n}\n\ndependencies {\n    // Jetpack Compose\n    implementation(platform(\"androidx.compose:compose-bom:2023.06.01\"))\n    implementation(\"androidx.compose.ui:ui\")\n    implementation(\"androidx.compose.material3:material3\")\n    implementation(\"androidx.compose.ui:ui-tooling-preview\")\n    debugImplementation(\"androidx.compose.ui:ui-tooling\")\n    \n    // Architecture Components\n    implementation(\"androidx.lifecycle:lifecycle-viewmodel-compose:2.6.1\")\n    implementation(\"androidx.lifecycle:lifecycle-runtime-compose:2.6.1\")\n    \n    // Navigation\n    implementation(\"androidx.navigation:navigation-compose:2.6.0\")\n    \n    // Hilt\n    implementation(\"com.google.dagger:hilt-android:2.46\")\n    ksp(\"com.google.dagger:hilt-compiler:2.46\")\n    implementation(\"androidx.hilt:hilt-navigation-compose:1.0.0\")\n    \n    // Coroutines\n    implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.1\")\n    \n    // Room\n    implementation(\"androidx.room:room-runtime:2.5.2\")\n    implementation(\"androidx.room:room-ktx:2.5.2\")\n    ksp(\"androidx.room:room-compiler:2.5.2\")\n    \n    // DataStore\n    implementation(\"androidx.datastore:datastore-preferences:1.0.0\")\n    \n    // Retrofit\n    implementation(\"com.squareup.retrofit2:retrofit:2.9.0\")\n    implementation(\"com.squareup.retrofit2:converter-gson:2.9.0\")\n}\n\n// 2. Modern App Architecture\n@HiltAndroidApp\nclass ModernApp : Application()\n\n// Domain Layer\ndata class User(\n    val id: String,\n    val name: String,\n    val email: String\n)\n\ninterface UserRepository {\n    suspend fun getUsers(): Result<List<User>>\n    fun observeUsers(): Flow<List<User>>\n}\n\nclass GetUsersUseCase @Inject constructor(\n    private val repository: UserRepository\n) {\n    suspend operator fun invoke(): Result<List<User>> = repository.getUsers()\n}\n\n// Data Layer\n@Entity(tableName = \"users\")\ndata class UserEntity(\n    @PrimaryKey val id: String,\n    val name: String,\n    val email: String\n)\n\n@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM users\")\n    fun observeAll(): Flow<List<UserEntity>>\n    \n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertAll(users: List<UserEntity>)\n}\n\nclass UserRepositoryImpl @Inject constructor(\n    private val api: UserApi,\n    private val dao: UserDao\n) : UserRepository {\n    override suspend fun getUsers(): Result<List<User>> = withContext(Dispatchers.IO) {\n        try {\n            val users = api.getUsers()\n            dao.insertAll(users.map { it.toEntity() })\n            Result.success(users.map { it.toDomain() })\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n    \n    override fun observeUsers(): Flow<List<User>> {\n        return dao.observeAll().map { entities ->\n            entities.map { it.toDomain() }\n        }\n    }\n}\n\n// Presentation Layer with Compose\n@HiltViewModel\nclass UserViewModel @Inject constructor(\n    private val getUsersUseCase: GetUsersUseCase,\n    private val repository: UserRepository\n) : ViewModel() {\n    \n    private val _uiState = MutableStateFlow<UiState>(UiState.Loading)\n    val uiState: StateFlow<UiState> = _uiState.asStateFlow()\n    \n    init {\n        loadUsers()\n    }\n    \n    fun loadUsers() {\n        viewModelScope.launch {\n            _uiState.value = UiState.Loading\n            getUsersUseCase().fold(\n                onSuccess = { users ->\n                    _uiState.value = UiState.Success(users)\n                },\n                onFailure = { exception ->\n                    _uiState.value = UiState.Error(exception.message ?: \"Unknown error\")\n                }\n            )\n        }\n    }\n    \n    sealed interface UiState {\n        object Loading : UiState\n        data class Success(val users: List<User>) : UiState\n        data class Error(val message: String) : UiState\n    }\n}\n\n// Compose UI\n@Composable\nfun UserScreen(\n    viewModel: UserViewModel = hiltViewModel()\n) {\n    val uiState by viewModel.uiState.collectAsStateWithLifecycle()\n    \n    when (val state = uiState) {\n        is UserViewModel.UiState.Loading -> {\n            LoadingScreen()\n        }\n        is UserViewModel.UiState.Success -> {\n            UserList(users = state.users)\n        }\n        is UserViewModel.UiState.Error -> {\n            ErrorScreen(message = state.message)\n        }\n    }\n}\n\n@Composable\nfun UserList(users: List<User>) {\n    LazyColumn {\n        items(users) { user ->\n            UserItem(user = user)\n        }\n    }\n}\n\n@Composable\nfun UserItem(user: User) {\n    Card(\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(8.dp)\n    ) {\n        Column(\n            modifier = Modifier.padding(16.dp)\n        ) {\n            Text(\n                text = user.name,\n                style = MaterialTheme.typography.titleMedium\n            )\n            Text(\n                text = user.email,\n                style = MaterialTheme.typography.bodyMedium\n            )\n        }\n    }\n}\n\n// 3. Material Design 3 Theme\n@Composable\nfun ModernAppTheme(\n    darkTheme: Boolean = isSystemInDarkTheme(),\n    dynamicColor: Boolean = true,\n    content: @Composable () -> Unit\n) {\n    val colorScheme = when {\n        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {\n            val context = LocalContext.current\n            if (darkTheme) dynamicDarkColorScheme(context)\n            else dynamicLightColorScheme(context)\n        }\n        darkTheme -> darkColorScheme()\n        else -> lightColorScheme()\n    }\n    \n    MaterialTheme(\n        colorScheme = colorScheme,\n        typography = Typography,\n        content = content\n    )\n}\n\n// 4. Navigation with Compose\n@Composable\nfun AppNavigation() {\n    val navController = rememberNavController()\n    \n    NavHost(navController = navController, startDestination = \"home\") {\n        composable(\"home\") {\n            HomeScreen(\n                onNavigateToUsers = {\n                    navController.navigate(\"users\")\n                }\n            )\n        }\n        composable(\"users\") {\n            UserScreen()\n        }\n    }\n}\n\n// 5. Modern Testing\n@RunWith(AndroidJUnit4::class)\nclass UserViewModelTest {\n    \n    @get:Rule\n    val mainDispatcherRule = MainDispatcherRule()\n    \n    private lateinit var viewModel: UserViewModel\n    private lateinit var getUsersUseCase: GetUsersUseCase\n    private lateinit var repository: UserRepository\n    \n    @Before\n    fun setup() {\n        repository = mockk()\n        getUsersUseCase = GetUsersUseCase(repository)\n        viewModel = UserViewModel(getUsersUseCase, repository)\n    }\n    \n    @Test\n    fun `loadUsers emits success state when repository returns data`() = runTest {\n        val users = listOf(User(\"1\", \"John\", \"john@example.com\"))\n        coEvery { repository.getUsers() } returns Result.success(users)\n        \n        viewModel.loadUsers()\n        advanceUntilIdle()\n        \n        val state = viewModel.uiState.value\n        assertTrue(state is UserViewModel.UiState.Success)\n        assertEquals(users, (state as UserViewModel.UiState.Success).users)\n    }\n}\n\n// This completes all 100 Native Android interview questions!"
    }
  ]
}
