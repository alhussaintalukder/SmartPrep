{
  "topic": "React Native",
  "questions": [
    {
      "id": 1,
      "question": "What is React Native and how does it differ from React?",
      "answer": "React Native is a mobile application development framework that allows developers to build native mobile apps using JavaScript and React.\n\nKey Differences:\n• React is for web applications, React Native is for mobile applications\n• React uses HTML elements (div, span), React Native uses native components (View, Text)\n• React Native compiles to native code for iOS and Android\n• React Native has access to native device features\n• Styling is done using StyleSheet API instead of CSS\n• React Native uses Bridge to communicate with native modules",
      "explanation": "React Native is a framework for building mobile apps using React, differing from web React by using native components instead of HTML and compiling to native code for mobile platforms.",
      "difficulty": "Easy",
      "code": "// React (Web)\nimport React from 'react';\n\nfunction App() {\n  return <div><h1>Hello Web</h1></div>;\n}\n\n// React Native (Mobile)\nimport React from 'react';\nimport { View, Text } from 'react-native';\n\nfunction App() {\n  return (\n    <View>\n      <Text>Hello Mobile</Text>\n    </View>\n  );\n}"
    },
    {
      "id": 2,
      "question": "What are the core components in React Native?",
      "answer": "React Native provides essential built-in components that map to native platform components.\n\nCore Components:\n• View - Container component similar to div, used for layout\n• Text - Display text content, only component that can contain text\n• Image - Display images from various sources\n• ScrollView - Scrollable container for content\n• TextInput - Input field for user text entry\n• StyleSheet - API for creating styles\n• Button - Basic button component\n• FlatList - Efficient list for rendering large datasets\n• TouchableOpacity - Wrapper for making views respond to touches\n• SafeAreaView - Renders content within safe area boundaries",
      "explanation": "Core components like View, Text, Image, and TextInput are React Native's fundamental building blocks that map to native UI elements on iOS and Android.",
      "difficulty": "Easy",
      "code": "import React from 'react';\nimport {\n  View,\n  Text,\n  Image,\n  TextInput,\n  ScrollView,\n  Button\n} from 'react-native';\n\nfunction MyComponent() {\n  return (\n    <ScrollView>\n      <View>\n        <Text>Hello React Native</Text>\n        <Image source={{ uri: 'https://example.com/image.png' }} />\n        <TextInput placeholder=\"Enter text\" />\n        <Button title=\"Click Me\" onPress={() => {}} />\n      </View>\n    </ScrollView>\n  );\n}"
    },
    {
      "id": 3,
      "question": "How does styling work in React Native?",
      "answer": "React Native uses JavaScript objects for styling instead of CSS, with a subset of CSS properties written in camelCase.\n\nStyling Approach:\n• Uses StyleSheet API to create style objects\n• Properties are camelCase (backgroundColor not background-color)\n• No units - numbers are density-independent pixels\n• Flexbox is the default layout system\n• No CSS cascading or inheritance (except Text)\n• Inline styles or StyleSheet.create() for optimization\n• Platform-specific styles using Platform API\n• No classes or IDs, styles applied directly to components",
      "explanation": "React Native styling uses JavaScript objects with camelCase properties and the StyleSheet API instead of CSS, with Flexbox as the default layout system.",
      "difficulty": "Easy",
      "code": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\n\nfunction StyledComponent() {\n  return (\n    <View style={styles.container}>\n      <Text style={styles.title}>Styled Text</Text>\n      <View style={[styles.box, styles.blueBox]} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    padding: 20,\n    backgroundColor: '#f5f5f5'\n  },\n  title: {\n    fontSize: 24,\n    fontWeight: 'bold',\n    color: '#333'\n  },\n  box: {\n    width: 100,\n    height: 100,\n    marginTop: 10\n  },\n  blueBox: {\n    backgroundColor: 'blue'\n  }\n});"
    },
    {
      "id": 4,
      "question": "What is the React Native Bridge and how does it work?",
      "answer": "The React Native Bridge is the communication layer between JavaScript code and native platform code.\n\nHow It Works:\n• JavaScript runs in JavaScriptCore engine (or Hermes)\n• Native code runs in native threads (iOS/Android)\n• Bridge serializes data and passes messages asynchronously\n• JSON is used for data exchange between layers\n• Communication is batched for performance\n• Native modules expose APIs to JavaScript\n• Bridge handles method calls, callbacks, and events\n• Introduced performance overhead due to serialization",
      "explanation": "The React Native Bridge is an asynchronous communication layer that enables JavaScript code to interact with native platform APIs by serializing and passing messages between the two environments.",
      "difficulty": "Medium",
      "code": "// Native Module (iOS - Objective-C)\n// CalendarManager.m\n#import \"CalendarManager.h\"\n\n@implementation CalendarManager\nRCT_EXPORT_MODULE();\n\nRCT_EXPORT_METHOD(addEvent:(NSString *)name location:(NSString *)location)\n{\n  // Native iOS code\n  NSLog(@\"Adding event %@ at %@\", name, location);\n}\n@end\n\n// JavaScript usage\nimport { NativeModules } from 'react-native';\nconst { CalendarManager } = NativeModules;\n\n// Call native method through bridge\nCalendarManager.addEvent('Party', 'My House');"
    },
    {
      "id": 5,
      "question": "What is JSX in React Native?",
      "answer": "JSX (JavaScript XML) is a syntax extension that allows writing component markup inside JavaScript code.\n\nKey Features:\n• Combines JavaScript and XML-like syntax\n• Compiles to React.createElement() calls\n• Makes component structure more readable\n• Supports JavaScript expressions inside curly braces\n• Requires components to be capitalized\n• Can embed expressions, functions, and conditional rendering\n• Must return single root element\n• More type-safe than template strings",
      "explanation": "JSX is a syntax extension that combines JavaScript with XML-like markup, making React Native component code more readable and maintainable by allowing declarative UI definitions.",
      "difficulty": "Easy",
      "code": "import React from 'react';\nimport { View, Text } from 'react-native';\n\n// JSX syntax\nfunction Greeting({ name, age }) {\n  const isAdult = age >= 18;\n  \n  return (\n    <View>\n      <Text>Hello, {name}!</Text>\n      <Text>Age: {age}</Text>\n      {isAdult && <Text>You are an adult</Text>}\n    </View>\n  );\n}\n\n// Compiles to:\nfunction Greeting({ name, age }) {\n  const isAdult = age >= 18;\n  \n  return React.createElement(\n    View,\n    null,\n    React.createElement(Text, null, 'Hello, ', name, '!'),\n    React.createElement(Text, null, 'Age: ', age),\n    isAdult && React.createElement(Text, null, 'You are an adult')\n  );\n}"
    },
    {
      "id": 6,
      "question": "What are Props in React Native?",
      "answer": "Props (properties) are arguments passed to React Native components, similar to function parameters.\n\nCharacteristics:\n• Read-only and immutable\n• Passed from parent to child components\n• Used to customize component behavior\n• Can be any JavaScript type (string, number, object, function)\n• Accessed via props object or destructuring\n• Enable component reusability\n• Support default values using defaultProps\n• Can pass callback functions for child-to-parent communication",
      "explanation": "Props are immutable data passed from parent to child components to customize behavior and enable reusability, acting as the component's configuration.",
      "difficulty": "Easy",
      "code": "import React from 'react';\nimport { View, Text, Button } from 'react-native';\n\n// Child component receiving props\nfunction UserCard({ name, age, onPress }) {\n  return (\n    <View>\n      <Text>Name: {name}</Text>\n      <Text>Age: {age}</Text>\n      <Button title=\"View Profile\" onPress={onPress} />\n    </View>\n  );\n}\n\n// Default props\nUserCard.defaultProps = {\n  age: 18\n};\n\n// Parent component passing props\nfunction App() {\n  const handlePress = () => console.log('Pressed');\n  \n  return (\n    <UserCard \n      name=\"John Doe\" \n      age={25} \n      onPress={handlePress}\n    />\n  );\n}"
    },
    {
      "id": 7,
      "question": "What is State in React Native and how does it differ from Props?",
      "answer": "State is mutable data managed within a component that can change over time and trigger re-renders.\n\nState vs Props:\n• State is mutable, Props are immutable\n• State is managed internally, Props are passed from parent\n• State changes trigger re-renders, Props updates come from parent\n• State uses useState or this.setState, Props are read-only\n• State is private to component, Props are public interface\n• State represents dynamic data, Props are configuration\n• State can be updated asynchronously\n• Changing state re-renders component and children",
      "explanation": "State is mutable internal data that components manage themselves and can update to trigger re-renders, while Props are immutable data passed from parent components.",
      "difficulty": "Easy",
      "code": "import React, { useState } from 'react';\nimport { View, Text, Button } from 'react-native';\n\n// Using state\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const [name, setName] = useState('Counter');\n  \n  return (\n    <View>\n      <Text>{name}: {count}</Text>\n      <Button \n        title=\"Increment\" \n        onPress={() => setCount(count + 1)} \n      />\n    </View>\n  );\n}\n\n// Using props\nfunction Display({ count, name }) {\n  return (\n    <View>\n      <Text>{name}: {count}</Text>\n    </View>\n  );\n}\n\nfunction App() {\n  return <Display count={5} name=\"Display\" />;\n}"
    },
    {
      "id": 8,
      "question": "What are the different types of components in React Native?",
      "answer": "React Native supports two main types of components: Functional and Class components.\n\nFunctional Components:\n• Simple JavaScript functions that return JSX\n• Use Hooks for state and lifecycle (useState, useEffect)\n• More concise and easier to read\n• Better performance in modern React\n• Recommended approach for new code\n• No this binding issues\n\nClass Components:\n• ES6 classes extending React.Component\n• Use this.state and this.setState for state\n• Lifecycle methods (componentDidMount, etc.)\n• Legacy approach, still supported\n• Required before Hooks were introduced",
      "explanation": "React Native has functional components using Hooks (modern, recommended) and class components using lifecycle methods (legacy), both capable of rendering UI and managing state.",
      "difficulty": "Easy",
      "code": "import React, { useState, useEffect, Component } from 'react';\nimport { View, Text } from 'react-native';\n\n// Functional Component with Hooks\nfunction FunctionalComponent({ name }) {\n  const [count, setCount] = useState(0);\n  \n  useEffect(() => {\n    console.log('Component mounted');\n    return () => console.log('Component unmounted');\n  }, []);\n  \n  return <Text>{name}: {count}</Text>;\n}\n\n// Class Component\nclass ClassComponent extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n  \n  componentDidMount() {\n    console.log('Component mounted');\n  }\n  \n  componentWillUnmount() {\n    console.log('Component unmounted');\n  }\n  \n  render() {\n    return <Text>{this.props.name}: {this.state.count}</Text>;\n  }\n}"
    },
    {
      "id": 9,
      "question": "What is useState Hook and how is it used?",
      "answer": "useState is a React Hook that adds state management to functional components.\n\nKey Features:\n• Returns array with current state and setter function\n• Initial state passed as argument\n• Setter function replaces entire state value\n• Can have multiple useState calls in one component\n• State updates are asynchronous\n• Triggers component re-render when state changes\n• Can use functional updates for state based on previous value\n• Initial state can be a function for lazy initialization",
      "explanation": "useState is a Hook that enables functional components to manage local state by returning the current state value and a function to update it.",
      "difficulty": "Easy",
      "code": "import React, { useState } from 'react';\nimport { View, Text, Button, TextInput } from 'react-native';\n\nfunction FormExample() {\n  // Simple state\n  const [count, setCount] = useState(0);\n  \n  // Object state\n  const [user, setUser] = useState({ name: '', age: 0 });\n  \n  // Array state\n  const [items, setItems] = useState([]);\n  \n  // Functional update\n  const increment = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n  \n  // Update object state\n  const updateName = (newName) => {\n    setUser(prevUser => ({ ...prevUser, name: newName }));\n  };\n  \n  // Add to array\n  const addItem = (item) => {\n    setItems(prevItems => [...prevItems, item]);\n  };\n  \n  return (\n    <View>\n      <Text>Count: {count}</Text>\n      <Button title=\"Increment\" onPress={increment} />\n    </View>\n  );\n}"
    },
    {
      "id": 10,
      "question": "What is useEffect Hook and when should it be used?",
      "answer": "useEffect is a Hook for performing side effects in functional components, replacing lifecycle methods.\n\nCommon Use Cases:\n• Fetching data from APIs\n• Setting up subscriptions or event listeners\n• Manually changing the DOM\n• Setting up timers or intervals\n• Logging or analytics\n• Cleanup operations on unmount\n\nHow It Works:\n• Runs after every render by default\n• Second argument (dependency array) controls when it runs\n• Empty array means run once on mount\n• Return function for cleanup\n• Multiple useEffect calls for separation of concerns",
      "explanation": "useEffect is a Hook that handles side effects in functional components, running after renders and supporting cleanup, with control over when it executes via dependency arrays.",
      "difficulty": "Medium",
      "code": "import React, { useState, useEffect } from 'react';\nimport { View, Text } from 'react-native';\n\nfunction DataFetcher({ userId }) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  \n  // Run on mount and when userId changes\n  useEffect(() => {\n    setLoading(true);\n    \n    fetch(`https://api.example.com/users/${userId}`)\n      .then(response => response.json())\n      .then(data => {\n        setData(data);\n        setLoading(false);\n      });\n    \n    // Cleanup function\n    return () => {\n      console.log('Cleanup');\n    };\n  }, [userId]); // Dependency array\n  \n  // Run once on mount\n  useEffect(() => {\n    const timer = setInterval(() => {\n      console.log('Tick');\n    }, 1000);\n    \n    return () => clearInterval(timer);\n  }, []);\n  \n  return loading ? <Text>Loading...</Text> : <Text>{data?.name}</Text>;\n}"
    },
    {
      "id": 11,
      "question": "What is Flexbox and how is it used in React Native?",
      "answer": "Flexbox is the default layout system in React Native, used to create responsive layouts.\n\nKey Properties:\n• flexDirection - row or column layout (default: column)\n• justifyContent - main axis alignment (flex-start, center, flex-end, space-between)\n• alignItems - cross axis alignment (flex-start, center, flex-end, stretch)\n• flex - proportional sizing of components\n• flexWrap - wrap items to new lines\n• alignSelf - override alignItems for single item\n• flexGrow, flexShrink, flexBasis - fine control\n\nDefaults Differ from Web:\n• flexDirection defaults to column (not row)\n• alignItems defaults to stretch\n• flex number behavior differs from web",
      "explanation": "Flexbox is React Native's default layout system for creating responsive UIs, with properties like flexDirection and justifyContent controlling component positioning and sizing.",
      "difficulty": "Easy",
      "code": "import React from 'react';\nimport { View, StyleSheet } from 'react-native';\n\nfunction FlexboxExample() {\n  return (\n    <View style={styles.container}>\n      <View style={styles.box1} />\n      <View style={styles.box2} />\n      <View style={styles.box3} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    flexDirection: 'row', // horizontal layout\n    justifyContent: 'space-around', // distribute space\n    alignItems: 'center', // vertical center\n    padding: 20\n  },\n  box1: {\n    width: 50,\n    height: 50,\n    backgroundColor: 'red'\n  },\n  box2: {\n    flex: 1, // takes remaining space\n    height: 50,\n    backgroundColor: 'blue',\n    marginHorizontal: 10\n  },\n  box3: {\n    width: 50,\n    height: 50,\n    backgroundColor: 'green'\n  }\n});"
    },
    {
      "id": 12,
      "question": "What is FlatList and how does it differ from ScrollView?",
      "answer": "FlatList is an optimized component for rendering large lists with better performance than ScrollView.\n\nFlatList Advantages:\n• Lazy rendering - only visible items are rendered\n• Item recycling for memory efficiency\n• Built-in pull-to-refresh support\n• Header and footer components\n• Separator components\n• Horizontal scrolling support\n• Efficient updates with keyExtractor\n• Handles large datasets efficiently\n\nScrollView vs FlatList:\n• ScrollView renders all children immediately\n• FlatList renders items on demand\n• ScrollView better for small, static content\n• FlatList better for dynamic, large lists",
      "explanation": "FlatList is a high-performance list component that renders items lazily and recycles views, making it ideal for large datasets unlike ScrollView which renders everything upfront.",
      "difficulty": "Medium",
      "code": "import React, { useState } from 'react';\nimport { FlatList, Text, View, StyleSheet } from 'react-native';\n\nfunction ListExample() {\n  const [data] = useState([\n    { id: '1', name: 'Item 1' },\n    { id: '2', name: 'Item 2' },\n    { id: '3', name: 'Item 3' }\n  ]);\n  \n  const renderItem = ({ item, index }) => (\n    <View style={styles.item}>\n      <Text>{item.name}</Text>\n    </View>\n  );\n  \n  return (\n    <FlatList\n      data={data}\n      renderItem={renderItem}\n      keyExtractor={item => item.id}\n      ItemSeparatorComponent={() => <View style={styles.separator} />}\n      ListHeaderComponent={() => <Text>Header</Text>}\n      ListFooterComponent={() => <Text>Footer</Text>}\n      ListEmptyComponent={() => <Text>No items</Text>}\n      refreshing={false}\n      onRefresh={() => console.log('Refresh')}\n      onEndReached={() => console.log('Load more')}\n      onEndReachedThreshold={0.5}\n    />\n  );\n}\n\nconst styles = StyleSheet.create({\n  item: { padding: 20 },\n  separator: { height: 1, backgroundColor: '#ccc' }\n});"
    },
    {
      "id": 13,
      "question": "What is the Virtual List pattern and why is it important?",
      "answer": "Virtual List (or windowing) is a technique that renders only visible items in a scrollable list to improve performance.\n\nHow It Works:\n• Only renders items in viewport plus buffer\n• Recycles DOM nodes as user scrolls\n• Calculates visible range based on scroll position\n• Maintains fixed heights for efficient calculation\n• Dramatically reduces memory usage\n• Improves initial render time\n• Enables smooth scrolling with thousands of items\n\nImplementation in React Native:\n• FlatList implements virtual list by default\n• SectionList also uses virtualization\n• Can optimize with getItemLayout for fixed heights\n• windowSize prop controls number of rendered items",
      "explanation": "Virtual List is a performance optimization technique that renders only visible list items plus a buffer, used by FlatList to efficiently handle large datasets with minimal memory usage.",
      "difficulty": "Medium",
      "code": "import React from 'react';\nimport { FlatList, Text, View, StyleSheet } from 'react-native';\n\nfunction VirtualListExample() {\n  const data = Array.from({ length: 10000 }, (_, i) => ({\n    id: String(i),\n    title: `Item ${i}`\n  }));\n  \n  // Optimize with fixed item height\n  const ITEM_HEIGHT = 50;\n  const getItemLayout = (data, index) => ({\n    length: ITEM_HEIGHT,\n    offset: ITEM_HEIGHT * index,\n    index\n  });\n  \n  const renderItem = ({ item }) => (\n    <View style={styles.item}>\n      <Text>{item.title}</Text>\n    </View>\n  );\n  \n  return (\n    <FlatList\n      data={data}\n      renderItem={renderItem}\n      keyExtractor={item => item.id}\n      getItemLayout={getItemLayout} // Performance boost\n      initialNumToRender={10} // Initial items to render\n      maxToRenderPerBatch={10} // Batch size\n      windowSize={5} // Number of screens to render\n      removeClippedSubviews={true} // Unmount off-screen views\n    />\n  );\n}\n\nconst styles = StyleSheet.create({\n  item: { height: 50, justifyContent: 'center', padding: 15 }\n});"
    },
    {
      "id": 14,
      "question": "What are Touchable components and when to use each type?",
      "answer": "Touchable components make views respond to touch interactions with visual feedback.\n\nTypes:\n• TouchableOpacity - Reduces opacity when pressed (most common)\n• TouchableHighlight - Darkens background when pressed\n• TouchableWithoutFeedback - No visual feedback\n• TouchableNativeFeedback - Android ripple effect (Android only)\n• Pressable - Modern replacement with more features\n\nWhen to Use:\n• TouchableOpacity - General buttons and interactive elements\n• TouchableHighlight - Single color backgrounds\n• TouchableWithoutFeedback - Custom feedback or no feedback needed\n• TouchableNativeFeedback - Android material design\n• Pressable - New projects, need advanced press states",
      "explanation": "Touchable components add touch interaction and visual feedback to views, with different types providing opacity changes, highlights, ripples, or custom feedback for user interactions.",
      "difficulty": "Easy",
      "code": "import React from 'react';\nimport {\n  View,\n  Text,\n  TouchableOpacity,\n  TouchableHighlight,\n  Pressable,\n  StyleSheet\n} from 'react-native';\n\nfunction TouchableExample() {\n  return (\n    <View style={styles.container}>\n      {/* Opacity feedback */}\n      <TouchableOpacity \n        onPress={() => console.log('Pressed')}\n        activeOpacity={0.7}\n      >\n        <Text style={styles.button}>TouchableOpacity</Text>\n      </TouchableOpacity>\n      \n      {/* Highlight feedback */}\n      <TouchableHighlight\n        onPress={() => console.log('Pressed')}\n        underlayColor=\"#DDDDDD\"\n      >\n        <Text style={styles.button}>TouchableHighlight</Text>\n      </TouchableHighlight>\n      \n      {/* Modern Pressable */}\n      <Pressable\n        onPress={() => console.log('Pressed')}\n        style={({ pressed }) => [\n          styles.button,\n          pressed && styles.pressed\n        ]}\n      >\n        {({ pressed }) => (\n          <Text>{pressed ? 'Pressed' : 'Pressable'}</Text>\n        )}\n      </Pressable>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { padding: 20 },\n  button: { padding: 15, backgroundColor: '#2196F3', margin: 5 },\n  pressed: { opacity: 0.7 }\n});"
    },
    {
      "id": 15,
      "question": "What is TextInput and how do you handle text input in React Native?",
      "answer": "TextInput is the component for entering text through the keyboard.\n\nKey Features:\n• Controlled or uncontrolled input\n• Various keyboard types (numeric, email, phone)\n• Auto-correction and auto-capitalization\n• Secure text entry for passwords\n• Multiline support for text areas\n• Selection control and cursor position\n• Input validation and formatting\n• Platform-specific customization\n\nCommon Props:\n• value and onChangeText for controlled input\n• placeholder for hint text\n• keyboardType for keyboard layout\n• secureTextEntry for passwords\n• autoFocus, autoCapitalize, autoCorrect\n• onFocus, onBlur for focus events",
      "explanation": "TextInput is React Native's text input component with support for controlled input, various keyboard types, validation, and platform-specific features for capturing user text.",
      "difficulty": "Easy",
      "code": "import React, { useState } from 'react';\nimport { View, TextInput, Text, StyleSheet } from 'react-native';\n\nfunction FormExample() {\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n  const [description, setDescription] = useState('');\n  \n  return (\n    <View style={styles.container}>\n      {/* Email input */}\n      <TextInput\n        style={styles.input}\n        placeholder=\"Enter email\"\n        value={email}\n        onChangeText={setEmail}\n        keyboardType=\"email-address\"\n        autoCapitalize=\"none\"\n        autoCorrect={false}\n      />\n      \n      {/* Password input */}\n      <TextInput\n        style={styles.input}\n        placeholder=\"Enter password\"\n        value={password}\n        onChangeText={setPassword}\n        secureTextEntry={true}\n      />\n      \n      {/* Multiline input */}\n      <TextInput\n        style={[styles.input, styles.textArea]}\n        placeholder=\"Description\"\n        value={description}\n        onChangeText={setDescription}\n        multiline={true}\n        numberOfLines={4}\n      />\n      \n      <Text>Email: {email}</Text>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { padding: 20 },\n  input: {\n    borderWidth: 1,\n    borderColor: '#ddd',\n    padding: 10,\n    marginBottom: 10,\n    borderRadius: 5\n  },\n  textArea: { height: 100, textAlignVertical: 'top' }\n});"
    },
    {
      "id": 16,
      "question": "How does navigation work in React Native?",
      "answer": "Navigation in React Native is typically handled by React Navigation library, which provides routing and navigation capabilities.\n\nCore Concepts:\n• Stack Navigator - push/pop screen navigation\n• Tab Navigator - bottom or top tab navigation\n• Drawer Navigator - side menu navigation\n• Navigation prop - passed to screen components\n• Route params - pass data between screens\n• Navigation lifecycle - focus and blur events\n• Deep linking - open app to specific screen\n• Authentication flow - conditional navigation\n\nNavigation Actions:\n• navigate() - go to screen\n• push() - add screen to stack\n• goBack() - return to previous\n• pop() - remove from stack\n• popToTop() - return to first screen",
      "explanation": "React Navigation provides routing with Stack, Tab, and Drawer navigators, allowing screen transitions, parameter passing, and navigation actions like navigate and goBack.",
      "difficulty": "Medium",
      "code": "import React from 'react';\nimport { View, Text, Button } from 'react-native';\nimport { NavigationContainer } from '@react-navigation/native';\nimport { createStackNavigator } from '@react-navigation/stack';\n\nconst Stack = createStackNavigator();\n\nfunction HomeScreen({ navigation }) {\n  return (\n    <View>\n      <Text>Home Screen</Text>\n      <Button\n        title=\"Go to Details\"\n        onPress={() => navigation.navigate('Details', {\n          itemId: 86,\n          otherParam: 'anything'\n        })}\n      />\n    </View>\n  );\n}\n\nfunction DetailsScreen({ route, navigation }) {\n  const { itemId, otherParam } = route.params;\n  \n  return (\n    <View>\n      <Text>Details: {itemId}</Text>\n      <Button title=\"Go Back\" onPress={() => navigation.goBack()} />\n      <Button title=\"Go Home\" onPress={() => navigation.popToTop()} />\n    </View>\n  );\n}\n\nfunction App() {\n  return (\n    <NavigationContainer>\n      <Stack.Navigator initialRouteName=\"Home\">\n        <Stack.Screen name=\"Home\" component={HomeScreen} />\n        <Stack.Screen name=\"Details\" component={DetailsScreen} />\n      </Stack.Navigator>\n    </NavigationContainer>\n  );\n}"
    },
    {
      "id": 17,
      "question": "What is the difference between Stack Navigator and Tab Navigator?",
      "answer": "Stack Navigator and Tab Navigator are different navigation patterns for organizing app screens.\n\nStack Navigator:\n• Linear navigation flow (push/pop)\n• One screen at a time visible\n• Back button returns to previous screen\n• Used for hierarchical content\n• Common in iOS apps\n• Header with back button\n• Transition animations\n• Deep navigation trees\n\nTab Navigator:\n• Parallel navigation structure\n• Multiple tabs always accessible\n• Switch between main sections\n• Bottom or top tab bars\n• Each tab can have its own stack\n• No automatic back navigation\n• Common for main app sections",
      "explanation": "Stack Navigator provides linear screen-to-screen navigation with push/pop actions, while Tab Navigator allows switching between parallel app sections via bottom or top tabs.",
      "difficulty": "Medium",
      "code": "import React from 'react';\nimport { createBottomTabNavigator } from '@react-navigation/bottom-tabs';\nimport { createStackNavigator } from '@react-navigation/stack';\nimport Icon from 'react-native-vector-icons/Ionicons';\n\nconst Tab = createBottomTabNavigator();\nconst Stack = createStackNavigator();\n\n// Stack Navigator for Home section\nfunction HomeStack() {\n  return (\n    <Stack.Navigator>\n      <Stack.Screen name=\"HomeMain\" component={HomeScreen} />\n      <Stack.Screen name=\"Details\" component={DetailsScreen} />\n    </Stack.Navigator>\n  );\n}\n\n// Tab Navigator with nested stacks\nfunction App() {\n  return (\n    <Tab.Navigator\n      screenOptions={({ route }) => ({\n        tabBarIcon: ({ focused, color, size }) => {\n          let iconName;\n          if (route.name === 'Home') {\n            iconName = focused ? 'home' : 'home-outline';\n          } else if (route.name === 'Settings') {\n            iconName = focused ? 'settings' : 'settings-outline';\n          }\n          return <Icon name={iconName} size={size} color={color} />;\n        }\n      })}\n    >\n      <Tab.Screen name=\"Home\" component={HomeStack} />\n      <Tab.Screen name=\"Settings\" component={SettingsScreen} />\n    </Tab.Navigator>\n  );\n}"
    },
    {
      "id": 18,
      "question": "What is Platform module and how do you write platform-specific code?",
      "answer": "Platform module allows writing code that behaves differently on iOS and Android.\n\nPlatform Detection Methods:\n• Platform.OS - returns 'ios' or 'android'\n• Platform.Version - OS version number\n• Platform.select() - choose values per platform\n• Platform-specific file extensions (.ios.js, .android.js)\n• Conditional rendering based on platform\n\nCommon Use Cases:\n• Different styling per platform\n• Platform-specific UI components\n• Different navigation behaviors\n• Native module integrations\n• API differences handling\n• Different layout requirements\n• Platform-specific permissions",
      "explanation": "Platform module enables platform-specific code with Platform.OS checks, Platform.select() for value selection, and platform-specific file extensions for iOS and Android differences.",
      "difficulty": "Medium",
      "code": "import { Platform, StyleSheet } from 'react-native';\n\n// Method 1: Platform.select()\nconst styles = StyleSheet.create({\n  container: {\n    padding: Platform.select({\n      ios: 20,\n      android: 15\n    }),\n    ...Platform.select({\n      ios: {\n        shadowColor: '#000',\n        shadowOffset: { width: 0, height: 2 },\n        shadowOpacity: 0.25,\n        shadowRadius: 3.84\n      },\n      android: {\n        elevation: 5\n      }\n    })\n  }\n});\n\n// Method 2: Platform.OS\nconst isIOS = Platform.OS === 'ios';\nconst fontSize = Platform.OS === 'ios' ? 16 : 14;\n\n// Method 3: Platform.Version\nif (Platform.OS === 'android' && Platform.Version >= 21) {\n  // Android 5.0+ specific code\n}\n\n// Method 4: Platform-specific files\n// Button.ios.js - iOS implementation\n// Button.android.js - Android implementation\n// Import as: import Button from './Button';"
    },
    {
      "id": 19,
      "question": "What is AsyncStorage and how is it used for data persistence?",
      "answer": "AsyncStorage is a simple, asynchronous, persistent key-value storage system for React Native.\n\nCharacteristics:\n• Unencrypted storage (not secure for sensitive data)\n• Async API with Promises\n• String key-value pairs only\n• Global to the app\n• Persists across app launches\n• Limited storage space (6MB on Android by default)\n• Should use JSON.stringify for objects\n• Deprecated in core, now community package\n\nCommon Operations:\n• setItem() - save data\n• getItem() - retrieve data\n• removeItem() - delete data\n• clear() - delete all data\n• multiSet/multiGet - batch operations\n• getAllKeys() - list all keys",
      "explanation": "AsyncStorage is an asynchronous key-value storage system for persisting simple data locally, using string-based storage with JSON serialization for objects.",
      "difficulty": "Medium",
      "code": "import AsyncStorage from '@react-native-async-storage/async-storage';\n\n// Save data\nconst saveData = async (key, value) => {\n  try {\n    await AsyncStorage.setItem(key, JSON.stringify(value));\n    console.log('Data saved');\n  } catch (error) {\n    console.error('Error saving data:', error);\n  }\n};\n\n// Retrieve data\nconst getData = async (key) => {\n  try {\n    const value = await AsyncStorage.getItem(key);\n    if (value !== null) {\n      return JSON.parse(value);\n    }\n  } catch (error) {\n    console.error('Error retrieving data:', error);\n  }\n};\n\n// Remove data\nconst removeData = async (key) => {\n  try {\n    await AsyncStorage.removeItem(key);\n  } catch (error) {\n    console.error('Error removing data:', error);\n  }\n};\n\n// Usage\nconst user = { name: 'John', age: 30 };\nawait saveData('user', user);\nconst retrievedUser = await getData('user');\nawait removeData('user');"
    },
    {
      "id": 20,
      "question": "What are React Native lifecycle methods in class components?",
      "answer": "Lifecycle methods allow hooking into different phases of a component's existence in class components.\n\nMounting Phase:\n• constructor() - initialize state\n• componentDidMount() - after first render, setup subscriptions\n\nUpdating Phase:\n• shouldComponentUpdate() - optimize rendering\n• componentDidUpdate() - after updates, side effects\n\nUnmounting Phase:\n• componentWillUnmount() - cleanup before removal\n\nError Handling:\n• componentDidCatch() - error boundaries\n• getDerivedStateFromError() - render fallback\n\nDeprecated:\n• componentWillMount, componentWillReceiveProps, componentWillUpdate\n\nFunctional Alternative:\n• useEffect replaces most lifecycle methods",
      "explanation": "Class component lifecycle methods like componentDidMount, componentDidUpdate, and componentWillUnmount allow executing code at specific phases, now replaced by useEffect Hook in functional components.",
      "difficulty": "Medium",
      "code": "import React, { Component } from 'react';\nimport { View, Text } from 'react-native';\n\nclass LifecycleExample extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n    console.log('1. Constructor');\n  }\n  \n  componentDidMount() {\n    console.log('2. Component Mounted');\n    // Fetch data, setup subscriptions\n    this.interval = setInterval(() => {\n      this.setState({ count: this.state.count + 1 });\n    }, 1000);\n  }\n  \n  shouldComponentUpdate(nextProps, nextState) {\n    console.log('3. Should Update?');\n    // Return false to prevent re-render\n    return nextState.count !== this.state.count;\n  }\n  \n  componentDidUpdate(prevProps, prevState) {\n    console.log('4. Component Updated');\n    if (prevState.count !== this.state.count) {\n      console.log('Count changed to:', this.state.count);\n    }\n  }\n  \n  componentWillUnmount() {\n    console.log('5. Component Unmounted');\n    // Cleanup\n    clearInterval(this.interval);\n  }\n  \n  render() {\n    return <Text>Count: {this.state.count}</Text>;\n  }\n}"
    },
    {
      "id": 21,
      "question": "What is Context API and how is it used for state management?",
      "answer": "Context API provides a way to pass data through component tree without prop drilling.\n\nKey Concepts:\n• React.createContext() - creates context\n• Provider - supplies value to descendants\n• Consumer or useContext - accesses context value\n• Avoids prop drilling through multiple levels\n• Good for global state (theme, auth, language)\n• Re-renders all consumers on value change\n• Can have multiple contexts\n• Not replacement for all state management\n\nWhen to Use:\n• Theming and styling\n• User authentication state\n• Language/localization\n• Global configurations\n• Sharing data across distant components",
      "explanation": "Context API enables passing data through the component tree without prop drilling, ideal for global state like themes and authentication accessible via Provider and useContext Hook.",
      "difficulty": "Medium",
      "code": "import React, { createContext, useContext, useState } from 'react';\nimport { View, Text, Button } from 'react-native';\n\n// Create Context\nconst ThemeContext = createContext();\n\n// Provider Component\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n  \n  const toggleTheme = () => {\n    setTheme(prevTheme => prevTheme === 'light' ? 'dark' : 'light');\n  };\n  \n  return (\n    <ThemeContext.Provider value={{ theme, toggleTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\n// Consumer Component using useContext\nfunction ThemedButton() {\n  const { theme, toggleTheme } = useContext(ThemeContext);\n  \n  return (\n    <View style={{ backgroundColor: theme === 'light' ? '#fff' : '#333' }}>\n      <Text style={{ color: theme === 'light' ? '#000' : '#fff' }}>\n        Current Theme: {theme}\n      </Text>\n      <Button title=\"Toggle Theme\" onPress={toggleTheme} />\n    </View>\n  );\n}\n\n// App\nfunction App() {\n  return (\n    <ThemeProvider>\n      <ThemedButton />\n    </ThemeProvider>\n  );\n}"
    },
    {
      "id": 22,
      "question": "What is Redux and how is it integrated with React Native?",
      "answer": "Redux is a predictable state management library for managing global application state.\n\nCore Concepts:\n• Store - single source of truth for state\n• Actions - plain objects describing what happened\n• Reducers - pure functions that update state\n• Dispatch - send actions to store\n• Selectors - extract data from state\n• Middleware - extend Redux with async logic\n\nIntegration with React Native:\n• react-redux package provides Provider and hooks\n• useSelector - access state\n• useDispatch - dispatch actions\n• Provider wraps app root\n• Redux DevTools for debugging\n• Redux Toolkit simplifies setup",
      "explanation": "Redux manages global application state through a single store, actions, and reducers, integrating with React Native via react-redux Provider and hooks like useSelector and useDispatch.",
      "difficulty": "Medium",
      "code": "// store.js\nimport { createStore } from 'redux';\n\nconst initialState = { count: 0 };\n\nconst counterReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case 'INCREMENT':\n      return { count: state.count + 1 };\n    case 'DECREMENT':\n      return { count: state.count - 1 };\n    default:\n      return state;\n  }\n};\n\nexport const store = createStore(counterReducer);\n\n// App.js\nimport React from 'react';\nimport { Provider, useSelector, useDispatch } from 'react-redux';\nimport { View, Text, Button } from 'react-native';\nimport { store } from './store';\n\nfunction Counter() {\n  const count = useSelector(state => state.count);\n  const dispatch = useDispatch();\n  \n  return (\n    <View>\n      <Text>Count: {count}</Text>\n      <Button \n        title=\"Increment\" \n        onPress={() => dispatch({ type: 'INCREMENT' })} \n      />\n      <Button \n        title=\"Decrement\" \n        onPress={() => dispatch({ type: 'DECREMENT' })} \n      />\n    </View>\n  );\n}\n\nexport default function App() {\n  return (\n    <Provider store={store}>\n      <Counter />\n    </Provider>\n  );\n}"
    },
    {
      "id": 23,
      "question": "What is the difference between useState and useReducer?",
      "answer": "Both manage state in functional components but with different complexity and use cases.\n\nuseState:\n• Simple state updates\n• Single value or simple object\n• Direct state updates\n• Good for independent state values\n• Less boilerplate\n• Easier to understand\n\nuseReducer:\n• Complex state logic\n• Multiple related state values\n• State transitions based on actions\n• Good for interdependent state\n• More predictable updates\n• Similar to Redux pattern\n• Better for complex state objects\n• Easier to test logic\n\nWhen to Use useReducer:\n• State has complex update logic\n• Multiple sub-values in state\n• Next state depends on previous\n• Want centralized state logic",
      "explanation": "useState is ideal for simple state values with direct updates, while useReducer handles complex state logic with multiple related values and action-based state transitions.",
      "difficulty": "Medium",
      "code": "import React, { useState, useReducer } from 'react';\nimport { View, Text, Button } from 'react-native';\n\n// useState example - simple state\nfunction CounterWithState() {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <View>\n      <Text>Count: {count}</Text>\n      <Button title=\"+\" onPress={() => setCount(count + 1)} />\n    </View>\n  );\n}\n\n// useReducer example - complex state\nconst initialState = { count: 0, history: [] };\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return {\n        count: state.count + 1,\n        history: [...state.history, state.count + 1]\n      };\n    case 'decrement':\n      return {\n        count: state.count - 1,\n        history: [...state.history, state.count - 1]\n      };\n    case 'reset':\n      return { count: 0, history: [] };\n    default:\n      return state;\n  }\n}\n\nfunction CounterWithReducer() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  \n  return (\n    <View>\n      <Text>Count: {state.count}</Text>\n      <Button title=\"+\" onPress={() => dispatch({ type: 'increment' })} />\n      <Button title=\"-\" onPress={() => dispatch({ type: 'decrement' })} />\n      <Button title=\"Reset\" onPress={() => dispatch({ type: 'reset' })} />\n    </View>\n  );\n}"
    },
    {
      "id": 24,
      "question": "What is useCallback Hook and when should it be used?",
      "answer": "useCallback returns a memoized callback function to prevent unnecessary re-creations.\n\nKey Features:\n• Memoizes function between re-renders\n• Returns same function reference if dependencies unchanged\n• Prevents child component re-renders\n• Useful with React.memo components\n• Optimizes performance for expensive operations\n• Dependencies array controls when to recreate\n• Similar to useEffect but for functions\n\nWhen to Use:\n• Passing callbacks to optimized child components\n• Functions passed as dependencies to useEffect\n• Event handlers in memoized components\n• Functions used in dependency arrays\n• Expensive function definitions\n\nWhen NOT to Use:\n• Simple functions without performance issues\n• Not passed to child components",
      "explanation": "useCallback memoizes callback functions to maintain the same reference across re-renders, preventing unnecessary child component re-renders when functions are passed as props.",
      "difficulty": "Medium",
      "code": "import React, { useState, useCallback, memo } from 'react';\nimport { View, Text, Button } from 'react-native';\n\n// Child component wrapped with memo\nconst ChildComponent = memo(({ onPress, name }) => {\n  console.log(`${name} rendered`);\n  return <Button title={name} onPress={onPress} />;\n});\n\nfunction ParentComponent() {\n  const [count, setCount] = useState(0);\n  const [other, setOther] = useState(0);\n  \n  // Without useCallback - recreated on every render\n  const handleClick1 = () => {\n    console.log('Clicked 1');\n  };\n  \n  // With useCallback - only recreated when count changes\n  const handleClick2 = useCallback(() => {\n    console.log('Clicked 2', count);\n  }, [count]);\n  \n  // Stable reference - never recreated\n  const handleClick3 = useCallback(() => {\n    console.log('Clicked 3');\n  }, []);\n  \n  return (\n    <View>\n      <Text>Count: {count}</Text>\n      <Button title=\"Increment\" onPress={() => setCount(count + 1)} />\n      <Button title=\"Change Other\" onPress={() => setOther(other + 1)} />\n      \n      {/* Child1 re-renders on every parent render */}\n      <ChildComponent onPress={handleClick1} name=\"Child1\" />\n      \n      {/* Child2 re-renders only when count changes */}\n      <ChildComponent onPress={handleClick2} name=\"Child2\" />\n      \n      {/* Child3 never re-renders */}\n      <ChildComponent onPress={handleClick3} name=\"Child3\" />\n    </View>\n  );\n}"
    },
    {
      "id": 25,
      "question": "What is useMemo Hook and how does it differ from useCallback?",
      "answer": "useMemo memoizes computed values to avoid expensive recalculations on every render.\n\nKey Features:\n• Caches computed result value\n• Only recalculates when dependencies change\n• Optimizes expensive calculations\n• Returns memoized value (not function)\n• Prevents unnecessary processing\n• Dependencies array controls recalculation\n\nuseMemo vs useCallback:\n• useMemo returns memoized value\n• useCallback returns memoized function\n• useMemo for expensive computations\n• useCallback for function references\n• useMemo(() => fn) equivalent to useCallback(fn)\n\nWhen to Use:\n• Expensive calculations or transformations\n• Filtering or sorting large arrays\n• Complex object creation\n• Derived state from props or state",
      "explanation": "useMemo memoizes computed values to avoid recalculation on every render, while useCallback memoizes functions; both prevent unnecessary work when dependencies haven't changed.",
      "difficulty": "Medium",
      "code": "import React, { useState, useMemo, useCallback } from 'react';\nimport { View, Text, Button } from 'react-native';\n\nfunction ExpensiveComponent() {\n  const [count, setCount] = useState(0);\n  const [items, setItems] = useState([1, 2, 3, 4, 5]);\n  \n  // Expensive calculation - only runs when items change\n  const sortedItems = useMemo(() => {\n    console.log('Sorting items...');\n    return [...items].sort((a, b) => b - a);\n  }, [items]);\n  \n  // Without useMemo - runs on every render\n  const unsortedItems = [...items].sort((a, b) => b - a);\n  \n  // useMemo returns value\n  const doubledCount = useMemo(() => {\n    return count * 2;\n  }, [count]);\n  \n  // useCallback returns function\n  const handleIncrement = useCallback(() => {\n    setCount(c => c + 1);\n  }, []);\n  \n  // Complex object creation\n  const expensiveObject = useMemo(() => {\n    return {\n      count,\n      items: sortedItems,\n      computed: count * items.length\n    };\n  }, [count, sortedItems, items.length]);\n  \n  return (\n    <View>\n      <Text>Count: {count}</Text>\n      <Text>Doubled: {doubledCount}</Text>\n      <Text>Sorted: {sortedItems.join(', ')}</Text>\n      <Button title=\"Increment\" onPress={handleIncrement} />\n    </View>\n  );\n}"
    },
    {
      "id": 26,
      "question": "What is useRef Hook and what are its use cases?",
      "answer": "useRef creates a mutable reference that persists across re-renders without causing re-renders when changed.\n\nKey Features:\n• Returns object with current property\n• Persists for component lifetime\n• Changing ref doesn't trigger re-render\n• Can store any mutable value\n• Commonly used for DOM/component references\n• Useful for storing previous values\n• Access native component methods\n\nCommon Use Cases:\n• Accessing native component methods (focus, measure)\n• Storing mutable values without re-renders\n• Keeping track of previous prop/state values\n• Storing interval or timeout IDs\n• Managing animation values\n• Imperative parent-child communication\n• Storing any value that shouldn't trigger updates",
      "explanation": "useRef creates a persistent mutable reference that survives re-renders without triggering updates, commonly used for accessing component instances and storing values that shouldn't cause re-renders.",
      "difficulty": "Medium",
      "code": "import React, { useRef, useState, useEffect } from 'react';\nimport { View, TextInput, Button, Text } from 'react-native';\n\nfunction RefExample() {\n  const inputRef = useRef(null);\n  const countRef = useRef(0);\n  const previousValueRef = useRef();\n  const [count, setCount] = useState(0);\n  \n  // Focus input programmatically\n  const focusInput = () => {\n    inputRef.current?.focus();\n  };\n  \n  // Track render count without causing re-renders\n  countRef.current++;\n  \n  // Store previous value\n  useEffect(() => {\n    previousValueRef.current = count;\n  }, [count]);\n  \n  // Store interval ID\n  const intervalRef = useRef();\n  \n  const startInterval = () => {\n    intervalRef.current = setInterval(() => {\n      setCount(c => c + 1);\n    }, 1000);\n  };\n  \n  const stopInterval = () => {\n    clearInterval(intervalRef.current);\n  };\n  \n  return (\n    <View>\n      <TextInput ref={inputRef} placeholder=\"Focus me\" />\n      <Button title=\"Focus Input\" onPress={focusInput} />\n      \n      <Text>Current: {count}</Text>\n      <Text>Previous: {previousValueRef.current}</Text>\n      <Text>Render count: {countRef.current}</Text>\n      \n      <Button title=\"Start\" onPress={startInterval} />\n      <Button title=\"Stop\" onPress={stopInterval} />\n    </View>\n  );\n}"
    },
    {
      "id": 27,
      "question": "What are Custom Hooks and how do you create them?",
      "answer": "Custom Hooks are reusable functions that encapsulate stateful logic and can use other Hooks.\n\nCharacteristics:\n• Function name must start with use\n• Can use other Hooks inside\n• Extract and share logic between components\n• Maintain their own state\n• Can accept parameters and return values\n• Follow same rules as built-in Hooks\n• Enable composition of behavior\n• Don't share state between usages\n\nBenefits:\n• Code reusability\n• Separation of concerns\n• Easier testing\n• Clean component code\n• Composable logic\n\nCommon Patterns:\n• Data fetching hooks\n• Form handling hooks\n• Animation hooks\n• Timer hooks",
      "explanation": "Custom Hooks are reusable functions starting with 'use' that encapsulate stateful logic using other Hooks, enabling code reuse and separation of concerns across components.",
      "difficulty": "Medium",
      "code": "import { useState, useEffect } from 'react';\n\n// Custom Hook for data fetching\nfunction useFetch(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        const response = await fetch(url);\n        const json = await response.json();\n        setData(json);\n      } catch (err) {\n        setError(err);\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    fetchData();\n  }, [url]);\n  \n  return { data, loading, error };\n}\n\n// Custom Hook for form input\nfunction useInput(initialValue) {\n  const [value, setValue] = useState(initialValue);\n  \n  const handleChange = (text) => {\n    setValue(text);\n  };\n  \n  const reset = () => {\n    setValue(initialValue);\n  };\n  \n  return { value, onChange: handleChange, reset };\n}\n\n// Usage\nfunction MyComponent() {\n  const { data, loading, error } = useFetch('https://api.example.com/data');\n  const email = useInput('');\n  \n  return loading ? <Text>Loading...</Text> : <Text>{data.name}</Text>;\n}"
    },
    {
      "id": 28,
      "question": "What is the Component Lifecycle in React Native?",
      "answer": "Component lifecycle refers to the series of phases a component goes through from creation to destruction.\n\nThree Main Phases:\n\nMounting (Birth):\n• Component is created and inserted into DOM\n• Constructor, getDerivedStateFromProps, render, componentDidMount\n• useEffect with empty array mimics componentDidMount\n\nUpdating (Growth):\n• Component re-renders due to props or state changes\n• getDerivedStateFromProps, shouldComponentUpdate, render, componentDidUpdate\n• useEffect with dependencies mimics componentDidUpdate\n\nUnmounting (Death):\n• Component is removed from DOM\n• componentWillUnmount for cleanup\n• useEffect cleanup function mimics componentWillUnmount\n\nFunctional Components:\n• Use useEffect Hook for lifecycle behavior\n• Simpler and more intuitive API",
      "explanation": "Component lifecycle consists of mounting (creation), updating (re-rendering), and unmounting (cleanup) phases, managed by lifecycle methods in classes or useEffect Hook in functional components.",
      "difficulty": "Medium",
      "code": "import React, { useState, useEffect } from 'react';\nimport { View, Text, Button } from 'react-native';\n\n// Functional component with lifecycle using Hooks\nfunction LifecycleComponent({ userId }) {\n  const [data, setData] = useState(null);\n  \n  // Mount + Update (when userId changes)\n  useEffect(() => {\n    console.log('Fetching data for user:', userId);\n    \n    const fetchData = async () => {\n      const response = await fetch(`/api/users/${userId}`);\n      const json = await response.json();\n      setData(json);\n    };\n    \n    fetchData();\n    \n    // Cleanup (unmount or before next effect)\n    return () => {\n      console.log('Cleaning up for user:', userId);\n    };\n  }, [userId]); // Re-run when userId changes\n  \n  // Mount only (empty dependency array)\n  useEffect(() => {\n    console.log('Component mounted');\n    \n    return () => {\n      console.log('Component unmounted');\n    };\n  }, []);\n  \n  // Every render (no dependency array)\n  useEffect(() => {\n    console.log('Component rendered');\n  });\n  \n  return <Text>{data?.name}</Text>;\n}\n\nfunction App() {\n  const [show, setShow] = useState(true);\n  \n  return (\n    <View>\n      <Button \n        title={show ? 'Hide' : 'Show'} \n        onPress={() => setShow(!show)} \n      />\n      {show && <LifecycleComponent userId={1} />}\n    </View>\n  );\n}"
    },
    {
      "id": 29,
      "question": "What is React.memo and when should it be used?",
      "answer": "React.memo is a higher-order component that memoizes functional components to prevent unnecessary re-renders.\n\nHow It Works:\n• Shallow compares props before re-rendering\n• Re-renders only if props changed\n• Returns memoized component\n• Can provide custom comparison function\n• Similar to PureComponent for functional components\n• Optimization technique for performance\n\nWhen to Use:\n• Component renders often with same props\n• Component is expensive to render\n• Pure functional component (output depends only on props)\n• Parent re-renders frequently\n• Component has many child components\n\nWhen NOT to Use:\n• Props change frequently\n• Component is already fast\n• Premature optimization\n• Props include functions or objects (need useCallback/useMemo)",
      "explanation": "React.memo is a higher-order component that prevents re-renders of functional components when props haven't changed, optimizing performance by shallow comparing props.",
      "difficulty": "Medium",
      "code": "import React, { useState, memo } from 'react';\nimport { View, Text, Button } from 'react-native';\n\n// Without memo - re-renders every time parent renders\nfunction RegularChild({ name }) {\n  console.log('Regular Child rendered');\n  return <Text>Regular: {name}</Text>;\n}\n\n// With memo - only re-renders when name changes\nconst MemoizedChild = memo(({ name }) => {\n  console.log('Memoized Child rendered');\n  return <Text>Memoized: {name}</Text>;\n});\n\n// Custom comparison function\nconst MemoizedWithCustomComparison = memo(\n  ({ user }) => {\n    console.log('Custom comparison child rendered');\n    return <Text>{user.name}</Text>;\n  },\n  (prevProps, nextProps) => {\n    // Return true if props are equal (skip render)\n    return prevProps.user.id === nextProps.user.id;\n  }\n);\n\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  const [name] = useState('John');\n  \n  return (\n    <View>\n      <Text>Count: {count}</Text>\n      <Button \n        title=\"Increment\" \n        onPress={() => setCount(count + 1)} \n      />\n      \n      {/* Re-renders on every parent update */}\n      <RegularChild name={name} />\n      \n      {/* Only re-renders when name changes */}\n      <MemoizedChild name={name} />\n    </View>\n  );\n}"
    },
    {
      "id": 30,
      "question": "What are Error Boundaries and how do you implement them?",
      "answer": "Error Boundaries are components that catch JavaScript errors in child component tree and display fallback UI.\n\nKey Features:\n• Catch errors during rendering\n• Catch errors in lifecycle methods\n• Catch errors in constructors\n• Display fallback UI instead of crash\n• Log error information\n• Only work in class components (no Hook equivalent)\n• Don't catch errors in event handlers\n• Don't catch async errors\n\nLifecycle Methods:\n• static getDerivedStateFromError() - render fallback UI\n• componentDidCatch() - log error info\n\nLimitations:\n• Don't catch errors in error boundary itself\n• Don't catch errors in event handlers\n• Don't catch server-side rendering errors\n• Don't catch async code errors",
      "explanation": "Error Boundaries are class components using getDerivedStateFromError and componentDidCatch to catch rendering errors in child components and display fallback UI instead of crashing.",
      "difficulty": "Medium",
      "code": "import React, { Component } from 'react';\nimport { View, Text, Button } from 'react-native';\n\n// Error Boundary Component\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n  \n  static getDerivedStateFromError(error) {\n    // Update state to render fallback UI\n    return { hasError: true, error };\n  }\n  \n  componentDidCatch(error, errorInfo) {\n    // Log error to service\n    console.error('Error caught:', error, errorInfo);\n  }\n  \n  resetError = () => {\n    this.setState({ hasError: false, error: null });\n  };\n  \n  render() {\n    if (this.state.hasError) {\n      return (\n        <View>\n          <Text>Something went wrong!</Text>\n          <Text>{this.state.error?.toString()}</Text>\n          <Button title=\"Try Again\" onPress={this.resetError} />\n        </View>\n      );\n    }\n    \n    return this.props.children;\n  }\n}\n\n// Component that might throw error\nfunction BuggyComponent({ shouldThrow }) {\n  if (shouldThrow) {\n    throw new Error('Intentional error');\n  }\n  return <Text>Working fine</Text>;\n}\n\n// Usage\nfunction App() {\n  return (\n    <ErrorBoundary>\n      <BuggyComponent shouldThrow={false} />\n    </ErrorBoundary>\n  );\n}"
    },
    {
      "id": 31,
      "question": "What is the Animated API and how is it used?",
      "answer": "Animated API provides powerful animation capabilities for creating smooth, performant animations in React Native.\n\nCore Components:\n• Animated.View, Animated.Text, Animated.Image, Animated.ScrollView\n• Animated.Value - single animated value\n• Animated.ValueXY - 2D animated value (x, y coordinates)\n\nAnimation Types:\n• Animated.timing() - animate value over time\n• Animated.spring() - spring physics animation\n• Animated.decay() - deceleration animation\n\nComposition:\n• Animated.parallel() - run animations simultaneously\n• Animated.sequence() - run animations one after another\n• Animated.stagger() - delay between parallel animations\n• Animated.loop() - repeat animation\n\nInterpolation:\n• Map animated values to different ranges\n• Support for color, rotation, scale interpolation",
      "explanation": "Animated API provides declarative animation capabilities with Animated.timing, spring, and decay for smooth animations, plus composition methods and interpolation for complex animation sequences.",
      "difficulty": "Medium",
      "code": "import React, { useRef, useEffect } from 'react';\nimport { Animated, View, Button, StyleSheet } from 'react-native';\n\nfunction AnimationExample() {\n  const fadeAnim = useRef(new Animated.Value(0)).current;\n  const slideAnim = useRef(new Animated.Value(-100)).current;\n  const scaleAnim = useRef(new Animated.Value(1)).current;\n  \n  const fadeIn = () => {\n    Animated.timing(fadeAnim, {\n      toValue: 1,\n      duration: 1000,\n      useNativeDriver: true\n    }).start();\n  };\n  \n  const springAnimation = () => {\n    Animated.spring(scaleAnim, {\n      toValue: 1.5,\n      friction: 3,\n      tension: 40,\n      useNativeDriver: true\n    }).start();\n  };\n  \n  const sequenceAnimation = () => {\n    Animated.sequence([\n      Animated.timing(slideAnim, {\n        toValue: 0,\n        duration: 500,\n        useNativeDriver: true\n      }),\n      Animated.timing(fadeAnim, {\n        toValue: 1,\n        duration: 500,\n        useNativeDriver: true\n      })\n    ]).start();\n  };\n  \n  return (\n    <View style={styles.container}>\n      <Animated.View\n        style={[\n          styles.box,\n          {\n            opacity: fadeAnim,\n            transform: [\n              { translateY: slideAnim },\n              { scale: scaleAnim }\n            ]\n          }\n        ]}\n      />\n      <Button title=\"Fade In\" onPress={fadeIn} />\n      <Button title=\"Spring\" onPress={springAnimation} />\n      <Button title=\"Sequence\" onPress={sequenceAnimation} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'blue' }\n});"
    },
    {
      "id": 32,
      "question": "What is React Native Reanimated and how does it differ from Animated API?",
      "answer": "Reanimated is a third-party library providing more powerful and performant animations than the built-in Animated API.\n\nKey Features:\n• Runs animations on UI thread (not JS thread)\n• More performant for complex animations\n• Supports gesture-driven animations\n• Declarative worklet syntax\n• Better interpolation and composition\n• Works with React Native Gesture Handler\n• Supports layout animations\n• Smoother 60fps animations\n\nReanimated vs Animated API:\n• Reanimated runs on native thread\n• Animated API can drop frames on JS thread\n• Reanimated has better gesture support\n• Reanimated has layout animations\n• Animated API is built-in\n• Reanimated requires installation\n• Reanimated better for complex animations",
      "explanation": "Reanimated is a performant animation library running on the UI thread unlike Animated API, providing smoother animations, gesture support, and layout animations with declarative worklet syntax.",
      "difficulty": "Hard",
      "code": "import React from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withSpring,\n  withTiming\n} from 'react-native-reanimated';\n\nfunction ReanimatedExample() {\n  const offset = useSharedValue(0);\n  const scale = useSharedValue(1);\n  \n  // Animated style using worklets\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: offset.value },\n        { scale: scale.value }\n      ]\n    };\n  });\n  \n  const moveRight = () => {\n    offset.value = withSpring(100);\n  };\n  \n  const scaleUp = () => {\n    scale.value = withTiming(1.5, { duration: 300 });\n  };\n  \n  const reset = () => {\n    offset.value = withSpring(0);\n    scale.value = withSpring(1);\n  };\n  \n  return (\n    <View style={styles.container}>\n      <Animated.View style={[styles.box, animatedStyles]} />\n      <Button title=\"Move Right\" onPress={moveRight} />\n      <Button title=\"Scale Up\" onPress={scaleUp} />\n      <Button title=\"Reset\" onPress={reset} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },\n  box: { width: 100, height: 100, backgroundColor: 'purple' }\n});"
    },
    {
      "id": 33,
      "question": "What is PanResponder and how is it used for gestures?",
      "answer": "PanResponder provides a gesture responder system to capture touch interactions and gestures.\n\nKey Features:\n• Handles touch events (start, move, end)\n• Captures pan gestures (drag, swipe)\n• Provides gesture velocity and position\n• Negotiates with parent and child responders\n• Supports multi-touch gestures\n• Works with Animated API\n• Lower-level than gesture libraries\n\nGesture Lifecycle:\n• onStartShouldSetPanResponder - request to become responder\n• onMoveShouldSetPanResponder - during move\n• onPanResponderGrant - became responder\n• onPanResponderMove - finger moving\n• onPanResponderRelease - finger lifted\n• onPanResponderTerminate - responder taken away\n\nCommon Use Cases:\n• Drag and drop\n• Swipeable components\n• Custom sliders\n• Pinch to zoom",
      "explanation": "PanResponder is a low-level API for handling touch gestures like drag and swipe, providing lifecycle callbacks for touch events and working with Animated API for gesture-driven animations.",
      "difficulty": "Hard",
      "code": "import React, { useRef } from 'react';\nimport { View, Animated, PanResponder, StyleSheet } from 'react-native';\n\nfunction DraggableBox() {\n  const pan = useRef(new Animated.ValueXY()).current;\n  \n  const panResponder = useRef(\n    PanResponder.create({\n      onStartShouldSetPanResponder: () => true,\n      onMoveShouldSetPanResponder: () => true,\n      \n      onPanResponderGrant: () => {\n        // Gesture started\n        pan.setOffset({\n          x: pan.x._value,\n          y: pan.y._value\n        });\n      },\n      \n      onPanResponderMove: Animated.event(\n        [\n          null,\n          { dx: pan.x, dy: pan.y }\n        ],\n        { useNativeDriver: false }\n      ),\n      \n      onPanResponderRelease: (evt, gestureState) => {\n        // Gesture ended\n        pan.flattenOffset();\n        \n        // Check velocity for swipe\n        if (Math.abs(gestureState.vx) > 0.5) {\n          console.log('Swiped!');\n        }\n      }\n    })\n  ).current;\n  \n  return (\n    <View style={styles.container}>\n      <Animated.View\n        style={[\n          styles.box,\n          {\n            transform: [\n              { translateX: pan.x },\n              { translateY: pan.y }\n            ]\n          }\n        ]}\n        {...panResponder.panHandlers}\n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  box: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n    borderRadius: 5\n  }\n});"
    },
    {
      "id": 34,
      "question": "What is React Native Gesture Handler and why use it over PanResponder?",
      "answer": "React Native Gesture Handler is a declarative API for handling gestures that runs on native thread.\n\nAdvantages over PanResponder:\n• Runs on native thread (better performance)\n• No JS bridge crossing during gesture\n• Better gesture recognition\n• Works with Reanimated for smooth animations\n• More gesture types out of the box\n• Easier API for common gestures\n• Better multi-gesture handling\n• Cancellation and failure handling\n\nSupported Gestures:\n• PanGestureHandler - drag gestures\n• TapGestureHandler - tap detection\n• LongPressGestureHandler - long press\n• PinchGestureHandler - pinch to zoom\n• RotationGestureHandler - rotation\n• FlingGestureHandler - fast swipe\n\nComposition:\n• Simultaneous gestures\n• Gesture dependencies\n• Native gesture cancellation",
      "explanation": "Gesture Handler is a performant gesture library running on the native thread, providing better performance than PanResponder with declarative API and support for complex gesture combinations.",
      "difficulty": "Hard",
      "code": "import React from 'react';\nimport { StyleSheet } from 'react-native';\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  useAnimatedGestureHandler\n} from 'react-native-reanimated';\nimport {\n  GestureHandlerRootView,\n  PanGestureHandler\n} from 'react-native-gesture-handler';\n\nfunction DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n  \n  const gestureHandler = useAnimatedGestureHandler({\n    onStart: (_, ctx) => {\n      ctx.startX = translateX.value;\n      ctx.startY = translateY.value;\n    },\n    onActive: (event, ctx) => {\n      translateX.value = ctx.startX + event.translationX;\n      translateY.value = ctx.startY + event.translationY;\n    },\n    onEnd: (event) => {\n      // Check velocity for animations\n      console.log('Velocity:', event.velocityX, event.velocityY);\n    }\n  });\n  \n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value }\n      ]\n    };\n  });\n  \n  return (\n    <GestureHandlerRootView style={styles.container}>\n      <PanGestureHandler onGestureEvent={gestureHandler}>\n        <Animated.View style={[styles.box, animatedStyle]} />\n      </PanGestureHandler>\n    </GestureHandlerRootView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  box: { width: 100, height: 100, backgroundColor: 'blue' }\n});"
    },
    {
      "id": 35,
      "question": "How do you optimize FlatList performance?",
      "answer": "FlatList performance can be optimized through various techniques to handle large datasets efficiently.\n\nOptimization Techniques:\n• Use getItemLayout for fixed height items\n• Set initialNumToRender to minimal number\n• Use keyExtractor for stable keys\n• Implement shouldComponentUpdate or React.memo for items\n• Use windowSize to control rendered items\n• Set maxToRenderPerBatch for controlled batching\n• Enable removeClippedSubviews on Android\n• Avoid anonymous functions in renderItem\n• Use PureComponent or memo for item components\n• Optimize images (resize, cache)\n• Reduce item complexity\n• Use pagination for infinite lists\n\nPerformance Props:\n• initialNumToRender - initial batch size\n• maxToRenderPerBatch - items per batch\n• windowSize - screens to render\n• updateCellsBatchingPeriod - batching delay\n• removeClippedSubviews - unmount off-screen",
      "explanation": "FlatList performance is optimized through getItemLayout for fixed heights, limiting rendered items with initialNumToRender and windowSize, memoizing item components, and using removeClippedSubviews for memory efficiency.",
      "difficulty": "Hard",
      "code": "import React, { memo } from 'react';\nimport { FlatList, View, Text, StyleSheet } from 'react-native';\n\n// Memoized item component\nconst ListItem = memo(({ item }) => {\n  return (\n    <View style={styles.item}>\n      <Text>{item.title}</Text>\n    </View>\n  );\n});\n\nfunction OptimizedList() {\n  const data = Array.from({ length: 1000 }, (_, i) => ({\n    id: String(i),\n    title: `Item ${i}`\n  }));\n  \n  const ITEM_HEIGHT = 50;\n  \n  // Performance optimization\n  const getItemLayout = (data, index) => ({\n    length: ITEM_HEIGHT,\n    offset: ITEM_HEIGHT * index,\n    index\n  });\n  \n  // Stable key extractor\n  const keyExtractor = (item) => item.id;\n  \n  // Optimized render function (not anonymous)\n  const renderItem = ({ item }) => <ListItem item={item} />;\n  \n  return (\n    <FlatList\n      data={data}\n      renderItem={renderItem}\n      keyExtractor={keyExtractor}\n      getItemLayout={getItemLayout}\n      initialNumToRender={10}\n      maxToRenderPerBatch={10}\n      windowSize={5}\n      removeClippedSubviews={true}\n      updateCellsBatchingPeriod={50}\n    />\n  );\n}\n\nconst styles = StyleSheet.create({\n  item: {\n    height: 50,\n    justifyContent: 'center',\n    padding: 15,\n    borderBottomWidth: 1,\n    borderBottomColor: '#ddd'\n  }\n});"
    },
    {
      "id": 36,
      "question": "What are Native Modules and how do you create them?",
      "answer": "Native Modules allow calling platform-specific native code (iOS/Android) from JavaScript.\n\nWhy Use Native Modules:\n• Access platform APIs not available in React Native\n• Use existing native libraries\n• Performance-critical operations\n• Hardware access (camera, sensors)\n• Platform-specific features\n• Reuse native code\n\nCreation Steps:\n• Write native code (Objective-C/Swift for iOS, Java/Kotlin for Android)\n• Export methods with RCT_EXPORT_METHOD\n• Register module with bridge\n• Import and use in JavaScript\n\nCommunication:\n• Asynchronous by default\n• Supports callbacks and promises\n• Can send events to JavaScript\n• Thread-safe communication\n\nModern Alternative:\n• TurboModules for better performance\n• JSI (JavaScript Interface) for synchronous calls",
      "explanation": "Native Modules enable calling platform-specific native code from JavaScript by bridging iOS/Android APIs, created by exporting native methods and registering them with the React Native bridge.",
      "difficulty": "Hard",
      "code": "// iOS Native Module (CalendarManager.m)\n#import \"CalendarManager.h\"\n#import <React/RCTLog.h>\n\n@implementation CalendarManager\n\nRCT_EXPORT_MODULE();\n\nRCT_EXPORT_METHOD(addEvent:(NSString *)name\n                  location:(NSString *)location\n                  callback:(RCTResponseSenderBlock)callback)\n{\n  RCTLogInfo(@\"Adding event %@ at %@\", name, location);\n  callback(@[[NSNull null], @{@\"eventId\": @\"123\"}]);\n}\n\nRCT_EXPORT_METHOD(findEvents:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n  NSArray *events = @[@\"Event1\", @\"Event2\"];\n  if (events) {\n    resolve(events);\n  } else {\n    reject(@\"no_events\", @\"No events found\", nil);\n  }\n}\n\n@end\n\n// JavaScript Usage\nimport { NativeModules } from 'react-native';\nconst { CalendarManager } = NativeModules;\n\n// Using callback\nCalendarManager.addEvent('Party', 'My House', (error, eventId) => {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('Event added:', eventId);\n  }\n});\n\n// Using promise\nCalendarManager.findEvents()\n  .then(events => console.log(events))\n  .catch(error => console.error(error));"
    },
    {
      "id": 37,
      "question": "What is the New Architecture in React Native?",
      "answer": "The New Architecture is a re-architecture of React Native for better performance and developer experience.\n\nKey Components:\n\nJSI (JavaScript Interface):\n• Direct JavaScript to native communication\n• No bridge serialization overhead\n• Synchronous native calls possible\n• Better memory management\n• Faster startup time\n\nFabric (New Renderer):\n• New UI rendering system\n• Synchronous layout and rendering\n• Improved prioritization\n• Better concurrent features support\n• Type-safe\n\nTurboModules:\n• Lazy-loaded native modules\n• Type-safe interface\n• Faster module initialization\n• Better tree shaking\n• Direct JSI access\n\nCodegen:\n• Static type checking\n• Generates boilerplate code\n• Type safety between layers",
      "explanation": "The New Architecture introduces JSI for direct JavaScript-native communication, Fabric renderer for synchronous UI updates, and TurboModules for lazy-loaded native modules, improving performance and type safety.",
      "difficulty": "Hard",
      "code": "// TurboModule Spec (NativeCalculator.ts)\nimport type { TurboModule } from 'react-native';\nimport { TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): number;\n  multiply(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.getEnforcing<Spec>('Calculator');\n\n// Usage\nimport NativeCalculator from './NativeCalculator';\n\n// Synchronous call via JSI\nconst result = NativeCalculator.add(5, 3); // Returns 8 immediately\n\n// Asynchronous call\nNativeCalculator.multiply(4, 5).then(result => {\n  console.log(result); // 20\n});\n\n// Fabric Component Spec\nimport type { ViewProps } from 'react-native';\nimport type { HostComponent } from 'react-native';\nimport codegenNativeComponent from 'react-native/Libraries/Utilities/codegenNativeComponent';\n\ninterface NativeProps extends ViewProps {\n  color?: string;\n  opacity?: number;\n}\n\nexport default codegenNativeComponent<NativeProps>('CustomView');"
    },
    {
      "id": 38,
      "question": "What is Hermes and what are its benefits?",
      "answer": "Hermes is an optimized JavaScript engine specifically designed for React Native applications.\n\nKey Features:\n• Ahead-of-time (AOT) compilation\n• Optimized for mobile constraints\n• Smaller app size\n• Faster app startup time\n• Reduced memory usage\n• Improved performance on Android\n• Better garbage collection\n• Supports bytecode format\n\nBenefits:\n• 50% faster app startup\n• Smaller APK/IPA size\n• Lower memory footprint\n• Better performance on low-end devices\n• Improved TTI (Time to Interactive)\n• Efficient garbage collection\n\nTrade-offs:\n• Some modern JS features not supported\n• Different debugging experience\n• iOS benefits less than Android\n\nEnabling Hermes:\n• Default in React Native 0.70+\n• Configure in android/app/build.gradle\n• Configure in iOS Podfile",
      "explanation": "Hermes is a JavaScript engine optimized for React Native with AOT compilation, providing faster startup times, smaller app sizes, and reduced memory usage especially on Android devices.",
      "difficulty": "Medium",
      "code": "// Enable Hermes on Android (android/app/build.gradle)\nproject.ext.react = [\n    enableHermes: true  // Enable Hermes\n]\n\n// Enable Hermes on iOS (ios/Podfile)\nuse_react_native!(\n  :path => config[:reactNativePath],\n  :hermes_enabled => true  // Enable Hermes\n)\n\n// Check if Hermes is enabled\nimport { Platform } from 'react-native';\n\nconst isHermesEnabled = () => {\n  return !!global.HermesInternal;\n};\n\nconsole.log('Hermes enabled:', isHermesEnabled());\n\n// Performance comparison\nconst start = Date.now();\n\n// Heavy computation\nfor (let i = 0; i < 1000000; i++) {\n  Math.sqrt(i);\n}\n\nconst end = Date.now();\nconsole.log(`Execution time: ${end - start}ms`);\n\n// With Hermes: typically 20-30% faster\n// Memory usage: typically 30-50% less"
    },
    {
      "id": 39,
      "question": "How do you handle deep linking in React Native?",
      "answer": "Deep linking allows opening specific screens in your app from external URLs or other apps.\n\nTypes of Deep Links:\n• Custom URL schemes (myapp://)\n• Universal Links (iOS) / App Links (Android)\n• Deferred deep links (after app install)\n\nImplementation Steps:\n• Configure URL schemes in native code\n• Set up React Navigation linking\n• Handle incoming links\n• Parse URL parameters\n• Navigate to appropriate screen\n\nReact Navigation Integration:\n• Configure linking config\n• Define screen paths\n• Handle parameters\n• Support nested navigation\n\nCommon Use Cases:\n• Email verification links\n• Password reset flows\n• Share content links\n• Promotional campaigns\n• Social media sharing\n• Push notification actions",
      "explanation": "Deep linking enables opening specific app screens from URLs using custom schemes or universal links, configured through native settings and React Navigation's linking configuration with URL parsing.",
      "difficulty": "Medium",
      "code": "// React Navigation Deep Linking Configuration\nimport { NavigationContainer } from '@react-navigation/native';\nimport { Linking } from 'react-native';\n\nconst linking = {\n  prefixes: ['myapp://', 'https://myapp.com'],\n  config: {\n    screens: {\n      Home: '',\n      Profile: 'profile/:userId',\n      Details: {\n        path: 'details/:itemId',\n        parse: {\n          itemId: (itemId) => parseInt(itemId)\n        }\n      },\n      Settings: 'settings'\n    }\n  }\n};\n\nfunction App() {\n  return (\n    <NavigationContainer linking={linking}>\n      {/* Navigation setup */}\n    </NavigationContainer>\n  );\n}\n\n// iOS Configuration (Info.plist)\n/*\n<key>CFBundleURLTypes</key>\n<array>\n  <dict>\n    <key>CFBundleURLSchemes</key>\n    <array>\n      <string>myapp</string>\n    </array>\n  </dict>\n</array>\n*/\n\n// Android Configuration (AndroidManifest.xml)\n/*\n<intent-filter>\n  <action android:name=\"android.intent.action.VIEW\" />\n  <category android:name=\"android.intent.category.DEFAULT\" />\n  <category android:name=\"android.intent.category.BROWSABLE\" />\n  <data android:scheme=\"myapp\" />\n</intent-filter>\n*/\n\n// Manual Link Handling\nimport { useEffect } from 'react';\n\nfunction MyComponent() {\n  useEffect(() => {\n    const handleUrl = ({ url }) => {\n      console.log('Opened with:', url);\n      // Parse and navigate\n    };\n    \n    Linking.addEventListener('url', handleUrl);\n    \n    return () => Linking.removeEventListener('url', handleUrl);\n  }, []);\n}"
    },
    {
      "id": 40,
      "question": "What are Push Notifications and how do you implement them?",
      "answer": "Push notifications allow sending messages to users' devices even when app is not running.\n\nImplementation Libraries:\n• react-native-firebase (FCM for Android/iOS)\n• react-native-push-notification\n• OneSignal, Pusher, etc.\n\nSetup Steps:\n• Configure Firebase Cloud Messaging\n• Request notification permissions\n• Get device token\n• Send token to backend\n• Handle incoming notifications\n• Handle notification tap\n• Display local notifications\n\nNotification States:\n• Foreground - app is active\n• Background - app is background\n• Quit - app is closed\n\nFeatures:\n• Rich notifications (images, actions)\n• Scheduled notifications\n• Deep linking from notifications\n• Badge counts\n• Notification categories\n• Silent notifications",
      "explanation": "Push notifications enable sending messages to devices using Firebase Cloud Messaging, requiring permission requests, device token management, and handling notifications in foreground, background, and quit states.",
      "difficulty": "Medium",
      "code": "// Installation: npm install @react-native-firebase/app @react-native-firebase/messaging\n\nimport messaging from '@react-native-firebase/messaging';\nimport { Platform } from 'react-native';\n\n// Request permission (iOS)\nasync function requestUserPermission() {\n  const authStatus = await messaging().requestPermission();\n  const enabled =\n    authStatus === messaging.AuthorizationStatus.AUTHORIZED ||\n    authStatus === messaging.AuthorizationStatus.PROVISIONAL;\n  \n  if (enabled) {\n    console.log('Notification permission granted');\n  }\n}\n\n// Get FCM token\nasync function getFCMToken() {\n  const token = await messaging().getToken();\n  console.log('FCM Token:', token);\n  // Send token to backend\n  await sendTokenToServer(token);\n}\n\n// Handle foreground notifications\nmessaging().onMessage(async remoteMessage => {\n  console.log('Foreground notification:', remoteMessage);\n  // Display notification manually\n});\n\n// Handle background notifications\nmessaging().setBackgroundMessageHandler(async remoteMessage => {\n  console.log('Background notification:', remoteMessage);\n});\n\n// Handle notification tap\nmessaging().onNotificationOpenedApp(remoteMessage => {\n  console.log('Notification opened app:', remoteMessage);\n  // Navigate to specific screen\n});\n\n// Check if app opened from notification\nmessaging()\n  .getInitialNotification()\n  .then(remoteMessage => {\n    if (remoteMessage) {\n      console.log('App opened from quit state:', remoteMessage);\n    }\n  });\n\n// Token refresh\nmessaging().onTokenRefresh(token => {\n  console.log('Token refreshed:', token);\n  sendTokenToServer(token);\n});"
    },
    {
      "id": 41,
      "question": "How do you handle network requests in React Native?",
      "answer": "Network requests in React Native can be handled using the built-in Fetch API or third-party libraries.\n\nFetch API:\n• Built-in, no installation needed\n• Promise-based\n• Similar to browser Fetch\n• Supports GET, POST, PUT, DELETE\n• Handles JSON automatically\n• Cookie and authentication support\n\nAlternative Libraries:\n• Axios - popular, feature-rich\n• React Query - caching and state management\n• SWR - stale-while-revalidate pattern\n\nBest Practices:\n• Handle loading states\n• Handle errors properly\n• Implement timeouts\n• Add request/response interceptors\n• Cache responses when appropriate\n• Cancel requests on unmount\n• Use environment variables for URLs\n• Implement retry logic",
      "explanation": "Network requests in React Native use Fetch API or libraries like Axios, requiring proper error handling, loading states, and cleanup to prevent memory leaks and provide good user experience.",
      "difficulty": "Medium",
      "code": "import React, { useState, useEffect } from 'react';\nimport { View, Text, ActivityIndicator } from 'react-native';\n\n// Using Fetch API\nfunction FetchExample() {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    const controller = new AbortController();\n    \n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        const response = await fetch('https://api.example.com/data', {\n          method: 'GET',\n          headers: {\n            'Content-Type': 'application/json',\n            'Authorization': 'Bearer token'\n          },\n          signal: controller.signal // For cancellation\n        });\n        \n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const json = await response.json();\n        setData(json);\n      } catch (err) {\n        if (err.name !== 'AbortError') {\n          setError(err.message);\n        }\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    fetchData();\n    \n    // Cleanup: cancel request on unmount\n    return () => controller.abort();\n  }, []);\n  \n  if (loading) return <ActivityIndicator />;\n  if (error) return <Text>Error: {error}</Text>;\n  return <Text>{JSON.stringify(data)}</Text>;\n}\n\n// POST request\nasync function postData(url, data) {\n  const response = await fetch(url, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(data)\n  });\n  return response.json();\n}"
    },
    {
      "id": 42,
      "question": "What is React Query and why use it for data fetching?",
      "answer": "React Query is a powerful data fetching and state management library for server state.\n\nKey Features:\n• Automatic caching\n• Background refetching\n• Stale-while-revalidate pattern\n• Request deduplication\n• Pagination support\n• Infinite scroll support\n• Optimistic updates\n• Automatic retries\n• Loading and error states\n• DevTools for debugging\n\nBenefits:\n• Reduces boilerplate code\n• Automatic cache management\n• Better user experience with background updates\n• Memory efficient\n• Handles race conditions\n• Built-in error handling\n• Supports mutations\n• Easy data synchronization\n\nCore Concepts:\n• useQuery - fetch data\n• useMutation - modify data\n• QueryClient - manage cache\n• Stale time and cache time",
      "explanation": "React Query manages server state with automatic caching, background refetching, and request deduplication, reducing boilerplate and providing better UX through stale-while-revalidate pattern.",
      "difficulty": "Medium",
      "code": "// Installation: npm install @tanstack/react-query\nimport React from 'react';\nimport { View, Text, Button } from 'react-native';\nimport {\n  QueryClient,\n  QueryClientProvider,\n  useQuery,\n  useMutation,\n  useQueryClient\n} from '@tanstack/react-query';\n\nconst queryClient = new QueryClient();\n\n// Fetch function\nconst fetchUser = async (userId) => {\n  const response = await fetch(`https://api.example.com/users/${userId}`);\n  if (!response.ok) throw new Error('Network error');\n  return response.json();\n};\n\nfunction UserProfile({ userId }) {\n  // Query with caching\n  const { data, isLoading, error, refetch } = useQuery({\n    queryKey: ['user', userId],\n    queryFn: () => fetchUser(userId),\n    staleTime: 5 * 60 * 1000, // 5 minutes\n    cacheTime: 10 * 60 * 1000, // 10 minutes\n    retry: 3\n  });\n  \n  if (isLoading) return <Text>Loading...</Text>;\n  if (error) return <Text>Error: {error.message}</Text>;\n  \n  return (\n    <View>\n      <Text>{data.name}</Text>\n      <Button title=\"Refetch\" onPress={refetch} />\n    </View>\n  );\n}\n\n// Mutation example\nfunction UpdateUser() {\n  const queryClient = useQueryClient();\n  \n  const mutation = useMutation({\n    mutationFn: (newUser) => {\n      return fetch('https://api.example.com/users', {\n        method: 'POST',\n        body: JSON.stringify(newUser)\n      });\n    },\n    onSuccess: () => {\n      queryClient.invalidateQueries(['user']);\n    }\n  });\n  \n  return (\n    <Button\n      title=\"Update\"\n      onPress={() => mutation.mutate({ name: 'John' })}\n    />\n  );\n}\n\nfunction App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <UserProfile userId={1} />\n    </QueryClientProvider>\n  );\n}"
    },
    {
      "id": 43,
      "question": "How do you handle images in React Native?",
      "answer": "React Native provides the Image component for displaying images from various sources.\n\nImage Sources:\n• Local images - require() for bundled images\n• Network images - URI from remote server\n• Base64 images - inline data URIs\n• Native image assets - platform-specific\n\nImage Component Features:\n• resizeMode - how image fits container (cover, contain, stretch, repeat, center)\n• Loading indicators\n• Error handling with onError\n• Progress tracking with onProgress\n• Cache control\n• Multiple image formats (PNG, JPG, GIF, WebP)\n\nOptimization:\n• Use appropriate image sizes\n• Enable caching\n• Use WebP format\n• Lazy load images\n• Use image optimization libraries\n• Use react-native-fast-image for better performance\n\nCommon Issues:\n• Android requires specific sizes\n• iOS caching behavior",
      "explanation": "The Image component displays images from local or network sources with resizeMode options, supporting caching, loading states, and optimization techniques for performance.",
      "difficulty": "Easy",
      "code": "import React, { useState } from 'react';\nimport { View, Image, ActivityIndicator, StyleSheet } from 'react-native';\n\nfunction ImageExample() {\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(false);\n  \n  return (\n    <View style={styles.container}>\n      {/* Local image */}\n      <Image\n        source={require('./assets/logo.png')}\n        style={styles.image}\n        resizeMode=\"contain\"\n      />\n      \n      {/* Network image */}\n      <Image\n        source={{ uri: 'https://example.com/image.jpg' }}\n        style={styles.image}\n        resizeMode=\"cover\"\n        onLoadStart={() => setLoading(true)}\n        onLoadEnd={() => setLoading(false)}\n        onError={() => setError(true)}\n      />\n      \n      {/* With cache control */}\n      <Image\n        source={{\n          uri: 'https://example.com/image.jpg',\n          cache: 'force-cache',\n          headers: {\n            Authorization: 'Bearer token'\n          }\n        }}\n        style={styles.image}\n      />\n      \n      {/* Background image */}\n      <ImageBackground\n        source={{ uri: 'https://example.com/bg.jpg' }}\n        style={styles.background}\n        resizeMode=\"cover\"\n      >\n        {/* Content here */}\n      </ImageBackground>\n      \n      {loading && <ActivityIndicator style={styles.loader} />}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  image: {\n    width: 200,\n    height: 200\n  },\n  background: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center'\n  },\n  loader: {\n    position: 'absolute'\n  }\n});"
    },
    {
      "id": 44,
      "question": "What is React Native Fast Image and when should you use it?",
      "answer": "React Native Fast Image is a high-performance image component that provides better caching and performance than the default Image component.\n\nFeatures:\n• Aggressive caching strategy\n• Priority-based loading\n• Better memory management\n• Preloading support\n• Auth headers support\n• Loading and error states\n• Progress tracking\n• GIF support\n• Border radius support\n• Blur placeholder (iOS)\n\nAdvantages over Image:\n• Better cache control\n• Faster image loading\n• Lower memory usage\n• Smoother scrolling in lists\n• More predictable caching\n• Better error handling\n\nWhen to Use:\n• Many images in lists\n• Need better caching control\n• Performance-critical scenarios\n• Images from authenticated sources\n• Need preloading\n• Better memory management needed",
      "explanation": "Fast Image is a performant alternative to the default Image component with aggressive caching, priority loading, and better memory management, ideal for lists with many images.",
      "difficulty": "Medium",
      "code": "// Installation: npm install react-native-fast-image\nimport FastImage from 'react-native-fast-image';\nimport React from 'react';\nimport { View, StyleSheet } from 'react-native';\n\nfunction FastImageExample() {\n  return (\n    <View style={styles.container}>\n      {/* Basic usage */}\n      <FastImage\n        style={styles.image}\n        source={{\n          uri: 'https://example.com/image.jpg',\n          priority: FastImage.priority.high,\n          cache: FastImage.cacheControl.immutable\n        }}\n        resizeMode={FastImage.resizeMode.cover}\n      />\n      \n      {/* With auth headers */}\n      <FastImage\n        style={styles.image}\n        source={{\n          uri: 'https://example.com/private.jpg',\n          headers: { Authorization: 'Bearer token' },\n          priority: FastImage.priority.normal\n        }}\n      />\n      \n      {/* With loading states */}\n      <FastImage\n        style={styles.image}\n        source={{ uri: 'https://example.com/image.jpg' }}\n        onLoadStart={() => console.log('Started')}\n        onProgress={(e) => console.log(e.nativeEvent.loaded / e.nativeEvent.total)}\n        onLoad={() => console.log('Loaded')}\n        onError={() => console.log('Error')}\n      />\n    </View>\n  );\n}\n\n// Preload images\nFastImage.preload([\n  {\n    uri: 'https://example.com/image1.jpg',\n    priority: FastImage.priority.high\n  },\n  {\n    uri: 'https://example.com/image2.jpg'\n  }\n]);\n\n// Clear cache\nFastImage.clearMemoryCache();\nFastImage.clearDiskCache();\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  image: { width: 200, height: 200 }\n});"
    },
    {
      "id": 45,
      "question": "How do you implement form validation in React Native?",
      "answer": "Form validation ensures user input meets requirements before submission.\n\nValidation Approaches:\n• Manual validation with state\n• Form libraries (Formik, React Hook Form)\n• Validation schemas (Yup, Zod)\n• Real-time vs on-submit validation\n• Field-level vs form-level validation\n\nCommon Validations:\n• Required fields\n• Email format\n• Password strength\n• Number ranges\n• String length\n• Pattern matching (regex)\n• Custom validation logic\n• Async validation (API calls)\n\nBest Practices:\n• Show errors clearly\n• Validate on blur or change\n• Disable submit until valid\n• Provide helpful error messages\n• Use validation libraries\n• Handle async validation\n• Accessibility for errors",
      "explanation": "Form validation ensures data integrity using manual state checks or libraries like Formik with Yup schemas, validating fields in real-time or on submission with clear error messaging.",
      "difficulty": "Medium",
      "code": "// Installation: npm install formik yup\nimport React from 'react';\nimport { View, TextInput, Button, Text, StyleSheet } from 'react-native';\nimport { Formik } from 'formik';\nimport * as Yup from 'yup';\n\n// Validation schema\nconst LoginSchema = Yup.object().shape({\n  email: Yup.string()\n    .email('Invalid email')\n    .required('Email is required'),\n  password: Yup.string()\n    .min(8, 'Password too short')\n    .matches(/[A-Z]/, 'Must contain uppercase')\n    .required('Password is required')\n});\n\nfunction LoginForm() {\n  const handleSubmit = (values) => {\n    console.log('Submitting:', values);\n  };\n  \n  return (\n    <Formik\n      initialValues={{ email: '', password: '' }}\n      validationSchema={LoginSchema}\n      onSubmit={handleSubmit}\n    >\n      {({ handleChange, handleBlur, handleSubmit, values, errors, touched }) => (\n        <View style={styles.form}>\n          <TextInput\n            style={styles.input}\n            placeholder=\"Email\"\n            value={values.email}\n            onChangeText={handleChange('email')}\n            onBlur={handleBlur('email')}\n            keyboardType=\"email-address\"\n            autoCapitalize=\"none\"\n          />\n          {touched.email && errors.email && (\n            <Text style={styles.error}>{errors.email}</Text>\n          )}\n          \n          <TextInput\n            style={styles.input}\n            placeholder=\"Password\"\n            value={values.password}\n            onChangeText={handleChange('password')}\n            onBlur={handleBlur('password')}\n            secureTextEntry\n          />\n          {touched.password && errors.password && (\n            <Text style={styles.error}>{errors.password}</Text>\n          )}\n          \n          <Button title=\"Submit\" onPress={handleSubmit} />\n        </View>\n      )}\n    </Formik>\n  );\n}\n\nconst styles = StyleSheet.create({\n  form: { padding: 20 },\n  input: {\n    borderWidth: 1,\n    borderColor: '#ddd',\n    padding: 10,\n    marginBottom: 10\n  },\n  error: { color: 'red', marginBottom: 10 }\n});"
    },
    {
      "id": 51,
      "question": "How do you debug React Native applications?",
      "answer": "React Native provides multiple debugging tools and techniques for troubleshooting.\n\nDebugging Tools:\n• React Native Debugger - standalone app with Redux DevTools\n• Chrome DevTools - network, console, sources\n• Flipper - official debugging platform\n• React DevTools - component hierarchy\n• Console logging\n• Reactotron - custom debugging tool\n\nDebugging Methods:\n• Enable Debug Mode (Cmd+D iOS, Cmd+M Android)\n• Remote JS Debugging\n• Element Inspector\n• Performance Monitor\n• Network Inspector\n• Breakpoints in VSCode\n\nCommon Issues:\n• Metro bundler not running\n• Port conflicts\n• Cache issues (clear with --reset-cache)\n• Native module linking problems\n• Version mismatches\n\nProduction Debugging:\n• Error tracking (Sentry, Bugsnag)\n• Crash reporting\n• Analytics integration",
      "explanation": "React Native debugging uses tools like Flipper, Chrome DevTools, and React Native Debugger for inspecting components, network requests, and performance with console logs and breakpoints.",
      "difficulty": "Medium",
      "code": "// Console logging\nconsole.log('Debug message');\nconsole.warn('Warning message');\nconsole.error('Error message');\nconsole.table(data);\n\n// Conditional logging\nif (__DEV__) {\n  console.log('Development mode');\n}\n\n// Performance measurement\nconst start = performance.now();\n// Code to measure\nconst end = performance.now();\nconsole.log(`Execution time: ${end - start}ms`);\n\n// VSCode debugging (launch.json)\n/*\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"Debug Android\",\n      \"cwd\": \"${workspaceFolder}\",\n      \"type\": \"reactnative\",\n      \"request\": \"launch\",\n      \"platform\": \"android\"\n    },\n    {\n      \"name\": \"Debug iOS\",\n      \"cwd\": \"${workspaceFolder}\",\n      \"type\": \"reactnative\",\n      \"request\": \"launch\",\n      \"platform\": \"ios\"\n    }\n  ]\n}\n*/\n\n// Error boundary with logging\nimport { Component } from 'react';\n\nclass ErrorBoundary extends Component {\n  componentDidCatch(error, errorInfo) {\n    // Log to error tracking service\n    logErrorToService(error, errorInfo);\n  }\n  \n  render() {\n    return this.props.children;\n  }\n}\n\n// Network debugging\nglobal.XMLHttpRequest = global.originalXMLHttpRequest || global.XMLHttpRequest;\nglobal.FormData = global.originalFormData || global.FormData;\n\n// Clear cache command\n// npm start -- --reset-cache"
    },
    {
      "id": 52,
      "question": "What are the different ways to style React Native components?",
      "answer": "React Native offers multiple styling approaches for component design.\n\nStyling Methods:\n• StyleSheet.create() - optimized style objects\n• Inline styles - direct style objects\n• Style arrays - combine multiple styles\n• Styled Components - CSS-in-JS library\n• Tailwind CSS (NativeWind) - utility-first CSS\n• Style functions - dynamic styles\n\nStyleSheet Benefits:\n• Performance optimization\n• Validation and error checking\n• Code completion in IDEs\n• Reduced re-renders\n• Named styles for debugging\n\nDynamic Styling:\n• Conditional styles\n• Props-based styles\n• State-based styles\n• Theme-based styling\n• Responsive styles\n\nStyle Composition:\n• Array of styles\n• Style inheritance (Text only)\n• Platform-specific styles\n• Overriding styles",
      "explanation": "React Native styling uses StyleSheet.create for optimized styles, inline objects, style arrays for composition, or libraries like Styled Components, with support for dynamic and platform-specific styling.",
      "difficulty": "Easy",
      "code": "import React from 'react';\nimport { View, Text, StyleSheet, Platform } from 'react-native';\nimport styled from 'styled-components/native';\n\n// 1. StyleSheet.create()\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    padding: 20,\n    backgroundColor: '#f5f5f5'\n  },\n  text: {\n    fontSize: 16,\n    color: '#333'\n  }\n});\n\n// 2. Inline styles\nfunction InlineExample() {\n  return <View style={{ padding: 20, backgroundColor: 'blue' }} />;\n}\n\n// 3. Style arrays\nfunction ArrayExample({ isActive }) {\n  return (\n    <View style={[styles.container, isActive && { backgroundColor: 'green' }]} />\n  );\n}\n\n// 4. Styled Components\nconst Container = styled.View`\n  flex: 1;\n  padding: 20px;\n  background-color: ${props => props.active ? 'green' : 'blue'};\n`;\n\nconst StyledText = styled.Text`\n  font-size: 16px;\n  color: #333;\n`;\n\n// 5. Platform-specific styles\nconst platformStyles = StyleSheet.create({\n  container: {\n    padding: Platform.OS === 'ios' ? 20 : 15,\n    ...Platform.select({\n      ios: {\n        shadowColor: '#000',\n        shadowOffset: { width: 0, height: 2 },\n        shadowOpacity: 0.25\n      },\n      android: {\n        elevation: 5\n      }\n    })\n  }\n});\n\n// 6. Dynamic styles\nfunction DynamicExample({ size, color }) {\n  const dynamicStyles = StyleSheet.create({\n    box: {\n      width: size,\n      height: size,\n      backgroundColor: color\n    }\n  });\n  \n  return <View style={dynamicStyles.box} />;\n}"
    },
    {
      "id": 53,
      "question": "What is Expo and how does it differ from bare React Native?",
      "answer": "Expo is a framework and platform for React Native that simplifies development and deployment.\n\nExpo Features:\n• Managed workflow - no native code\n• Over-the-air updates\n• Easy native module access\n• Built-in components and APIs\n• Expo Go app for testing\n• EAS Build for cloud builds\n• EAS Submit for app stores\n• Development client for custom native code\n\nExpo vs Bare React Native:\n• Expo has managed workflow, bare requires native setup\n• Expo limits custom native modules, bare allows any\n• Expo easier to start, bare more flexible\n• Expo provides many built-in APIs\n• Expo larger bundle size\n• Expo supports OTA updates easily\n• Can eject Expo to bare workflow\n\nWhen to Use Expo:\n• Rapid prototyping\n• Standard features sufficient\n• No custom native modules needed\n• Want easy updates",
      "explanation": "Expo is a managed React Native framework providing built-in APIs, development tools, and OTA updates without native code, differing from bare React Native which requires native setup but offers more flexibility.",
      "difficulty": "Medium",
      "code": "// Expo managed workflow project creation\n// npx create-expo-app my-app\n\n// app.json configuration\n/*\n{\n  \"expo\": {\n    \"name\": \"My App\",\n    \"slug\": \"my-app\",\n    \"version\": \"1.0.0\",\n    \"orientation\": \"portrait\",\n    \"icon\": \"./assets/icon.png\",\n    \"splash\": {\n      \"image\": \"./assets/splash.png\",\n      \"resizeMode\": \"contain\",\n      \"backgroundColor\": \"#ffffff\"\n    },\n    \"updates\": {\n      \"fallbackToCacheTimeout\": 0,\n      \"url\": \"https://u.expo.dev/your-project-id\"\n    },\n    \"ios\": {\n      \"supportsTablet\": true,\n      \"bundleIdentifier\": \"com.yourcompany.myapp\"\n    },\n    \"android\": {\n      \"package\": \"com.yourcompany.myapp\"\n    }\n  }\n}\n*/\n\n// Using Expo APIs\nimport * as Location from 'expo-location';\nimport * as Camera from 'expo-camera';\nimport * as ImagePicker from 'expo-image-picker';\nimport * as Notifications from 'expo-notifications';\n\nasync function useExpoAPIs() {\n  // Location\n  const { status } = await Location.requestForegroundPermissionsAsync();\n  const location = await Location.getCurrentPositionAsync({});\n  \n  // Camera\n  const { status: cameraStatus } = await Camera.requestCameraPermissionsAsync();\n  \n  // Image Picker\n  const result = await ImagePicker.launchImageLibraryAsync({\n    mediaTypes: ImagePicker.MediaTypeOptions.Images,\n    quality: 1\n  });\n}\n\n// Ejecting to bare workflow\n// npx expo prebuild\n// This creates ios/ and android/ folders"
    },
    {
      "id": 54,
      "question": "How do you handle app permissions in React Native?",
      "answer": "React Native requires requesting runtime permissions for accessing sensitive device features.\n\niOS Permissions:\n• Declared in Info.plist\n• Request at runtime with permission APIs\n• User grants or denies\n• Once denied, must go to settings\n\nAndroid Permissions:\n• Declared in AndroidManifest.xml\n• Runtime permissions for dangerous permissions\n• Can request again if denied\n• Different behavior on Android 6.0+\n\nCommon Permissions:\n• Camera access\n• Photo library access\n• Location services\n• Microphone access\n• Contacts access\n• Calendar access\n• Push notifications\n• Storage access\n\nLibraries:\n• react-native-permissions - unified API\n• PermissionsAndroid (Android only, built-in)\n• expo-permissions (Expo)",
      "explanation": "React Native permissions are declared in native configuration files and requested at runtime using permission APIs or libraries like react-native-permissions, with different handling for iOS and Android.",
      "difficulty": "Medium",
      "code": "// Installation: npm install react-native-permissions\nimport { check, request, PERMISSIONS, RESULTS } from 'react-native-permissions';\nimport { Platform, Alert } from 'react-native';\n\n// Request camera permission\nasync function requestCameraPermission() {\n  try {\n    const permission = Platform.select({\n      ios: PERMISSIONS.IOS.CAMERA,\n      android: PERMISSIONS.ANDROID.CAMERA\n    });\n    \n    const result = await check(permission);\n    \n    if (result === RESULTS.DENIED) {\n      const requestResult = await request(permission);\n      return requestResult === RESULTS.GRANTED;\n    }\n    \n    if (result === RESULTS.BLOCKED) {\n      Alert.alert(\n        'Permission Denied',\n        'Please enable camera access in settings',\n        [{ text: 'OK' }]\n      );\n      return false;\n    }\n    \n    return result === RESULTS.GRANTED;\n  } catch (error) {\n    console.error(error);\n    return false;\n  }\n}\n\n// Android built-in API\nimport { PermissionsAndroid } from 'react-native';\n\nasync function requestAndroidPermission() {\n  try {\n    const granted = await PermissionsAndroid.request(\n      PermissionsAndroid.PERMISSIONS.CAMERA,\n      {\n        title: 'Camera Permission',\n        message: 'App needs camera access',\n        buttonNeutral: 'Ask Me Later',\n        buttonNegative: 'Cancel',\n        buttonPositive: 'OK'\n      }\n    );\n    return granted === PermissionsAndroid.RESULTS.GRANTED;\n  } catch (err) {\n    console.error(err);\n    return false;\n  }\n}\n\n// iOS Info.plist\n/*\n<key>NSCameraUsageDescription</key>\n<string>We need camera access to take photos</string>\n<key>NSPhotoLibraryUsageDescription</key>\n<string>We need photo library access</string>\n<key>NSLocationWhenInUseUsageDescription</key>\n<string>We need location to show nearby places</string>\n*/\n\n// Android AndroidManifest.xml\n/*\n<uses-permission android:name=\"android.permission.CAMERA\" />\n<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n<uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\n*/"
    },
    {
      "id": 55,
      "question": "What is React Native WebView and when should you use it?",
      "answer": "WebView is a component that renders web content within a native app.\n\nFeatures:\n• Display web pages\n• Execute JavaScript\n• Inject custom CSS/JS\n• Handle navigation\n• Post messages between web and native\n• File upload support\n• Cookie management\n• Custom user agent\n\nCommon Use Cases:\n• Display terms and conditions\n• OAuth authentication flows\n• Payment gateways\n• Third-party content\n• Hybrid web/native apps\n• Legacy web content integration\n• Quick prototyping\n\nConsiderations:\n• Performance slower than native\n• Limited native features\n• Styling challenges\n• Debugging complexity\n• Security concerns\n• Better alternatives exist for most cases\n\nAlternatives:\n• Native implementation preferred\n• React Native components\n• Deep linking\n• Native modules",
      "explanation": "WebView renders web content in native apps using react-native-webview, supporting JavaScript injection and native-web communication, useful for OAuth flows, payments, and displaying web content.",
      "difficulty": "Medium",
      "code": "// Installation: npm install react-native-webview\nimport React, { useRef } from 'react';\nimport { View, Button } from 'react-native';\nimport WebView from 'react-native-webview';\n\nfunction WebViewExample() {\n  const webViewRef = useRef(null);\n  \n  // Inject JavaScript\n  const injectedJavaScript = `\n    document.body.style.backgroundColor = 'lightblue';\n    window.ReactNativeWebView.postMessage('Hello from WebView');\n  `;\n  \n  // Handle messages from WebView\n  const onMessage = (event) => {\n    const data = event.nativeEvent.data;\n    console.log('Message from WebView:', data);\n  };\n  \n  // Run JavaScript\n  const runJS = () => {\n    webViewRef.current?.injectJavaScript(`\n      alert('Hello from React Native');\n    `);\n  };\n  \n  return (\n    <View style={{ flex: 1 }}>\n      <WebView\n        ref={webViewRef}\n        source={{ uri: 'https://example.com' }}\n        injectedJavaScript={injectedJavaScript}\n        onMessage={onMessage}\n        onNavigationStateChange={(navState) => {\n          console.log('Navigation:', navState.url);\n        }}\n        onLoad={() => console.log('Loaded')}\n        onError={(syntheticEvent) => {\n          const { nativeEvent } = syntheticEvent;\n          console.error('Error:', nativeEvent);\n        }}\n        javaScriptEnabled={true}\n        domStorageEnabled={true}\n        startInLoadingState={true}\n        scalesPageToFit={true}\n      />\n      <Button title=\"Run JS\" onPress={runJS} />\n    </View>\n  );\n}\n\n// HTML string\nconst htmlContent = `\n  <!DOCTYPE html>\n  <html>\n    <body>\n      <h1>Hello from HTML</h1>\n      <button onclick=\"window.ReactNativeWebView.postMessage('Button clicked')\">Click Me</button>\n    </body>\n  </html>\n`;\n\nfunction HTMLWebView() {\n  return <WebView source={{ html: htmlContent }} />;\n}"
    },
    {
      "id": 46,
      "question": "What is Testing in React Native and what are the testing approaches?",
      "answer": "Testing ensures code quality and prevents regressions in React Native applications.\n\nTesting Types:\n• Unit Tests - test individual functions/components\n• Integration Tests - test component interactions\n• End-to-End Tests - test complete user flows\n• Snapshot Tests - detect UI changes\n• Component Tests - test React components\n\nTesting Libraries:\n• Jest - JavaScript testing framework\n• React Native Testing Library - component testing\n• Detox - E2E testing framework\n• Enzyme - component testing (legacy)\n• Appium - cross-platform E2E testing\n\nBest Practices:\n• Test user behavior not implementation\n• Mock external dependencies\n• Use data-testid for reliable selectors\n• Test accessibility\n• Keep tests fast and isolated\n• Mock navigation\n• Test error states\n• Use test coverage tools",
      "explanation": "React Native testing includes unit, integration, and E2E tests using Jest, React Native Testing Library, and Detox, focusing on user behavior and component interactions with proper mocking.",
      "difficulty": "Medium",
      "code": "// Installation: npm install --save-dev @testing-library/react-native jest\n\nimport React from 'react';\nimport { render, fireEvent, waitFor } from '@testing-library/react-native';\nimport { Text, Button, TextInput } from 'react-native';\n\n// Component to test\nfunction Counter() {\n  const [count, setCount] = React.useState(0);\n  \n  return (\n    <>\n      <Text testID=\"count-text\">Count: {count}</Text>\n      <Button\n        testID=\"increment-button\"\n        title=\"Increment\"\n        onPress={() => setCount(c => c + 1)}\n      />\n    </>\n  );\n}\n\n// Unit test\ndescribe('Counter', () => {\n  it('renders initial count', () => {\n    const { getByTestId } = render(<Counter />);\n    expect(getByTestId('count-text')).toHaveTextContent('Count: 0');\n  });\n  \n  it('increments count on button press', () => {\n    const { getByTestId } = render(<Counter />);\n    const button = getByTestId('increment-button');\n    \n    fireEvent.press(button);\n    expect(getByTestId('count-text')).toHaveTextContent('Count: 1');\n  });\n});\n\n// Async test with data fetching\nfunction UserProfile({ userId }) {\n  const [user, setUser] = React.useState(null);\n  const [loading, setLoading] = React.useState(true);\n  \n  React.useEffect(() => {\n    fetch(`/api/users/${userId}`)\n      .then(r => r.json())\n      .then(data => {\n        setUser(data);\n        setLoading(false);\n      });\n  }, [userId]);\n  \n  if (loading) return <Text testID=\"loading\">Loading...</Text>;\n  return <Text testID=\"username\">{user.name}</Text>;\n}\n\n// Mocking fetch\nglobal.fetch = jest.fn();\n\ndescribe('UserProfile', () => {\n  it('loads and displays user data', async () => {\n    fetch.mockResolvedValueOnce({\n      json: async () => ({ name: 'John Doe' })\n    });\n    \n    const { getByTestId, queryByTestId } = render(<UserProfile userId={1} />);\n    \n    expect(getByTestId('loading')).toBeTruthy();\n    \n    await waitFor(() => {\n      expect(queryByTestId('loading')).toBeNull();\n      expect(getByTestId('username')).toHaveTextContent('John Doe');\n    });\n  });\n});\n\n// Snapshot test\nit('matches snapshot', () => {\n  const tree = render(<Counter />).toJSON();\n  expect(tree).toMatchSnapshot();\n});"
    },
    {
      "id": 47,
      "question": "What is Detox and how do you write E2E tests?",
      "answer": "Detox is a gray-box end-to-end testing framework for React Native apps.\n\nKey Features:\n• Cross-platform (iOS and Android)\n• Gray-box testing (app internals knowledge)\n• Automatic synchronization\n• No flaky tests\n• Test on simulators and devices\n• Supports CI/CD integration\n• Fast execution\n• Debugging support\n\nHow It Works:\n• Runs app in test mode\n• Executes test scenarios\n• Interacts with UI elements\n• Waits for app to be idle\n• Takes screenshots on failure\n• Provides detailed logs\n\nTest Structure:\n• beforeAll - setup\n• beforeEach - per-test setup\n• it - test case\n• afterEach - cleanup\n• afterAll - teardown\n\nCommon Actions:\n• tap, longPress, multiTap\n• typeText, clearText\n• scroll, swipe\n• waitFor - element visibility\n• expect - assertions",
      "explanation": "Detox is an E2E testing framework providing gray-box testing with automatic synchronization, supporting iOS and Android with actions like tap, scroll, and waitFor for reliable automated testing.",
      "difficulty": "Hard",
      "code": "// Installation:\n// npm install --save-dev detox jest\n\n// .detoxrc.json\n/*\n{\n  \"testRunner\": \"jest\",\n  \"runnerConfig\": \"e2e/config.json\",\n  \"apps\": {\n    \"ios\": {\n      \"type\": \"ios.app\",\n      \"binaryPath\": \"ios/build/Build/Products/Debug-iphonesimulator/MyApp.app\",\n      \"build\": \"xcodebuild -workspace ios/MyApp.xcworkspace -scheme MyApp -configuration Debug -sdk iphonesimulator -derivedDataPath ios/build\"\n    },\n    \"android\": {\n      \"type\": \"android.apk\",\n      \"binaryPath\": \"android/app/build/outputs/apk/debug/app-debug.apk\",\n      \"build\": \"cd android && ./gradlew assembleDebug assembleAndroidTest -DtestBuildType=debug\"\n    }\n  },\n  \"devices\": {\n    \"simulator\": {\n      \"type\": \"ios.simulator\",\n      \"device\": {\n        \"type\": \"iPhone 14\"\n      }\n    },\n    \"emulator\": {\n      \"type\": \"android.emulator\",\n      \"device\": {\n        \"avdName\": \"Pixel_4_API_30\"\n      }\n    }\n  },\n  \"configurations\": {\n    \"ios\": {\n      \"device\": \"simulator\",\n      \"app\": \"ios\"\n    },\n    \"android\": {\n      \"device\": \"emulator\",\n      \"app\": \"android\"\n    }\n  }\n}\n*/\n\n// e2e/firstTest.e2e.js\ndescribe('Login Flow', () => {\n  beforeAll(async () => {\n    await device.launchApp();\n  });\n  \n  beforeEach(async () => {\n    await device.reloadReactNative();\n  });\n  \n  it('should login successfully', async () => {\n    // Type email\n    await element(by.id('emailInput')).typeText('user@example.com');\n    \n    // Type password\n    await element(by.id('passwordInput')).typeText('password123');\n    \n    // Tap login button\n    await element(by.id('loginButton')).tap();\n    \n    // Wait for home screen\n    await waitFor(element(by.id('homeScreen')))\n      .toBeVisible()\n      .withTimeout(5000);\n    \n    // Assert welcome message\n    await expect(element(by.text('Welcome'))).toBeVisible();\n  });\n  \n  it('should scroll and tap item', async () => {\n    // Scroll to element\n    await element(by.id('scrollView')).scrollTo('bottom');\n    \n    // Swipe\n    await element(by.id('card')).swipe('left');\n    \n    // Long press\n    await element(by.id('item')).longPress();\n  });\n  \n  it('should handle errors', async () => {\n    await element(by.id('emailInput')).typeText('invalid');\n    await element(by.id('loginButton')).tap();\n    \n    await expect(element(by.text('Invalid email'))).toBeVisible();\n  });\n});\n\n// Run tests:\n// detox test --configuration ios\n// detox test --configuration android"
    },
    {
      "id": 48,
      "question": "What is Continuous Integration/Deployment (CI/CD) for React Native?",
      "answer": "CI/CD automates building, testing, and deploying React Native apps.\n\nPopular CI/CD Platforms:\n• GitHub Actions - integrated with GitHub\n• Bitrise - mobile-focused\n• CircleCI - flexible pipelines\n• Fastlane - iOS/Android automation\n• App Center - Microsoft's solution\n• Jenkins - self-hosted\n• GitLab CI - integrated with GitLab\n\nCI/CD Pipeline Stages:\n• Code checkout\n• Dependency installation\n• Linting and formatting\n• Unit tests\n• Build app\n• E2E tests\n• Deploy to test environments\n• Release to app stores\n\nCommon Tasks:\n• Automated testing\n• Code signing (iOS)\n• Version bumping\n• Changelog generation\n• Beta distribution (TestFlight, Firebase App Distribution)\n• App store submission\n• OTA updates\n\nTools:\n• Fastlane - automate builds and releases\n• EAS Build - Expo's build service",
      "explanation": "CI/CD automates React Native app building, testing, and deployment using platforms like GitHub Actions or Bitrise, with Fastlane for release automation and app store submissions.",
      "difficulty": "Hard",
      "code": "// .github/workflows/ci.yml (GitHub Actions)\nname: CI\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n      \n      - name: Install dependencies\n        run: npm ci\n      \n      - name: Lint\n        run: npm run lint\n      \n      - name: Test\n        run: npm test -- --coverage\n      \n      - name: Upload coverage\n        uses: codecov/codecov-action@v3\n  \n  build-android:\n    runs-on: ubuntu-latest\n    needs: test\n    \n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Setup Java\n        uses: actions/setup-java@v3\n        with:\n          distribution: 'zulu'\n          java-version: '11'\n      \n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n      \n      - name: Install dependencies\n        run: npm ci\n      \n      - name: Build Android\n        run: |\n          cd android\n          ./gradlew assembleRelease\n      \n      - name: Upload APK\n        uses: actions/upload-artifact@v3\n        with:\n          name: app-release.apk\n          path: android/app/build/outputs/apk/release/\n  \n  build-ios:\n    runs-on: macos-latest\n    needs: test\n    \n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n      \n      - name: Install dependencies\n        run: npm ci\n      \n      - name: Install CocoaPods\n        run: |\n          cd ios\n          pod install\n      \n      - name: Build iOS\n        run: |\n          cd ios\n          xcodebuild -workspace MyApp.xcworkspace \\\n            -scheme MyApp \\\n            -configuration Release \\\n            -archivePath MyApp.xcarchive \\\n            archive\n\n// Fastlane configuration (fastlane/Fastfile)\ndefault_platform(:ios)\n\nplatform :ios do\n  desc \"Build and upload to TestFlight\"\n  lane :beta do\n    increment_build_number\n    build_app(scheme: \"MyApp\")\n    upload_to_testflight\n  end\nend\n\nplatform :android do\n  desc \"Build and upload to Play Store\"\n  lane :beta do\n    gradle(task: \"clean assembleRelease\")\n    upload_to_play_store(track: \"beta\")\n  end\nend"
    },
    {
      "id": 49,
      "question": "What is App Signing and how does it work for iOS and Android?",
      "answer": "App signing cryptographically signs your app to verify its authenticity and integrity.\n\niOS Signing:\n• Requires Apple Developer account\n• Uses certificates and provisioning profiles\n• Development, Ad Hoc, App Store profiles\n• Automatic signing with Xcode\n• Manual signing for complex setups\n• Certificates expire and need renewal\n• Different profiles for different environments\n\nAndroid Signing:\n• Uses keystore file (.jks or .keystore)\n• Same keystore for all app versions\n• Debug keystore for development\n• Release keystore for production\n• Must keep keystore secure and backed up\n• Google Play App Signing recommended\n• SHA-256 fingerprint for services\n\nBest Practices:\n• Never commit keystores to version control\n• Use CI/CD secrets for credentials\n• Backup signing keys securely\n• Use different keys for debug/release\n• Document signing process\n• Use App Store Connect API",
      "explanation": "App signing verifies app authenticity using certificates and provisioning profiles on iOS, and keystore files on Android, requiring secure storage and management of signing credentials.",
      "difficulty": "Hard",
      "code": "// Android signing configuration (android/app/build.gradle)\nandroid {\n    signingConfigs {\n        debug {\n            storeFile file('debug.keystore')\n            storePassword 'android'\n            keyAlias 'androiddebugkey'\n            keyPassword 'android'\n        }\n        release {\n            if (project.hasProperty('MYAPP_RELEASE_STORE_FILE')) {\n                storeFile file(MYAPP_RELEASE_STORE_FILE)\n                storePassword MYAPP_RELEASE_STORE_PASSWORD\n                keyAlias MYAPP_RELEASE_KEY_ALIAS\n                keyPassword MYAPP_RELEASE_KEY_PASSWORD\n            }\n        }\n    }\n    \n    buildTypes {\n        debug {\n            signingConfig signingConfigs.debug\n        }\n        release {\n            signingConfig signingConfigs.release\n            minifyEnabled true\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\n// gradle.properties (not in version control)\nMYAPP_RELEASE_STORE_FILE=my-release-key.keystore\nMYAPP_RELEASE_KEY_ALIAS=my-key-alias\nMYAPP_RELEASE_STORE_PASSWORD=***\nMYAPP_RELEASE_KEY_PASSWORD=***\n\n// Generate Android keystore\n/*\nkeytool -genkeypair -v -storetype PKCS12 \\\n  -keystore my-release-key.keystore \\\n  -alias my-key-alias \\\n  -keyalg RSA \\\n  -keysize 2048 \\\n  -validity 10000\n*/\n\n// iOS automatic signing (Xcode project)\n/*\n1. Open project in Xcode\n2. Select target > Signing & Capabilities\n3. Enable \"Automatically manage signing\"\n4. Select team\n5. Xcode handles certificates and profiles\n*/\n\n// iOS manual signing (Export Options)\n/*\nexportOptions.plist:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"...\">\n<plist version=\"1.0\">\n<dict>\n    <key>method</key>\n    <string>app-store</string>\n    <key>teamID</key>\n    <string>YOUR_TEAM_ID</string>\n    <key>provisioningProfiles</key>\n    <dict>\n        <key>com.yourcompany.yourapp</key>\n        <string>YOUR_PROVISIONING_PROFILE_NAME</string>\n    </dict>\n</dict>\n</plist>\n*/\n\n// Fastlane signing (Matchfile)\n/*\ngit_url(\"https://github.com/yourcompany/certificates\")\napp_identifier([\"com.yourcompany.yourapp\"])\nusername(\"your@email.com\")\n\n# Run: fastlane match appstore\n*/"
    },
    {
      "id": 50,
      "question": "How do you handle App Updates and Version Management?",
      "answer": "App updates and versioning ensure users get latest features and fixes.\n\nVersion Management:\n• Semantic versioning (MAJOR.MINOR.PATCH)\n• Version code (Android) - incremental number\n• Build number (iOS) - incremental number\n• Marketing version - user-facing version\n• Update version in package.json, build files\n\nUpdate Strategies:\n• Mandatory updates - force upgrade\n• Optional updates - suggest upgrade\n• Incremental updates - gradual rollout\n• Phased rollouts - percentage-based\n• Beta testing before production\n\nUpdate Mechanisms:\n• App Store updates (full rebuild)\n• Over-the-air updates (JS/assets only)\n• CodePush or EAS Update\n• In-app update prompts\n• Force update for critical fixes\n\nVersion Checking:\n• Check current vs latest version\n• API endpoint for version info\n• Deep linking to app stores\n• Show update dialog",
      "explanation": "App updates use semantic versioning with version codes and build numbers, deployed through app stores for native changes or OTA updates for JavaScript, with strategies for mandatory or optional updates.",
      "difficulty": "Medium",
      "code": "// package.json\n{\n  \"name\": \"MyApp\",\n  \"version\": \"1.2.3\"\n}\n\n// Android versioning (android/app/build.gradle)\nandroid {\n    defaultConfig {\n        applicationId \"com.myapp\"\n        versionCode 4  // Increment for each release\n        versionName \"1.2.3\"  // User-facing version\n    }\n}\n\n// iOS versioning (ios/MyApp/Info.plist)\n/*\n<key>CFBundleShortVersionString</key>\n<string>1.2.3</string>\n<key>CFBundleVersion</key>\n<string>4</string>\n*/\n\n// Version check component\nimport React, { useEffect, useState } from 'react';\nimport { Alert, Linking } from 'react-native';\nimport DeviceInfo from 'react-native-device-info';\n\nfunction VersionChecker() {\n  const [needsUpdate, setNeedsUpdate] = useState(false);\n  \n  useEffect(() => {\n    checkVersion();\n  }, []);\n  \n  const checkVersion = async () => {\n    const currentVersion = DeviceInfo.getVersion();\n    \n    // Fetch latest version from API\n    const response = await fetch('https://api.myapp.com/version');\n    const { latestVersion, minimumVersion, storeUrl } = await response.json();\n    \n    // Check if update needed\n    if (compareVersions(currentVersion, minimumVersion) < 0) {\n      // Mandatory update\n      Alert.alert(\n        'Update Required',\n        'Please update to the latest version',\n        [\n          {\n            text: 'Update',\n            onPress: () => Linking.openURL(storeUrl)\n          }\n        ],\n        { cancelable: false }\n      );\n    } else if (compareVersions(currentVersion, latestVersion) < 0) {\n      // Optional update\n      Alert.alert(\n        'Update Available',\n        'A new version is available. Update now?',\n        [\n          { text: 'Later', style: 'cancel' },\n          {\n            text: 'Update',\n            onPress: () => Linking.openURL(storeUrl)\n          }\n        ]\n      );\n    }\n  };\n  \n  const compareVersions = (v1, v2) => {\n    const parts1 = v1.split('.').map(Number);\n    const parts2 = v2.split('.').map(Number);\n    \n    for (let i = 0; i < 3; i++) {\n      if (parts1[i] > parts2[i]) return 1;\n      if (parts1[i] < parts2[i]) return -1;\n    }\n    return 0;\n  };\n  \n  return null;\n}\n\n// Auto-increment version script (scripts/bump-version.js)\nconst fs = require('fs');\nconst pkg = require('../package.json');\n\nconst [major, minor, patch] = pkg.version.split('.').map(Number);\npkg.version = `${major}.${minor}.${patch + 1}`;\n\nfs.writeFileSync('package.json', JSON.stringify(pkg, null, 2));\nconsole.log(`Version bumped to ${pkg.version}`);\n\n// Run: node scripts/bump-version.js"
    },
    {
      "id": 56,
      "question": "How do you implement dark mode in React Native?",
      "answer": "Dark mode provides a dark color scheme for better viewing in low-light conditions.\n\nImplementation Approaches:\n• React Context for theme state\n• useColorScheme Hook - detect system preference\n• AsyncStorage - persist user preference\n• styled-components theming\n• React Navigation theme integration\n\nTheme Structure:\n• Colors object for light/dark\n• Typography settings\n• Spacing values\n• Component styles\n• Dynamic style updates\n\nBest Practices:\n• Follow system preference by default\n• Allow manual override\n• Persist user choice\n• Smooth transitions\n• Test both themes\n• Use semantic color names\n• Update status bar colors\n• Handle images for both themes\n\nSystem Integration:\n• iOS appearance API\n• Android dark theme\n• Status bar styling",
      "explanation": "Dark mode is implemented using React Context for theme state, useColorScheme to detect system preference, and dynamic styles that switch between light and dark color schemes with persistence.",
      "difficulty": "Medium",
      "code": "import React, { createContext, useContext, useState, useEffect } from 'react';\nimport { useColorScheme, StatusBar, View, Text, Button, StyleSheet } from 'react-native';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\n// Theme definitions\nconst lightTheme = {\n  background: '#FFFFFF',\n  text: '#000000',\n  primary: '#007AFF',\n  card: '#F2F2F7'\n};\n\nconst darkTheme = {\n  background: '#000000',\n  text: '#FFFFFF',\n  primary: '#0A84FF',\n  card: '#1C1C1E'\n};\n\n// Theme Context\nconst ThemeContext = createContext();\n\nexport function ThemeProvider({ children }) {\n  const systemScheme = useColorScheme();\n  const [theme, setTheme] = useState(systemScheme);\n  \n  useEffect(() => {\n    loadTheme();\n  }, []);\n  \n  const loadTheme = async () => {\n    const savedTheme = await AsyncStorage.getItem('theme');\n    if (savedTheme) {\n      setTheme(savedTheme);\n    }\n  };\n  \n  const toggleTheme = async () => {\n    const newTheme = theme === 'light' ? 'dark' : 'light';\n    setTheme(newTheme);\n    await AsyncStorage.setItem('theme', newTheme);\n  };\n  \n  const colors = theme === 'light' ? lightTheme : darkTheme;\n  \n  return (\n    <ThemeContext.Provider value={{ theme, colors, toggleTheme }}>\n      <StatusBar barStyle={theme === 'light' ? 'dark-content' : 'light-content'} />\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\nexport const useTheme = () => useContext(ThemeContext);\n\n// Using the theme\nfunction ThemedComponent() {\n  const { colors, toggleTheme, theme } = useTheme();\n  \n  return (\n    <View style={[styles.container, { backgroundColor: colors.background }]}>\n      <Text style={{ color: colors.text }}>Current Theme: {theme}</Text>\n      <Button title=\"Toggle Theme\" onPress={toggleTheme} color={colors.primary} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, padding: 20, justifyContent: 'center' }\n});"
    },
    {
      "id": 57,
      "question": "What is Internationalization (i18n) and how do you implement it?",
      "answer": "Internationalization (i18n) is the process of making your app support multiple languages and locales.\n\nKey Concepts:\n• Translations for different languages\n• Locale-specific formatting (dates, numbers, currency)\n• RTL (Right-to-Left) language support\n• Pluralization rules\n• Dynamic language switching\n• Fallback languages\n\nCommon Libraries:\n• react-i18next - popular i18n framework\n• react-native-localize - device locale info\n• i18n-js - lightweight alternative\n\nImplementation Steps:\n• Install i18n library\n• Create translation files\n• Configure i18n instance\n• Wrap app with provider\n• Use translation hooks/HOCs\n• Handle language switching\n• Persist language preference\n\nBest Practices:\n• Extract all text strings\n• Use keys not text in code\n• Handle pluralization\n• Format dates/numbers properly\n• Test RTL layouts",
      "explanation": "Internationalization enables multi-language support using libraries like react-i18next, with translation files for each language, locale-specific formatting, and dynamic language switching with persistence.",
      "difficulty": "Medium",
      "code": "// Installation: npm install react-i18next i18next react-native-localize\nimport i18n from 'i18next';\nimport { initReactI18next, useTranslation } from 'react-i18next';\nimport * as RNLocalize from 'react-native-localize';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\n// Translation resources\nconst resources = {\n  en: {\n    translation: {\n      welcome: 'Welcome',\n      hello: 'Hello {{name}}',\n      items: 'You have {{count}} item',\n      items_plural: 'You have {{count}} items',\n      greeting: {\n        morning: 'Good morning',\n        evening: 'Good evening'\n      }\n    }\n  },\n  es: {\n    translation: {\n      welcome: 'Bienvenido',\n      hello: 'Hola {{name}}',\n      items: 'Tienes {{count}} artículo',\n      items_plural: 'Tienes {{count}} artículos'\n    }\n  },\n  ar: {\n    translation: {\n      welcome: 'مرحبا',\n      hello: 'مرحبا {{name}}'\n    }\n  }\n};\n\n// Initialize i18n\nconst languageDetector = {\n  type: 'languageDetector',\n  async: true,\n  detect: async (callback) => {\n    const savedLanguage = await AsyncStorage.getItem('language');\n    if (savedLanguage) {\n      return callback(savedLanguage);\n    }\n    const deviceLanguage = RNLocalize.getLocales()[0].languageCode;\n    callback(deviceLanguage);\n  },\n  init: () => {},\n  cacheUserLanguage: async (language) => {\n    await AsyncStorage.setItem('language', language);\n  }\n};\n\ni18n\n  .use(languageDetector)\n  .use(initReactI18next)\n  .init({\n    resources,\n    fallbackLng: 'en',\n    interpolation: { escapeValue: false }\n  });\n\n// Using translations\nfunction MyComponent() {\n  const { t, i18n } = useTranslation();\n  \n  const changeLanguage = (lng) => {\n    i18n.changeLanguage(lng);\n  };\n  \n  return (\n    <View>\n      <Text>{t('welcome')}</Text>\n      <Text>{t('hello', { name: 'John' })}</Text>\n      <Text>{t('items', { count: 5 })}</Text>\n      <Text>{t('greeting.morning')}</Text>\n      <Button title=\"English\" onPress={() => changeLanguage('en')} />\n      <Button title=\"Español\" onPress={() => changeLanguage('es')} />\n    </View>\n  );\n}"
    },
    {
      "id": 58,
      "question": "What is Code Push and how does it enable over-the-air updates?",
      "answer": "Code Push (now App Center CodePush) enables pushing JavaScript and asset updates directly to users without going through app stores.\n\nKey Features:\n• Instant bug fixes\n• Feature rollouts without store review\n• A/B testing capabilities\n• Rollback support\n• Staged rollouts\n• Update metadata and descriptions\n• Mandatory vs optional updates\n• Differential updates (only changed files)\n\nHow It Works:\n• Bundle JS code and assets\n• Upload to CodePush server\n• App checks for updates on launch\n• Download and install updates\n• Restart to apply changes\n\nLimitations:\n• Only JS code and assets\n• Cannot update native code\n• Cannot change permissions\n• Subject to store policies\n• Requires internet connection\n\nAlternatives:\n• Expo Updates (EAS Update)\n• Custom OTA solution",
      "explanation": "CodePush enables over-the-air JavaScript and asset updates without app store submissions, checking for updates on launch and applying them dynamically for instant bug fixes and features.",
      "difficulty": "Hard",
      "code": "// Installation: npm install react-native-code-push\nimport codePush from 'react-native-code-push';\nimport React, { useEffect, useState } from 'react';\nimport { View, Text, Button } from 'react-native';\n\n// Basic setup\nconst codePushOptions = {\n  checkFrequency: codePush.CheckFrequency.ON_APP_RESUME,\n  installMode: codePush.InstallMode.IMMEDIATE,\n  mandatoryInstallMode: codePush.InstallMode.IMMEDIATE\n};\n\nfunction App() {\n  const [updateStatus, setUpdateStatus] = useState('');\n  \n  useEffect(() => {\n    checkForUpdate();\n  }, []);\n  \n  const checkForUpdate = async () => {\n    try {\n      const update = await codePush.checkForUpdate();\n      if (update) {\n        setUpdateStatus('Update available');\n        await update.download();\n        await codePush.restartApp();\n      } else {\n        setUpdateStatus('App is up to date');\n      }\n    } catch (error) {\n      console.error(error);\n    }\n  };\n  \n  return (\n    <View>\n      <Text>{updateStatus}</Text>\n      <Button title=\"Check for Updates\" onPress={checkForUpdate} />\n    </View>\n  );\n}\n\nexport default codePush(codePushOptions)(App);\n\n// Custom update handling\nfunction ManualUpdateApp() {\n  const syncWithCodePush = () => {\n    codePush.sync(\n      {\n        updateDialog: {\n          title: 'Update Available',\n          optionalUpdateMessage: 'An update is available. Install?',\n          mandatoryUpdateMessage: 'An update is required.',\n          optionalInstallButtonLabel: 'Install',\n          optionalIgnoreButtonLabel: 'Later'\n        },\n        installMode: codePush.InstallMode.IMMEDIATE\n      },\n      (status) => {\n        switch (status) {\n          case codePush.SyncStatus.DOWNLOADING_PACKAGE:\n            console.log('Downloading...');\n            break;\n          case codePush.SyncStatus.INSTALLING_UPDATE:\n            console.log('Installing...');\n            break;\n          case codePush.SyncStatus.UP_TO_DATE:\n            console.log('Up to date');\n            break;\n        }\n      }\n    );\n  };\n  \n  useEffect(() => {\n    syncWithCodePush();\n  }, []);\n}\n\n// Deployment command\n// appcenter codepush release-react -a <ownerName>/<appName> -d Production"
    },
    {
      "id": 59,
      "question": "How do you handle app crashes and error tracking?",
      "answer": "Crash and error tracking helps identify and fix issues in production apps.\n\nError Types:\n• JavaScript errors\n• Native crashes (iOS/Android)\n• Unhandled promise rejections\n• Network errors\n• ANR (Application Not Responding)\n\nTracking Solutions:\n• Sentry - comprehensive error tracking\n• Firebase Crashlytics - Google's solution\n• Bugsnag - detailed crash reports\n• Instabug - in-app bug reporting\n• Custom logging services\n\nImplementation:\n• Install SDK\n• Initialize in app entry\n• Add error boundaries\n• Track custom errors\n• Add user context\n• Log breadcrumbs\n• Source map upload for stack traces\n\nBest Practices:\n• Catch and log all errors\n• Add relevant context\n• Group similar errors\n• Set up alerts\n• Monitor error rates\n• Test error reporting\n• Privacy considerations",
      "explanation": "Error tracking uses services like Sentry or Crashlytics to capture JavaScript and native crashes, providing stack traces, user context, and breadcrumbs for debugging production issues.",
      "difficulty": "Medium",
      "code": "// Installation: npm install @sentry/react-native\nimport * as Sentry from '@sentry/react-native';\nimport { useEffect } from 'react';\n\n// Initialize Sentry\nSentry.init({\n  dsn: 'YOUR_DSN_HERE',\n  environment: __DEV__ ? 'development' : 'production',\n  tracesSampleRate: 1.0,\n  enableAutoSessionTracking: true,\n  sessionTrackingIntervalMillis: 30000,\n  beforeSend(event, hint) {\n    // Filter or modify events\n    if (event.exception) {\n      console.log('Error captured:', event.exception);\n    }\n    return event;\n  }\n});\n\n// Error boundary with Sentry\nclass ErrorBoundary extends React.Component {\n  componentDidCatch(error, errorInfo) {\n    Sentry.captureException(error, {\n      contexts: {\n        react: { componentStack: errorInfo.componentStack }\n      }\n    });\n  }\n  \n  render() {\n    return this.props.children;\n  }\n}\n\n// Usage in component\nfunction MyComponent() {\n  useEffect(() => {\n    // Set user context\n    Sentry.setUser({\n      id: '123',\n      email: 'user@example.com',\n      username: 'john_doe'\n    });\n    \n    // Add breadcrumb\n    Sentry.addBreadcrumb({\n      category: 'navigation',\n      message: 'Navigated to profile',\n      level: 'info'\n    });\n  }, []);\n  \n  const handleError = async () => {\n    try {\n      // Risky operation\n      await fetchData();\n    } catch (error) {\n      // Capture exception\n      Sentry.captureException(error, {\n        tags: {\n          section: 'data-fetch'\n        },\n        extra: {\n          userId: '123',\n          timestamp: new Date().toISOString()\n        }\n      });\n    }\n  };\n  \n  // Custom error logging\n  const logCustomError = () => {\n    Sentry.captureMessage('Custom error message', 'error');\n  };\n  \n  // Track performance\n  const transaction = Sentry.startTransaction({\n    name: 'Load Profile'\n  });\n  // ... operation\n  transaction.finish();\n}\n\n// Wrap App with Error Boundary\nfunction App() {\n  return (\n    <ErrorBoundary>\n      <MyComponent />\n    </ErrorBoundary>\n  );\n}\n\nexport default Sentry.wrap(App);"
    },
    {
      "id": 60,
      "question": "What is React Native performance optimization and best practices?",
      "answer": "Performance optimization ensures smooth, responsive app experience.\n\nCommon Performance Issues:\n• Slow list rendering\n• Large bundle size\n• Unnecessary re-renders\n• Heavy computations on UI thread\n• Memory leaks\n• Inefficient navigation\n• Large images\n• Too many bridge calls\n\nOptimization Techniques:\n• Use PureComponent or React.memo\n• Optimize FlatList with getItemLayout\n• Use Hermes engine\n• Enable ProGuard/R8 (Android)\n• Optimize images (resize, compress, WebP)\n• Lazy load components\n• Use useCallback and useMemo\n• Avoid inline functions in render\n• Batch state updates\n• Use native driver for animations\n• Split bundles and lazy load\n• Profile with React DevTools Profiler\n\nMonitoring:\n• Frame rate monitoring\n• Memory profiling\n• Bundle size analysis\n• Performance monitoring tools",
      "explanation": "React Native performance optimization involves memoization, FlatList optimization, Hermes engine, image optimization, avoiding unnecessary re-renders, and using native driver for animations to ensure smooth 60fps experience.",
      "difficulty": "Hard",
      "code": "import React, { memo, useCallback, useMemo } from 'react';\nimport { FlatList, Image } from 'react-native';\n\n// 1. Memoize components\nconst ListItem = memo(({ item }) => {\n  return <Text>{item.title}</Text>;\n}, (prevProps, nextProps) => {\n  // Custom comparison\n  return prevProps.item.id === nextProps.item.id;\n});\n\n// 2. Optimize FlatList\nfunction OptimizedList({ data }) {\n  const ITEM_HEIGHT = 50;\n  \n  const getItemLayout = useCallback(\n    (data, index) => ({\n      length: ITEM_HEIGHT,\n      offset: ITEM_HEIGHT * index,\n      index\n    }),\n    []\n  );\n  \n  const keyExtractor = useCallback((item) => item.id, []);\n  \n  const renderItem = useCallback(\n    ({ item }) => <ListItem item={item} />,\n    []\n  );\n  \n  return (\n    <FlatList\n      data={data}\n      renderItem={renderItem}\n      keyExtractor={keyExtractor}\n      getItemLayout={getItemLayout}\n      initialNumToRender={10}\n      maxToRenderPerBatch={10}\n      windowSize={5}\n      removeClippedSubviews={true}\n    />\n  );\n}\n\n// 3. Memoize expensive computations\nfunction ExpensiveComponent({ data }) {\n  const processedData = useMemo(() => {\n    return data.map(item => {\n      // Expensive operation\n      return { ...item, processed: true };\n    });\n  }, [data]);\n  \n  return <Text>{processedData.length}</Text>;\n}\n\n// 4. Optimize images\nfunction ImageOptimization() {\n  return (\n    <Image\n      source={{ uri: 'https://example.com/image.jpg' }}\n      style={{ width: 200, height: 200 }}\n      resizeMode=\"cover\"\n      resizeMethod=\"resize\" // Android\n    />\n  );\n}\n\n// 5. Use native driver\nimport Animated from 'react-native-reanimated';\n\nfunction AnimatedComponent() {\n  const opacity = useRef(new Animated.Value(0)).current;\n  \n  Animated.timing(opacity, {\n    toValue: 1,\n    duration: 300,\n    useNativeDriver: true // Run on native thread\n  }).start();\n}\n\n// 6. Batch updates\nfunction BatchUpdates() {\n  const [state, setState] = useState({ count: 0, name: '' });\n  \n  const update = () => {\n    // Single re-render\n    setState(prev => ({\n      count: prev.count + 1,\n      name: 'Updated'\n    }));\n  };\n}\n\n// 7. Performance monitoring\nimport Perf from 'react-native-performance';\n\nPerf.measure('operation', () => {\n  // Code to measure\n});"
    },
    {
      "id": 61,
      "question": "What is Memory Management in React Native?",
      "answer": "Memory management ensures efficient memory usage and prevents leaks in React Native apps.\n\nCommon Memory Issues:\n• Memory leaks from subscriptions\n• Retained event listeners\n• Large images in memory\n• Circular references\n• Timers not cleared\n• Navigation stack buildup\n• Heavy computation results cached\n• Uncleared intervals\n\nPrevention Strategies:\n• Clean up subscriptions in useEffect\n• Remove event listeners on unmount\n• Optimize images (resize, lazy load)\n• Use weak references when appropriate\n• Clear timers and intervals\n• Release resources on unmount\n• Use FlatList for long lists\n• Profile memory usage regularly\n\nMemory Profiling Tools:\n• React DevTools Profiler\n• Chrome DevTools Memory tab\n• Xcode Instruments\n• Android Profiler\n• Flipper Memory Plugin",
      "explanation": "Memory management prevents leaks by cleaning up subscriptions, timers, and listeners in useEffect cleanup, optimizing images, using FlatList for lists, and profiling memory usage regularly.",
      "difficulty": "Hard",
      "code": "import React, { useEffect, useRef, useState } from 'react';\nimport { View, Image } from 'react-native';\n\n// 1. Clean up subscriptions\nfunction SubscriptionExample() {\n  const [data, setData] = useState(null);\n  \n  useEffect(() => {\n    // Subscribe to event\n    const subscription = someEventEmitter.addListener('event', (data) => {\n      setData(data);\n    });\n    \n    // Cleanup function\n    return () => {\n      subscription.remove();\n    };\n  }, []);\n}\n\n// 2. Clear timers\nfunction TimerExample() {\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      console.log('Timer executed');\n    }, 1000);\n    \n    const interval = setInterval(() => {\n      console.log('Interval executed');\n    }, 1000);\n    \n    return () => {\n      clearTimeout(timer);\n      clearInterval(interval);\n    };\n  }, []);\n}\n\n// 3. Cleanup async operations\nfunction AsyncCleanup() {\n  useEffect(() => {\n    let isMounted = true;\n    \n    const fetchData = async () => {\n      const result = await fetch('https://api.example.com/data');\n      const data = await result.json();\n      \n      // Only update if still mounted\n      if (isMounted) {\n        setData(data);\n      }\n    };\n    \n    fetchData();\n    \n    return () => {\n      isMounted = false;\n    };\n  }, []);\n}\n\n// 4. Optimize images\nfunction ImageMemoryManagement() {\n  return (\n    <Image\n      source={{ uri: 'https://example.com/large-image.jpg' }}\n      style={{ width: 200, height: 200 }}\n      resizeMode=\"cover\"\n      // Android: use resize method\n      resizeMethod=\"resize\"\n    />\n  );\n}\n\n// 5. Use refs carefully\nfunction RefMemoryExample() {\n  const dataRef = useRef(null);\n  \n  useEffect(() => {\n    dataRef.current = { large: 'data' };\n    \n    return () => {\n      // Clear ref on unmount\n      dataRef.current = null;\n    };\n  }, []);\n}\n\n// 6. Navigation cleanup\nimport { useFocusEffect } from '@react-navigation/native';\n\nfunction NavigationCleanup() {\n  useFocusEffect(\n    React.useCallback(() => {\n      // Setup when screen focused\n      const subscription = subscribeToUpdates();\n      \n      return () => {\n        // Cleanup when screen unfocused\n        subscription.unsubscribe();\n      };\n    }, [])\n  );\n}\n\n// 7. Monitor memory\nif (__DEV__) {\n  global.gc && global.gc(); // Force garbage collection (debug only)\n  console.log('Memory usage:', performance.memory?.usedJSHeapSize);\n}"
    },
    {
      "id": 62,
      "question": "What is the Render Cycle in React Native?",
      "answer": "The render cycle describes how React Native updates the UI in response to state or prop changes.\n\nRender Phases:\n\n1. Reconciliation (Virtual DOM):\n• Create virtual DOM tree\n• Compare with previous tree (diffing)\n• Calculate minimal changes needed\n• Happens in JavaScript thread\n\n2. Commit:\n• Apply changes to native views\n• Update shadow tree\n• Batch updates for performance\n• Bridge communication\n\n3. Layout:\n• Calculate component positions\n• Yoga layout engine\n• Flexbox calculations\n\n4. Paint:\n• Render native components\n• Display on screen\n• Native thread work\n\nRender Triggers:\n• State changes (useState, useReducer)\n• Props changes from parent\n• Context value changes\n• Force update\n• Parent re-render (unless memoized)\n\nOptimization:\n• Avoid unnecessary renders with memo\n• Use keys properly\n• Batch state updates",
      "explanation": "The render cycle consists of reconciliation (virtual DOM diffing), commit (applying changes), layout (calculating positions), and paint (native rendering), triggered by state, props, or context changes.",
      "difficulty": "Hard",
      "code": "import React, { useState, useEffect, useLayoutEffect } from 'react';\nimport { View, Text, Button } from 'react-native';\n\n// Understanding render timing\nfunction RenderCycleExample() {\n  const [count, setCount] = useState(0);\n  \n  console.log('1. Render phase - creating virtual DOM');\n  \n  // Runs after paint (asynchronous)\n  useEffect(() => {\n    console.log('4. useEffect - after paint');\n    return () => console.log('Cleanup before next effect');\n  });\n  \n  // Runs before paint (synchronous)\n  useLayoutEffect(() => {\n    console.log('3. useLayoutEffect - before paint');\n    // Measure layout here if needed\n  });\n  \n  return (\n    <View>\n      <Text>Count: {count}</Text>\n      <Button \n        title=\"Increment\" \n        onPress={() => {\n          console.log('0. State update triggered');\n          setCount(c => c + 1);\n          // React schedules re-render\n        }} \n      />\n    </View>\n  );\n}\n\n// Preventing unnecessary renders\nconst MemoizedChild = React.memo(({ value }) => {\n  console.log('Child rendered');\n  return <Text>{value}</Text>;\n});\n\nfunction ParentComponent() {\n  const [count, setCount] = useState(0);\n  const [other, setOther] = useState(0);\n  \n  return (\n    <View>\n      <Text>Count: {count}</Text>\n      <Button title=\"Increment Count\" onPress={() => setCount(c => c + 1)} />\n      <Button title=\"Change Other\" onPress={() => setOther(o => o + 1)} />\n      \n      {/* Only re-renders when count changes */}\n      <MemoizedChild value={count} />\n    </View>\n  );\n}\n\n// Batching updates\nfunction BatchingExample() {\n  const [count1, setCount1] = useState(0);\n  const [count2, setCount2] = useState(0);\n  \n  const handleClick = () => {\n    // React 18: automatic batching in events\n    setCount1(c => c + 1);\n    setCount2(c => c + 1);\n    // Only one render!\n  };\n  \n  return <Button title=\"Update Both\" onPress={handleClick} />;\n}"
    },
    {
      "id": 63,
      "question": "What is the difference between controlled and uncontrolled components?",
      "answer": "Controlled and uncontrolled components differ in how form input state is managed.\n\nControlled Components:\n• React state controls input value\n• value prop set to state\n• onChange updates state\n• Single source of truth\n• More predictable\n• Easy validation\n• Can manipulate input\n• Immediate state access\n\nUncontrolled Components:\n• DOM maintains input state\n• Access via refs\n• Less code for simple forms\n• Closer to traditional HTML\n• Better performance for large forms\n• Integration with non-React code\n• Less React overhead\n\nWhen to Use Each:\n• Controlled - validation, formatting, dynamic behavior\n• Uncontrolled - simple forms, legacy integration\n• Controlled recommended for most cases",
      "explanation": "Controlled components have React state manage input values via value and onChange props, while uncontrolled components let DOM manage state accessed via refs, with controlled being more predictable.",
      "difficulty": "Medium",
      "code": "import React, { useState, useRef } from 'react';\nimport { View, TextInput, Button, Text } from 'react-native';\n\n// Controlled Component\nfunction ControlledInput() {\n  const [value, setValue] = useState('');\n  const [submitted, setSubmitted] = useState('');\n  \n  const handleSubmit = () => {\n    setSubmitted(value);\n  };\n  \n  return (\n    <View>\n      <TextInput\n        value={value}\n        onChangeText={(text) => {\n          // Can validate/format here\n          setValue(text.toUpperCase());\n        }}\n        placeholder=\"Controlled Input\"\n      />\n      <Button title=\"Submit\" onPress={handleSubmit} />\n      <Text>Current: {value}</Text>\n      <Text>Submitted: {submitted}</Text>\n    </View>\n  );\n}\n\n// Uncontrolled Component\nfunction UncontrolledInput() {\n  const inputRef = useRef(null);\n  const [submitted, setSubmitted] = useState('');\n  \n  const handleSubmit = () => {\n    // Access value via ref\n    const value = inputRef.current?.value;\n    setSubmitted(value);\n  };\n  \n  return (\n    <View>\n      <TextInput\n        ref={inputRef}\n        defaultValue=\"\"\n        placeholder=\"Uncontrolled Input\"\n      />\n      <Button title=\"Submit\" onPress={handleSubmit} />\n      <Text>Submitted: {submitted}</Text>\n    </View>\n  );\n}\n\n// Hybrid approach\nfunction HybridForm() {\n  const [email, setEmail] = useState(''); // Controlled for validation\n  const notesRef = useRef(null); // Uncontrolled for large text\n  \n  const handleSubmit = () => {\n    const formData = {\n      email,\n      notes: notesRef.current?.value\n    };\n    console.log(formData);\n  };\n  \n  return (\n    <View>\n      {/* Controlled - needs validation */}\n      <TextInput\n        value={email}\n        onChangeText={setEmail}\n        keyboardType=\"email-address\"\n        placeholder=\"Email\"\n      />\n      {email && !email.includes('@') && (\n        <Text style={{ color: 'red' }}>Invalid email</Text>\n      )}\n      \n      {/* Uncontrolled - simple text area */}\n      <TextInput\n        ref={notesRef}\n        multiline\n        placeholder=\"Notes\"\n      />\n      \n      <Button title=\"Submit\" onPress={handleSubmit} />\n    </View>\n  );\n}"
    },
    {
      "id": 64,
      "question": "What is Hot Reloading and Fast Refresh?",
      "answer": "Hot Reloading and Fast Refresh are development features that update code changes without full app reload.\n\nFast Refresh (Modern):\n• Automatically reloads on save\n• Preserves component state\n• Handles hooks properly\n• Better error recovery\n• More reliable than old hot reload\n• Enabled by default in React Native 0.61+\n• Only reloads changed components\n• Handles syntax errors gracefully\n\nHow It Works:\n• Detects file changes\n• Re-evaluates changed modules\n• Updates component definitions\n• Preserves state when possible\n• Remounts on export changes\n• Full reload on certain changes\n\nLimitations:\n• Class components remount\n• Anonymous functions may not preserve state\n• Changes outside components may need full reload\n• Native code changes need rebuild\n\nFull Reload Triggers:\n• Native code changes\n• Package.json changes\n• Pod file changes",
      "explanation": "Fast Refresh automatically updates code changes while preserving component state, reloading only changed components without full app restart, improving development speed with better error handling than old hot reload.",
      "difficulty": "Easy",
      "code": "import React, { useState } from 'react';\nimport { View, Text, Button } from 'react-native';\n\n// Fast Refresh preserves state in this component\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <View>\n      <Text>Count: {count}</Text>\n      <Button \n        title=\"Increment\" \n        onPress={() => setCount(c => c + 1)} \n      />\n      {/* You can edit this text and state will be preserved */}\n      <Text>Edit me and I'll refresh!</Text>\n    </View>\n  );\n}\n\n// State is reset when:\n// 1. Changing from function to class component\n// 2. Changing export type\n// 3. Adding/removing hooks\n\n// Enable/disable Fast Refresh\n// In React Native CLI:\n// - Shake device > Enable Fast Refresh\n// - Or in metro.config.js:\n/*\nmodule.exports = {\n  transformer: {\n    getTransformOptions: async () => ({\n      transform: {\n        experimentalImportSupport: false,\n        inlineRequires: true,\n      },\n    }),\n  },\n};\n*/\n\n// Forcing full reload programmatically (rare use case)\nimport { DevSettings } from 'react-native';\n\nif (__DEV__) {\n  DevSettings.reload();\n}\n\n// Handling Fast Refresh edge cases\n// Use effect cleanup for subscriptions\nfunction SubscriptionComponent() {\n  useEffect(() => {\n    const subscription = subscribe();\n    \n    // Cleanup ensures no leaks during Fast Refresh\n    return () => subscription.unsubscribe();\n  }, []);\n}\n\n// Keep functions outside component if they don't need props/state\nconst helperFunction = () => {\n  // This won't cause remount on Fast Refresh\n};\n\nfunction MyComponent() {\n  // Using the helper\n  const result = helperFunction();\n  return <Text>{result}</Text>;\n}"
    },
    {
      "id": 65,
      "question": "What is the Metro Bundler and how does it work?",
      "answer": "Metro is React Native's JavaScript bundler that compiles and bundles code for the app.\n\nKey Features:\n• Fast incremental builds\n• Optimized for React Native\n• Supports modern JavaScript\n• Source maps for debugging\n• Code transformation (Babel)\n• Module resolution\n• Asset handling (images, fonts)\n• Tree shaking\n• Hot Module Replacement support\n\nHow It Works:\n• Resolves module dependencies\n• Transforms code (JSX, ES6+)\n• Bundles modules into single file\n• Generates source maps\n• Serves bundle to app\n• Watches for file changes\n\nConfiguration:\n• metro.config.js for customization\n• Transform options\n• Asset extensions\n• Blacklist/blocklist patterns\n• Custom resolvers\n\nCommands:\n• npm start - start Metro\n• npm start -- --reset-cache - clear cache",
      "explanation": "Metro is React Native's JavaScript bundler that transforms, resolves, and packages code into bundles, supporting fast incremental builds, hot reloading, and source maps for debugging.",
      "difficulty": "Medium",
      "code": "// metro.config.js configuration\nconst { getDefaultConfig } = require('metro-config');\n\nmodule.exports = (async () => {\n  const {\n    resolver: { sourceExts, assetExts }\n  } = await getDefaultConfig();\n  \n  return {\n    transformer: {\n      babelTransformerPath: require.resolve('react-native-svg-transformer'),\n      getTransformOptions: async () => ({\n        transform: {\n          experimentalImportSupport: false,\n          inlineRequires: true,\n        },\n      }),\n    },\n    resolver: {\n      assetExts: assetExts.filter(ext => ext !== 'svg'),\n      sourceExts: [...sourceExts, 'svg'],\n      // Block certain paths\n      blockList: [\n        /node_modules\\/.*\\/node_modules\\/react-native\\/.*/,\n      ],\n      // Custom module resolution\n      extraNodeModules: {\n        '@components': __dirname + '/src/components',\n      },\n    },\n    // Watch folders\n    watchFolders: [\n      __dirname,\n      __dirname + '/../shared-package',\n    ],\n    // Server options\n    server: {\n      port: 8081,\n    },\n    // Cache options\n    cacheVersion: '1.0',\n  };\n})();\n\n// Using Metro CLI\n// Start Metro:\n// npx react-native start\n\n// With options:\n// npx react-native start --reset-cache --port 8082\n\n// Bundle for production (Android):\n/*\nnpx react-native bundle \\\n  --platform android \\\n  --dev false \\\n  --entry-file index.js \\\n  --bundle-output android/app/src/main/assets/index.android.bundle \\\n  --assets-dest android/app/src/main/res/\n*/\n\n// Bundle for production (iOS):\n/*\nnpx react-native bundle \\\n  --platform ios \\\n  --dev false \\\n  --entry-file index.js \\\n  --bundle-output ios/main.jsbundle \\\n  --assets-dest ios/\n*/\n\n// Custom transformer example\nmodule.exports = {\n  transform: async ({ filename, options, src }) => {\n    // Custom transformation logic\n    return {\n      code: transformedCode,\n      map: sourceMap,\n    };\n  },\n};"
    },
    {
      "id": 66,
      "question": "What is Code Splitting and Lazy Loading in React Native?",
      "answer": "Code splitting and lazy loading optimize app performance by loading code on demand.\n\nCode Splitting Benefits:\n• Smaller initial bundle size\n• Faster app startup\n• Load features on demand\n• Better memory usage\n• Improved user experience\n\nImplementation Methods:\n• React.lazy() for component lazy loading\n• Dynamic import() for modules\n• Split by routes/screens\n• Split by features\n• Conditional loading\n\nLazy Loading Strategies:\n• Route-based splitting\n• Component-based splitting\n• Vendor code splitting\n• Common chunks extraction\n• Preloading critical paths\n\nConsiderations:\n• Loading states and suspense\n• Error boundaries for failures\n• Bundle size analysis\n• Network conditions\n• Cache strategies\n\nLimitations:\n• Native modules cannot be split\n• Limited compared to web\n• Metro bundler constraints",
      "explanation": "Code splitting loads JavaScript code on demand using React.lazy and dynamic imports, reducing initial bundle size and improving startup time by splitting code by routes or features.",
      "difficulty": "Hard",
      "code": "import React, { Suspense, lazy } from 'react';\nimport { View, Text, ActivityIndicator, Button } from 'react-native';\n\n// Lazy load component\nconst HeavyComponent = lazy(() => import('./HeavyComponent'));\n\nfunction App() {\n  const [showHeavy, setShowHeavy] = React.useState(false);\n  \n  return (\n    <View>\n      <Button \n        title=\"Load Heavy Component\" \n        onPress={() => setShowHeavy(true)} \n      />\n      \n      {showHeavy && (\n        <Suspense fallback={<ActivityIndicator />}>\n          <HeavyComponent />\n        </Suspense>\n      )}\n    </View>\n  );\n}\n\n// Route-based code splitting with React Navigation\nimport { NavigationContainer } from '@react-navigation/native';\nimport { createStackNavigator } from '@react-navigation/stack';\n\nconst Stack = createStackNavigator();\n\nconst HomeScreen = lazy(() => import('./screens/HomeScreen'));\nconst ProfileScreen = lazy(() => import('./screens/ProfileScreen'));\nconst SettingsScreen = lazy(() => import('./screens/SettingsScreen'));\n\nfunction AppNavigator() {\n  return (\n    <NavigationContainer>\n      <Stack.Navigator>\n        <Stack.Screen name=\"Home\">\n          {(props) => (\n            <Suspense fallback={<LoadingScreen />}>\n              <HomeScreen {...props} />\n            </Suspense>\n          )}\n        </Stack.Screen>\n        <Stack.Screen name=\"Profile\">\n          {(props) => (\n            <Suspense fallback={<LoadingScreen />}>\n              <ProfileScreen {...props} />\n            </Suspense>\n          )}\n        </Stack.Screen>\n      </Stack.Navigator>\n    </NavigationContainer>\n  );\n}\n\n// Dynamic module loading\nasync function loadFeature() {\n  const module = await import('./features/AdvancedFeature');\n  return module.default;\n}\n\n// Preloading on mount\nfunction PreloadingExample() {\n  React.useEffect(() => {\n    // Preload while user is on home screen\n    import('./screens/ProfileScreen');\n  }, []);\n}\n\n// Error boundary for lazy loading failures\nclass LazyLoadErrorBoundary extends React.Component {\n  state = { hasError: false };\n  \n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n  \n  render() {\n    if (this.state.hasError) {\n      return <Text>Failed to load component. Please try again.</Text>;\n    }\n    return this.props.children;\n  }\n}\n\n// Usage with error handling\nfunction SafeLazyLoad() {\n  return (\n    <LazyLoadErrorBoundary>\n      <Suspense fallback={<ActivityIndicator />}>\n        <HeavyComponent />\n      </Suspense>\n    </LazyLoadErrorBoundary>\n  );\n}"
    },
    {
      "id": 67,
      "question": "What is Accessibility in React Native and how do you implement it?",
      "answer": "Accessibility makes apps usable by people with disabilities.\n\nAccessibility Features:\n• Screen reader support (TalkBack, VoiceOver)\n• Accessible labels and hints\n• Touch target sizing\n• Color contrast\n• Dynamic text sizing\n• Keyboard navigation\n• Focus management\n• Semantic markup\n\nCore Props:\n• accessible - marks as accessible element\n• accessibilityLabel - descriptive label\n• accessibilityHint - usage hint\n• accessibilityRole - semantic role (button, header, etc.)\n• accessibilityState - current state (disabled, selected)\n• accessibilityValue - current value\n• accessibilityActions - custom actions\n\nBest Practices:\n• Provide meaningful labels\n• Ensure sufficient contrast\n• Minimum touch targets (44x44 points)\n• Test with screen readers\n• Support dynamic type\n• Use semantic roles\n• Keyboard accessible\n• Focus order logical",
      "explanation": "React Native accessibility uses props like accessibilityLabel and accessibilityRole to support screen readers and assistive technologies, ensuring apps are usable by people with disabilities.",
      "difficulty": "Medium",
      "code": "import React from 'react';\nimport {\n  View,\n  Text,\n  TouchableOpacity,\n  TextInput,\n  AccessibilityInfo,\n  StyleSheet\n} from 'react-native';\n\nfunction AccessibleComponent() {\n  const [count, setCount] = React.useState(0);\n  \n  // Check if screen reader is enabled\n  React.useEffect(() => {\n    AccessibilityInfo.isScreenReaderEnabled().then(enabled => {\n      console.log('Screen reader enabled:', enabled);\n    });\n    \n    // Listen for screen reader changes\n    const subscription = AccessibilityInfo.addEventListener(\n      'screenReaderChanged',\n      (enabled) => console.log('Screen reader:', enabled)\n    );\n    \n    return () => subscription.remove();\n  }, []);\n  \n  return (\n    <View style={styles.container}>\n      {/* Accessible button */}\n      <TouchableOpacity\n        accessible={true}\n        accessibilityLabel=\"Increment counter\"\n        accessibilityHint=\"Increases the counter by one\"\n        accessibilityRole=\"button\"\n        accessibilityState={{ disabled: false }}\n        onPress={() => setCount(count + 1)}\n        style={styles.button}\n      >\n        <Text>Increment</Text>\n      </TouchableOpacity>\n      \n      {/* Accessible text */}\n      <Text\n        accessible={true}\n        accessibilityLabel={`Counter value is ${count}`}\n        accessibilityRole=\"text\"\n      >\n        Count: {count}\n      </Text>\n      \n      {/* Accessible input */}\n      <TextInput\n        accessible={true}\n        accessibilityLabel=\"Email input\"\n        accessibilityHint=\"Enter your email address\"\n        placeholder=\"Email\"\n        style={styles.input}\n      />\n      \n      {/* Group elements */}\n      <View\n        accessible={true}\n        accessibilityLabel=\"User profile section\"\n        accessibilityRole=\"summary\"\n      >\n        <Text>Name: John Doe</Text>\n        <Text>Email: john@example.com</Text>\n      </View>\n      \n      {/* Custom accessibility actions */}\n      <View\n        accessible={true}\n        accessibilityLabel=\"Message\"\n        accessibilityActions={[\n          { name: 'delete', label: 'Delete message' },\n          { name: 'forward', label: 'Forward message' }\n        ]}\n        onAccessibilityAction={(event) => {\n          switch (event.nativeEvent.actionName) {\n            case 'delete':\n              console.log('Delete');\n              break;\n            case 'forward':\n              console.log('Forward');\n              break;\n          }\n        }}\n      >\n        <Text>Message content</Text>\n      </View>\n    </View>\n  );\n}\n\n// Announce to screen reader\nconst announceMessage = (message) => {\n  AccessibilityInfo.announceForAccessibility(message);\n};\n\nconst styles = StyleSheet.create({\n  container: { padding: 20 },\n  button: {\n    minWidth: 44,  // Minimum touch target\n    minHeight: 44,\n    padding: 12,\n    backgroundColor: '#007AFF'\n  },\n  input: {\n    height: 44,  // Minimum touch target height\n    borderWidth: 1,\n    borderColor: '#ddd',\n    padding: 10\n  }\n});"
    },
    {
      "id": 68,
      "question": "What is React Native Maps and how do you implement maps?",
      "answer": "React Native Maps provides map components for displaying interactive maps in apps.\n\nFeatures:\n• Google Maps (Android) and Apple Maps (iOS)\n• Custom markers and annotations\n• Polylines and polygons\n• Clustering\n• Geolocation integration\n• Custom map styles\n• Heatmaps\n• Overlays\n• Region change callbacks\n• Animated map movements\n\nCommon Components:\n• MapView - main map container\n• Marker - pin locations\n• Polyline - draw lines\n• Polygon - draw shapes\n• Circle - draw circles\n• Callout - marker info windows\n\nSetup Requirements:\n• Google Maps API key (Android)\n• iOS configuration\n• Location permissions\n• Native dependencies\n\nUse Cases:\n• Store locators\n• Navigation apps\n• Tracking apps\n• Location-based services\n• Geofencing",
      "explanation": "React Native Maps provides MapView component with markers, polylines, and custom styling for interactive maps, using Google Maps on Android and Apple Maps on iOS with geolocation support.",
      "difficulty": "Medium",
      "code": "// Installation: npm install react-native-maps\nimport React, { useRef, useState } from 'react';\nimport { View, Button, StyleSheet } from 'react-native';\nimport MapView, {\n  Marker,\n  Polyline,\n  Circle,\n  Callout,\n  PROVIDER_GOOGLE\n} from 'react-native-maps';\nimport Geolocation from '@react-native-community/geolocation';\n\nfunction MapExample() {\n  const mapRef = useRef(null);\n  const [region, setRegion] = useState({\n    latitude: 37.78825,\n    longitude: -122.4324,\n    latitudeDelta: 0.0922,\n    longitudeDelta: 0.0421\n  });\n  \n  const [markers, setMarkers] = useState([\n    {\n      id: 1,\n      coordinate: { latitude: 37.78825, longitude: -122.4324 },\n      title: 'San Francisco',\n      description: 'City by the Bay'\n    },\n    {\n      id: 2,\n      coordinate: { latitude: 37.75825, longitude: -122.4624 },\n      title: 'Mission District'\n    }\n  ]);\n  \n  const polylineCoords = [\n    { latitude: 37.78825, longitude: -122.4324 },\n    { latitude: 37.75825, longitude: -122.4624 }\n  ];\n  \n  // Get current location\n  const getCurrentLocation = () => {\n    Geolocation.getCurrentPosition(\n      (position) => {\n        const { latitude, longitude } = position.coords;\n        mapRef.current?.animateToRegion({\n          latitude,\n          longitude,\n          latitudeDelta: 0.01,\n          longitudeDelta: 0.01\n        });\n      },\n      (error) => console.error(error),\n      { enableHighAccuracy: true, timeout: 20000 }\n    );\n  };\n  \n  return (\n    <View style={styles.container}>\n      <MapView\n        ref={mapRef}\n        provider={PROVIDER_GOOGLE}\n        style={styles.map}\n        initialRegion={region}\n        onRegionChangeComplete={setRegion}\n        showsUserLocation={true}\n        showsMyLocationButton={true}\n        onPress={(e) => {\n          // Add marker on tap\n          const newMarker = {\n            id: Date.now(),\n            coordinate: e.nativeEvent.coordinate,\n            title: 'New Location'\n          };\n          setMarkers([...markers, newMarker]);\n        }}\n      >\n        {/* Markers */}\n        {markers.map((marker) => (\n          <Marker\n            key={marker.id}\n            coordinate={marker.coordinate}\n            title={marker.title}\n            description={marker.description}\n            pinColor=\"red\"\n          >\n            <Callout>\n              <View>\n                <Text>{marker.title}</Text>\n              </View>\n            </Callout>\n          </Marker>\n        ))}\n        \n        {/* Polyline */}\n        <Polyline\n          coordinates={polylineCoords}\n          strokeColor=\"#0000FF\"\n          strokeWidth={3}\n        />\n        \n        {/* Circle */}\n        <Circle\n          center={region}\n          radius={1000}\n          fillColor=\"rgba(255, 0, 0, 0.2)\"\n          strokeColor=\"rgba(255, 0, 0, 0.5)\"\n        />\n      </MapView>\n      \n      <Button title=\"My Location\" onPress={getCurrentLocation} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  map: { flex: 1 }\n});\n\n// Android configuration (android/app/src/main/AndroidManifest.xml)\n/*\n<application>\n  <meta-data\n    android:name=\"com.google.android.geo.API_KEY\"\n    android:value=\"YOUR_GOOGLE_MAPS_API_KEY\"/>\n</application>\n*/"
    },
    {
      "id": 69,
      "question": "What is React Native Camera and how do you capture photos/videos?",
      "answer": "React Native Camera provides access to device camera for capturing photos and videos.\n\nFeatures:\n• Photo capture\n• Video recording\n• QR/Barcode scanning\n• Face detection\n• Flash control\n• Zoom control\n• Focus and exposure\n• Front/back camera switching\n• Image quality settings\n\nPopular Libraries:\n• react-native-vision-camera - modern, performant\n• react-native-camera - legacy, feature-rich\n• expo-camera - Expo managed\n\nPermissions Required:\n• Camera permission\n• Microphone permission (for video)\n• Storage permission (for saving)\n\nCommon Use Cases:\n• Profile photos\n• Document scanning\n• QR code scanning\n• Augmented reality\n• Video calls\n• Photo filters\n\nOptimization:\n• Compress images\n• Set appropriate resolution\n• Handle memory properly\n• Clean up resources",
      "explanation": "React Native Camera libraries like vision-camera provide camera access for capturing photos and videos with features like flash control, zoom, and barcode scanning, requiring camera and storage permissions.",
      "difficulty": "Medium",
      "code": "// Installation: npm install react-native-vision-camera\nimport React, { useRef, useState } from 'react';\nimport { View, Button, Image, StyleSheet } from 'react-native';\nimport {\n  Camera,\n  useCameraDevices,\n  useFrameProcessor\n} from 'react-native-vision-camera';\n\nfunction CameraExample() {\n  const camera = useRef(null);\n  const devices = useCameraDevices();\n  const device = devices.back;\n  const [photo, setPhoto] = useState(null);\n  const [hasPermission, setHasPermission] = useState(false);\n  \n  // Request permissions\n  React.useEffect(() => {\n    (async () => {\n      const cameraPermission = await Camera.requestCameraPermission();\n      const microphonePermission = await Camera.requestMicrophonePermission();\n      setHasPermission(\n        cameraPermission === 'authorized' && \n        microphonePermission === 'authorized'\n      );\n    })();\n  }, []);\n  \n  // Take photo\n  const takePhoto = async () => {\n    try {\n      const photo = await camera.current?.takePhoto({\n        qualityPrioritization: 'speed',\n        flash: 'auto',\n        enableAutoStabilization: true\n      });\n      setPhoto(photo);\n      console.log('Photo saved to:', photo.path);\n    } catch (error) {\n      console.error('Failed to take photo:', error);\n    }\n  };\n  \n  // Record video\n  const startRecording = async () => {\n    try {\n      await camera.current?.startRecording({\n        flash: 'off',\n        onRecordingFinished: (video) => {\n          console.log('Video saved to:', video.path);\n        },\n        onRecordingError: (error) => {\n          console.error('Recording error:', error);\n        }\n      });\n    } catch (error) {\n      console.error('Failed to start recording:', error);\n    }\n  };\n  \n  const stopRecording = async () => {\n    await camera.current?.stopRecording();\n  };\n  \n  if (!device || !hasPermission) {\n    return <Text>Loading camera...</Text>;\n  }\n  \n  return (\n    <View style={styles.container}>\n      {photo ? (\n        <View>\n          <Image source={{ uri: photo.path }} style={styles.preview} />\n          <Button title=\"Retake\" onPress={() => setPhoto(null)} />\n        </View>\n      ) : (\n        <>\n          <Camera\n            ref={camera}\n            style={styles.camera}\n            device={device}\n            isActive={true}\n            photo={true}\n            video={true}\n            audio={true}\n          />\n          <View style={styles.controls}>\n            <Button title=\"Take Photo\" onPress={takePhoto} />\n            <Button title=\"Start Recording\" onPress={startRecording} />\n            <Button title=\"Stop Recording\" onPress={stopRecording} />\n          </View>\n        </>\n      )}\n    </View>\n  );\n}\n\n// QR Code scanning\nimport { useScanBarcodes, BarcodeFormat } from 'vision-camera-code-scanner';\n\nfunction QRScanner() {\n  const [barcodes, setBarcodes] = useScanBarcodes([BarcodeFormat.QR_CODE]);\n  \n  const frameProcessor = useFrameProcessor((frame) => {\n    'worklet';\n    const detectedBarcodes = scanBarcodes(frame, [BarcodeFormat.QR_CODE]);\n    console.log('Detected QR codes:', detectedBarcodes);\n  }, []);\n  \n  return (\n    <Camera\n      device={device}\n      isActive={true}\n      frameProcessor={frameProcessor}\n    />\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n  camera: { flex: 1 },\n  controls: {\n    position: 'absolute',\n    bottom: 20,\n    flexDirection: 'row',\n    justifyContent: 'space-around',\n    width: '100%'\n  },\n  preview: { width: '100%', height: 400 }\n});"
    },
    {
      "id": 70,
      "question": "What is Offline Support and how do you implement it?",
      "answer": "Offline support allows apps to function without internet connectivity.\n\nOffline Strategies:\n• Local data caching\n• Optimistic UI updates\n• Request queuing\n• Sync when online\n• Conflict resolution\n• Offline-first architecture\n\nImplementation Approaches:\n• AsyncStorage for simple data\n• SQLite for structured data\n• Realm for complex data\n• Redux Persist for state\n• WatermelonDB for performance\n\nNetwork Detection:\n• NetInfo - check connectivity\n• Listen for network changes\n• Show offline indicators\n• Queue failed requests\n\nSync Strategies:\n• Manual sync triggers\n• Background sync\n• Incremental sync\n• Last-write-wins\n• Operational transformation\n\nBest Practices:\n• Cache critical data\n• Show offline state clearly\n• Queue mutations\n• Handle conflicts gracefully\n• Test offline scenarios",
      "explanation": "Offline support enables app functionality without internet using local storage (AsyncStorage, SQLite), NetInfo for connectivity detection, request queuing, and data sync strategies when connection returns.",
      "difficulty": "Hard",
      "code": "// Installation: npm install @react-native-community/netinfo\nimport React, { useEffect, useState } from 'react';\nimport { View, Text, Button } from 'react-native';\nimport NetInfo from '@react-native-community/netinfo';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\n// Network status hook\nfunction useNetworkStatus() {\n  const [isConnected, setIsConnected] = useState(true);\n  \n  useEffect(() => {\n    const unsubscribe = NetInfo.addEventListener(state => {\n      setIsConnected(state.isConnected);\n    });\n    \n    return () => unsubscribe();\n  }, []);\n  \n  return isConnected;\n}\n\n// Offline data manager\nclass OfflineDataManager {\n  static QUEUE_KEY = '@offline_queue';\n  \n  // Save to local storage\n  static async saveOffline(key, data) {\n    try {\n      await AsyncStorage.setItem(key, JSON.stringify(data));\n    } catch (error) {\n      console.error('Save offline error:', error);\n    }\n  }\n  \n  // Load from local storage\n  static async loadOffline(key) {\n    try {\n      const data = await AsyncStorage.getItem(key);\n      return data ? JSON.parse(data) : null;\n    } catch (error) {\n      console.error('Load offline error:', error);\n      return null;\n    }\n  }\n  \n  // Queue request for later\n  static async queueRequest(request) {\n    try {\n      const queue = await this.loadOffline(this.QUEUE_KEY) || [];\n      queue.push({ ...request, timestamp: Date.now() });\n      await this.saveOffline(this.QUEUE_KEY, queue);\n    } catch (error) {\n      console.error('Queue request error:', error);\n    }\n  }\n  \n  // Process queued requests\n  static async processQueue() {\n    try {\n      const queue = await this.loadOffline(this.QUEUE_KEY) || [];\n      const results = [];\n      \n      for (const request of queue) {\n        try {\n          const response = await fetch(request.url, request.options);\n          if (response.ok) {\n            results.push({ success: true, request });\n          }\n        } catch (error) {\n          results.push({ success: false, request, error });\n        }\n      }\n      \n      // Clear successful requests\n      const failed = queue.filter((_, i) => !results[i].success);\n      await this.saveOffline(this.QUEUE_KEY, failed);\n      \n      return results;\n    } catch (error) {\n      console.error('Process queue error:', error);\n    }\n  }\n}\n\n// Offline-aware API client\nfunction useOfflineAPI() {\n  const isConnected = useNetworkStatus();\n  \n  const fetchData = async (url, options = {}) => {\n    // Try to load from cache first\n    const cacheKey = `@cache_${url}`;\n    const cachedData = await OfflineDataManager.loadOffline(cacheKey);\n    \n    if (!isConnected) {\n      console.log('Offline: returning cached data');\n      return cachedData;\n    }\n    \n    try {\n      const response = await fetch(url, options);\n      const data = await response.json();\n      \n      // Cache the data\n      await OfflineDataManager.saveOffline(cacheKey, data);\n      return data;\n    } catch (error) {\n      console.log('Fetch failed, returning cached data');\n      return cachedData;\n    }\n  };\n  \n  const mutateData = async (url, options = {}) => {\n    if (!isConnected) {\n      // Queue for later\n      await OfflineDataManager.queueRequest({ url, options });\n      return { queued: true };\n    }\n    \n    try {\n      const response = await fetch(url, options);\n      return await response.json();\n    } catch (error) {\n      // Queue on failure\n      await OfflineDataManager.queueRequest({ url, options });\n      throw error;\n    }\n  };\n  \n  return { fetchData, mutateData, isConnected };\n}\n\n// Usage component\nfunction OfflineComponent() {\n  const { fetchData, mutateData, isConnected } = useOfflineAPI();\n  const [data, setData] = useState(null);\n  \n  useEffect(() => {\n    loadData();\n  }, []);\n  \n  // Sync when online\n  useEffect(() => {\n    if (isConnected) {\n      OfflineDataManager.processQueue();\n    }\n  }, [isConnected]);\n  \n  const loadData = async () => {\n    const result = await fetchData('https://api.example.com/data');\n    setData(result);\n  };\n  \n  const saveData = async () => {\n    await mutateData('https://api.example.com/data', {\n      method: 'POST',\n      body: JSON.stringify({ name: 'Test' })\n    });\n  };\n  \n  return (\n    <View>\n      {!isConnected && (\n        <Text style={{ backgroundColor: 'yellow' }}>Offline Mode</Text>\n      )}\n      <Button title=\"Save\" onPress={saveData} />\n    </View>\n  );\n}"
    },
    {
      "id": 71,
      "question": "What is Biometric Authentication in React Native?",
      "answer": "Biometric authentication uses fingerprint, face recognition, or iris scanning for secure user authentication.\n\nTypes of Biometrics:\n• Touch ID (iOS fingerprint)\n• Face ID (iOS facial recognition)\n• Fingerprint (Android)\n• Face unlock (Android)\n• Iris scanning (select devices)\n\nImplementation Libraries:\n• react-native-biometrics - cross-platform\n• expo-local-authentication - Expo managed\n• react-native-touch-id - legacy iOS/Android\n\nFeatures:\n• Check biometric availability\n• Authenticate with biometrics\n• Fallback to passcode\n• Secure key storage\n• Biometric enrollment check\n\nSecurity Considerations:\n• Biometrics for convenience, not sole security\n• Server-side token validation\n• Secure storage for tokens\n• Handle biometric changes\n• Privacy compliance\n\nUse Cases:\n• App unlock\n• Payment confirmation\n• Sensitive actions\n• Quick login",
      "explanation": "Biometric authentication in React Native uses Touch ID, Face ID, or fingerprint scanning via libraries like react-native-biometrics for secure, convenient user authentication with fallback options.",
      "difficulty": "Medium",
      "code": "// Installation: npm install react-native-biometrics\nimport React, { useEffect, useState } from 'react';\nimport { View, Button, Text, Alert } from 'react-native';\nimport ReactNativeBiometrics from 'react-native-biometrics';\n\nconst rnBiometrics = new ReactNativeBiometrics();\n\nfunction BiometricAuth() {\n  const [biometryType, setBiometryType] = useState(null);\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n  \n  useEffect(() => {\n    checkBiometricSupport();\n  }, []);\n  \n  // Check if biometrics available\n  const checkBiometricSupport = async () => {\n    try {\n      const { available, biometryType } = await rnBiometrics.isSensorAvailable();\n      \n      if (available) {\n        setBiometryType(biometryType);\n        console.log('Biometric type:', biometryType);\n        // biometryType can be: TouchID, FaceID, Biometrics\n      } else {\n        console.log('Biometrics not available');\n      }\n    } catch (error) {\n      console.error('Check biometric error:', error);\n    }\n  };\n  \n  // Simple biometric authentication\n  const authenticate = async () => {\n    try {\n      const { success } = await rnBiometrics.simplePrompt({\n        promptMessage: 'Confirm your identity',\n        cancelButtonText: 'Cancel'\n      });\n      \n      if (success) {\n        setIsAuthenticated(true);\n        Alert.alert('Success', 'Authentication successful');\n      } else {\n        Alert.alert('Failed', 'Authentication failed');\n      }\n    } catch (error) {\n      console.error('Authentication error:', error);\n    }\n  };\n  \n  // Create signature (for advanced use)\n  const createSignature = async () => {\n    try {\n      // Create keys if not exist\n      const { publicKey } = await rnBiometrics.createKeys();\n      console.log('Public key:', publicKey);\n      \n      // Create signature\n      const payload = 'user_id_123';\n      const { success, signature } = await rnBiometrics.createSignature({\n        promptMessage: 'Sign in',\n        payload: payload\n      });\n      \n      if (success) {\n        // Send signature and payload to server for verification\n        verifySignatureOnServer(signature, payload);\n      }\n    } catch (error) {\n      console.error('Create signature error:', error);\n    }\n  };\n  \n  // Delete keys\n  const deleteKeys = async () => {\n    try {\n      await rnBiometrics.deleteKeys();\n      console.log('Keys deleted');\n    } catch (error) {\n      console.error('Delete keys error:', error);\n    }\n  };\n  \n  const verifySignatureOnServer = async (signature, payload) => {\n    // Send to backend for verification\n    const response = await fetch('https://api.example.com/verify', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ signature, payload })\n    });\n    const result = await response.json();\n    return result.verified;\n  };\n  \n  return (\n    <View style={{ padding: 20 }}>\n      <Text>Biometric Type: {biometryType || 'Not Available'}</Text>\n      <Text>Authenticated: {isAuthenticated ? 'Yes' : 'No'}</Text>\n      \n      <Button\n        title=\"Authenticate\"\n        onPress={authenticate}\n        disabled={!biometryType}\n      />\n      \n      <Button\n        title=\"Create Signature\"\n        onPress={createSignature}\n        disabled={!biometryType}\n      />\n      \n      <Button title=\"Delete Keys\" onPress={deleteKeys} />\n    </View>\n  );\n}\n\n// Using with Expo\nimport * as LocalAuthentication from 'expo-local-authentication';\n\nasync function authenticateWithExpo() {\n  // Check hardware support\n  const hasHardware = await LocalAuthentication.hasHardwareAsync();\n  \n  // Check if biometrics enrolled\n  const isEnrolled = await LocalAuthentication.isEnrolledAsync();\n  \n  if (hasHardware && isEnrolled) {\n    const result = await LocalAuthentication.authenticateAsync({\n      promptMessage: 'Authenticate',\n      fallbackLabel: 'Use Passcode'\n    });\n    \n    return result.success;\n  }\n  \n  return false;\n}\n\nexport default BiometricAuth;"
    },
    {
      "id": 72,
      "question": "What is Secure Storage and how do you store sensitive data?",
      "answer": "Secure storage protects sensitive data like tokens, passwords, and personal information.\n\nSecurity Concerns with AsyncStorage:\n• Not encrypted by default\n• Accessible in device backups\n• Can be read by other apps (rooted devices)\n• Not suitable for sensitive data\n\nSecure Storage Solutions:\n• Keychain (iOS) - encrypted storage\n• Keystore (Android) - hardware-backed encryption\n• react-native-keychain - cross-platform secure storage\n• react-native-encrypted-storage - encrypted AsyncStorage\n• expo-secure-store - Expo managed\n\nWhat to Store Securely:\n• Authentication tokens\n• API keys\n• Encryption keys\n• User credentials\n• Payment information\n• Personal identifiable information\n\nBest Practices:\n• Never store passwords\n• Use tokens with expiration\n• Encrypt sensitive data\n• Use biometric protection\n• Clear data on logout\n• Handle root/jailbreak detection",
      "explanation": "Secure storage uses iOS Keychain and Android Keystore via libraries like react-native-keychain for encrypted storage of sensitive data like tokens and credentials, unlike insecure AsyncStorage.",
      "difficulty": "Medium",
      "code": "// Installation: npm install react-native-keychain\nimport * as Keychain from 'react-native-keychain';\nimport { Alert } from 'react-native';\n\n// Secure Storage Manager\nclass SecureStorageManager {\n  // Store credentials\n  static async setCredentials(username, password) {\n    try {\n      await Keychain.setGenericPassword(username, password, {\n        service: 'com.myapp.auth',\n        accessible: Keychain.ACCESSIBLE.WHEN_UNLOCKED,\n        securityLevel: Keychain.SECURITY_LEVEL.SECURE_HARDWARE\n      });\n      return true;\n    } catch (error) {\n      console.error('Store credentials error:', error);\n      return false;\n    }\n  }\n  \n  // Get credentials\n  static async getCredentials() {\n    try {\n      const credentials = await Keychain.getGenericPassword({\n        service: 'com.myapp.auth'\n      });\n      \n      if (credentials) {\n        return {\n          username: credentials.username,\n          password: credentials.password\n        };\n      }\n      return null;\n    } catch (error) {\n      console.error('Get credentials error:', error);\n      return null;\n    }\n  }\n  \n  // Delete credentials\n  static async deleteCredentials() {\n    try {\n      await Keychain.resetGenericPassword({\n        service: 'com.myapp.auth'\n      });\n      return true;\n    } catch (error) {\n      console.error('Delete credentials error:', error);\n      return false;\n    }\n  }\n  \n  // Store with biometric protection\n  static async setSecureWithBiometric(username, password) {\n    try {\n      await Keychain.setGenericPassword(username, password, {\n        service: 'com.myapp.auth',\n        accessControl: Keychain.ACCESS_CONTROL.BIOMETRY_CURRENT_SET,\n        accessible: Keychain.ACCESSIBLE.WHEN_UNLOCKED_THIS_DEVICE_ONLY\n      });\n      return true;\n    } catch (error) {\n      console.error('Store with biometric error:', error);\n      return false;\n    }\n  }\n  \n  // Get with biometric\n  static async getSecureWithBiometric() {\n    try {\n      const credentials = await Keychain.getGenericPassword({\n        service: 'com.myapp.auth',\n        authenticationPrompt: {\n          title: 'Authentication Required',\n          subtitle: 'Access your credentials',\n          cancel: 'Cancel'\n        }\n      });\n      return credentials;\n    } catch (error) {\n      console.error('Get with biometric error:', error);\n      return null;\n    }\n  }\n  \n  // Store token\n  static async setToken(token) {\n    return await this.setCredentials('token', token);\n  }\n  \n  // Get token\n  static async getToken() {\n    const credentials = await this.getCredentials();\n    return credentials?.password;\n  }\n}\n\n// Usage in authentication flow\nclass AuthManager {\n  static async login(username, password) {\n    try {\n      // Authenticate with server\n      const response = await fetch('https://api.example.com/login', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ username, password })\n      });\n      \n      const { token } = await response.json();\n      \n      // Store token securely\n      await SecureStorageManager.setToken(token);\n      \n      return true;\n    } catch (error) {\n      console.error('Login error:', error);\n      return false;\n    }\n  }\n  \n  static async logout() {\n    await SecureStorageManager.deleteCredentials();\n  }\n  \n  static async isAuthenticated() {\n    const token = await SecureStorageManager.getToken();\n    return !!token;\n  }\n  \n  static async getAuthToken() {\n    return await SecureStorageManager.getToken();\n  }\n}\n\n// Encrypted Storage Alternative\nimport EncryptedStorage from 'react-native-encrypted-storage';\n\nclass EncryptedStorageManager {\n  static async setItem(key, value) {\n    try {\n      await EncryptedStorage.setItem(key, JSON.stringify(value));\n    } catch (error) {\n      console.error('Encrypted storage set error:', error);\n    }\n  }\n  \n  static async getItem(key) {\n    try {\n      const value = await EncryptedStorage.getItem(key);\n      return value ? JSON.parse(value) : null;\n    } catch (error) {\n      console.error('Encrypted storage get error:', error);\n      return null;\n    }\n  }\n  \n  static async removeItem(key) {\n    try {\n      await EncryptedStorage.removeItem(key);\n    } catch (error) {\n      console.error('Encrypted storage remove error:', error);\n    }\n  }\n}\n\nexport { SecureStorageManager, AuthManager, EncryptedStorageManager };"
    },
    {
      "id": 73,
      "question": "What is the difference between React Native and Flutter?",
      "answer": "React Native and Flutter are both cross-platform mobile frameworks with different approaches.\n\nReact Native:\n• Uses JavaScript/TypeScript\n• React-based component architecture\n• Native components (bridge to native)\n• Larger community and ecosystem\n• Easier for web developers\n• Hot reload for development\n• Mature and stable\n• Used by Facebook, Instagram, Airbnb\n\nFlutter:\n• Uses Dart language\n• Own rendering engine (Skia)\n• Pixel-perfect UI across platforms\n• Faster performance (no bridge)\n• Rich widget library\n• Hot reload built-in\n• Newer but growing fast\n• Used by Google, Alibaba\n\nPerformance:\n• Flutter generally faster (no bridge)\n• React Native improving with new architecture\n\nDeveloper Experience:\n• React Native better for JS developers\n• Flutter better for custom UI\n\nChoosing Between Them:\n• React Native: existing JS knowledge, large team\n• Flutter: high performance needs, custom UI",
      "explanation": "React Native uses JavaScript with native components via bridge, while Flutter uses Dart with its own rendering engine; Flutter offers better performance and custom UI, React Native has larger ecosystem and JS familiarity.",
      "difficulty": "Medium"
    },
    {
      "id": 74,
      "question": "What is Modularization and Code Organization in React Native?",
      "answer": "Modularization organizes code into maintainable, reusable modules.\n\nProject Structure:\n• Feature-based organization\n• Component library\n• Shared utilities\n• Service layer\n• Type definitions\n• Assets management\n• Constants and configs\n\nCommon Patterns:\n• Atomic design (atoms, molecules, organisms)\n• Feature folders\n• Domain-driven design\n• Layer architecture\n• Monorepo structure\n\nFolder Structure Example:\n• /src/components - reusable components\n• /src/screens - screen components\n• /src/services - API clients\n• /src/utils - helper functions\n• /src/hooks - custom hooks\n• /src/context - context providers\n• /src/navigation - navigation config\n• /src/constants - app constants\n• /src/types - TypeScript types\n• /src/assets - images, fonts\n\nBenefits:\n• Better maintainability\n• Code reusability\n• Team scalability\n• Easier testing\n• Clear dependencies",
      "explanation": "Modularization organizes React Native code into feature-based or layer-based structures with components, screens, services, and utilities separated for maintainability, reusability, and team scalability.",
      "difficulty": "Medium",
      "code": "// Feature-based structure\n/*\nsrc/\n  features/\n    auth/\n      components/\n        LoginForm.tsx\n        SignupForm.tsx\n      screens/\n        LoginScreen.tsx\n        SignupScreen.tsx\n      services/\n        authService.ts\n      hooks/\n        useAuth.ts\n      types/\n        auth.types.ts\n      index.ts\n    profile/\n      components/\n      screens/\n      services/\n      hooks/\n      types/\n      index.ts\n  shared/\n    components/\n      Button/\n        Button.tsx\n        Button.styles.ts\n        Button.test.tsx\n        index.ts\n      Input/\n      Card/\n    hooks/\n      useDebounce.ts\n      useThrottle.ts\n    utils/\n      validation.ts\n      formatting.ts\n    constants/\n      colors.ts\n      api.ts\n    types/\n      common.types.ts\n  navigation/\n    RootNavigator.tsx\n    AuthNavigator.tsx\n  services/\n    api/\n      client.ts\n      endpoints.ts\n    storage/\n      storage.ts\n  App.tsx\n*/\n\n// Barrel exports (index.ts)\nexport { default as Button } from './Button';\nexport { default as Input } from './Input';\nexport * from './types';\n\n// Shared component example\n// src/shared/components/Button/Button.tsx\nimport React from 'react';\nimport { TouchableOpacity, Text, StyleSheet } from 'react-native';\nimport { ButtonProps } from './Button.types';\n\nexport const Button: React.FC<ButtonProps> = ({\n  title,\n  onPress,\n  variant = 'primary',\n  disabled = false\n}) => {\n  return (\n    <TouchableOpacity\n      style={[styles.button, styles[variant], disabled && styles.disabled]}\n      onPress={onPress}\n      disabled={disabled}\n    >\n      <Text style={styles.text}>{title}</Text>\n    </TouchableOpacity>\n  );\n};\n\n// Service layer example\n// src/services/api/client.ts\nimport axios from 'axios';\nimport { API_BASE_URL } from '@/constants/api';\nimport { getToken } from '@/services/storage';\n\nconst apiClient = axios.create({\n  baseURL: API_BASE_URL,\n  timeout: 10000\n});\n\napiClient.interceptors.request.use(async (config) => {\n  const token = await getToken();\n  if (token) {\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n  return config;\n});\n\nexport default apiClient;\n\n// Custom hook example\n// src/features/auth/hooks/useAuth.ts\nimport { useContext } from 'react';\nimport { AuthContext } from '../context/AuthContext';\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within AuthProvider');\n  }\n  return context;\n};\n\n// Import aliases (tsconfig.json)\n/*\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\"src/*\"],\n      \"@components/*\": [\"src/shared/components/*\"],\n      \"@screens/*\": [\"src/screens/*\"],\n      \"@services/*\": [\"src/services/*\"],\n      \"@utils/*\": [\"src/shared/utils/*\"]\n    }\n  }\n}\n*/"
    },
    {
      "id": 75,
      "question": "What is TypeScript integration in React Native?",
      "answer": "TypeScript adds static typing to React Native for better code quality and developer experience.\n\nBenefits:\n• Type safety and error prevention\n• Better IDE support and autocomplete\n• Refactoring confidence\n• Documentation through types\n• Catch errors at compile time\n• Improved team collaboration\n• Better maintainability\n\nSetup:\n• Create React Native TypeScript template\n• Add TypeScript to existing project\n• Configure tsconfig.json\n• Type React Native components\n• Type navigation\n• Type Redux/Context\n\nCommon Types:\n• Component props interfaces\n• Navigation types\n• API response types\n• Redux state types\n• Hook return types\n• Utility types\n\nBest Practices:\n• Define prop interfaces\n• Use strict mode\n• Avoid any type\n• Use generics for reusability\n• Type third-party libraries\n• Export types separately\n• Use type inference",
      "explanation": "TypeScript in React Native provides static typing for props, state, and navigation, improving code quality through type safety, better IDE support, and compile-time error detection.",
      "difficulty": "Medium",
      "code": "// Creating TypeScript React Native project\n// npx react-native init MyApp --template react-native-template-typescript\n\n// tsconfig.json\n/*\n{\n  \"compilerOptions\": {\n    \"target\": \"esnext\",\n    \"module\": \"commonjs\",\n    \"lib\": [\"es2017\"],\n    \"jsx\": \"react-native\",\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"resolveJsonModule\": true,\n    \"moduleResolution\": \"node\",\n    \"allowSyntheticDefaultImports\": true\n  },\n  \"exclude\": [\"node_modules\"]\n}\n*/\n\n// Component with TypeScript\nimport React, { FC, useState } from 'react';\nimport { View, Text, TextInput, Button, StyleSheet } from 'react-native';\n\n// Props interface\ninterface LoginFormProps {\n  onSubmit: (email: string, password: string) => Promise<void>;\n  loading?: boolean;\n  error?: string;\n}\n\n// Component with typed props\nexport const LoginForm: FC<LoginFormProps> = ({\n  onSubmit,\n  loading = false,\n  error\n}) => {\n  const [email, setEmail] = useState<string>('');\n  const [password, setPassword] = useState<string>('');\n  \n  const handleSubmit = async (): Promise<void> => {\n    await onSubmit(email, password);\n  };\n  \n  return (\n    <View style={styles.container}>\n      <TextInput\n        value={email}\n        onChangeText={setEmail}\n        placeholder=\"Email\"\n      />\n      <TextInput\n        value={password}\n        onChangeText={setPassword}\n        placeholder=\"Password\"\n        secureTextEntry\n      />\n      {error && <Text style={styles.error}>{error}</Text>}\n      <Button title=\"Login\" onPress={handleSubmit} disabled={loading} />\n    </View>\n  );\n};\n\n// Navigation types\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\n\ntype RootStackParamList = {\n  Home: undefined;\n  Profile: { userId: string };\n  Settings: { section?: string };\n};\n\ntype ProfileScreenProps = NativeStackScreenProps<RootStackParamList, 'Profile'>;\n\nconst ProfileScreen: FC<ProfileScreenProps> = ({ route, navigation }) => {\n  const { userId } = route.params;\n  \n  navigation.navigate('Settings', { section: 'profile' });\n  \n  return <Text>Profile: {userId}</Text>;\n};\n\n// API types\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n  avatar?: string;\n}\n\ninterface ApiResponse<T> {\n  data: T;\n  status: number;\n  message?: string;\n}\n\nconst fetchUser = async (id: string): Promise<ApiResponse<User>> => {\n  const response = await fetch(`/api/users/${id}`);\n  return response.json();\n};\n\n// Custom hook with TypeScript\ninterface UseApiResult<T> {\n  data: T | null;\n  loading: boolean;\n  error: Error | null;\n  refetch: () => void;\n}\n\nfunction useApi<T>(url: string): UseApiResult<T> {\n  const [data, setData] = useState<T | null>(null);\n  const [loading, setLoading] = useState<boolean>(true);\n  const [error, setError] = useState<Error | null>(null);\n  \n  const fetchData = async (): Promise<void> => {\n    try {\n      setLoading(true);\n      const response = await fetch(url);\n      const json = await response.json();\n      setData(json);\n    } catch (err) {\n      setError(err as Error);\n    } finally {\n      setLoading(false);\n    }\n  };\n  \n  return { data, loading, error, refetch: fetchData };\n}\n\n// Usage\nconst { data, loading } = useApi<User[]>('/api/users');\n\nconst styles = StyleSheet.create({\n  container: { padding: 20 },\n  error: { color: 'red' }\n});"
    },
    {
      "id": 76,
      "question": "What are the best practices for React Native app security?",
      "answer": "Security best practices protect user data and prevent vulnerabilities.\n\nCommon Security Threats:\n• Data storage vulnerabilities\n• Insecure network communication\n• Code tampering and reverse engineering\n• Insufficient authentication\n• Insecure APIs\n• Man-in-the-middle attacks\n• Root/jailbreak detection bypass\n\nSecurity Best Practices:\n• Use HTTPS for all network requests\n• Implement SSL certificate pinning\n• Store sensitive data securely (Keychain/Keystore)\n• Never store passwords or keys in code\n• Validate all user input\n• Implement proper authentication\n• Use biometric authentication\n• Obfuscate code\n• Implement root/jailbreak detection\n• Use encrypted storage\n• Implement proper session management\n• Keep dependencies updated\n• Use environment variables for secrets\n• Implement rate limiting\n• Add security headers\n• Test for vulnerabilities",
      "explanation": "React Native security involves HTTPS communication, SSL pinning, secure storage with Keychain/Keystore, input validation, code obfuscation, root detection, and proper authentication to protect against common vulnerabilities.",
      "difficulty": "Hard",
      "code": "// 1. SSL Certificate Pinning\nimport { fetch } from 'react-native-ssl-pinning';\n\nconst secureRequest = async () => {\n  try {\n    const response = await fetch('https://api.example.com/data', {\n      method: 'POST',\n      timeoutInterval: 10000,\n      sslPinning: {\n        certs: ['certificate'], // certificate name in assets\n      },\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ data: 'value' })\n    });\n    return response.json();\n  } catch (error) {\n    console.error('SSL Pinning Error:', error);\n  }\n};\n\n// 2. Root/Jailbreak Detection\nimport JailMonkey from 'jail-monkey';\n\nconst checkDeviceSecurity = () => {\n  const isJailBroken = JailMonkey.isJailBroken();\n  const canMockLocation = JailMonkey.canMockLocation();\n  const trustFall = JailMonkey.trustFall();\n  \n  if (isJailBroken || canMockLocation) {\n    Alert.alert(\n      'Security Warning',\n      'This device may be compromised. Some features may not work.',\n      [{ text: 'OK' }]\n    );\n    return false;\n  }\n  return true;\n};\n\n// 3. Input Validation\nconst validateInput = (input: string, type: 'email' | 'phone' | 'text'): boolean => {\n  // Prevent injection attacks\n  const sanitized = input.trim();\n  \n  switch (type) {\n    case 'email':\n      const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n      return emailRegex.test(sanitized);\n    case 'phone':\n      const phoneRegex = /^\\+?[1-9]\\d{1,14}$/;\n      return phoneRegex.test(sanitized.replace(/\\s/g, ''));\n    case 'text':\n      // Check for SQL injection patterns\n      const sqlPatterns = /('|(--)|;|\\*|\\/\\*|\\*\\/|xp_|sp_)/i;\n      return !sqlPatterns.test(sanitized);\n    default:\n      return false;\n  }\n};\n\n// 4. Secure API Client\nimport axios, { AxiosInstance } from 'axios';\nimport { getToken } from './secureStorage';\n\nclass SecureApiClient {\n  private client: AxiosInstance;\n  \n  constructor() {\n    this.client = axios.create({\n      baseURL: process.env.API_BASE_URL,\n      timeout: 10000,\n      headers: {\n        'Content-Type': 'application/json',\n        'X-App-Version': '1.0.0'\n      }\n    });\n    \n    // Request interceptor\n    this.client.interceptors.request.use(\n      async (config) => {\n        const token = await getToken();\n        if (token) {\n          config.headers.Authorization = `Bearer ${token}`;\n        }\n        // Add request signature\n        config.headers['X-Request-ID'] = this.generateRequestId();\n        return config;\n      },\n      (error) => Promise.reject(error)\n    );\n    \n    // Response interceptor\n    this.client.interceptors.response.use(\n      (response) => response,\n      async (error) => {\n        if (error.response?.status === 401) {\n          // Handle unauthorized - logout user\n          await this.handleUnauthorized();\n        }\n        return Promise.reject(error);\n      }\n    );\n  }\n  \n  private generateRequestId(): string {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n  \n  private async handleUnauthorized(): Promise<void> {\n    // Clear tokens and redirect to login\n    await clearTokens();\n    // Navigate to login\n  }\n  \n  async get<T>(url: string): Promise<T> {\n    const response = await this.client.get<T>(url);\n    return response.data;\n  }\n  \n  async post<T>(url: string, data: any): Promise<T> {\n    const response = await this.client.post<T>(url, data);\n    return response.data;\n  }\n}\n\n// 5. Environment Variables (.env)\n/*\nAPI_BASE_URL=https://api.example.com\nAPI_KEY=your_api_key_here\nENABLE_LOGGING=false\n*/\n\n// Access in code\nimport Config from 'react-native-config';\n\nconst apiUrl = Config.API_BASE_URL;\nconst apiKey = Config.API_KEY;\n\n// 6. Code Obfuscation (metro.config.js)\n/*\nmodule.exports = {\n  transformer: {\n    minifierPath: 'metro-minify-terser',\n    minifierConfig: {\n      compress: {\n        drop_console: true, // Remove console.log in production\n      },\n      mangle: {\n        keep_fnames: false,\n      },\n    },\n  },\n};\n*/\n\n// 7. Secure Session Management\nclass SessionManager {\n  private static TOKEN_EXPIRY_KEY = '@token_expiry';\n  private static REFRESH_THRESHOLD = 5 * 60 * 1000; // 5 minutes\n  \n  static async isSessionValid(): Promise<boolean> {\n    const expiry = await AsyncStorage.getItem(this.TOKEN_EXPIRY_KEY);\n    if (!expiry) return false;\n    \n    const expiryTime = parseInt(expiry, 10);\n    return Date.now() < expiryTime;\n  }\n  \n  static async shouldRefreshToken(): Promise<boolean> {\n    const expiry = await AsyncStorage.getItem(this.TOKEN_EXPIRY_KEY);\n    if (!expiry) return false;\n    \n    const expiryTime = parseInt(expiry, 10);\n    return Date.now() > (expiryTime - this.REFRESH_THRESHOLD);\n  }\n  \n  static async setTokenExpiry(expiresIn: number): Promise<void> {\n    const expiryTime = Date.now() + (expiresIn * 1000);\n    await AsyncStorage.setItem(this.TOKEN_EXPIRY_KEY, expiryTime.toString());\n  }\n}"
    },
    {
      "id": 77,
      "question": "What is App Bundle Size Optimization in React Native?",
      "answer": "Bundle size optimization reduces app size for faster downloads and better user experience.\n\nBundle Size Impact:\n• Download time\n• Installation time\n• Storage space\n• Update frequency\n• User retention\n\nOptimization Techniques:\n• Enable Hermes engine\n• Remove unused dependencies\n• Tree shaking and dead code elimination\n• Image optimization\n• Code splitting and lazy loading\n• Enable ProGuard/R8 (Android)\n• Asset optimization\n• Use vector graphics (SVG)\n• Compress assets\n• Remove debugging code\n• Analyze bundle composition\n• Use smaller alternatives\n• Enable minification\n\nTools:\n• react-native-bundle-visualizer - analyze bundle\n• Metro bundler optimization\n• Android App Bundle (AAB)\n• iOS App Thinning\n\nMeasurement:\n• Track APK/IPA size\n• Monitor over time\n• Set size budgets",
      "explanation": "Bundle size optimization reduces React Native app size through Hermes engine, ProGuard, image compression, code splitting, tree shaking, and removing unused dependencies for faster downloads and installs.",
      "difficulty": "Hard",
      "code": "// 1. Analyze bundle size\n// npm install --save-dev react-native-bundle-visualizer\n// npx react-native-bundle-visualizer\n\n// 2. Enable Hermes (android/app/build.gradle)\n/*\nproject.ext.react = [\n    enableHermes: true\n]\n*/\n\n// 3. Enable ProGuard (android/app/build.gradle)\n/*\nandroid {\n    buildTypes {\n        release {\n            minifyEnabled true\n            shrinkResources true\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n*/\n\n// 4. Image Optimization\nimport FastImage from 'react-native-fast-image';\n\n// Use WebP format (smaller than PNG/JPG)\nconst OptimizedImage = () => (\n  <FastImage\n    source={{\n      uri: 'https://example.com/image.webp',\n      priority: FastImage.priority.normal\n    }}\n    style={{ width: 200, height: 200 }}\n    resizeMode={FastImage.resizeMode.cover}\n  />\n);\n\n// 5. Lazy load heavy components\nimport React, { lazy, Suspense } from 'react';\n\nconst HeavyChart = lazy(() => import('./HeavyChart'));\n\nconst ChartScreen = () => (\n  <Suspense fallback={<ActivityIndicator />}>\n    <HeavyChart />\n  </Suspense>\n);\n\n// 6. Use smaller library alternatives\n// Instead of moment.js (large), use date-fns or dayjs\nimport dayjs from 'dayjs'; // Much smaller\n\nconst formatDate = (date) => dayjs(date).format('YYYY-MM-DD');\n\n// 7. Remove console.logs in production (metro.config.js)\n/*\nconst { getDefaultConfig } = require('metro-config');\n\nmodule.exports = (async () => {\n  const defaultConfig = await getDefaultConfig();\n  return {\n    ...defaultConfig,\n    transformer: {\n      ...defaultConfig.transformer,\n      minifierConfig: {\n        compress: {\n          drop_console: true, // Remove console.log\n        },\n      },\n    },\n  };\n})();\n*/\n\n// 8. Optimize imports - use specific imports\n// Bad - imports entire library\nimport _ from 'lodash';\n\n// Good - imports only what's needed\nimport debounce from 'lodash/debounce';\nimport throttle from 'lodash/throttle';\n\n// 9. Vector icons instead of images\nimport Icon from 'react-native-vector-icons/Ionicons';\n\nconst IconButton = () => (\n  <Icon name=\"home\" size={30} color=\"#000\" />\n);\n\n// 10. Build Android App Bundle (AAB)\n/*\ncd android\n./gradlew bundleRelease\n\n# Output: android/app/build/outputs/bundle/release/app-release.aab\n# Smaller download size with Google Play's dynamic delivery\n*/\n\n// 11. Analyze package sizes\n// package.json script\n/*\n{\n  \"scripts\": {\n    \"analyze\": \"npx react-native-bundle-visualizer\",\n    \"bundle-size\": \"du -sh ios/build/Build/Products/Release-iphonesimulator/MyApp.app\"\n  }\n}\n*/\n\n// 12. Remove unused dependencies\n// npm install -g depcheck\n// depcheck\n\n// 13. Use production builds for testing\n/*\n# iOS\nreact-native run-ios --configuration Release\n\n# Android\nreact-native run-android --variant=release\n*/\n\n// 14. Asset optimization script\n/*\n# Install dependencies\nnpm install --save-dev imagemin imagemin-mozjpeg imagemin-pngquant\n\n# Create script: scripts/optimize-images.js\nconst imagemin = require('imagemin');\nconst imageminMozjpeg = require('imagemin-mozjpeg');\nconst imageminPngquant = require('imagemin-pngquant');\n\n(async () => {\n  await imagemin(['src/assets/images/*.{jpg,png}'], {\n    destination: 'src/assets/images/optimized',\n    plugins: [\n      imageminMozjpeg({ quality: 75 }),\n      imageminPngquant({ quality: [0.6, 0.8] })\n    ]\n  });\n  console.log('Images optimized!');\n})();\n*/\n\n// 15. Monitor bundle size in CI/CD\n/*\n# GitHub Actions example\n- name: Check bundle size\n  run: |\n    npm run build\n    BUNDLE_SIZE=$(du -sh android/app/build/outputs/apk/release/app-release.apk | cut -f1)\n    echo \"Bundle size: $BUNDLE_SIZE\"\n    # Fail if size exceeds threshold\n*/"
    },
    {
      "id": 78,
      "question": "What is Background Task Management in React Native?",
      "answer": "Background tasks allow apps to perform work when not in foreground.\n\nBackground Task Types:\n• Background fetch - periodic data updates\n• Background geolocation - location tracking\n• Background audio - music playback\n• Push notification handling\n• Background uploads/downloads\n• Scheduled tasks\n\nLimitations:\n• iOS restricts background execution\n• Android has Doze mode restrictions\n• Battery optimization impacts\n• Different OS versions behave differently\n• Limited execution time\n\nLibraries:\n• react-native-background-fetch - periodic tasks\n• react-native-background-task - scheduled tasks\n• react-native-background-geolocation - location\n• Headless JS (Android) - background tasks\n\nBest Practices:\n• Minimize battery usage\n• Handle task completion\n• Respect OS limitations\n• Test on actual devices\n• Request proper permissions\n• Provide user controls\n• Handle failures gracefully",
      "explanation": "Background tasks in React Native enable periodic data fetching, location tracking, and scheduled work using libraries like background-fetch, with OS-specific limitations and battery considerations.",
      "difficulty": "Hard",
      "code": "// 1. Background Fetch\nimport BackgroundFetch from 'react-native-background-fetch';\n\nclass BackgroundFetchManager {\n  static async configure() {\n    try {\n      const status = await BackgroundFetch.configure(\n        {\n          minimumFetchInterval: 15, // minutes\n          stopOnTerminate: false,\n          enableHeadless: true,\n          startOnBoot: true,\n          requiredNetworkType: BackgroundFetch.NETWORK_TYPE_ANY\n        },\n        async (taskId) => {\n          console.log('[BackgroundFetch] Event:', taskId);\n          \n          // Perform background work\n          try {\n            await this.performBackgroundTask();\n            \n            // IMPORTANT: Signal completion\n            BackgroundFetch.finish(taskId);\n          } catch (error) {\n            console.error('[BackgroundFetch] Error:', error);\n            BackgroundFetch.finish(taskId);\n          }\n        },\n        (taskId) => {\n          // Task timeout callback\n          console.log('[BackgroundFetch] TIMEOUT:', taskId);\n          BackgroundFetch.finish(taskId);\n        }\n      );\n      \n      console.log('[BackgroundFetch] Status:', status);\n    } catch (error) {\n      console.error('[BackgroundFetch] Configure error:', error);\n    }\n  }\n  \n  static async performBackgroundTask() {\n    // Sync data, check notifications, etc.\n    const response = await fetch('https://api.example.com/sync');\n    const data = await response.json();\n    await AsyncStorage.setItem('@cached_data', JSON.stringify(data));\n    return data;\n  }\n  \n  static async scheduleTask() {\n    await BackgroundFetch.scheduleTask({\n      taskId: 'com.myapp.customtask',\n      delay: 60000, // milliseconds\n      periodic: false,\n      forceAlarmManager: true\n    });\n  }\n  \n  static async stop() {\n    await BackgroundFetch.stop();\n  }\n}\n\n// Initialize in App.tsx\nBackgroundFetchManager.configure();\n\n// 2. Headless JS (Android) - index.js\nimport { AppRegistry } from 'react-native';\nimport App from './App';\n\n// Background task handler\nconst BackgroundTask = async (taskData) => {\n  console.log('[Headless] Task started:', taskData);\n  \n  try {\n    // Perform work\n    await fetch('https://api.example.com/background');\n    \n    // Must finish in limited time\n    return Promise.resolve();\n  } catch (error) {\n    console.error('[Headless] Error:', error);\n    return Promise.reject(error);\n  }\n};\n\nAppRegistry.registerComponent('MyApp', () => App);\nAppRegistry.registerHeadlessTask('BackgroundTask', () => BackgroundTask);\n\n// Trigger from native (Android)\n/*\n// MainApplication.java\nimport com.facebook.react.HeadlessJsTaskService;\n\npublic class MyTaskService extends HeadlessJsTaskService {\n  @Override\n  protected HeadlessJsTaskConfig getTaskConfig(Intent intent) {\n    Bundle extras = intent.getExtras();\n    return new HeadlessJsTaskConfig(\n      \"BackgroundTask\",\n      extras != null ? Arguments.fromBundle(extras) : null,\n      5000, // timeout\n      true  // allow in foreground\n    );\n  }\n}\n*/\n\n// 3. Background Geolocation\nimport BackgroundGeolocation from 'react-native-background-geolocation';\n\nclass LocationManager {\n  static async configure() {\n    await BackgroundGeolocation.ready({\n      desiredAccuracy: BackgroundGeolocation.DESIRED_ACCURACY_HIGH,\n      distanceFilter: 10,\n      stopTimeout: 5,\n      debug: false,\n      logLevel: BackgroundGeolocation.LOG_LEVEL_OFF,\n      stopOnTerminate: false,\n      startOnBoot: true,\n      url: 'https://api.example.com/locations',\n      autoSync: true,\n      headers: {\n        Authorization: 'Bearer token'\n      }\n    });\n    \n    // Location listener\n    BackgroundGeolocation.onLocation(\n      (location) => {\n        console.log('[Location]:', location);\n      },\n      (error) => {\n        console.error('[Location] Error:', error);\n      }\n    );\n  }\n  \n  static async start() {\n    await BackgroundGeolocation.start();\n  }\n  \n  static async stop() {\n    await BackgroundGeolocation.stop();\n  }\n  \n  static async getCurrentPosition() {\n    const location = await BackgroundGeolocation.getCurrentPosition({\n      timeout: 30,\n      maximumAge: 5000,\n      enableHighAccuracy: true\n    });\n    return location;\n  }\n}\n\n// 4. Background Audio\nimport TrackPlayer, {\n  Capability,\n  Event\n} from 'react-native-track-player';\n\nclass AudioManager {\n  static async setup() {\n    await TrackPlayer.setupPlayer();\n    \n    await TrackPlayer.updateOptions({\n      capabilities: [\n        Capability.Play,\n        Capability.Pause,\n        Capability.SkipToNext,\n        Capability.SkipToPrevious,\n        Capability.Stop\n      ],\n      compactCapabilities: [\n        Capability.Play,\n        Capability.Pause\n      ]\n    });\n  }\n  \n  static async addTrack(track) {\n    await TrackPlayer.add({\n      id: track.id,\n      url: track.url,\n      title: track.title,\n      artist: track.artist,\n      artwork: track.artwork\n    });\n  }\n  \n  static async play() {\n    await TrackPlayer.play();\n  }\n  \n  static async pause() {\n    await TrackPlayer.pause();\n  }\n}\n\n// Register playback service (index.js)\nimport TrackPlayer from 'react-native-track-player';\n\nTrackPlayer.registerPlaybackService(() => require('./service'));\n\n// service.js\nmodule.exports = async function() {\n  TrackPlayer.addEventListener(Event.RemotePlay, () => {\n    TrackPlayer.play();\n  });\n  \n  TrackPlayer.addEventListener(Event.RemotePause, () => {\n    TrackPlayer.pause();\n  });\n};"
    },
    {
      "id": 79,
      "question": "What is App State Management across App Lifecycle?",
      "answer": "App state management handles app transitions between active, background, and inactive states.\n\nApp States:\n• Active - app is in foreground and receiving events\n• Background - app is running but not visible\n• Inactive - transitioning between states (iOS)\n\nCommon Scenarios:\n• User switches apps\n• Phone call received\n• Lock screen\n• App terminated\n• App resumed\n• Deep link opened\n\nUse AppState API:\n• Listen to state changes\n• Perform actions on state transitions\n• Pause/resume operations\n• Clear sensitive data\n• Refresh data on resume\n• Stop timers and animations\n\nBest Practices:\n• Save state on background\n• Clear sensitive data on inactive\n• Refresh data on active\n• Stop animations/timers\n• Release resources\n• Handle interruptions\n• Test all transitions",
      "explanation": "AppState API manages app lifecycle states (active, background, inactive) enabling actions like pausing timers, saving state on background, refreshing data on resume, and clearing sensitive information.",
      "difficulty": "Medium",
      "code": "import React, { useEffect, useRef, useState } from 'react';\nimport { AppState, AppStateStatus, View, Text } from 'react-native';\nimport type { AppStateEvent } from 'react-native';\n\n// Custom hook for AppState\nfunction useAppState() {\n  const [appState, setAppState] = useState(AppState.currentState);\n  const appStateRef = useRef(AppState.currentState);\n  \n  useEffect(() => {\n    const subscription = AppState.addEventListener(\n      'change',\n      (nextAppState: AppStateStatus) => {\n        console.log('AppState changed:', appStateRef.current, '->', nextAppState);\n        \n        if (\n          appStateRef.current.match(/inactive|background/) &&\n          nextAppState === 'active'\n        ) {\n          console.log('App has come to the foreground!');\n          handleAppForeground();\n        }\n        \n        if (\n          appStateRef.current === 'active' &&\n          nextAppState.match(/inactive|background/)\n        ) {\n          console.log('App has gone to the background!');\n          handleAppBackground();\n        }\n        \n        appStateRef.current = nextAppState;\n        setAppState(nextAppState);\n      }\n    );\n    \n    return () => {\n      subscription.remove();\n    };\n  }, []);\n  \n  return appState;\n}\n\n// App state manager\nclass AppStateManager {\n  private static timers: NodeJS.Timeout[] = [];\n  private static subscriptions: any[] = [];\n  \n  // Called when app comes to foreground\n  static handleAppForeground() {\n    // Refresh data\n    this.refreshData();\n    \n    // Resume animations\n    this.resumeAnimations();\n    \n    // Restart timers\n    this.restartTimers();\n    \n    // Check for updates\n    this.checkForUpdates();\n  }\n  \n  // Called when app goes to background\n  static handleAppBackground() {\n    // Save state\n    this.saveAppState();\n    \n    // Pause animations\n    this.pauseAnimations();\n    \n    // Clear timers\n    this.clearTimers();\n    \n    // Clear sensitive data from memory\n    this.clearSensitiveData();\n  }\n  \n  private static async refreshData() {\n    try {\n      const response = await fetch('https://api.example.com/refresh');\n      const data = await response.json();\n      // Update app state with fresh data\n    } catch (error) {\n      console.error('Refresh data error:', error);\n    }\n  }\n  \n  private static async saveAppState() {\n    try {\n      const state = {\n        lastActiveTime: Date.now(),\n        currentScreen: getCurrentScreen(),\n        // ... other state\n      };\n      await AsyncStorage.setItem('@app_state', JSON.stringify(state));\n    } catch (error) {\n      console.error('Save state error:', error);\n    }\n  }\n  \n  private static pauseAnimations() {\n    // Pause all running animations\n  }\n  \n  private static resumeAnimations() {\n    // Resume paused animations\n  }\n  \n  private static clearTimers() {\n    this.timers.forEach(timer => clearTimeout(timer));\n    this.timers = [];\n  }\n  \n  private static restartTimers() {\n    // Restart necessary timers\n  }\n  \n  private static clearSensitiveData() {\n    // Clear passwords, tokens from memory (not storage)\n    // Force garbage collection if possible\n  }\n  \n  private static async checkForUpdates() {\n    // Check for app updates or new content\n  }\n}\n\n// Usage in component\nfunction AppStateComponent() {\n  const appState = useAppState();\n  const [data, setData] = useState(null);\n  const intervalRef = useRef<NodeJS.Timeout | null>(null);\n  \n  useEffect(() => {\n    const subscription = AppState.addEventListener('change', handleAppStateChange);\n    \n    return () => {\n      subscription.remove();\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n      }\n    };\n  }, []);\n  \n  const handleAppStateChange = (nextAppState: AppStateStatus) => {\n    if (nextAppState === 'active') {\n      // App is active - start polling\n      startPolling();\n    } else if (nextAppState.match(/inactive|background/)) {\n      // App is background - stop polling\n      stopPolling();\n    }\n  };\n  \n  const startPolling = () => {\n    if (!intervalRef.current) {\n      intervalRef.current = setInterval(() => {\n        fetchData();\n      }, 5000);\n    }\n  };\n  \n  const stopPolling = () => {\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n      intervalRef.current = null;\n    }\n  };\n  \n  const fetchData = async () => {\n    try {\n      const response = await fetch('https://api.example.com/data');\n      const json = await response.json();\n      setData(json);\n    } catch (error) {\n      console.error('Fetch error:', error);\n    }\n  };\n  \n  return (\n    <View>\n      <Text>App State: {appState}</Text>\n      <Text>Data: {JSON.stringify(data)}</Text>\n    </View>\n  );\n}\n\n// Initialize in App.tsx\nfunction App() {\n  useEffect(() => {\n    const subscription = AppState.addEventListener('change', (state) => {\n      if (state === 'active') {\n        AppStateManager.handleAppForeground();\n      } else {\n        AppStateManager.handleAppBackground();\n      }\n    });\n    \n    return () => subscription.remove();\n  }, []);\n  \n  return <AppStateComponent />;\n}\n\nexport default App;"
    },
    {
      "id": 80,
      "question": "What are Advanced React Native Performance Patterns?",
      "answer": "Advanced performance patterns optimize React Native apps for production-level performance.\n\nAdvanced Techniques:\n• Native module optimization\n• Bridge batching\n• InteractionManager for deferred work\n• requestAnimationFrame for animations\n• LayoutAnimation for native animations\n• shouldComponentUpdate optimization\n• Immutable data structures\n• Virtualization patterns\n• Memory pooling\n• Worker threads\n• Native driver usage\n• Bundle splitting strategies\n\nPerformance Monitoring:\n• Systrace for Android profiling\n• Instruments for iOS profiling\n• React DevTools Profiler\n• Custom performance markers\n• FPS monitoring\n• Memory profiling\n• Network profiling\n\nProduction Optimizations:\n• Enable RAM bundles\n• Inline requires\n• ProGuard/R8 optimization\n• Image lazy loading\n• Component preloading\n• Predictive prefetching",
      "explanation": "Advanced performance patterns include InteractionManager for deferred work, native driver animations, bridge batching, virtualization, RAM bundles, and profiling with Systrace/Instruments for production optimization.",
      "difficulty": "Hard",
      "code": "import React, { useEffect, useCallback } from 'react';\nimport {\n  InteractionManager,\n  LayoutAnimation,\n  UIManager,\n  Platform\n} from 'react-native';\n\n// 1. InteractionManager - Defer expensive work\nfunction DeferredWorkComponent() {\n  useEffect(() => {\n    // Schedule work after interactions complete\n    const handle = InteractionManager.runAfterInteractions(() => {\n      // Expensive work here (data processing, rendering)\n      performExpensiveOperation();\n    });\n    \n    return () => handle.cancel();\n  }, []);\n  \n  const performExpensiveOperation = () => {\n    // Heavy computation that can wait\n    const largeArray = Array(10000).fill(0).map((_, i) => i * 2);\n  };\n}\n\n// 2. requestAnimationFrame for smooth animations\nfunction AnimationComponent() {\n  const animateValue = useCallback(() => {\n    let frame = 0;\n    const animate = () => {\n      frame++;\n      if (frame < 60) {\n        requestAnimationFrame(animate);\n        // Update animation value\n      }\n    };\n    requestAnimationFrame(animate);\n  }, []);\n}\n\n// 3. LayoutAnimation for native performance\nif (Platform.OS === 'android') {\n  UIManager.setLayoutAnimationEnabledExperimental?.(true);\n}\n\nfunction LayoutAnimationExample() {\n  const [expanded, setExpanded] = useState(false);\n  \n  const toggleExpand = () => {\n    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);\n    setExpanded(!expanded);\n  };\n  \n  return (\n    <View>\n      <TouchableOpacity onPress={toggleExpand}>\n        <Text>Toggle</Text>\n      </TouchableOpacity>\n      {expanded && <View style={{ height: 200 }} />}\n    </View>\n  );\n}\n\n// 4. Batch operations to reduce bridge calls\nclass BatchedOperations {\n  private queue: Array<() => void> = [];\n  private batchTimer: NodeJS.Timeout | null = null;\n  \n  addOperation(operation: () => void) {\n    this.queue.push(operation);\n    \n    if (!this.batchTimer) {\n      this.batchTimer = setTimeout(() => {\n        this.executeBatch();\n      }, 16); // ~60fps\n    }\n  }\n  \n  private executeBatch() {\n    const operations = [...this.queue];\n    this.queue = [];\n    this.batchTimer = null;\n    \n    // Execute all operations at once\n    operations.forEach(op => op());\n  }\n}\n\n// 5. Memory pooling for object reuse\nclass ObjectPool<T> {\n  private pool: T[] = [];\n  private factory: () => T;\n  private reset: (obj: T) => void;\n  \n  constructor(factory: () => T, reset: (obj: T) => void, initialSize = 10) {\n    this.factory = factory;\n    this.reset = reset;\n    \n    // Pre-create objects\n    for (let i = 0; i < initialSize; i++) {\n      this.pool.push(factory());\n    }\n  }\n  \n  acquire(): T {\n    return this.pool.pop() || this.factory();\n  }\n  \n  release(obj: T): void {\n    this.reset(obj);\n    this.pool.push(obj);\n  }\n}\n\n// Usage\nconst itemPool = new ObjectPool(\n  () => ({ id: 0, data: null }),\n  (obj) => { obj.id = 0; obj.data = null; },\n  20\n);\n\n// 6. Custom performance monitoring\nclass PerformanceMonitor {\n  private static marks: Map<string, number> = new Map();\n  \n  static mark(label: string): void {\n    this.marks.set(label, performance.now());\n  }\n  \n  static measure(startLabel: string, endLabel?: string): number {\n    const start = this.marks.get(startLabel);\n    const end = endLabel ? this.marks.get(endLabel) : performance.now();\n    \n    if (start === undefined) return 0;\n    \n    const duration = end! - start;\n    console.log(`[Performance] ${startLabel}: ${duration.toFixed(2)}ms`);\n    return duration;\n  }\n  \n  static clear(label: string): void {\n    this.marks.delete(label);\n  }\n}\n\n// Usage\nPerformanceMonitor.mark('data-fetch-start');\nawait fetchData();\nPerformanceMonitor.measure('data-fetch-start');\n\n// 7. RAM Bundle (metro.config.js)\n/*\nmodule.exports = {\n  transformer: {\n    getTransformOptions: async () => ({\n      transform: {\n        experimentalImportSupport: false,\n        inlineRequires: true, // Critical for RAM bundles\n      },\n    }),\n  },\n};\n*/\n\n// 8. Component preloading\nclass ComponentPreloader {\n  private static preloaded = new Set<string>();\n  \n  static async preload(componentImport: () => Promise<any>, id: string) {\n    if (this.preloaded.has(id)) return;\n    \n    InteractionManager.runAfterInteractions(async () => {\n      await componentImport();\n      this.preloaded.add(id);\n    });\n  }\n}\n\n// Usage\nComponentPreloader.preload(() => import('./HeavyScreen'), 'heavy-screen');\n\n// 9. FPS Monitor\nimport { useFps } from 'react-native-fps';\n\nfunction FPSMonitor() {\n  const fps = useFps();\n  \n  if (__DEV__) {\n    return <Text style={{ position: 'absolute', top: 0 }}>FPS: {fps}</Text>;\n  }\n  return null;\n}"
    },
    {
      "id": 81,
      "question": "What is React Native Splash Screen implementation?",
      "answer": "Splash screens provide visual feedback during app launch while the JavaScript bundle loads.\n\nPurpose:\n• Improve perceived performance\n• Brand visibility\n• Hide loading process\n• Professional appearance\n• iOS/Android requirement compliance\n\nImplementation Approaches:\n• Native splash screens (preferred)\n• react-native-splash-screen library\n• react-native-bootsplash\n• Expo splash screen (managed)\n\nNative Setup:\n• iOS - LaunchScreen.storyboard\n• Android - themes and drawable resources\n• Keep simple (no animations)\n• Match first app screen\n• Fast loading\n\nBest Practices:\n• Keep splash screen simple\n• Use vector graphics\n• Match first screen design\n• Hide splash when ready\n• Don't show too long\n• Test on slow devices\n• Optimize bundle for faster load",
      "explanation": "Splash screens display native UI during JavaScript bundle loading using native configurations or libraries like react-native-bootsplash, providing brand visibility and improving perceived app startup performance.",
      "difficulty": "Medium",
      "code": "// Installation: npm install react-native-bootsplash\n\n// 1. Generate splash screen assets\n/*\nnpx react-native generate-bootsplash assets/logo.png \\\n  --background-color=FFFFFF \\\n  --logo-width=100 \\\n  --assets-path=assets \\\n  --flavor=main\n*/\n\n// 2. iOS Setup (ios/AppDelegate.mm)\n/*\n#import \"RNBootSplash.h\"\n\n@implementation AppDelegate\n\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n{\n  // ... existing code\n  \n  [RNBootSplash initWithStoryboard:@\"BootSplash\" rootView:rootView];\n  \n  return YES;\n}\n\n@end\n*/\n\n// 3. Android Setup (android/app/src/main/java/.../MainActivity.java)\n/*\nimport com.zoontek.rnbootsplash.RNBootSplash;\n\npublic class MainActivity extends ReactActivity {\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    RNBootSplash.init(this);\n    super.onCreate(savedInstanceState);\n  }\n}\n*/\n\n// 4. Hide splash screen in App.tsx\nimport React, { useEffect } from 'react';\nimport RNBootSplash from 'react-native-bootsplash';\n\nfunction App() {\n  useEffect(() => {\n    const init = async () => {\n      // Perform initialization tasks\n      await loadAppData();\n      await checkAuthentication();\n      \n      // Hide splash screen\n      await RNBootSplash.hide({ fade: true });\n    };\n    \n    init();\n  }, []);\n  \n  return <AppNavigator />;\n}\n\n// 5. With Navigation (App.tsx)\nimport { NavigationContainer } from '@react-navigation/native';\n\nfunction App() {\n  const [isReady, setIsReady] = useState(false);\n  \n  useEffect(() => {\n    async function prepare() {\n      try {\n        // Pre-load fonts, make API calls, etc.\n        await Font.loadAsync(customFonts);\n        await loadUserData();\n      } catch (e) {\n        console.warn(e);\n      } finally {\n        setIsReady(true);\n      }\n    }\n    \n    prepare();\n  }, []);\n  \n  const onReady = useCallback(async () => {\n    await RNBootSplash.hide({ fade: true });\n  }, []);\n  \n  if (!isReady) {\n    return null;\n  }\n  \n  return (\n    <NavigationContainer onReady={onReady}>\n      <RootNavigator />\n    </NavigationContainer>\n  );\n}\n\n// 6. Custom Animation\nconst hideSplashWithAnimation = async () => {\n  const opacity = new Animated.Value(1);\n  \n  Animated.timing(opacity, {\n    toValue: 0,\n    duration: 500,\n    useNativeDriver: true\n  }).start(async () => {\n    await RNBootSplash.hide();\n  });\n};\n\n// 7. iOS LaunchScreen.storyboard (Manual)\n/*\n1. Open Xcode\n2. Navigate to ios/[ProjectName]/LaunchScreen.storyboard\n3. Add ImageView for logo\n4. Set constraints for centering\n5. Add image asset to Images.xcassets\n6. Configure background color\n*/\n\n// 8. Android themes (Manual) - android/app/src/main/res/values/styles.xml\n/*\n<resources>\n  <style name=\"AppTheme\" parent=\"Theme.AppCompat.DayNight.NoActionBar\">\n    <item name=\"android:windowBackground\">@drawable/launch_screen</item>\n  </style>\n  \n  <style name=\"SplashTheme\" parent=\"Theme.AppCompat.DayNight.NoActionBar\">\n    <item name=\"android:windowBackground\">@drawable/launch_screen</item>\n  </style>\n</resources>\n*/\n\n// 9. Android drawable - android/app/src/main/res/drawable/launch_screen.xml\n/*\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\">\n  <item android:drawable=\"@color/splash_background\"/>\n  <item>\n    <bitmap\n      android:gravity=\"center\"\n      android:src=\"@drawable/logo\"/>\n  </item>\n</layer-list>\n*/\n\n// 10. Expo Splash Screen\n/*\n// app.json\n{\n  \"expo\": {\n    \"splash\": {\n      \"image\": \"./assets/splash.png\",\n      \"resizeMode\": \"contain\",\n      \"backgroundColor\": \"#ffffff\"\n    }\n  }\n}\n\n// App.tsx\nimport * as SplashScreen from 'expo-splash-screen';\n\nSplashScreen.preventAutoHideAsync();\n\nfunction App() {\n  useEffect(() => {\n    async function prepare() {\n      await loadAssets();\n      await SplashScreen.hideAsync();\n    }\n    prepare();\n  }, []);\n}\n*/\n\nexport default App;"
    },
    {
      "id": 82,
      "question": "What is React Native Configuration Management?",
      "answer": "Configuration management handles environment-specific settings and app configurations.\n\nConfiguration Types:\n• Environment variables (dev, staging, production)\n• API endpoints\n• Feature flags\n• App secrets\n• Build configurations\n• Platform-specific settings\n• Runtime configurations\n\nTools and Libraries:\n• react-native-config - environment variables\n• react-native-dotenv - .env file support\n• Firebase Remote Config - runtime config\n• Feature flags services\n\nEnvironment Setup:\n• .env files for different environments\n• Build variants (Android)\n• Build schemes (iOS)\n• CI/CD environment variables\n\nBest Practices:\n• Never commit secrets to git\n• Use different configs per environment\n• Validate configuration on startup\n• Type-safe configuration access\n• Document all config options\n• Use feature flags for gradual rollouts\n• Separate sensitive and non-sensitive config",
      "explanation": "Configuration management uses react-native-config and .env files for environment-specific settings, API endpoints, and feature flags, enabling different configurations for development, staging, and production environments.",
      "difficulty": "Medium",
      "code": "// Installation: npm install react-native-config\n\n// 1. Environment files\n// .env.development\n/*\nAPI_URL=https://dev-api.example.com\nAPI_KEY=dev_key_123\nENABLE_LOGGING=true\nFEATURE_NEW_UI=false\nENVIRONMENT=development\n*/\n\n// .env.staging\n/*\nAPI_URL=https://staging-api.example.com\nAPI_KEY=staging_key_456\nENABLE_LOGGING=true\nFEATURE_NEW_UI=true\nENVIRONMENT=staging\n*/\n\n// .env.production\n/*\nAPI_URL=https://api.example.com\nAPI_KEY=prod_key_789\nENABLE_LOGGING=false\nFEATURE_NEW_UI=true\nENVIRONMENT=production\n*/\n\n// 2. Access configuration\nimport Config from 'react-native-config';\n\nconst appConfig = {\n  apiUrl: Config.API_URL,\n  apiKey: Config.API_KEY,\n  enableLogging: Config.ENABLE_LOGGING === 'true',\n  environment: Config.ENVIRONMENT\n};\n\nexport default appConfig;\n\n// 3. Type-safe configuration\ninterface AppConfiguration {\n  apiUrl: string;\n  apiKey: string;\n  enableLogging: boolean;\n  features: {\n    newUI: boolean;\n    analytics: boolean;\n  };\n  environment: 'development' | 'staging' | 'production';\n}\n\nclass ConfigurationManager {\n  private static instance: AppConfiguration;\n  \n  static get config(): AppConfiguration {\n    if (!this.instance) {\n      this.instance = this.loadConfiguration();\n    }\n    return this.instance;\n  }\n  \n  private static loadConfiguration(): AppConfiguration {\n    return {\n      apiUrl: Config.API_URL || '',\n      apiKey: Config.API_KEY || '',\n      enableLogging: Config.ENABLE_LOGGING === 'true',\n      features: {\n        newUI: Config.FEATURE_NEW_UI === 'true',\n        analytics: Config.FEATURE_ANALYTICS === 'true'\n      },\n      environment: Config.ENVIRONMENT as any || 'development'\n    };\n  }\n  \n  static validateConfiguration(): boolean {\n    const required = ['apiUrl', 'apiKey', 'environment'];\n    const missing = required.filter(key => !Config[key.toUpperCase()]);\n    \n    if (missing.length > 0) {\n      console.error('Missing required configuration:', missing);\n      return false;\n    }\n    return true;\n  }\n}\n\n// 4. Feature flags\nclass FeatureFlags {\n  static isEnabled(feature: string): boolean {\n    const flagValue = Config[`FEATURE_${feature.toUpperCase()}`];\n    return flagValue === 'true';\n  }\n  \n  static getAll(): Record<string, boolean> {\n    const flags: Record<string, boolean> = {};\n    Object.keys(Config).forEach(key => {\n      if (key.startsWith('FEATURE_')) {\n        flags[key] = Config[key] === 'true';\n      }\n    });\n    return flags;\n  }\n}\n\n// Usage\nif (FeatureFlags.isEnabled('NEW_UI')) {\n  // Show new UI\n}\n\n// 5. API Client with configuration\nimport axios from 'axios';\n\nconst createApiClient = () => {\n  const client = axios.create({\n    baseURL: ConfigurationManager.config.apiUrl,\n    timeout: 10000,\n    headers: {\n      'X-API-Key': ConfigurationManager.config.apiKey,\n      'X-App-Version': '1.0.0'\n    }\n  });\n  \n  if (ConfigurationManager.config.enableLogging) {\n    client.interceptors.request.use(request => {\n      console.log('Request:', request);\n      return request;\n    });\n  }\n  \n  return client;\n};\n\nexport const apiClient = createApiClient();\n\n// 6. Firebase Remote Config\nimport remoteConfig from '@react-native-firebase/remote-config';\n\nclass RemoteConfigManager {\n  static async initialize() {\n    await remoteConfig().setDefaults({\n      feature_new_ui: false,\n      maintenance_mode: false,\n      min_app_version: '1.0.0'\n    });\n    \n    await remoteConfig().fetchAndActivate();\n  }\n  \n  static getValue(key: string): any {\n    return remoteConfig().getValue(key).asString();\n  }\n  \n  static getBoolean(key: string): boolean {\n    return remoteConfig().getValue(key).asBoolean();\n  }\n  \n  static getNumber(key: string): number {\n    return remoteConfig().getValue(key).asNumber();\n  }\n}\n\n// 7. Build scripts (package.json)\n/*\n{\n  \"scripts\": {\n    \"android:dev\": \"ENVFILE=.env.development react-native run-android\",\n    \"android:staging\": \"ENVFILE=.env.staging react-native run-android\",\n    \"android:prod\": \"ENVFILE=.env.production react-native run-android\",\n    \"ios:dev\": \"ENVFILE=.env.development react-native run-ios\",\n    \"ios:staging\": \"ENVFILE=.env.staging react-native run-ios\",\n    \"ios:prod\": \"ENVFILE=.env.production react-native run-ios\"\n  }\n}\n*/\n\n// 8. Initialize configuration on app start\nfunction App() {\n  useEffect(() => {\n    const initialize = async () => {\n      // Validate configuration\n      if (!ConfigurationManager.validateConfiguration()) {\n        Alert.alert('Configuration Error', 'App is not configured correctly');\n        return;\n      }\n      \n      // Initialize remote config\n      await RemoteConfigManager.initialize();\n      \n      console.log('Environment:', ConfigurationManager.config.environment);\n      console.log('Features:', ConfigurationManager.config.features);\n    };\n    \n    initialize();\n  }, []);\n  \n  return <AppNavigator />;\n}\n\nexport default App;"
    },
    {
      "id": 83,
      "question": "What is React Native Analytics and Crash Reporting Integration?",
      "answer": "Analytics and crash reporting track user behavior and app issues for data-driven decisions.\n\nAnalytics Types:\n• User behavior analytics\n• Screen views and navigation\n• Event tracking\n• User properties\n• Conversion funnels\n• Performance metrics\n• Custom events\n\nPopular Solutions:\n• Firebase Analytics - free, comprehensive\n• Google Analytics - web and mobile\n• Mixpanel - advanced analytics\n• Amplitude - product analytics\n• Segment - analytics aggregator\n\nCrash Reporting:\n• Sentry - error tracking\n• Firebase Crashlytics - crash reports\n• Bugsnag - stability monitoring\n• Instabug - bug reporting\n\nBest Practices:\n• Track meaningful events\n• Set user properties\n• Respect user privacy (GDPR)\n• Avoid tracking sensitive data\n• Use consistent naming\n• Set up conversion funnels\n• Monitor retention metrics\n• Test tracking in development",
      "explanation": "Analytics integration tracks user behavior and app events using services like Firebase Analytics or Mixpanel, while crash reporting with Sentry or Crashlytics monitors app stability and errors.",
      "difficulty": "Medium",
      "code": "// Installation: npm install @react-native-firebase/analytics @react-native-firebase/crashlytics\n\n// 1. Firebase Analytics Setup\nimport analytics from '@react-native-firebase/analytics';\nimport crashlytics from '@react-native-firebase/crashlytics';\n\nclass AnalyticsManager {\n  // Log screen view\n  static logScreenView(screenName: string, screenClass?: string) {\n    analytics().logScreenView({\n      screen_name: screenName,\n      screen_class: screenClass || screenName\n    });\n  }\n  \n  // Log custom event\n  static logEvent(eventName: string, params?: Record<string, any>) {\n    analytics().logEvent(eventName, params);\n  }\n  \n  // Set user properties\n  static setUserProperties(properties: Record<string, string>) {\n    Object.entries(properties).forEach(([key, value]) => {\n      analytics().setUserProperty(key, value);\n    });\n  }\n  \n  // Set user ID\n  static setUserId(userId: string) {\n    analytics().setUserId(userId);\n  }\n  \n  // Log purchase event\n  static logPurchase(transactionId: string, value: number, currency: string, items: any[]) {\n    analytics().logPurchase({\n      transaction_id: transactionId,\n      value: value,\n      currency: currency,\n      items: items\n    });\n  }\n  \n  // Log app open\n  static logAppOpen() {\n    analytics().logAppOpen();\n  }\n}\n\n// 2. Screen tracking with React Navigation\nimport { useNavigationContainerRef } from '@react-navigation/native';\n\nfunction App() {\n  const navigationRef = useNavigationContainerRef();\n  const routeNameRef = useRef<string>();\n  \n  return (\n    <NavigationContainer\n      ref={navigationRef}\n      onReady={() => {\n        routeNameRef.current = navigationRef.getCurrentRoute()?.name;\n      }}\n      onStateChange={async () => {\n        const previousRouteName = routeNameRef.current;\n        const currentRouteName = navigationRef.getCurrentRoute()?.name;\n        \n        if (previousRouteName !== currentRouteName) {\n          // Log screen view\n          await AnalyticsManager.logScreenView(currentRouteName!);\n        }\n        \n        routeNameRef.current = currentRouteName;\n      }}\n    >\n      <RootNavigator />\n    </NavigationContainer>\n  );\n}\n\n// 3. Event tracking examples\nclass UserEvents {\n  static trackLogin(method: 'email' | 'google' | 'facebook') {\n    AnalyticsManager.logEvent('login', {\n      method: method\n    });\n  }\n  \n  static trackSignup(method: string) {\n    AnalyticsManager.logEvent('sign_up', {\n      method: method\n    });\n  }\n  \n  static trackSearch(searchTerm: string, category?: string) {\n    AnalyticsManager.logEvent('search', {\n      search_term: searchTerm,\n      category: category\n    });\n  }\n  \n  static trackAddToCart(itemId: string, itemName: string, price: number) {\n    AnalyticsManager.logEvent('add_to_cart', {\n      item_id: itemId,\n      item_name: itemName,\n      price: price,\n      currency: 'USD'\n    });\n  }\n  \n  static trackShare(contentType: string, itemId: string) {\n    AnalyticsManager.logEvent('share', {\n      content_type: contentType,\n      item_id: itemId\n    });\n  }\n}\n\n// 4. Crashlytics Integration\nclass CrashReportingManager {\n  static initialize() {\n    // Enable crash collection\n    crashlytics().setCrashlyticsCollectionEnabled(true);\n  }\n  \n  static setUserId(userId: string) {\n    crashlytics().setUserId(userId);\n  }\n  \n  static setCustomKey(key: string, value: string | number | boolean) {\n    crashlytics().setAttribute(key, String(value));\n  }\n  \n  static log(message: string) {\n    crashlytics().log(message);\n  }\n  \n  static recordError(error: Error, context?: string) {\n    if (context) {\n      crashlytics().log(`Context: ${context}`);\n    }\n    crashlytics().recordError(error);\n  }\n  \n  // Test crash (development only)\n  static testCrash() {\n    if (__DEV__) {\n      crashlytics().crash();\n    }\n  }\n}\n\n// 5. Sentry Integration (Alternative)\nimport * as Sentry from '@sentry/react-native';\n\nSentry.init({\n  dsn: 'YOUR_DSN_HERE',\n  environment: __DEV__ ? 'development' : 'production',\n  tracesSampleRate: 1.0\n});\n\nclass SentryManager {\n  static setUser(user: { id: string; email?: string; username?: string }) {\n    Sentry.setUser(user);\n  }\n  \n  static captureException(error: Error, context?: Record<string, any>) {\n    Sentry.captureException(error, {\n      extra: context\n    });\n  }\n  \n  static captureMessage(message: string, level: Sentry.SeverityLevel = 'info') {\n    Sentry.captureMessage(message, level);\n  }\n  \n  static addBreadcrumb(breadcrumb: Sentry.Breadcrumb) {\n    Sentry.addBreadcrumb(breadcrumb);\n  }\n}\n\n// 6. Usage in components\nfunction ProductScreen({ product }) {\n  useEffect(() => {\n    // Log screen view\n    AnalyticsManager.logScreenView('ProductDetail');\n    \n    // Set crashlytics context\n    CrashReportingManager.setCustomKey('product_id', product.id);\n    CrashReportingManager.log(`Viewing product: ${product.name}`);\n  }, [product]);\n  \n  const handleAddToCart = () => {\n    try {\n      // Track event\n      UserEvents.trackAddToCart(product.id, product.name, product.price);\n      \n      // Add to cart logic\n      addToCart(product);\n    } catch (error) {\n      // Report error\n      CrashReportingManager.recordError(error, 'Add to cart failed');\n    }\n  };\n  \n  return (\n    <View>\n      <Button title=\"Add to Cart\" onPress={handleAddToCart} />\n    </View>\n  );\n}\n\n// 7. Initialize on app start\nfunction App() {\n  useEffect(() => {\n    // Initialize crash reporting\n    CrashReportingManager.initialize();\n    \n    // Log app open\n    AnalyticsManager.logAppOpen();\n    \n    // Set user if logged in\n    const user = getCurrentUser();\n    if (user) {\n      AnalyticsManager.setUserId(user.id);\n      AnalyticsManager.setUserProperties({\n        plan: user.plan,\n        created_at: user.createdAt\n      });\n      CrashReportingManager.setUserId(user.id);\n    }\n  }, []);\n  \n  return <AppNavigator />;\n}\n\nexport default App;"
    },
    {
      "id": 84,
      "question": "What is React Native App Store Optimization and Distribution?",
      "answer": "App Store Optimization (ASO) improves app discoverability and conversion in app stores.\n\nASO Components:\n• App name and subtitle\n• Keywords and description\n• App icon design\n• Screenshots and previews\n• Ratings and reviews\n• Category selection\n• Localization\n• Update frequency\n\nApp Store Requirements:\niOS (App Store Connect):\n• Apple Developer account (99 USD/year)\n• App ID and provisioning profiles\n• Screenshots for all device sizes\n• Privacy policy URL\n• App review guidelines compliance\n• Metadata and descriptions\n• Age rating\n\nAndroid (Google Play Console):\n• Google Play Developer account (25 USD one-time)\n• App bundle (AAB) or APK\n• Feature graphic and screenshots\n• Privacy policy\n• Content rating\n• Store listing\n\nDistribution Strategies:\n• Beta testing (TestFlight, Google Play Beta)\n• Staged rollouts\n• A/B testing\n• Regular updates\n• User feedback monitoring",
      "explanation": "App Store Optimization involves optimizing app name, keywords, screenshots, and ratings for discoverability, with platform-specific requirements for iOS App Store and Google Play distribution.",
      "difficulty": "Medium",
      "code": "// 1. App Store Connect Metadata (iTunes Connect)\n/*\nApp Information:\n- App Name: \"MyApp - Task Manager\" (max 30 chars)\n- Subtitle: \"Organize your daily tasks\" (iOS, max 30 chars)\n- Keywords: \"task,todo,productivity,planner,organize\" (max 100 chars)\n- Description:\n  \"MyApp helps you organize your daily tasks efficiently.\n  \n  Features:\n  • Create and manage tasks\n  • Set reminders\n  • Track progress\n  • Sync across devices\n  \n  Get started today!\"\n  \n- What's New:\n  \"Version 1.2.0\n  • New dark mode\n  • Performance improvements\n  • Bug fixes\"\n  \n- Support URL: https://myapp.com/support\n- Marketing URL: https://myapp.com\n- Privacy Policy URL: https://myapp.com/privacy\n\nScreenshots Required:\n- iPhone 6.7\" (1290 x 2796)\n- iPhone 6.5\" (1242 x 2688)\n- iPhone 5.5\" (1242 x 2208)\n- iPad Pro 12.9\" (2048 x 2732)\n\nApp Review Information:\n- Contact Email\n- Contact Phone\n- Demo Account (if needed)\n- Notes for reviewer\n*/\n\n// 2. Google Play Console Metadata\n/*\nStore Listing:\n- App name: \"MyApp - Task Manager\" (max 50 chars)\n- Short description: \"Organize tasks efficiently\" (max 80 chars)\n- Full description: (max 4000 chars)\n  \"MyApp is your daily task management companion...\"\n  \n- Feature graphic: 1024 x 500\n- Screenshots: 320-3840 pixels (2-8 images)\n- Video (optional): YouTube URL\n\nCategorization:\n- Application: Productivity\n- Content rating: Everyone\n- Tags: productivity, tasks, todo\n\nContact details:\n- Email\n- Website\n- Privacy policy\n*/\n\n// 3. Fastlane for automated submission\n// fastlane/Fastfile\n/*\ndefault_platform(:ios)\n\nplatform :ios do\n  desc \"Submit to App Store\"\n  lane :release do\n    # Increment build number\n    increment_build_number\n    \n    # Build app\n    build_app(\n      scheme: \"MyApp\",\n      export_method: \"app-store\"\n    )\n    \n    # Upload to App Store\n    upload_to_app_store(\n      skip_metadata: false,\n      skip_screenshots: false,\n      submit_for_review: true,\n      automatic_release: false,\n      submission_information: {\n        add_id_info_uses_idfa: false,\n        export_compliance_uses_encryption: false\n      }\n    )\n  end\n  \n  desc \"Upload screenshots\"\n  lane :screenshots do\n    capture_screenshots\n    upload_to_app_store(skip_binary_upload: true)\n  end\nend\n\nplatform :android do\n  desc \"Submit to Play Store\"\n  lane :release do\n    # Build app bundle\n    gradle(\n      task: \"bundle\",\n      build_type: \"Release\"\n    )\n    \n    # Upload to Play Store\n    upload_to_play_store(\n      track: \"production\",\n      release_status: \"draft\",\n      skip_upload_apk: true\n    )\n  end\nend\n*/\n\n// 4. Metadata management (Fastlane metadata)\n/*\nfastlane/metadata/en-US/\n├── name.txt (App name)\n├── subtitle.txt (iOS subtitle)\n├── description.txt (Full description)\n├── keywords.txt (iOS keywords)\n├── release_notes.txt (What's new)\n├── marketing_url.txt\n├── privacy_url.txt\n├── support_url.txt\n└── screenshots/\n    ├── iPhone-6.7-inch/\n    ├── iPhone-6.5-inch/\n    └── iPad-Pro-12.9-inch/\n*/\n\n// 5. Version management for release\nconst releaseConfig = {\n  version: '1.2.0',\n  buildNumber: 42,\n  releaseNotes: {\n    en: 'Bug fixes and performance improvements',\n    es: 'Correcciones de errores y mejoras de rendimiento'\n  },\n  staged: true, // Staged rollout\n  rolloutPercentage: 10 // Start with 10%\n};\n\n// 6. Beta testing setup\n// TestFlight (iOS) - configured in App Store Connect\n// Google Play Beta - configure in Play Console\n\n// 7. Review guidelines compliance checklist\nconst reviewChecklist = {\n  ios: [\n    'App is fully functional',\n    'No placeholder content',\n    'Privacy policy accessible',\n    'No hidden features',\n    'Follows design guidelines',\n    'No crashes or major bugs',\n    'Accurate metadata',\n    'Age rating is correct',\n    'Uses approved APIs only',\n    'No references to other platforms'\n  ],\n  android: [\n    'App is stable',\n    'Content rating accurate',\n    'Privacy policy provided',\n    'Permissions justified',\n    'No malicious code',\n    'Metadata accurate',\n    'Graphics meet requirements',\n    'Follows material design'\n  ]\n};\n\n// 8. ASO tracking script\nclass ASOMetrics {\n  static trackImpression() {\n    // Track store page views\n    analytics().logEvent('store_impression');\n  }\n  \n  static trackInstall(source: string) {\n    // Track installs from different sources\n    analytics().logEvent('install', { source });\n  }\n  \n  static trackConversion(fromImpression: boolean) {\n    // Track conversion rate\n    analytics().logEvent('app_install_conversion', {\n      from_impression: fromImpression\n    });\n  }\n}"
    },
    {
      "id": 85,
      "question": "What are React Native Future Trends and Best Practices for 2024+?",
      "answer": "React Native continues evolving with new features, performance improvements, and best practices.\n\nEmerging Trends:\n• New Architecture (Fabric, TurboModules) adoption\n• Hermes engine as default\n• Better TypeScript support\n• Improved developer experience\n• Web support convergence\n• Better testing tools\n• Enhanced performance monitoring\n• Simplified native integration\n\nBest Practices 2024:\n• Use Fabric and TurboModules\n• TypeScript for all projects\n• Modern state management (Zustand, Jotai)\n• React 18 features (Suspense, Transitions)\n• Automated testing strategy\n• Performance monitoring\n• Accessibility first\n• Security by design\n• Modular architecture\n• CI/CD pipelines\n• OTA updates\n\nDevelopment Tools:\n• Expo Dev Tools\n• Flipper debugger\n• React DevTools\n• Redux DevTools\n• VS Code extensions\n\nPerformance:\n• RAM bundles\n• Code splitting\n• Image optimization\n• Network caching\n• Memory profiling",
      "explanation": "React Native's future includes New Architecture adoption, Hermes by default, better TypeScript support, with best practices emphasizing type safety, automated testing, accessibility, security, and performance optimization.",
      "difficulty": "Hard",
      "code": "// 1. Modern React Native Project Setup (2024+)\n/*\n# Create with latest template\nnpx react-native@latest init MyApp --template react-native-template-typescript\n\n# Enable New Architecture\ncd MyApp\n\n# iOS\nRCT_NEW_ARCH_ENABLED=1 pod install --project-directory=ios\n\n# Android (android/gradle.properties)\nnewArchEnabled=true\n*/\n\n// 2. TypeScript + Modern Hooks Pattern\nimport React, { FC } from 'react';\nimport { View, Text } from 'react-native';\nimport { useQuery, useMutation } from '@tanstack/react-query';\nimport { create } from 'zustand';\n\n// Zustand store (modern state management)\ninterface AppStore {\n  count: number;\n  increment: () => void;\n  decrement: () => void;\n}\n\nconst useStore = create<AppStore>((set) => ({\n  count: 0,\n  increment: () => set((state) => ({ count: state.count + 1 })),\n  decrement: () => set((state) => ({ count: state.count - 1 }))\n}));\n\n// Modern component with React Query\nconst ModernComponent: FC = () => {\n  const { count, increment } = useStore();\n  \n  const { data, isLoading } = useQuery({\n    queryKey: ['users'],\n    queryFn: fetchUsers\n  });\n  \n  const mutation = useMutation({\n    mutationFn: updateUser,\n    onSuccess: () => {\n      // Invalidate and refetch\n      queryClient.invalidateQueries({ queryKey: ['users'] });\n    }\n  });\n  \n  return (\n    <View>\n      <Text>Count: {count}</Text>\n    </View>\n  );\n};\n\n// 3. React 18 Concurrent Features\nimport { Suspense, useTransition } from 'react';\n\nconst ModernApp: FC = () => {\n  const [isPending, startTransition] = useTransition();\n  const [tab, setTab] = useState('home');\n  \n  const selectTab = (newTab: string) => {\n    startTransition(() => {\n      setTab(newTab);\n    });\n  };\n  \n  return (\n    <View>\n      <Suspense fallback={<Loading />}>\n        {tab === 'home' ? <HomeScreen /> : <ProfileScreen />}\n      </Suspense>\n      {isPending && <LoadingIndicator />}\n    </View>\n  );\n};\n\n// 4. TurboModule Example (New Architecture)\nimport { TurboModule, TurboModuleRegistry } from 'react-native';\n\nexport interface Spec extends TurboModule {\n  multiply(a: number, b: number): Promise<number>;\n}\n\nexport default TurboModuleRegistry.get<Spec>('Calculator') as Spec | null;\n\n// 5. Fabric Component (New Architecture)\nimport codegenNativeComponent from 'react-native/Libraries/Utilities/codegenNativeComponent';\nimport type { ViewProps } from 'react-native';\n\ninterface NativeProps extends ViewProps {\n  color?: string;\n}\n\nexport default codegenNativeComponent<NativeProps>('RTNCustomView');\n\n// 6. Modern Testing Setup\nimport { render, screen, fireEvent } from '@testing-library/react-native';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\n\ndescribe('ModernComponent', () => {\n  const queryClient = new QueryClient();\n  \n  it('renders correctly', () => {\n    render(\n      <QueryClientProvider client={queryClient}>\n        <ModernComponent />\n      </QueryClientProvider>\n    );\n    \n    expect(screen.getByText('Count: 0')).toBeTruthy();\n  });\n});\n\n// 7. Performance Monitoring (2024)\nimport { PerformanceObserver } from 'react-native-performance';\n\nconst observer = new PerformanceObserver((list) => {\n  const entries = list.getEntries();\n  entries.forEach((entry) => {\n    console.log(`${entry.name}: ${entry.duration}ms`);\n  });\n});\n\nobserver.observe({ entryTypes: ['measure'] });\n\nperformance.mark('fetch-start');\nawait fetchData();\nperformance.mark('fetch-end');\nperformance.measure('data-fetch', 'fetch-start', 'fetch-end');\n\n// 8. Modern Project Structure (2024)\n/*\nsrc/\n├── app/                    # App entry and providers\n│   ├── App.tsx\n│   └── providers/\n├── features/               # Feature modules\n│   ├── auth/\n│   │   ├── api/\n│   │   ├── components/\n│   │   ├── screens/\n│   │   ├── hooks/\n│   │   ├── store/\n│   │   └── types/\n│   └── profile/\n├── shared/                 # Shared resources\n│   ├── components/\n│   ├── hooks/\n│   ├── utils/\n│   ├── types/\n│   └── constants/\n├── navigation/\n├── services/              # API clients\n└── theme/                 # Design system\n*/\n\n// 9. Security Best Practices (2024)\nimport { Platform } from 'react-native';\nimport { getSecureRandomBytes } from 'react-native-secure-randombytes';\n\nclass SecurityManager {\n  // Use cryptographically secure random\n  static async generateToken(): Promise<string> {\n    const bytes = await getSecureRandomBytes(32);\n    return bytes.toString('hex');\n  }\n  \n  // Implement certificate pinning\n  static configureSecurity() {\n    // SSL pinning configuration\n    // Biometric requirements\n    // Screen capture prevention\n  }\n}\n\n// 10. Recommended Dependencies (2024)\n/*\npackage.json:\n{\n  \"dependencies\": {\n    \"react-native\": \"^0.73.0\",\n    \"react\": \"^18.2.0\",\n    \"@tanstack/react-query\": \"^5.0.0\",\n    \"zustand\": \"^4.4.0\",\n    \"react-navigation\": \"^6.0.0\",\n    \"react-native-reanimated\": \"^3.6.0\",\n    \"react-native-gesture-handler\": \"^2.14.0\"\n  },\n  \"devDependencies\": {\n    \"@types/react\": \"^18.2.0\",\n    \"@types/react-native\": \"^0.73.0\",\n    \"@testing-library/react-native\": \"^12.4.0\",\n    \"typescript\": \"^5.3.0\"\n  }\n}\n*/"
    },
    {
      "id": 86,
      "question": "What is Cross-Platform Development Strategy in React Native?",
      "answer": "Cross-platform development maximizes code sharing between iOS, Android, and web while managing platform differences.\n\nCode Sharing Strategies:\n• Shared business logic (95%+ code sharing)\n• Platform-specific UI when needed\n• Common components library\n• Shared utilities and helpers\n• Unified state management\n• Common navigation structure\n• Shared API layer\n\nPlatform Differentiation:\n• Platform.select() for values\n• Platform-specific files (.ios.js, .android.js)\n• Conditional rendering\n• Native modules when needed\n• Platform-specific styling\n• Different navigation patterns\n• OS-specific features\n\nBest Practices:\n• Abstract platform differences\n• Create unified APIs\n• Test on both platforms\n• Follow platform guidelines\n• Use platform strengths\n• Handle edge cases\n• Document platform differences\n• Consider performance implications",
      "explanation": "Cross-platform strategy maximizes code sharing through unified business logic and components while using Platform.select and platform-specific files to handle iOS/Android differences and native features.",
      "difficulty": "Hard",
      "code": "// 1. Platform-specific file structure\n/*\ncomponents/\n├── Button/\n│   ├── Button.tsx          # Shared logic\n│   ├── Button.ios.tsx      # iOS specific\n│   ├── Button.android.tsx  # Android specific\n│   └── Button.styles.ts\n*/\n\n// 2. Platform.select() for different values\nimport { Platform, StyleSheet } from 'react-native';\n\nconst styles = StyleSheet.create({\n  container: {\n    padding: Platform.select({\n      ios: 20,\n      android: 15,\n      default: 10\n    }),\n    // Different shadows\n    ...Platform.select({\n      ios: {\n        shadowColor: '#000',\n        shadowOffset: { width: 0, height: 2 },\n        shadowOpacity: 0.25,\n        shadowRadius: 3.84\n      },\n      android: {\n        elevation: 5\n      },\n      default: {\n        // Web fallback\n        boxShadow: '0 2px 4px rgba(0,0,0,0.1)'\n      }\n    })\n  }\n});\n\n// 3. Platform-specific components\n// Button.ios.tsx\nimport React from 'react';\nimport { TouchableOpacity, Text } from 'react-native';\n\nexport const Button = ({ title, onPress }) => (\n  <TouchableOpacity onPress={onPress} style={styles.iosButton}>\n    <Text style={styles.iosText}>{title}</Text>\n  </TouchableOpacity>\n);\n\n// Button.android.tsx\nimport React from 'react';\nimport { TouchableNativeFeedback, View, Text } from 'react-native';\n\nexport const Button = ({ title, onPress }) => (\n  <TouchableNativeFeedback onPress={onPress}>\n    <View style={styles.androidButton}>\n      <Text style={styles.androidText}>{title}</Text>\n    </View>\n  </TouchableNativeFeedback>\n);\n\n// Usage (automatic selection)\nimport { Button } from './components/Button';\n\n// 4. Conditional rendering based on platform\nfunction PlatformSpecificFeature() {\n  if (Platform.OS === 'ios') {\n    return <IOSSpecificComponent />;\n  }\n  \n  if (Platform.OS === 'android') {\n    return <AndroidSpecificComponent />;\n  }\n  \n  return <DefaultComponent />;\n}\n\n// 5. Platform-specific API wrappers\nclass PlatformUtils {\n  static async getDeviceInfo() {\n    if (Platform.OS === 'ios') {\n      return {\n        model: await DeviceInfo.getModel(),\n        version: Platform.Version,\n        isTablet: await DeviceInfo.isTablet()\n      };\n    } else {\n      return {\n        model: await DeviceInfo.getDeviceId(),\n        version: Platform.Version,\n        brand: await DeviceInfo.getBrand()\n      };\n    }\n  }\n  \n  static openSettings() {\n    if (Platform.OS === 'ios') {\n      Linking.openURL('app-settings:');\n    } else {\n      Linking.openSettings();\n    }\n  }\n}\n\n// 6. Unified navigation with platform differences\nimport { createBottomTabNavigator } from '@react-navigation/bottom-tabs';\nimport { createMaterialTopTabNavigator } from '@react-navigation/material-top-tabs';\n\nconst Tab = Platform.select({\n  ios: createBottomTabNavigator,\n  android: createMaterialTopTabNavigator\n})();\n\nfunction TabNavigator() {\n  return (\n    <Tab.Navigator\n      screenOptions={{\n        // iOS specific\n        ...(Platform.OS === 'ios' && {\n          tabBarStyle: { height: 90 }\n        }),\n        // Android specific\n        ...(Platform.OS === 'android' && {\n          tabBarIndicatorStyle: { backgroundColor: 'blue' }\n        })\n      }}\n    >\n      <Tab.Screen name=\"Home\" component={HomeScreen} />\n      <Tab.Screen name=\"Profile\" component={ProfileScreen} />\n    </Tab.Navigator>\n  );\n}\n\n// 7. Platform-specific constants\nconst CONSTANTS = {\n  HEADER_HEIGHT: Platform.select({\n    ios: 64,\n    android: 56,\n    default: 60\n  }),\n  STATUS_BAR_HEIGHT: Platform.select({\n    ios: 20,\n    android: 0\n  }),\n  FONT_FAMILY: Platform.select({\n    ios: 'System',\n    android: 'Roboto',\n    default: 'Arial'\n  })\n};\n\n// 8. Shared business logic with platform UI\nclass AuthService {\n  // Shared logic\n  static async login(email: string, password: string) {\n    const response = await fetch('/api/login', {\n      method: 'POST',\n      body: JSON.stringify({ email, password })\n    });\n    return response.json();\n  }\n  \n  // Platform-specific biometric\n  static async loginWithBiometric() {\n    if (Platform.OS === 'ios') {\n      return await this.loginWithTouchID();\n    } else {\n      return await this.loginWithFingerprint();\n    }\n  }\n}\n\n// 9. Platform-specific permissions\nclass PermissionManager {\n  static async requestCameraPermission() {\n    if (Platform.OS === 'ios') {\n      const permission = PERMISSIONS.IOS.CAMERA;\n      return await request(permission);\n    } else {\n      const permission = PERMISSIONS.ANDROID.CAMERA;\n      return await request(permission);\n    }\n  }\n}\n\n// 10. Testing platform-specific code\nimport { Platform } from 'react-native';\n\ndescribe('PlatformSpecificComponent', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n  \n  it('renders iOS variant', () => {\n    Platform.OS = 'ios';\n    const { getByTestId } = render(<PlatformSpecificComponent />);\n    expect(getByTestId('ios-specific')).toBeTruthy();\n  });\n  \n  it('renders Android variant', () => {\n    Platform.OS = 'android';\n    const { getByTestId } = render(<PlatformSpecificComponent />);\n    expect(getByTestId('android-specific')).toBeTruthy();\n  });\n});"
    },
    {
      "id": 87,
      "question": "What is React Native Web and how do you target web platform?",
      "answer": "React Native Web enables running React Native code on web browsers for maximum code sharing.\n\nKey Features:\n• Share 95%+ code between mobile and web\n• Use React Native primitives on web\n• Progressive Web App support\n• Server-side rendering support\n• Responsive design\n• Accessibility support\n• Standard web APIs\n\nSetup Requirements:\n• react-native-web package\n• Web bundler (Webpack, Metro)\n• Platform-specific resolution\n• Web-specific polyfills\n• Asset handling\n\nLimitations:\n• Not all React Native APIs available\n• Different navigation paradigm\n• Web-specific considerations\n• Performance differences\n• Browser compatibility\n\nBest Practices:\n• Use responsive design\n• Handle web-specific interactions\n• Test across browsers\n• Optimize for SEO\n• Progressive enhancement\n• Accessibility first\n• Performance monitoring",
      "explanation": "React Native Web enables running React Native code in browsers using react-native-web, sharing components and logic across mobile and web with web-specific adaptations for navigation and interactions.",
      "difficulty": "Hard",
      "code": "// 1. Installation\n// npm install react-native-web react-dom\n\n// 2. Webpack configuration (webpack.config.js)\n/*\nmodule.exports = {\n  resolve: {\n    alias: {\n      'react-native$': 'react-native-web'\n    },\n    extensions: ['.web.js', '.js', '.web.tsx', '.tsx']\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js|jsx|ts|tsx)$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: [\n              '@babel/preset-react',\n              '@babel/preset-typescript'\n            ]\n          }\n        }\n      }\n    ]\n  }\n};\n*/\n\n// 3. Entry point (index.web.js)\nimport { AppRegistry } from 'react-native';\nimport App from './App';\n\nAppRegistry.registerComponent('MyApp', () => App);\nAppRegistry.runApplication('MyApp', {\n  rootTag: document.getElementById('root')\n});\n\n// 4. HTML template (public/index.html)\n/*\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <title>MyApp</title>\n  <style>\n    #root {\n      display: flex;\n      height: 100vh;\n      flex: 1;\n    }\n    body {\n      margin: 0;\n      overflow: hidden;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"root\"></div>\n</body>\n</html>\n*/\n\n// 5. Platform-specific components\n// Component.web.tsx (web-specific)\nimport React from 'react';\nimport { View, Text } from 'react-native';\n\nexport const WebSpecificComponent = () => (\n  <View>\n    <Text>This is web-specific</Text>\n    <a href=\"/about\">About</a>\n  </View>\n);\n\n// Component.tsx (mobile)\nimport React from 'react';\nimport { View, Text, TouchableOpacity } from 'react-native';\nimport { useNavigation } from '@react-navigation/native';\n\nexport const MobileComponent = () => {\n  const navigation = useNavigation();\n  return (\n    <View>\n      <TouchableOpacity onPress={() => navigation.navigate('About')}>\n        <Text>Go to About</Text>\n      </TouchableOpacity>\n    </View>\n  );\n};\n\n// 6. Responsive design\nimport { Dimensions, Platform } from 'react-native';\n\nfunction useResponsive() {\n  const [dimensions, setDimensions] = React.useState({\n    width: Dimensions.get('window').width,\n    height: Dimensions.get('window').height\n  });\n  \n  React.useEffect(() => {\n    const subscription = Dimensions.addEventListener('change', ({ window }) => {\n      setDimensions({\n        width: window.width,\n        height: window.height\n      });\n    });\n    \n    return () => subscription?.remove();\n  }, []);\n  \n  return {\n    ...dimensions,\n    isSmall: dimensions.width < 768,\n    isMedium: dimensions.width >= 768 && dimensions.width < 1024,\n    isLarge: dimensions.width >= 1024\n  };\n}\n\nfunction ResponsiveComponent() {\n  const { isSmall, isMedium, isLarge } = useResponsive();\n  \n  return (\n    <View style={[\n      styles.container,\n      isSmall && styles.smallContainer,\n      isMedium && styles.mediumContainer,\n      isLarge && styles.largeContainer\n    ]}>\n      <Text>Responsive Content</Text>\n    </View>\n  );\n}\n\n// 7. Web-specific navigation\nimport { createBrowserRouter, RouterProvider } from 'react-router-dom';\n\nconst router = createBrowserRouter([\n  {\n    path: '/',\n    element: <HomeScreen />\n  },\n  {\n    path: '/profile/:id',\n    element: <ProfileScreen />\n  },\n  {\n    path: '/settings',\n    element: <SettingsScreen />\n  }\n]);\n\nfunction WebApp() {\n  if (Platform.OS === 'web') {\n    return <RouterProvider router={router} />;\n  }\n  return <MobileNavigator />;\n}\n\n// 8. SEO optimization (web only)\nimport { Helmet } from 'react-helmet';\n\nfunction SEOComponent({ title, description }) {\n  if (Platform.OS !== 'web') return null;\n  \n  return (\n    <Helmet>\n      <title>{title}</title>\n      <meta name=\"description\" content={description} />\n      <meta property=\"og:title\" content={title} />\n      <meta property=\"og:description\" content={description} />\n    </Helmet>\n  );\n}\n\n// 9. Web-specific hooks\nfunction useWebScroll() {\n  const [scrollY, setScrollY] = React.useState(0);\n  \n  React.useEffect(() => {\n    if (Platform.OS !== 'web') return;\n    \n    const handleScroll = () => {\n      setScrollY(window.scrollY);\n    };\n    \n    window.addEventListener('scroll', handleScroll);\n    return () => window.removeEventListener('scroll', handleScroll);\n  }, []);\n  \n  return scrollY;\n}\n\n// 10. Progressive Web App (service worker)\n// service-worker.js\n/*\nself.addEventListener('install', (event) => {\n  event.waitUntil(\n    caches.open('v1').then((cache) => {\n      return cache.addAll([\n        '/',\n        '/static/js/bundle.js',\n        '/static/css/main.css'\n      ]);\n    })\n  );\n});\n\nself.addEventListener('fetch', (event) => {\n  event.respondWith(\n    caches.match(event.request).then((response) => {\n      return response || fetch(event.request);\n    })\n  );\n});\n*/\n\n// Register service worker (index.web.js)\nif ('serviceWorker' in navigator) {\n  window.addEventListener('load', () => {\n    navigator.serviceWorker.register('/service-worker.js');\n  });\n}\n\n// 11. Web manifest (public/manifest.json)\n/*\n{\n  \"short_name\": \"MyApp\",\n  \"name\": \"MyApp - Task Manager\",\n  \"icons\": [\n    {\n      \"src\": \"icon-192.png\",\n      \"sizes\": \"192x192\",\n      \"type\": \"image/png\"\n    },\n    {\n      \"src\": \"icon-512.png\",\n      \"sizes\": \"512x512\",\n      \"type\": \"image/png\"\n    }\n  ],\n  \"start_url\": \"/\",\n  \"display\": \"standalone\",\n  \"theme_color\": \"#000000\",\n  \"background_color\": \"#ffffff\"\n}\n*/"
    },
    {
      "id": 88,
      "question": "What is Monorepo Architecture for React Native?",
      "answer": "Monorepo architecture manages multiple related projects in a single repository for better code sharing and tooling.\n\nBenefits:\n• Share code between apps\n• Unified dependency management\n• Atomic cross-project changes\n• Consistent tooling and configs\n• Easier refactoring\n• Better collaboration\n• Single source of truth\n\nMonorepo Tools:\n• Yarn Workspaces - package linking\n• npm Workspaces - npm alternative\n• Lerna - monorepo management\n• Nx - build system and tooling\n• Turborepo - fast build system\n\nProject Structure:\n• apps/ - individual applications\n• packages/ - shared libraries\n• tools/ - build and dev tools\n• configs/ - shared configurations\n\nChallenges:\n• Build complexity\n• CI/CD configuration\n• Dependency conflicts\n• Learning curve\n• Tooling setup\n\nBest Practices:\n• Clear package boundaries\n• Version management strategy\n• Incremental builds\n• Proper caching\n• CI/CD optimization",
      "explanation": "Monorepo architecture uses tools like Yarn Workspaces or Turborepo to manage multiple React Native apps and shared packages in one repository, enabling code sharing and unified tooling.",
      "difficulty": "Hard",
      "code": "// 1. Monorepo structure\n/*\nmy-monorepo/\n├── apps/\n│   ├── mobile/              # React Native app\n│   │   ├── package.json\n│   │   ├── App.tsx\n│   │   └── ...\n│   ├── web/                 # Web app\n│   │   ├── package.json\n│   │   └── ...\n│   └── admin/               # Admin app\n├── packages/\n│   ├── ui-components/       # Shared UI library\n│   │   ├── package.json\n│   │   ├── src/\n│   │   └── ...\n│   ├── api-client/          # API client\n│   │   ├── package.json\n│   │   └── src/\n│   ├── utils/               # Shared utilities\n│   └── types/               # Shared TypeScript types\n├── package.json             # Root package.json\n├── tsconfig.json            # Root TypeScript config\n└── yarn.lock\n*/\n\n// 2. Root package.json\n/*\n{\n  \"name\": \"my-monorepo\",\n  \"private\": true,\n  \"workspaces\": [\n    \"apps/*\",\n    \"packages/*\"\n  ],\n  \"scripts\": {\n    \"mobile\": \"yarn workspace @myapp/mobile start\",\n    \"web\": \"yarn workspace @myapp/web start\",\n    \"build:all\": \"yarn workspaces run build\",\n    \"test:all\": \"yarn workspaces run test\",\n    \"lint\": \"eslint . --ext .ts,.tsx\"\n  },\n  \"devDependencies\": {\n    \"typescript\": \"^5.0.0\",\n    \"eslint\": \"^8.0.0\",\n    \"prettier\": \"^3.0.0\"\n  }\n}\n*/\n\n// 3. Shared package (packages/ui-components/package.json)\n/*\n{\n  \"name\": \"@myapp/ui-components\",\n  \"version\": \"1.0.0\",\n  \"main\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"test\": \"jest\"\n  },\n  \"peerDependencies\": {\n    \"react\": \"^18.0.0\",\n    \"react-native\": \"^0.73.0\"\n  }\n}\n*/\n\n// 4. Shared UI component\n// packages/ui-components/src/Button/Button.tsx\nimport React, { FC } from 'react';\nimport { TouchableOpacity, Text, StyleSheet } from 'react-native';\n\ninterface ButtonProps {\n  title: string;\n  onPress: () => void;\n  variant?: 'primary' | 'secondary';\n}\n\nexport const Button: FC<ButtonProps> = ({ title, onPress, variant = 'primary' }) => (\n  <TouchableOpacity\n    style={[styles.button, styles[variant]]}\n    onPress={onPress}\n  >\n    <Text style={styles.text}>{title}</Text>\n  </TouchableOpacity>\n);\n\nconst styles = StyleSheet.create({\n  button: { padding: 12, borderRadius: 8 },\n  primary: { backgroundColor: '#007AFF' },\n  secondary: { backgroundColor: '#8E8E93' },\n  text: { color: 'white', textAlign: 'center' }\n});\n\n// packages/ui-components/src/index.ts\nexport { Button } from './Button/Button';\nexport { Input } from './Input/Input';\nexport { Card } from './Card/Card';\n\n// 5. Mobile app using shared components\n// apps/mobile/package.json\n/*\n{\n  \"name\": \"@myapp/mobile\",\n  \"version\": \"1.0.0\",\n  \"dependencies\": {\n    \"react\": \"^18.0.0\",\n    \"react-native\": \"^0.73.0\",\n    \"@myapp/ui-components\": \"*\",\n    \"@myapp/api-client\": \"*\",\n    \"@myapp/utils\": \"*\"\n  }\n}\n*/\n\n// apps/mobile/App.tsx\nimport React from 'react';\nimport { View } from 'react-native';\nimport { Button } from '@myapp/ui-components';\nimport { apiClient } from '@myapp/api-client';\nimport { formatDate } from '@myapp/utils';\n\nfunction App() {\n  const handlePress = async () => {\n    const data = await apiClient.get('/users');\n    console.log(data);\n  };\n  \n  return (\n    <View>\n      <Button title=\"Fetch Users\" onPress={handlePress} />\n    </View>\n  );\n}\n\n// 6. Shared API client (packages/api-client/src/index.ts)\nimport axios from 'axios';\n\nconst API_BASE_URL = process.env.API_URL || 'https://api.example.com';\n\nexport const apiClient = axios.create({\n  baseURL: API_BASE_URL,\n  timeout: 10000\n});\n\n// Add request interceptor\napiClient.interceptors.request.use((config) => {\n  // Add auth token\n  return config;\n});\n\nexport * from './types';\n\n// 7. Turborepo configuration (turbo.json)\n/*\n{\n  \"$schema\": \"https://turbo.build/schema.json\",\n  \"pipeline\": {\n    \"build\": {\n      \"dependsOn\": [\"^build\"],\n      \"outputs\": [\"dist/**\"]\n    },\n    \"test\": {\n      \"dependsOn\": [\"build\"],\n      \"outputs\": []\n    },\n    \"lint\": {\n      \"outputs\": []\n    },\n    \"dev\": {\n      \"cache\": false\n    }\n  }\n}\n*/\n\n// 8. TypeScript project references (tsconfig.json)\n/*\n{\n  \"compilerOptions\": {\n    \"composite\": true,\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@myapp/*\": [\"packages/*\"]\n    }\n  },\n  \"references\": [\n    { \"path\": \"./packages/ui-components\" },\n    { \"path\": \"./packages/api-client\" },\n    { \"path\": \"./packages/utils\" },\n    { \"path\": \"./apps/mobile\" },\n    { \"path\": \"./apps/web\" }\n  ]\n}\n*/\n\n// 9. CI/CD optimization (GitHub Actions)\n/*\n# .github/workflows/ci.yml\nname: CI\n\non: [push, pull_request]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'yarn'\n      \n      - name: Install dependencies\n        run: yarn install --frozen-lockfile\n      \n      - name: Build affected\n        run: yarn turbo run build --filter=...[HEAD^]\n      \n      - name: Test affected\n        run: yarn turbo run test --filter=...[HEAD^]\n      \n      - name: Lint\n        run: yarn lint\n*/\n\n// 10. Package versioning (using Lerna)\n// lerna.json\n/*\n{\n  \"version\": \"independent\",\n  \"npmClient\": \"yarn\",\n  \"useWorkspaces\": true,\n  \"command\": {\n    \"publish\": {\n      \"conventionalCommits\": true,\n      \"message\": \"chore(release): publish\"\n    }\n  }\n}\n*/\n\n// Publish packages\n// lerna publish"
    },
    {
      "id": 89,
      "question": "What is React Native Developer Productivity and Tooling?",
      "answer": "Developer productivity depends on efficient tooling, workflows, and development environment setup.\n\nEssential Tools:\n• VS Code with extensions\n• React Native Debugger\n• Flipper - debugging platform\n• Reactotron - dev tool\n• ESLint and Prettier\n• TypeScript\n• Git hooks (Husky)\n• Storybook for components\n\nVS Code Extensions:\n• React Native Tools\n• ES7 React/Redux snippets\n• Prettier formatter\n• ESLint\n• GitLens\n• Auto Import\n• Path Intellisense\n\nDevelopment Workflow:\n• Fast Refresh\n• Hot Module Replacement\n• Component isolation (Storybook)\n• Automated testing\n• Code generation\n• Git hooks for quality checks\n• Documentation generation\n\nProductivity Boosters:\n• Snippets and templates\n• CLI generators\n• Automated formatting\n• Type checking\n• Live reloading\n• Component libraries\n• Design systems",
      "explanation": "Developer productivity improves with VS Code extensions, Flipper debugger, Fast Refresh, ESLint/Prettier automation, TypeScript, Storybook component development, and Git hooks for code quality.",
      "difficulty": "Medium",
      "code": "// 1. VS Code settings (.vscode/settings.json)\n/*\n{\n  \"editor.formatOnSave\": true,\n  \"editor.defaultFormatter\": \"esbenp.prettier-vscode\",\n  \"editor.codeActionsOnSave\": {\n    \"source.fixAll.eslint\": true\n  },\n  \"typescript.tsdk\": \"node_modules/typescript/lib\",\n  \"typescript.enablePromptUseWorkspaceTsdk\": true,\n  \"[typescript]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[typescriptreact]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"emmet.includeLanguages\": {\n    \"typescript\": \"typescriptreact\"\n  }\n}\n*/\n\n// 2. ESLint configuration (.eslintrc.js)\n/*\nmodule.exports = {\n  root: true,\n  extends: [\n    '@react-native-community',\n    'plugin:@typescript-eslint/recommended',\n    'plugin:react-hooks/recommended',\n    'prettier'\n  ],\n  parser: '@typescript-eslint/parser',\n  plugins: ['@typescript-eslint', 'react-hooks'],\n  rules: {\n    '@typescript-eslint/no-unused-vars': 'error',\n    '@typescript-eslint/no-explicit-any': 'warn',\n    'react-hooks/rules-of-hooks': 'error',\n    'react-hooks/exhaustive-deps': 'warn',\n    'no-console': ['warn', { allow: ['warn', 'error'] }]\n  }\n};\n*/\n\n// 3. Prettier configuration (.prettierrc.js)\n/*\nmodule.exports = {\n  arrowParens: 'always',\n  bracketSameLine: false,\n  bracketSpacing: true,\n  singleQuote: true,\n  trailingComma: 'es5',\n  semi: true,\n  printWidth: 100,\n  tabWidth: 2\n};\n*/\n\n// 4. Git hooks with Husky (package.json)\n/*\n{\n  \"scripts\": {\n    \"prepare\": \"husky install\"\n  },\n  \"lint-staged\": {\n    \"*.{ts,tsx}\": [\n      \"eslint --fix\",\n      \"prettier --write\"\n    ],\n    \"*.{json,md}\": [\n      \"prettier --write\"\n    ]\n  },\n  \"devDependencies\": {\n    \"husky\": \"^8.0.0\",\n    \"lint-staged\": \"^13.0.0\"\n  }\n}\n*/\n\n// .husky/pre-commit\n/*\n#!/usr/bin/env sh\n. \"$(dirname -- \"$0\")/_/husky.sh\"\n\nnpx lint-staged\n*/\n\n// .husky/pre-push\n/*\n#!/usr/bin/env sh\n. \"$(dirname -- \"$0\")/_/husky.sh\"\n\nnpm test\n*/\n\n// 5. Code snippets (VS Code)\n// .vscode/reactnative.code-snippets\n/*\n{\n  \"React Native Component\": {\n    \"prefix\": \"rnc\",\n    \"body\": [\n      \"import React, { FC } from 'react';\",\n      \"import { View, Text, StyleSheet } from 'react-native';\",\n      \"\",\n      \"interface ${1:Component}Props {\",\n      \"  ${2:prop}: ${3:string};\",\n      \"}\",\n      \"\",\n      \"export const ${1:Component}: FC<${1:Component}Props> = ({ ${2:prop} }) => {\",\n      \"  return (\",\n      \"    <View style={styles.container}>\",\n      \"      <Text>${2:prop}: {${2:prop}}</Text>\",\n      \"    </View>\",\n      \"  );\",\n      \"};\",\n      \"\",\n      \"const styles = StyleSheet.create({\",\n      \"  container: {\",\n      \"    flex: 1,\",\n      \"    padding: 20\",\n      \"  }\",\n      \"});\"\n    ]\n  }\n}\n*/\n\n// 6. Storybook setup\n// .storybook/main.js\n/*\nmodule.exports = {\n  stories: ['../src/**/*.stories.?(ts|tsx|js|jsx)'],\n  addons: [\n    '@storybook/addon-ondevice-controls',\n    '@storybook/addon-ondevice-actions'\n  ]\n};\n*/\n\n// Component story\n// Button.stories.tsx\nimport React from 'react';\nimport { storiesOf } from '@storybook/react-native';\nimport { action } from '@storybook/addon-actions';\nimport { Button } from './Button';\n\nstoriesOf('Button', module)\n  .add('Primary', () => (\n    <Button\n      title=\"Primary Button\"\n      onPress={action('pressed')}\n      variant=\"primary\"\n    />\n  ))\n  .add('Secondary', () => (\n    <Button\n      title=\"Secondary Button\"\n      onPress={action('pressed')}\n      variant=\"secondary\"\n    />\n  ));\n\n// 7. Plop.js code generator (plopfile.js)\n/*\nmodule.exports = function (plop) {\n  plop.setGenerator('component', {\n    description: 'Create a new component',\n    prompts: [\n      {\n        type: 'input',\n        name: 'name',\n        message: 'Component name:'\n      }\n    ],\n    actions: [\n      {\n        type: 'add',\n        path: 'src/components/{{pascalCase name}}/{{pascalCase name}}.tsx',\n        templateFile: 'templates/Component.tsx.hbs'\n      },\n      {\n        type: 'add',\n        path: 'src/components/{{pascalCase name}}/{{pascalCase name}}.test.tsx',\n        templateFile: 'templates/Component.test.tsx.hbs'\n      },\n      {\n        type: 'add',\n        path: 'src/components/{{pascalCase name}}/index.ts',\n        templateFile: 'templates/index.ts.hbs'\n      }\n    ]\n  });\n};\n\n// Usage: npm run plop component\n*/\n\n// 8. TypeScript path aliases (tsconfig.json)\n/*\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@components/*\": [\"src/components/*\"],\n      \"@screens/*\": [\"src/screens/*\"],\n      \"@utils/*\": [\"src/utils/*\"],\n      \"@hooks/*\": [\"src/hooks/*\"],\n      \"@services/*\": [\"src/services/*\"]\n    }\n  }\n}\n*/\n\n// Usage\nimport { Button } from '@components/Button';\nimport { useAuth } from '@hooks/useAuth';\nimport { formatDate } from '@utils/date';\n\n// 9. Debug configuration (.vscode/launch.json)\n/*\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"Debug Android\",\n      \"cwd\": \"${workspaceFolder}\",\n      \"type\": \"reactnative\",\n      \"request\": \"launch\",\n      \"platform\": \"android\"\n    },\n    {\n      \"name\": \"Debug iOS\",\n      \"cwd\": \"${workspaceFolder}\",\n      \"type\": \"reactnative\",\n      \"request\": \"launch\",\n      \"platform\": \"ios\"\n    }\n  ]\n}\n*/\n\n// 10. Documentation generation\n// typedoc.json\n/*\n{\n  \"entryPoints\": [\"src/index.ts\"],\n  \"out\": \"docs\",\n  \"excludePrivate\": true,\n  \"excludeProtected\": true,\n  \"theme\": \"default\"\n}\n\n// Generate: npx typedoc\n*/"
    },
    {
      "id": 90,
      "question": "What is React Native Upgrade Strategy and Migration?",
      "answer": "Upgrading React Native requires careful planning to handle breaking changes and maintain app stability.\n\nUpgrade Considerations:\n• Breaking changes in new versions\n• Third-party dependency compatibility\n• Native code changes\n• API deprecations\n• Performance improvements\n• Security patches\n• New features\n\nUpgrade Process:\n• Review release notes\n• Check dependency compatibility\n• Update React Native version\n• Run upgrade helper\n• Update native dependencies\n• Test thoroughly\n• Update third-party libraries\n• Handle deprecations\n\nTools:\n• React Native Upgrade Helper\n• Upgrade command (npx react-native upgrade)\n• Diff tools\n• Version management\n\nBest Practices:\n• Test in development first\n• Incremental updates\n• Update dependencies gradually\n• Maintain changelog\n• Have rollback plan\n• Test on actual devices\n• Monitor crash reports\n• Communicate with team\n\nCommon Issues:\n• CocoaPods conflicts\n• Gradle version mismatches\n• Breaking API changes\n• Third-party incompatibilities",
      "explanation": "React Native upgrades require reviewing release notes, using upgrade helper, updating dependencies, testing thoroughly, and handling breaking changes while maintaining app stability with rollback plans.",
      "difficulty": "Hard",
      "code": "// 1. Check current version\n// package.json\n/*\n{\n  \"dependencies\": {\n    \"react-native\": \"0.71.0\"\n  }\n}\n*/\n\n// 2. Use React Native Upgrade Helper\n// Visit: https://react-native-community.github.io/upgrade-helper/\n// Compare your version (e.g., 0.71.0) to target (e.g., 0.73.0)\n\n// 3. Upgrade command\n/*\n# Recommended approach\nnpx react-native upgrade\n\n# Or manual version update\nnpm install react-native@0.73.0\nnpx react-native upgrade\n*/\n\n// 4. Common iOS changes (ios/Podfile)\n/*\n# Before (0.71)\nplatform :ios, '12.4'\n\n# After (0.73)\nplatform :ios, '13.0'\n\n# Update pods\ncd ios && pod install\n*/\n\n// 5. Common Android changes (android/build.gradle)\n/*\n// Before (0.71)\nbuildscript {\n  ext {\n    buildToolsVersion = \"31.0.0\"\n    minSdkVersion = 21\n    compileSdkVersion = 31\n    targetSdkVersion = 31\n  }\n}\n\n// After (0.73)\nbuildscript {\n  ext {\n    buildToolsVersion = \"33.0.0\"\n    minSdkVersion = 21\n    compileSdkVersion = 33\n    targetSdkVersion = 33\n  }\n}\n*/\n\n// 6. Handle deprecated APIs\n// Before (deprecated)\nimport { AsyncStorage } from 'react-native';\n\n// After (community package)\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\n// Before (deprecated)\nimport { DatePickerIOS } from 'react-native';\n\n// After (community package)\nimport DateTimePicker from '@react-native-community/datetimepicker';\n\n// 7. Update package.json dependencies\n/*\n{\n  \"dependencies\": {\n    \"react\": \"18.2.0\",\n    \"react-native\": \"0.73.0\",\n    \"@react-native-async-storage/async-storage\": \"^1.21.0\",\n    \"@react-native-community/datetimepicker\": \"^7.6.0\",\n    \"@react-navigation/native\": \"^6.1.0\",\n    \"react-native-screens\": \"^3.29.0\",\n    \"react-native-safe-area-context\": \"^4.8.0\"\n  },\n  \"devDependencies\": {\n    \"@types/react\": \"^18.2.0\",\n    \"@types/react-native\": \"^0.73.0\",\n    \"typescript\": \"5.0.4\"\n  }\n}\n*/\n\n// 8. Upgrade script (scripts/upgrade.sh)\n/*\n#!/bin/bash\n\n# Backup current state\ngit add -A\ngit commit -m \"Pre-upgrade checkpoint\"\n\n# Clean install\nrm -rf node_modules package-lock.json yarn.lock\n\n# Update React Native\nnpm install react-native@latest\n\n# Run upgrade helper\nnpx react-native upgrade\n\n# iOS\ncd ios\nrm -rf Pods Podfile.lock\npod install --repo-update\ncd ..\n\n# Android\ncd android\n./gradlew clean\ncd ..\n\n# Install dependencies\nnpm install\n\n# Test\nnpm test\n\necho \"Upgrade complete! Test thoroughly before committing.\"\n*/\n\n// 9. Migration guide documentation\n/*\n# MIGRATION_GUIDE.md\n\n## Upgrading from 0.71 to 0.73\n\n### Breaking Changes\n1. Minimum iOS version increased to 13.0\n2. AsyncStorage removed from core\n3. DatePickerIOS deprecated\n\n### Required Changes\n\n#### iOS\n1. Update Podfile minimum iOS version\n2. Update Xcode to latest version\n3. Run `pod install`\n\n#### Android\n1. Update build.gradle compileSdkVersion\n2. Update Gradle wrapper if needed\n3. Run `./gradlew clean`\n\n#### Dependencies\n1. Install @react-native-async-storage/async-storage\n2. Replace AsyncStorage imports\n3. Update all navigation packages\n\n### Testing Checklist\n- [ ] App launches successfully\n- [ ] All screens navigate correctly\n- [ ] API calls work\n- [ ] Push notifications work\n- [ ] Deep linking works\n- [ ] Biometric auth works\n- [ ] No console errors or warnings\n- [ ] Test on both iOS and Android\n- [ ] Test on different device sizes\n*/\n\n// 10. Rollback plan\n/*\n# If upgrade fails, rollback:\n\n1. Revert git changes:\n   git reset --hard HEAD~1\n   git clean -fd\n\n2. Reinstall dependencies:\n   rm -rf node_modules\n   npm install\n\n3. iOS:\n   cd ios && rm -rf Pods Podfile.lock && pod install\n\n4. Android:\n   cd android && ./gradlew clean\n\n5. Test app launches successfully\n*/\n\n// 11. Post-upgrade validation\nclass UpgradeValidator {\n  static async validate() {\n    const checks = [\n      this.checkVersion(),\n      this.checkDependencies(),\n      this.checkNativeModules(),\n      this.checkNavigation(),\n      this.checkAPIs()\n    ];\n    \n    const results = await Promise.all(checks);\n    const failed = results.filter(r => !r.success);\n    \n    if (failed.length > 0) {\n      console.error('Upgrade validation failed:', failed);\n      return false;\n    }\n    \n    console.log('Upgrade validation passed!');\n    return true;\n  }\n  \n  static async checkVersion() {\n    const version = require('react-native/package.json').version;\n    return { success: version === '0.73.0', check: 'version' };\n  }\n  \n  // Additional validation checks...\n}\n\n// Run validation\nUpgradeValidator.validate();"
    },
    {
      "id": 91,
      "question": "What is React Native App Size Reduction Techniques?",
      "answer": "App size reduction improves download rates, installation success, and user retention.\n\nSize Contributors:\n• JavaScript bundle\n• Native libraries\n• Images and assets\n• Fonts\n• Third-party dependencies\n• Debug symbols\n• Unused code\n\nReduction Techniques:\n• Enable Hermes engine\n• Remove unused dependencies\n• Optimize images (WebP, compression)\n• Use vector icons\n• Enable ProGuard/R8 (Android)\n• Remove debug code\n• Tree shaking\n• Code splitting\n• On-demand asset loading\n• App thinning (iOS)\n• Dynamic delivery (Android)\n• Analyze and monitor size\n\nMeasurement:\n• Track APK/AAB size\n• Monitor size over releases\n• Set size budgets\n• Use size analysis tools\n\nGoogle Play Benefits:\n• Better search ranking\n• Higher conversion\n• More installs\n• Less uninstalls",
      "explanation": "App size reduction uses Hermes, ProGuard, image optimization, removing unused code, and platform-specific techniques like Android App Bundle and iOS App Thinning for smaller downloads.",
      "difficulty": "Hard",
      "code": "// 1. Enable Hermes (android/app/build.gradle)\n/*\nproject.ext.react = [\n    enableHermes: true  // Reduces bundle size significantly\n]\n*/\n\n// 2. ProGuard configuration (android/app/proguard-rules.pro)\n/*\n# Keep React Native classes\n-keep class com.facebook.react.** { *; }\n-keep class com.facebook.hermes.** { *; }\n\n# Remove logging\n-assumenosideeffects class android.util.Log {\n    public static *** d(...);\n    public static *** v(...);\n    public static *** i(...);\n}\n\n# Optimize and shrink\n-optimizationpasses 5\n-dontusemixedcaseclassnames\n-dontskipnonpubliclibraryclasses\n-dontpreverify\n-verbose\n*/\n\n// Enable in build.gradle\n/*\nandroid {\n    buildTypes {\n        release {\n            minifyEnabled true\n            shrinkResources true\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n*/\n\n// 3. Image optimization\n// Use ImageOptim, TinyPNG, or automated tools\n\n// scripts/optimize-images.js\n/*\nconst imagemin = require('imagemin');\nconst imageminWebp = require('imagemin-webp');\nconst imageminPngquant = require('imagemin-pngquant');\nconst imageminMozjpeg = require('imagemin-mozjpeg');\n\n(async () => {\n  // Convert to WebP\n  await imagemin(['src/assets/images/*.{jpg,png}'], {\n    destination: 'src/assets/images/optimized',\n    plugins: [\n      imageminWebp({ quality: 75 })\n    ]\n  });\n  \n  // Compress PNG\n  await imagemin(['src/assets/images/*.png'], {\n    destination: 'src/assets/images/compressed',\n    plugins: [\n      imageminPngquant({ quality: [0.6, 0.8] })\n    ]\n  });\n  \n  // Compress JPEG\n  await imagemin(['src/assets/images/*.jpg'], {\n    destination: 'src/assets/images/compressed',\n    plugins: [\n      imageminMozjpeg({ quality: 75 })\n    ]\n  });\n  \n  console.log('Images optimized!');\n})();\n*/\n\n// 4. Use vector icons instead of images\nimport Icon from 'react-native-vector-icons/Ionicons';\n\n// Instead of:\n// <Image source={require('./icons/home.png')} />\n\n// Use:\n<Icon name=\"home\" size={30} color=\"#000\" />\n\n// 5. Lazy load images\nimport React, { useState } from 'react';\nimport { View, Image } from 'react-native';\n\nfunction LazyImage({ source, ...props }) {\n  const [loaded, setLoaded] = useState(false);\n  \n  return (\n    <View>\n      {!loaded && <PlaceholderImage />}\n      <Image\n        source={source}\n        onLoad={() => setLoaded(true)}\n        style={loaded ? styles.loaded : styles.hidden}\n        {...props}\n      />\n    </View>\n  );\n}\n\n// 6. Remove unused dependencies\n// Run dependency analysis\n/*\nnpm install -g depcheck\ndepcheck\n\n# Output shows unused dependencies\n# Remove them from package.json\n*/\n\n// 7. Analyze bundle size\n// Installation: npm install --save-dev react-native-bundle-visualizer\n// Run: npx react-native-bundle-visualizer\n\n// 8. Android App Bundle (AAB)\n/*\n# Build AAB instead of APK\ncd android\n./gradlew bundleRelease\n\n# Output: android/app/build/outputs/bundle/release/app-release.aab\n# Google Play will generate optimized APKs for each device\n*/\n\n// 9. Dynamic feature modules (Android)\n// android/dynamicfeatures/premium/build.gradle\n/*\napply plugin: 'com.android.dynamic-feature'\n\nandroid {\n    compileSdkVersion rootProject.ext.compileSdkVersion\n    \n    defaultConfig {\n        minSdkVersion rootProject.ext.minSdkVersion\n        targetSdkVersion rootProject.ext.targetSdkVersion\n    }\n}\n\ndependencies {\n    implementation project(':app')\n}\n*/\n\n// Load dynamic module\nimport { PlayCore } from '@react-native-community/play-core';\n\nconst loadPremiumFeature = async () => {\n  try {\n    await PlayCore.installModule('premium');\n    const PremiumFeature = require('./features/PremiumFeature');\n    return PremiumFeature;\n  } catch (error) {\n    console.error('Failed to load premium feature:', error);\n  }\n};\n\n// 10. Size tracking CI/CD\n// .github/workflows/size-check.yml\n/*\nname: Size Check\n\non: [pull_request]\n\njobs:\n  size-check:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Setup Node\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n      \n      - name: Install dependencies\n        run: npm ci\n      \n      - name: Build Android\n        run: |\n          cd android\n          ./gradlew assembleRelease\n      \n      - name: Check APK size\n        run: |\n          APK_SIZE=$(stat -f%z android/app/build/outputs/apk/release/app-release.apk)\n          MAX_SIZE=52428800  # 50MB\n          \n          if [ $APK_SIZE -gt $MAX_SIZE ]; then\n            echo \"APK size ($APK_SIZE bytes) exceeds maximum ($MAX_SIZE bytes)\"\n            exit 1\n          fi\n          \n          echo \"APK size: $(($APK_SIZE / 1024 / 1024))MB\"\n*/\n\n// 11. Remove console.log in production\n// babel.config.js\n/*\nmodule.exports = {\n  presets: ['module:metro-react-native-babel-preset'],\n  env: {\n    production: {\n      plugins: ['transform-remove-console']\n    }\n  }\n};\n*/\n\n// 12. iOS App Thinning\n// Xcode automatically handles app thinning\n// Includes:\n// - Slicing (device-specific assets)\n// - Bitcode (optimization)\n// - On-Demand Resources\n\n// 13. Monitor size metrics\nclass SizeMetrics {\n  static trackBundleSize() {\n    if (__DEV__) return;\n    \n    const bundleSize = getBundleSize();\n    analytics().logEvent('bundle_size', {\n      size_bytes: bundleSize,\n      size_mb: (bundleSize / 1024 / 1024).toFixed(2)\n    });\n  }\n  \n  static trackDownloadSize() {\n    // Track actual download size from store\n    analytics().logEvent('download_size', {\n      platform: Platform.OS,\n      version: DeviceInfo.getVersion()\n    });\n  }\n}"
    },
    {
      "id": 92,
      "question": "What are React Native Animation Libraries and Techniques?",
      "answer": "Animations enhance user experience with smooth, performant visual transitions.\n\nAnimation Libraries:\n• React Native Animated API (built-in)\n• React Native Reanimated (recommended)\n• React Native Gesture Handler\n• Lottie - JSON animations\n• React Spring - physics-based\n• Moti - declarative animations\n\nAnimation Types:\n• Layout animations\n• Gesture-driven animations\n• Transitions\n• Value interpolations\n• Spring physics\n• Timing animations\n• Decay animations\n• SVG animations\n\nPerformance:\n• Use native driver (useNativeDriver: true)\n• Run on UI thread\n• Avoid JS bridge\n• 60 FPS target\n• Optimize re-renders\n• Profile animations\n\nBest Practices:\n• Keep animations under 300ms\n• Use appropriate easing\n• Provide feedback\n• Support reduced motion\n• Test on low-end devices\n• Avoid layout thrashing",
      "explanation": "React Native animations use Reanimated for performant UI-thread animations, Animated API for basic transitions, Lottie for complex animations, and Gesture Handler for interactive gestures.",
      "difficulty": "Hard",
      "code": "// 1. Reanimated 2 (Recommended)\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withSpring,\n  withTiming,\n  withSequence,\n  withRepeat\n} from 'react-native-reanimated';\nimport { Pressable } from 'react-native';\n\nfunction ReanimatedExample() {\n  const scale = useSharedValue(1);\n  const rotation = useSharedValue(0);\n  \n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { scale: scale.value },\n        { rotate: `${rotation.value}deg` }\n      ]\n    };\n  });\n  \n  const handlePress = () => {\n    // Spring animation\n    scale.value = withSpring(1.2);\n    \n    // Sequence of animations\n    rotation.value = withSequence(\n      withTiming(10, { duration: 100 }),\n      withTiming(-10, { duration: 100 }),\n      withTiming(0, { duration: 100 })\n    );\n  };\n  \n  return (\n    <Pressable onPress={handlePress}>\n      <Animated.View style={[styles.box, animatedStyle]} />\n    </Pressable>\n  );\n}\n\n// 2. Gesture-driven animation\nimport { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nfunction DraggableBox() {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n  const context = useSharedValue({ x: 0, y: 0 });\n  \n  const gesture = Gesture.Pan()\n    .onStart(() => {\n      context.value = { x: translateX.value, y: translateY.value };\n    })\n    .onUpdate((event) => {\n      translateX.value = event.translationX + context.value.x;\n      translateY.value = event.translationY + context.value.y;\n    })\n    .onEnd(() => {\n      // Snap back with spring\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    });\n  \n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value }\n    ]\n  }));\n  \n  return (\n    <GestureDetector gesture={gesture}>\n      <Animated.View style={[styles.box, animatedStyle]} />\n    </GestureDetector>\n  );\n}\n\n// 3. Layout animations\nimport { Layout, FadeIn, FadeOut } from 'react-native-reanimated';\n\nfunction LayoutAnimationExample() {\n  const [items, setItems] = useState([1, 2, 3]);\n  \n  return (\n    <View>\n      {items.map((item) => (\n        <Animated.View\n          key={item}\n          entering={FadeIn}\n          exiting={FadeOut}\n          layout={Layout.springify()}\n        >\n          <Text>{item}</Text>\n        </Animated.View>\n      ))}\n    </View>\n  );\n}\n\n// 4. Lottie animations\nimport LottieView from 'lottie-react-native';\n\nfunction LottieExample() {\n  const animationRef = useRef<LottieView>(null);\n  \n  useEffect(() => {\n    animationRef.current?.play();\n  }, []);\n  \n  return (\n    <LottieView\n      ref={animationRef}\n      source={require('./animations/success.json')}\n      autoPlay\n      loop={false}\n      style={{ width: 200, height: 200 }}\n      onAnimationFinish={() => console.log('Animation finished')}\n    />\n  );\n}\n\n// 5. Spring physics animation\nfunction SpringExample() {\n  const progress = useSharedValue(0);\n  \n  const animatedStyle = useAnimatedStyle(() => ({\n    opacity: progress.value,\n    transform: [{ scale: progress.value }]\n  }));\n  \n  useEffect(() => {\n    progress.value = withSpring(1, {\n      damping: 10,\n      stiffness: 100,\n      mass: 1\n    });\n  }, []);\n  \n  return <Animated.View style={[styles.box, animatedStyle]} />;\n}\n\n// 6. Interpolation\nfunction InterpolationExample() {\n  const scrollY = useSharedValue(0);\n  \n  const headerStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(\n      scrollY.value,\n      [0, 100],\n      [1, 0],\n      Extrapolate.CLAMP\n    );\n    \n    const height = interpolate(\n      scrollY.value,\n      [0, 100],\n      [100, 60],\n      Extrapolate.CLAMP\n    );\n    \n    return { opacity, height };\n  });\n  \n  return (\n    <View>\n      <Animated.View style={[styles.header, headerStyle]} />\n      <Animated.ScrollView\n        onScroll={(event) => {\n          scrollY.value = event.nativeEvent.contentOffset.y;\n        }}\n        scrollEventThrottle={16}\n      >\n        {/* Content */}\n      </Animated.ScrollView>\n    </View>\n  );\n}\n\n// 7. Animated shared element transition\nimport { SharedElement } from 'react-navigation-shared-element';\n\nfunction ListScreen({ navigation }) {\n  return (\n    <TouchableOpacity\n      onPress={() => navigation.navigate('Detail', { id: '1' })}\n    >\n      <SharedElement id=\"image-1\">\n        <Image source={{ uri: 'https://...' }} />\n      </SharedElement>\n    </TouchableOpacity>\n  );\n}\n\nfunction DetailScreen() {\n  return (\n    <SharedElement id=\"image-1\">\n      <Image source={{ uri: 'https://...' }} />\n    </SharedElement>\n  );\n}\n\n// Configure shared element\nDetailScreen.sharedElements = (route) => {\n  return [{ id: `image-${route.params.id}` }];\n};\n\n// 8. Custom hook for animations\nfunction useAnimatedValue(initialValue: number) {\n  const value = useSharedValue(initialValue);\n  \n  const animateTo = useCallback((toValue: number, config?: any) => {\n    value.value = withSpring(toValue, config);\n  }, []);\n  \n  const reset = useCallback(() => {\n    value.value = withTiming(initialValue);\n  }, [initialValue]);\n  \n  return { value, animateTo, reset };\n}\n\n// Usage\nfunction AnimatedComponent() {\n  const { value, animateTo } = useAnimatedValue(0);\n  \n  const style = useAnimatedStyle(() => ({\n    opacity: value.value\n  }));\n  \n  return (\n    <View>\n      <Animated.View style={[styles.box, style]} />\n      <Button title=\"Fade In\" onPress={() => animateTo(1)} />\n    </View>\n  );\n}\n\n// 9. Performance monitoring\nfunction AnimationPerformanceMonitor() {\n  const frameCallback = useCallback(() => {\n    'worklet';\n    const currentTime = performance.now();\n    // Monitor frame time\n  }, []);\n  \n  useFrameCallback(frameCallback);\n}\n\n// 10. Reduced motion support\nimport { AccessibilityInfo } from 'react-native';\n\nfunction useReducedMotion() {\n  const [reducedMotion, setReducedMotion] = useState(false);\n  \n  useEffect(() => {\n    AccessibilityInfo.isReduceMotionEnabled().then(setReducedMotion);\n    \n    const subscription = AccessibilityInfo.addEventListener(\n      'reduceMotionChanged',\n      setReducedMotion\n    );\n    \n    return () => subscription.remove();\n  }, []);\n  \n  return reducedMotion;\n}\n\nfunction AccessibleAnimation() {\n  const reducedMotion = useReducedMotion();\n  const scale = useSharedValue(1);\n  \n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }]\n  }));\n  \n  const animate = () => {\n    if (reducedMotion) {\n      // Instant transition\n      scale.value = 1.2;\n    } else {\n      // Smooth animation\n      scale.value = withSpring(1.2);\n    }\n  };\n  \n  return <Animated.View style={[styles.box, animatedStyle]} />;\n}"
    },
    {
      "id": 93,
      "question": "What are React Native Design Patterns and Architecture?",
      "answer": "Design patterns provide proven solutions for common architectural challenges.\n\nArchitectural Patterns:\n• Container/Presentational pattern\n• Higher-Order Components (HOC)\n• Render Props\n• Custom Hooks\n• Compound Components\n• Provider pattern\n• Observer pattern\n• Repository pattern\n\nState Management Patterns:\n• Flux architecture (Redux)\n• Atomic state (Recoil, Jotai)\n• Proxy state (Valtio, Zustand)\n• Context + Hooks\n• MobX observable\n\nProject Structure Patterns:\n• Feature-based\n• Domain-driven\n• Atomic design\n• Module-based\n• Layer architecture\n\nBest Practices:\n• Separation of concerns\n• Single responsibility\n• DRY (Don't Repeat Yourself)\n• SOLID principles\n• Dependency injection\n• Composition over inheritance\n• Immutable data patterns\n• Error boundaries",
      "explanation": "React Native design patterns include Container/Presentational separation, Custom Hooks for logic reuse, Provider pattern for state, and architectural patterns like feature-based organization and SOLID principles.",
      "difficulty": "Hard",
      "code": "// 1. Container/Presentational Pattern\n// Presentational Component (UI only)\ninterface UserProfileProps {\n  user: User;\n  onUpdate: (user: User) => void;\n  loading: boolean;\n}\n\nconst UserProfileView: FC<UserProfileProps> = ({ user, onUpdate, loading }) => (\n  <View style={styles.container}>\n    {loading ? (\n      <ActivityIndicator />\n    ) : (\n      <View>\n        <Text>{user.name}</Text>\n        <Button title=\"Update\" onPress={() => onUpdate(user)} />\n      </View>\n    )}\n  </View>\n);\n\n// Container Component (logic)\nconst UserProfileContainer: FC<{ userId: string }> = ({ userId }) => {\n  const { data: user, isLoading } = useQuery(['user', userId], () =>\n    fetchUser(userId)\n  );\n  \n  const updateMutation = useMutation(updateUser, {\n    onSuccess: () => queryClient.invalidateQueries(['user', userId])\n  });\n  \n  return (\n    <UserProfileView\n      user={user}\n      onUpdate={updateMutation.mutate}\n      loading={isLoading}\n    />\n  );\n};\n\n// 2. Custom Hook Pattern\nfunction useAuth() {\n  const [user, setUser] = useState<User | null>(null);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    loadUser();\n  }, []);\n  \n  const loadUser = async () => {\n    try {\n      const userData = await getStoredUser();\n      setUser(userData);\n    } finally {\n      setLoading(false);\n    }\n  };\n  \n  const login = async (email: string, password: string) => {\n    const userData = await authService.login(email, password);\n    setUser(userData);\n    await storeUser(userData);\n  };\n  \n  const logout = async () => {\n    await authService.logout();\n    setUser(null);\n    await clearStoredUser();\n  };\n  \n  return { user, loading, login, logout };\n}\n\n// Usage\nfunction LoginScreen() {\n  const { login, loading } = useAuth();\n  \n  const handleLogin = async () => {\n    await login(email, password);\n  };\n  \n  return <LoginForm onSubmit={handleLogin} loading={loading} />;\n}\n\n// 3. Compound Components Pattern\nconst Accordion = ({ children }: { children: ReactNode }) => {\n  const [openIndex, setOpenIndex] = useState<number | null>(null);\n  \n  return (\n    <AccordionContext.Provider value={{ openIndex, setOpenIndex }}>\n      {children}\n    </AccordionContext.Provider>\n  );\n};\n\nconst AccordionItem = ({\n  index,\n  title,\n  children\n}: {\n  index: number;\n  title: string;\n  children: ReactNode;\n}) => {\n  const { openIndex, setOpenIndex } = useContext(AccordionContext);\n  const isOpen = openIndex === index;\n  \n  return (\n    <View>\n      <TouchableOpacity onPress={() => setOpenIndex(isOpen ? null : index)}>\n        <Text>{title}</Text>\n      </TouchableOpacity>\n      {isOpen && <View>{children}</View>}\n    </View>\n  );\n};\n\n// Usage\n<Accordion>\n  <AccordionItem index={0} title=\"Section 1\">\n    <Text>Content 1</Text>\n  </AccordionItem>\n  <AccordionItem index={1} title=\"Section 2\">\n    <Text>Content 2</Text>\n  </AccordionItem>\n</Accordion>\n\n// 4. Repository Pattern\ninterface UserRepository {\n  getUser(id: string): Promise<User>;\n  getUsers(): Promise<User[]>;\n  createUser(user: CreateUserDto): Promise<User>;\n  updateUser(id: string, user: UpdateUserDto): Promise<User>;\n  deleteUser(id: string): Promise<void>;\n}\n\nclass ApiUserRepository implements UserRepository {\n  async getUser(id: string): Promise<User> {\n    const response = await apiClient.get(`/users/${id}`);\n    return response.data;\n  }\n  \n  async getUsers(): Promise<User[]> {\n    const response = await apiClient.get('/users');\n    return response.data;\n  }\n  \n  async createUser(user: CreateUserDto): Promise<User> {\n    const response = await apiClient.post('/users', user);\n    return response.data;\n  }\n  \n  async updateUser(id: string, user: UpdateUserDto): Promise<User> {\n    const response = await apiClient.put(`/users/${id}`, user);\n    return response.data;\n  }\n  \n  async deleteUser(id: string): Promise<void> {\n    await apiClient.delete(`/users/${id}`);\n  }\n}\n\n// Dependency injection\nconst userRepository: UserRepository = new ApiUserRepository();\n\n// 5. Observer Pattern\nclass EventEmitter {\n  private events: Map<string, Function[]> = new Map();\n  \n  on(event: string, callback: Function) {\n    if (!this.events.has(event)) {\n      this.events.set(event, []);\n    }\n    this.events.get(event)!.push(callback);\n  }\n  \n  off(event: string, callback: Function) {\n    const callbacks = this.events.get(event);\n    if (callbacks) {\n      const index = callbacks.indexOf(callback);\n      if (index > -1) callbacks.splice(index, 1);\n    }\n  }\n  \n  emit(event: string, data?: any) {\n    const callbacks = this.events.get(event);\n    if (callbacks) {\n      callbacks.forEach(callback => callback(data));\n    }\n  }\n}\n\nconst appEvents = new EventEmitter();\n\n// Usage\nfunction NotificationListener() {\n  useEffect(() => {\n    const handleNotification = (notification: Notification) => {\n      showToast(notification.message);\n    };\n    \n    appEvents.on('notification', handleNotification);\n    \n    return () => {\n      appEvents.off('notification', handleNotification);\n    };\n  }, []);\n  \n  return null;\n}\n\n// Emit event\nappEvents.emit('notification', { message: 'New message!' });\n\n// 6. Atomic State Pattern (Jotai)\nimport { atom, useAtom } from 'jotai';\n\nconst userAtom = atom<User | null>(null);\nconst userLoadingAtom = atom(true);\n\n// Derived atom\nconst isAuthenticatedAtom = atom((get) => get(userAtom) !== null);\n\nfunction useAuthAtoms() {\n  const [user, setUser] = useAtom(userAtom);\n  const [loading, setLoading] = useAtom(userLoadingAtom);\n  const [isAuthenticated] = useAtom(isAuthenticatedAtom);\n  \n  return { user, loading, isAuthenticated, setUser, setLoading };\n}\n\n// 7. Factory Pattern\ninterface Logger {\n  log(message: string): void;\n  error(message: string): void;\n}\n\nclass ConsoleLogger implements Logger {\n  log(message: string) {\n    console.log(message);\n  }\n  \n  error(message: string) {\n    console.error(message);\n  }\n}\n\nclass SentryLogger implements Logger {\n  log(message: string) {\n    Sentry.captureMessage(message, 'info');\n  }\n  \n  error(message: string) {\n    Sentry.captureMessage(message, 'error');\n  }\n}\n\nclass LoggerFactory {\n  static create(): Logger {\n    return __DEV__ ? new ConsoleLogger() : new SentryLogger();\n  }\n}\n\nconst logger = LoggerFactory.create();\n\n// 8. Singleton Pattern\nclass ApiClient {\n  private static instance: ApiClient;\n  private client: AxiosInstance;\n  \n  private constructor() {\n    this.client = axios.create({\n      baseURL: Config.API_URL\n    });\n  }\n  \n  static getInstance(): ApiClient {\n    if (!ApiClient.instance) {\n      ApiClient.instance = new ApiClient();\n    }\n    return ApiClient.instance;\n  }\n  \n  async get<T>(url: string): Promise<T> {\n    const response = await this.client.get<T>(url);\n    return response.data;\n  }\n}\n\nconst apiClient = ApiClient.getInstance();"
    },
    {
      "id": 94,
      "question": "What is React Native State Management with Zustand?",
      "answer": "Zustand is a lightweight state management solution with minimal boilerplate.\n\nKey Features:\n• Small bundle size (~1KB)\n• Simple API\n• No providers needed\n• TypeScript support\n• Middleware support\n• Devtools integration\n• Persistence support\n• Async actions\n• Computed values\n• No context re-render issues\n\nBenefits over Redux:\n• Less boilerplate\n• Simpler setup\n• Better TypeScript inference\n• No actions/reducers split\n• Flexible architecture\n• Easy testing\n\nWhen to Use:\n• Small to medium apps\n• Need simple global state\n• Want minimal setup\n• Prefer hooks API\n• Need good performance\n\nAlternatives:\n• Redux (complex apps)\n• Jotai (atomic state)\n• Valtio (proxy state)\n• MobX (observable state)\n• Context API (simple cases)",
      "explanation": "Zustand provides lightweight state management with hooks API, minimal boilerplate, no providers, TypeScript support, and middleware for persistence and devtools integration.",
      "difficulty": "Medium",
      "code": "// Installation: npm install zustand\nimport { create } from 'zustand';\nimport { persist, createJSONStorage } from 'zustand/middleware';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\n// 1. Basic store\ninterface BearStore {\n  bears: number;\n  increase: (by: number) => void;\n  decrease: () => void;\n  reset: () => void;\n}\n\nconst useBearStore = create<BearStore>((set) => ({\n  bears: 0,\n  increase: (by) => set((state) => ({ bears: state.bears + by })),\n  decrease: () => set((state) => ({ bears: state.bears - 1 })),\n  reset: () => set({ bears: 0 })\n}));\n\n// Usage in component\nfunction BearCounter() {\n  const bears = useBearStore((state) => state.bears);\n  return <Text>Bears: {bears}</Text>;\n}\n\nfunction Controls() {\n  const increase = useBearStore((state) => state.increase);\n  const decrease = useBearStore((state) => state.decrease);\n  \n  return (\n    <View>\n      <Button title=\"+1\" onPress={() => increase(1)} />\n      <Button title=\"-1\" onPress={decrease} />\n    </View>\n  );\n}\n\n// 2. Store with async actions\ninterface UserStore {\n  user: User | null;\n  loading: boolean;\n  error: string | null;\n  fetchUser: (id: string) => Promise<void>;\n  updateUser: (user: Partial<User>) => Promise<void>;\n  logout: () => void;\n}\n\nconst useUserStore = create<UserStore>((set, get) => ({\n  user: null,\n  loading: false,\n  error: null,\n  \n  fetchUser: async (id) => {\n    set({ loading: true, error: null });\n    try {\n      const response = await fetch(`/api/users/${id}`);\n      const user = await response.json();\n      set({ user, loading: false });\n    } catch (error) {\n      set({ error: error.message, loading: false });\n    }\n  },\n  \n  updateUser: async (updates) => {\n    const { user } = get();\n    if (!user) return;\n    \n    set({ loading: true });\n    try {\n      const response = await fetch(`/api/users/${user.id}`, {\n        method: 'PUT',\n        body: JSON.stringify(updates)\n      });\n      const updatedUser = await response.json();\n      set({ user: updatedUser, loading: false });\n    } catch (error) {\n      set({ error: error.message, loading: false });\n    }\n  },\n  \n  logout: () => set({ user: null })\n}));\n\n// 3. Persisted store\ninterface SettingsStore {\n  theme: 'light' | 'dark';\n  notifications: boolean;\n  setTheme: (theme: 'light' | 'dark') => void;\n  toggleNotifications: () => void;\n}\n\nconst useSettingsStore = create<SettingsStore>()(persist(\n  (set) => ({\n    theme: 'light',\n    notifications: true,\n    setTheme: (theme) => set({ theme }),\n    toggleNotifications: () => set((state) => ({\n      notifications: !state.notifications\n    }))\n  }),\n  {\n    name: 'settings-storage',\n    storage: createJSONStorage(() => AsyncStorage)\n  }\n));\n\n// 4. Computed values (selectors)\nconst useCartStore = create<CartStore>((set, get) => ({\n  items: [],\n  \n  addItem: (item) => set((state) => ({\n    items: [...state.items, item]\n  })),\n  \n  removeItem: (id) => set((state) => ({\n    items: state.items.filter(item => item.id !== id)\n  }))\n}));\n\n// Computed selector\nconst useCartTotal = () => useCartStore((state) =>\n  state.items.reduce((total, item) => total + item.price, 0)\n);\n\nfunction CartSummary() {\n  const total = useCartTotal();\n  const itemCount = useCartStore((state) => state.items.length);\n  \n  return (\n    <View>\n      <Text>Items: {itemCount}</Text>\n      <Text>Total: ${total}</Text>\n    </View>\n  );\n}\n\n// 5. Middleware for logging\nimport { devtools } from 'zustand/middleware';\n\nconst useStore = create<Store>()(devtools(\n  (set) => ({\n    // Store implementation\n  }),\n  { name: 'MyStore' }\n));\n\n// 6. Slices pattern (splitting large stores)\nconst createUserSlice = (set, get) => ({\n  user: null,\n  setUser: (user) => set({ user })\n});\n\nconst createCartSlice = (set, get) => ({\n  items: [],\n  addItem: (item) => set((state) => ({\n    items: [...state.items, item]\n  }))\n});\n\nconst useStore = create((set, get) => ({\n  ...createUserSlice(set, get),\n  ...createCartSlice(set, get)\n}));\n\n// 7. Subscribe to store changes\nfunction logMiddleware(config) {\n  return (set, get, api) =>\n    config(\n      (...args) => {\n        console.log('Before:', get());\n        set(...args);\n        console.log('After:', get());\n      },\n      get,\n      api\n    );\n}\n\nconst useStore = create(logMiddleware((set) => ({\n  // Store implementation\n})));\n\n// 8. Testing Zustand stores\nimport { act, renderHook } from '@testing-library/react-hooks';\n\ndescribe('useBearStore', () => {\n  beforeEach(() => {\n    useBearStore.setState({ bears: 0 });\n  });\n  \n  it('increases bear count', () => {\n    const { result } = renderHook(() => useBearStore());\n    \n    act(() => {\n      result.current.increase(1);\n    });\n    \n    expect(result.current.bears).toBe(1);\n  });\n});"
    },
    {
      "id": 95,
      "question": "What are React Native Best Practices for Production Apps?",
      "answer": "Production-ready React Native apps require following established best practices for quality, performance, and maintainability.\n\nCode Quality:\n• Use TypeScript\n• ESLint and Prettier\n• Code reviews\n• Git hooks (pre-commit, pre-push)\n• Consistent naming conventions\n• Documentation\n• Type safety\n• Unit tests coverage\n\nPerformance:\n• Enable Hermes\n• Optimize images\n• Use FlatList properly\n• Lazy loading\n• Code splitting\n• Native driver for animations\n• Avoid unnecessary re-renders\n• Profile regularly\n\nSecurity:\n• Secure storage for sensitive data\n• SSL pinning\n• Input validation\n• No secrets in code\n• Root/jailbreak detection\n• Proper authentication\n• API security\n\nUser Experience:\n• Loading states\n• Error handling\n• Offline support\n• Accessibility\n• Smooth animations\n• Pull-to-refresh\n• Deep linking\n• Push notifications\n\nMonitoring:\n• Crash reporting\n• Analytics\n• Performance monitoring\n• Error tracking\n• User feedback",
      "explanation": "Production React Native apps require TypeScript, comprehensive testing, performance optimization with Hermes, secure data handling, proper error monitoring, and following platform-specific guidelines for quality apps.",
      "difficulty": "Hard",
      "code": "// 1. Project structure for production\n/*\nsrc/\n├── api/                    # API clients\n│   ├── client.ts\n│   ├── endpoints.ts\n│   └── types.ts\n├── assets/                 # Images, fonts\n├── components/            # Reusable components\n│   ├── Button/\n│   │   ├── Button.tsx\n│   │   ├── Button.test.tsx\n│   │   ├── Button.stories.tsx\n│   │   └── index.ts\n├── features/              # Feature modules\n│   ├── auth/\n│   │   ├── screens/\n│   │   ├── components/\n│   │   ├── hooks/\n│   │   ├── store/\n│   │   └── types/\n├── navigation/\n├── services/\n├── utils/\n├── constants/\n├── types/\n└── App.tsx\n*/\n\n// 2. Error boundary wrapper\nclass ErrorBoundary extends Component {\n  state = { hasError: false, error: null };\n  \n  static getDerivedStateFromError(error) {\n    return { hasError: true, error };\n  }\n  \n  componentDidCatch(error, errorInfo) {\n    // Log to crash reporting service\n    crashlytics().recordError(error);\n    Sentry.captureException(error, { extra: errorInfo });\n  }\n  \n  render() {\n    if (this.state.hasError) {\n      return <ErrorScreen error={this.state.error} />;\n    }\n    return this.props.children;\n  }\n}\n\n// 3. Global error handler\nErrorUtils.setGlobalHandler((error, isFatal) => {\n  if (isFatal) {\n    crashlytics().recordError(error);\n    Alert.alert(\n      'Unexpected error occurred',\n      'We will fix it soon. Please restart the app.'\n    );\n  } else {\n    console.error(error);\n  }\n});\n\n// 4. API client with interceptors\nimport axios from 'axios';\nimport Config from 'react-native-config';\n\nconst apiClient = axios.create({\n  baseURL: Config.API_URL,\n  timeout: 10000\n});\n\n// Request interceptor\napiClient.interceptors.request.use(\n  async (config) => {\n    const token = await SecureStore.getToken();\n    if (token) {\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n    config.headers['X-Request-ID'] = generateRequestId();\n    return config;\n  },\n  (error) => {\n    logger.error('Request error:', error);\n    return Promise.reject(error);\n  }\n);\n\n// Response interceptor\napiClient.interceptors.response.use(\n  (response) => response,\n  async (error) => {\n    if (error.response?.status === 401) {\n      await handleUnauthorized();\n    }\n    \n    // Track API errors\n    analytics().logEvent('api_error', {\n      url: error.config?.url,\n      status: error.response?.status,\n      message: error.message\n    });\n    \n    return Promise.reject(error);\n  }\n);\n\n// 5. Environment configuration\n// .env.production\n/*\nAPI_URL=https://api.production.com\nENABLE_ANALYTICS=true\nLOG_LEVEL=error\nENVIRONMENT=production\n*/\n\nclass Config {\n  static get apiUrl() {\n    return process.env.API_URL;\n  }\n  \n  static get isProduction() {\n    return process.env.ENVIRONMENT === 'production';\n  }\n  \n  static validate() {\n    const required = ['API_URL', 'ENVIRONMENT'];\n    const missing = required.filter(key => !process.env[key]);\n    \n    if (missing.length > 0) {\n      throw new Error(`Missing required config: ${missing.join(', ')}`);\n    }\n  }\n}\n\n// 6. Feature flags\nclass FeatureFlags {\n  private static flags: Record<string, boolean> = {};\n  \n  static async initialize() {\n    const remoteFlags = await remoteConfig().getAll();\n    this.flags = Object.entries(remoteFlags).reduce(\n      (acc, [key, value]) => ({\n        ...acc,\n        [key]: value.asBoolean()\n      }),\n      {}\n    );\n  }\n  \n  static isEnabled(flag: string): boolean {\n    return this.flags[flag] ?? false;\n  }\n}\n\n// 7. Performance monitoring\nclass PerformanceMonitor {\n  static startTrace(name: string) {\n    if (!__DEV__) {\n      return perf().startTrace(name);\n    }\n  }\n  \n  static logMetric(name: string, value: number) {\n    if (!__DEV__) {\n      perf().putMetric(name, value);\n    }\n  }\n}\n\n// 8. Comprehensive App initialization\nfunction App() {\n  const [isReady, setIsReady] = useState(false);\n  \n  useEffect(() => {\n    async function initialize() {\n      try {\n        // Validate configuration\n        Config.validate();\n        \n        // Initialize services\n        await Promise.all([\n          FeatureFlags.initialize(),\n          SecureStore.initialize(),\n          CrashReporting.initialize(),\n          Analytics.initialize()\n        ]);\n        \n        // Load persisted data\n        await loadPersistedState();\n        \n        // Check app version\n        await checkForUpdates();\n      } catch (error) {\n        crashlytics().recordError(error);\n      } finally {\n        setIsReady(true);\n        await SplashScreen.hide();\n      }\n    }\n    \n    initialize();\n  }, []);\n  \n  if (!isReady) return null;\n  \n  return (\n    <ErrorBoundary>\n      <ThemeProvider>\n        <NavigationContainer>\n          <RootNavigator />\n        </NavigationContainer>\n      </ThemeProvider>\n    </ErrorBoundary>\n  );\n}\n\n// 9. Production build checklist\n/*\n- [ ] Remove console.logs\n- [ ] Enable ProGuard/R8\n- [ ] Enable Hermes\n- [ ] Optimize images\n- [ ] Test on real devices\n- [ ] Check bundle size\n- [ ] Review permissions\n- [ ] Test offline scenarios\n- [ ] Test on slow networks\n- [ ] Verify analytics\n- [ ] Test crash reporting\n- [ ] Update version number\n- [ ] Generate release notes\n- [ ] Create release builds\n- [ ] Submit for review\n*/\n\nexport default App;"
    },
    {
      "id": 96,
      "question": "What is React Native Modular Architecture and Code Organization?",
      "answer": "Modular architecture divides the app into independent, reusable modules for better maintainability and scalability.\n\nModule Types:\n• Feature modules (Auth, Profile, Cart)\n• UI component library\n• Shared utilities\n• API clients\n• Native modules\n• Business logic layer\n• Data layer\n\nBenefits:\n• Code reusability\n• Parallel development\n• Independent testing\n• Easier maintenance\n• Better scalability\n• Clear dependencies\n• Team autonomy\n• Faster builds\n\nOrganization Strategies:\n• Feature-based structure\n• Domain-driven design\n• Atomic design system\n• Micro-frontends\n• Monorepo approach\n\nBest Practices:\n• Clear module boundaries\n• Single responsibility\n• Dependency injection\n• Interface-based contracts\n• Version control per module\n• Independent deployment\n• Comprehensive documentation",
      "explanation": "Modular architecture organizes React Native apps into independent feature modules with clear boundaries, enabling parallel development, better testing, code reusability, and team scalability.",
      "difficulty": "Hard",
      "code": "// 1. Feature-based modular structure\n/*\nsrc/\n├── modules/\n│   ├── auth/\n│   │   ├── index.ts              # Public API\n│   │   ├── screens/\n│   │   │   ├── LoginScreen.tsx\n│   │   │   ├── RegisterScreen.tsx\n│   │   │   └── ForgotPasswordScreen.tsx\n│   │   ├── components/\n│   │   │   ├── LoginForm.tsx\n│   │   │   └── SocialLoginButton.tsx\n│   │   ├── hooks/\n│   │   │   ├── useAuth.ts\n│   │   │   └── useAuthForm.ts\n│   │   ├── store/\n│   │   │   └── authStore.ts\n│   │   ├── services/\n│   │   │   └── authService.ts\n│   │   ├── types/\n│   │   │   └── auth.types.ts\n│   │   └── navigation/\n│   │       └── AuthNavigator.tsx\n│   ├── profile/\n│   ├── cart/\n│   └── products/\n├── shared/\n│   ├── components/            # Shared UI components\n│   ├── hooks/\n│   ├── utils/\n│   ├── types/\n│   └── constants/\n├── core/\n│   ├── api/\n│   ├── navigation/\n│   ├── theme/\n│   └── services/\n└── App.tsx\n*/\n\n// 2. Module public API\n// modules/auth/index.ts\nexport { default as LoginScreen } from './screens/LoginScreen';\nexport { default as RegisterScreen } from './screens/RegisterScreen';\nexport { default as AuthNavigator } from './navigation/AuthNavigator';\nexport { useAuth } from './hooks/useAuth';\nexport type { User, AuthState } from './types/auth.types';\n\n// Usage from other modules\nimport { LoginScreen, useAuth } from '@modules/auth';\n\n// 3. Dependency injection pattern\n// core/api/ApiClient.interface.ts\nexport interface IApiClient {\n  get<T>(url: string, config?: AxiosRequestConfig): Promise<T>;\n  post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T>;\n  put<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T>;\n  delete<T>(url: string, config?: AxiosRequestConfig): Promise<T>;\n}\n\n// core/api/ApiClient.ts\nexport class ApiClient implements IApiClient {\n  private client: AxiosInstance;\n  \n  constructor(config: { baseURL: string; timeout?: number }) {\n    this.client = axios.create(config);\n    this.setupInterceptors();\n  }\n  \n  async get<T>(url: string, config?: AxiosRequestConfig): Promise<T> {\n    const response = await this.client.get<T>(url, config);\n    return response.data;\n  }\n  \n  // ... other methods\n}\n\n// modules/auth/services/authService.ts\nexport class AuthService {\n  constructor(private apiClient: IApiClient) {}\n  \n  async login(email: string, password: string): Promise<AuthResponse> {\n    return this.apiClient.post('/auth/login', { email, password });\n  }\n  \n  async register(userData: RegisterData): Promise<AuthResponse> {\n    return this.apiClient.post('/auth/register', userData);\n  }\n}\n\n// Dependency injection container\nclass Container {\n  private services = new Map();\n  \n  register<T>(name: string, instance: T) {\n    this.services.set(name, instance);\n  }\n  \n  resolve<T>(name: string): T {\n    return this.services.get(name);\n  }\n}\n\nconst container = new Container();\ncontainer.register('apiClient', new ApiClient({ baseURL: Config.API_URL }));\ncontainer.register('authService', new AuthService(container.resolve('apiClient')));\n\n// 4. Module registry for dynamic loading\nclass ModuleRegistry {\n  private modules = new Map<string, () => Promise<any>>();\n  \n  register(name: string, loader: () => Promise<any>) {\n    this.modules.set(name, loader);\n  }\n  \n  async load(name: string) {\n    const loader = this.modules.get(name);\n    if (!loader) throw new Error(`Module ${name} not found`);\n    return await loader();\n  }\n  \n  isRegistered(name: string): boolean {\n    return this.modules.has(name);\n  }\n}\n\nconst moduleRegistry = new ModuleRegistry();\n\n// Register modules\nmoduleRegistry.register('auth', () => import('@modules/auth'));\nmoduleRegistry.register('profile', () => import('@modules/profile'));\nmoduleRegistry.register('cart', () => import('@modules/cart'));\n\n// Lazy load module\nconst AuthModule = lazy(() => moduleRegistry.load('auth'));\n\n// 5. Inter-module communication (Event Bus)\ntype EventCallback = (data: any) => void;\n\nclass EventBus {\n  private events = new Map<string, Set<EventCallback>>();\n  \n  on(event: string, callback: EventCallback) {\n    if (!this.events.has(event)) {\n      this.events.set(event, new Set());\n    }\n    this.events.get(event)!.add(callback);\n  }\n  \n  off(event: string, callback: EventCallback) {\n    this.events.get(event)?.delete(callback);\n  }\n  \n  emit(event: string, data?: any) {\n    this.events.get(event)?.forEach(callback => callback(data));\n  }\n  \n  clear() {\n    this.events.clear();\n  }\n}\n\nexport const eventBus = new EventBus();\n\n// Module A emits event\neventBus.emit('user:logout', { userId: '123' });\n\n// Module B listens to event\nuseEffect(() => {\n  const handleLogout = (data) => {\n    clearCart();\n  };\n  \n  eventBus.on('user:logout', handleLogout);\n  return () => eventBus.off('user:logout', handleLogout);\n}, []);\n\n// 6. Module configuration\n// modules/auth/config.ts\nexport interface AuthModuleConfig {\n  enableSocialLogin: boolean;\n  enableBiometric: boolean;\n  tokenRefreshInterval: number;\n  sessionTimeout: number;\n}\n\nexport class AuthModule {\n  private config: AuthModuleConfig;\n  \n  constructor(config: Partial<AuthModuleConfig> = {}) {\n    this.config = {\n      enableSocialLogin: false,\n      enableBiometric: false,\n      tokenRefreshInterval: 5 * 60 * 1000, // 5 minutes\n      sessionTimeout: 30 * 60 * 1000,      // 30 minutes\n      ...config\n    };\n  }\n  \n  initialize() {\n    // Setup module based on config\n    if (this.config.enableBiometric) {\n      this.setupBiometric();\n    }\n    \n    if (this.config.enableSocialLogin) {\n      this.setupSocialProviders();\n    }\n  }\n}\n\n// App initialization\nconst authModule = new AuthModule({\n  enableSocialLogin: true,\n  enableBiometric: Platform.OS === 'ios'\n});\n\nauthModule.initialize();\n\n// 7. Module versioning and compatibility\n// modules/auth/package.json\n/*\n{\n  \"name\": \"@app/auth\",\n  \"version\": \"1.2.0\",\n  \"dependencies\": {\n    \"@app/core\": \"^2.0.0\",\n    \"@app/ui\": \"^1.5.0\"\n  },\n  \"peerDependencies\": {\n    \"react-native\": \">=0.70.0\"\n  }\n}\n*/\n\n// 8. Monorepo setup with workspaces\n// package.json (root)\n/*\n{\n  \"name\": \"my-app\",\n  \"private\": true,\n  \"workspaces\": [\n    \"packages/*\",\n    \"modules/*\"\n  ],\n  \"scripts\": {\n    \"start\": \"react-native start\",\n    \"build:modules\": \"yarn workspaces run build\",\n    \"test:modules\": \"yarn workspaces run test\"\n  }\n}\n*/\n\n// 9. Module testing in isolation\n// modules/auth/__tests__/authService.test.ts\nimport { AuthService } from '../services/authService';\nimport { MockApiClient } from '@app/testing';\n\ndescribe('AuthService', () => {\n  let authService: AuthService;\n  let mockApiClient: MockApiClient;\n  \n  beforeEach(() => {\n    mockApiClient = new MockApiClient();\n    authService = new AuthService(mockApiClient);\n  });\n  \n  it('should login successfully', async () => {\n    const credentials = { email: 'test@example.com', password: 'password' };\n    const mockResponse = { token: 'abc123', user: { id: '1' } };\n    \n    mockApiClient.post.mockResolvedValue(mockResponse);\n    \n    const result = await authService.login(\n      credentials.email,\n      credentials.password\n    );\n    \n    expect(result).toEqual(mockResponse);\n    expect(mockApiClient.post).toHaveBeenCalledWith('/auth/login', credentials);\n  });\n});\n\n// 10. Documentation generation\n// modules/auth/README.md\n/*\n# Auth Module\n\n## Installation\n```bash\nyarn add @app/auth\n```\n\n## Usage\n```typescript\nimport { useAuth, LoginScreen } from '@app/auth';\n\nfunction App() {\n  const { user, login, logout } = useAuth();\n  \n  return (\n    <NavigationContainer>\n      {user ? <MainNavigator /> : <LoginScreen />}\n    </NavigationContainer>\n  );\n}\n```\n\n## API Reference\n\n### `useAuth()`\nReturns authentication state and methods.\n\n#### Returns\n- `user: User | null` - Current user\n- `loading: boolean` - Loading state\n- `login: (email, password) => Promise<void>` - Login function\n- `logout: () => Promise<void>` - Logout function\n\n## Configuration\n```typescript\nconst authModule = new AuthModule({\n  enableSocialLogin: true,\n  enableBiometric: true\n});\n```\n*/"
    },
    {
      "id": 97,
      "question": "What is React Native Enterprise Patterns and Scalability?",
      "answer": "Enterprise React Native apps require patterns for large-scale development, team collaboration, and long-term maintenance.\n\nEnterprise Challenges:\n• Large codebases\n• Multiple teams\n• Complex business logic\n• High performance requirements\n• Security compliance\n• Legacy system integration\n• Global distribution\n• Continuous delivery\n\nScalability Patterns:\n• Micro-frontends\n• Monorepo architecture\n• Module federation\n• Service-oriented architecture\n• Event-driven architecture\n• CQRS pattern\n• Backend for Frontend (BFF)\n\nTeam Practices:\n• Code ownership\n• Pull request workflow\n• Continuous integration\n• Automated testing\n• Documentation standards\n• Code review guidelines\n• Architecture decisions records\n\nPerformance at Scale:\n• Bundle optimization\n• Code splitting\n• Lazy loading\n• Caching strategies\n• CDN integration\n• Load balancing\n• Monitoring and alerting",
      "explanation": "Enterprise React Native requires monorepo architecture, micro-frontends, automated CI/CD, comprehensive testing, performance monitoring, security compliance, and team collaboration patterns for large-scale success.",
      "difficulty": "Hard",
      "code": "// 1. Monorepo structure with Nx/Turborepo\n/*\nmy-enterprise-app/\n├── apps/\n│   ├── mobile/                    # React Native app\n│   ├── mobile-admin/              # Admin app\n│   └── web/                       # Web version\n├── packages/\n│   ├── ui/                        # Shared UI components\n│   ├── api-client/                # API client\n│   ├── auth/                      # Auth module\n│   ├── analytics/                 # Analytics module\n│   ├── utils/                     # Shared utilities\n│   └── types/                     # Shared TypeScript types\n├── libs/\n│   ├── business-logic/            # Business rules\n│   └── data-access/               # Data layer\n├── tools/\n│   └── scripts/                   # Build and deploy scripts\n├── nx.json\n├── package.json\n└── turbo.json\n*/\n\n// nx.json configuration\n/*\n{\n  \"tasksRunnerOptions\": {\n    \"default\": {\n      \"runner\": \"nx/tasks-runners/default\",\n      \"options\": {\n        \"cacheableOperations\": [\"build\", \"test\", \"lint\"]\n      }\n    }\n  },\n  \"targetDefaults\": {\n    \"build\": {\n      \"dependsOn\": [\"^build\"]\n    }\n  }\n}\n*/\n\n// 2. Micro-frontend pattern\n// Host app\nimport React, { lazy, Suspense } from 'react';\nimport { ModuleRegistry } from './core/ModuleRegistry';\n\nclass MicroFrontendRegistry {\n  private modules = new Map<string, React.ComponentType>();\n  \n  register(name: string, component: React.ComponentType) {\n    this.modules.set(name, component);\n  }\n  \n  get(name: string): React.ComponentType | undefined {\n    return this.modules.get(name);\n  }\n}\n\nconst registry = new MicroFrontendRegistry();\n\n// Register micro-frontends\nregistry.register(\n  'commerce',\n  lazy(() => import('@modules/commerce'))\n);\nregistry.register(\n  'customer-service',\n  lazy(() => import('@modules/customer-service'))\n);\n\nfunction MicroFrontendHost() {\n  return (\n    <NavigationContainer>\n      <Stack.Navigator>\n        <Stack.Screen\n          name=\"Commerce\"\n          component={() => (\n            <Suspense fallback={<Loading />}>\n              {React.createElement(registry.get('commerce')!)}\n            </Suspense>\n          )}\n        />\n      </Stack.Navigator>\n    </NavigationContainer>\n  );\n}\n\n// 3. Backend for Frontend (BFF) pattern\n// Each client has its own optimized API gateway\n\nclass BFFClient {\n  private apiClient: ApiClient;\n  \n  constructor(baseURL: string) {\n    this.apiClient = new ApiClient({\n      baseURL,\n      headers: {\n        'X-Client-Type': 'mobile',\n        'X-Client-Version': DeviceInfo.getVersion()\n      }\n    });\n  }\n  \n  // Aggregated endpoint for home screen\n  async getHomeData(): Promise<HomeData> {\n    // Single request that combines multiple backend calls\n    return this.apiClient.get('/mobile/home');\n  }\n  \n  // Optimized for mobile bandwidth\n  async getProductDetails(id: string): Promise<Product> {\n    return this.apiClient.get(`/mobile/products/${id}`, {\n      params: {\n        fields: 'id,name,price,images[0],rating'\n      }\n    });\n  }\n}\n\n// 4. Event-driven architecture\ninterface DomainEvent {\n  type: string;\n  payload: any;\n  timestamp: number;\n  metadata?: Record<string, any>;\n}\n\nclass EventBus {\n  private handlers = new Map<string, Set<(event: DomainEvent) => void>>();\n  \n  subscribe(eventType: string, handler: (event: DomainEvent) => void) {\n    if (!this.handlers.has(eventType)) {\n      this.handlers.set(eventType, new Set());\n    }\n    this.handlers.get(eventType)!.add(handler);\n  }\n  \n  publish(event: DomainEvent) {\n    const handlers = this.handlers.get(event.type);\n    if (handlers) {\n      handlers.forEach(handler => {\n        try {\n          handler(event);\n        } catch (error) {\n          console.error(`Error handling event ${event.type}:`, error);\n        }\n      });\n    }\n  }\n}\n\nconst eventBus = new EventBus();\n\n// Domain events\neventBus.publish({\n  type: 'ORDER_PLACED',\n  payload: { orderId: '123', userId: '456' },\n  timestamp: Date.now()\n});\n\n// Different modules can react to same event\neventBus.subscribe('ORDER_PLACED', (event) => {\n  // Analytics module\n  analytics.track('Order Placed', event.payload);\n});\n\neventBus.subscribe('ORDER_PLACED', (event) => {\n  // Notification module\n  showNotification('Order confirmed!');\n});\n\n// 5. CQRS (Command Query Responsibility Segregation)\ninterface Command {\n  type: string;\n  payload: any;\n}\n\ninterface Query {\n  type: string;\n  params: any;\n}\n\nclass CommandBus {\n  private handlers = new Map<string, (command: Command) => Promise<void>>();\n  \n  register(commandType: string, handler: (command: Command) => Promise<void>) {\n    this.handlers.set(commandType, handler);\n  }\n  \n  async execute(command: Command): Promise<void> {\n    const handler = this.handlers.get(command.type);\n    if (!handler) throw new Error(`No handler for command ${command.type}`);\n    await handler(command);\n  }\n}\n\nclass QueryBus {\n  private handlers = new Map<string, (query: Query) => Promise<any>>();\n  \n  register(queryType: string, handler: (query: Query) => Promise<any>) {\n    this.handlers.set(queryType, handler);\n  }\n  \n  async execute<T>(query: Query): Promise<T> {\n    const handler = this.handlers.get(query.type);\n    if (!handler) throw new Error(`No handler for query ${query.type}`);\n    return handler(query);\n  }\n}\n\nconst commandBus = new CommandBus();\nconst queryBus = new QueryBus();\n\n// Command: Changes state\ncommandBus.register('CREATE_ORDER', async (command) => {\n  const order = await orderService.create(command.payload);\n  eventBus.publish({\n    type: 'ORDER_CREATED',\n    payload: order,\n    timestamp: Date.now()\n  });\n});\n\n// Query: Reads state\nqueryBus.register('GET_ORDER', async (query) => {\n  return orderService.getById(query.params.id);\n});\n\n// Usage\nawait commandBus.execute({\n  type: 'CREATE_ORDER',\n  payload: { userId: '123', items: [...] }\n});\n\nconst order = await queryBus.execute<Order>({\n  type: 'GET_ORDER',\n  params: { id: '456' }\n});\n\n// 6. Feature flags for enterprise\nclass FeatureFlagService {\n  private flags = new Map<string, boolean>();\n  private userSegments = new Map<string, string[]>();\n  \n  async initialize() {\n    const response = await fetch('/api/feature-flags');\n    const data = await response.json();\n    \n    data.flags.forEach(flag => {\n      this.flags.set(flag.name, flag.enabled);\n    });\n    \n    data.segments.forEach(segment => {\n      this.userSegments.set(segment.name, segment.users);\n    });\n  }\n  \n  isEnabled(flagName: string, userId?: string): boolean {\n    const flag = this.flags.get(flagName);\n    if (flag === undefined) return false;\n    \n    // Check if user is in specific segment\n    if (userId) {\n      const segment = this.userSegments.get(flagName);\n      if (segment && !segment.includes(userId)) {\n        return false;\n      }\n    }\n    \n    return flag;\n  }\n  \n  // A/B testing support\n  getVariant(experimentName: string, userId: string): string {\n    const hash = this.hashUserId(userId);\n    return hash % 2 === 0 ? 'control' : 'variant';\n  }\n  \n  private hashUserId(userId: string): number {\n    let hash = 0;\n    for (let i = 0; i < userId.length; i++) {\n      hash = ((hash << 5) - hash) + userId.charCodeAt(i);\n      hash |= 0;\n    }\n    return Math.abs(hash);\n  }\n}\n\nconst featureFlags = new FeatureFlagService();\n\n// Usage\nfunction NewFeature() {\n  const { user } = useAuth();\n  const isEnabled = featureFlags.isEnabled('new-checkout', user?.id);\n  \n  if (!isEnabled) return null;\n  \n  return <NewCheckoutFlow />;\n}\n\n// 7. Distributed tracing\nclass TracingService {\n  private traces = new Map<string, Span[]>();\n  \n  startSpan(name: string, parentId?: string): string {\n    const spanId = generateId();\n    const span: Span = {\n      id: spanId,\n      name,\n      parentId,\n      startTime: Date.now(),\n      attributes: {}\n    };\n    \n    if (!this.traces.has(spanId)) {\n      this.traces.set(spanId, []);\n    }\n    this.traces.get(spanId)!.push(span);\n    \n    return spanId;\n  }\n  \n  endSpan(spanId: string, attributes?: Record<string, any>) {\n    const spans = this.traces.get(spanId);\n    if (spans && spans.length > 0) {\n      const span = spans[spans.length - 1];\n      span.endTime = Date.now();\n      span.duration = span.endTime - span.startTime;\n      if (attributes) {\n        span.attributes = { ...span.attributes, ...attributes };\n      }\n      \n      // Send to tracing backend\n      this.sendTrace(span);\n    }\n  }\n  \n  private async sendTrace(span: Span) {\n    // Send to distributed tracing system (Jaeger, Zipkin, etc.)\n    await fetch('/api/traces', {\n      method: 'POST',\n      body: JSON.stringify(span)\n    });\n  }\n}\n\nconst tracing = new TracingService();\n\n// Usage in API calls\nasync function fetchUserData(userId: string) {\n  const spanId = tracing.startSpan('fetchUserData');\n  \n  try {\n    const data = await apiClient.get(`/users/${userId}`);\n    tracing.endSpan(spanId, { success: true, userId });\n    return data;\n  } catch (error) {\n    tracing.endSpan(spanId, { success: false, error: error.message });\n    throw error;\n  }\n}\n\n// 8. Multi-tenant support\nclass TenantContext {\n  private static currentTenant: string | null = null;\n  \n  static setTenant(tenantId: string) {\n    this.currentTenant = tenantId;\n  }\n  \n  static getTenant(): string | null {\n    return this.currentTenant;\n  }\n  \n  static clearTenant() {\n    this.currentTenant = null;\n  }\n}\n\n// Tenant-aware API client\nclass TenantApiClient extends ApiClient {\n  async get<T>(url: string, config?: AxiosRequestConfig): Promise<T> {\n    const tenantId = TenantContext.getTenant();\n    if (tenantId) {\n      config = {\n        ...config,\n        headers: {\n          ...config?.headers,\n          'X-Tenant-ID': tenantId\n        }\n      };\n    }\n    return super.get(url, config);\n  }\n}"
    },
    {
      "id": 98,
      "question": "What is React Native Migration Strategy from Legacy Apps?",
      "answer": "Migrating from legacy native apps to React Native requires a strategic, incremental approach to minimize risk and maintain app functionality.\n\nMigration Approaches:\n• Brownfield integration (gradual)\n• Greenfield rewrite (complete)\n• Hybrid approach (phased)\n• Feature-by-feature migration\n• Screen-by-screen migration\n\nBrownfield Strategy:\n• Integrate React Native into existing app\n• Start with low-risk screens\n• Native bridge communication\n• Shared data layer\n• Gradual team transition\n• Parallel development\n• Feature flags for rollback\n\nChallenges:\n• Code duplication during transition\n• Build complexity\n• Team training\n• Performance considerations\n• Navigation integration\n• State management sync\n• Third-party library compatibility\n\nBest Practices:\n• Start with isolated features\n• Establish bridge patterns\n• Maintain native expertise\n• Comprehensive testing\n• Performance monitoring\n• Gradual user rollout\n• Rollback plans",
      "explanation": "React Native migration uses brownfield integration to gradually replace native screens, starting with low-risk features, using native bridges for communication, and maintaining parallel codebases during transition.",
      "difficulty": "Hard",
      "code": "// 1. iOS Brownfield Integration\n// AppDelegate.m (Objective-C)\n/*\n#import <React/RCTBundleURLProvider.h>\n#import <React/RCTRootView.h>\n\n@implementation AppDelegate\n\n- (BOOL)application:(UIApplication *)application\n    didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n  \n  // Initialize React Native bridge\n  NSURL *jsCodeLocation = [[RCTBundleURLProvider sharedSettings]\n                           jsBundleURLForBundleRoot:@\"index\"\n                           fallbackResource:nil];\n  \n  // Store bridge for later use\n  self.bridge = [[RCTBridge alloc] initWithBundleURL:jsCodeLocation\n                                       moduleProvider:nil\n                                        launchOptions:launchOptions];\n  \n  return YES;\n}\n\n// Method to present React Native screen\n- (void)presentReactNativeScreen:(NSString *)moduleName\n                      withProps:(NSDictionary *)props {\n  RCTRootView *rootView = [[RCTRootView alloc] initWithBridge:self.bridge\n                                                    moduleName:moduleName\n                                             initialProperties:props];\n  \n  UIViewController *vc = [[UIViewController alloc] init];\n  vc.view = rootView;\n  \n  [self.window.rootViewController presentViewController:vc\n                                               animated:YES\n                                             completion:nil];\n}\n\n@end\n*/\n\n// Native Swift code to launch React Native\n/*\nimport React\n\nclass ProfileViewController: UIViewController {\n    \n    func openReactNativeProfile() {\n        let appDelegate = UIApplication.shared.delegate as! AppDelegate\n        \n        let props: [String: Any] = [\n            \"userId\": \"12345\",\n            \"showEdit\": true\n        ]\n        \n        appDelegate.presentReactNativeScreen(\"Profile\", withProps: props)\n    }\n}\n*/\n\n// 2. Android Brownfield Integration\n// MainActivity.java\n/*\nimport com.facebook.react.ReactActivity;\nimport com.facebook.react.ReactActivityDelegate;\nimport com.facebook.react.ReactRootView;\nimport com.facebook.react.modules.core.DefaultHardwareBackBtnHandler;\n\npublic class MainActivity extends AppCompatActivity \n        implements DefaultHardwareBackBtnHandler {\n    \n    private ReactRootView mReactRootView;\n    private ReactInstanceManager mReactInstanceManager;\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        \n        // Initialize React Native\n        mReactRootView = new ReactRootView(this);\n        mReactInstanceManager = ReactInstanceManager.builder()\n            .setApplication(getApplication())\n            .setCurrentActivity(this)\n            .setBundleAssetName(\"index.android.bundle\")\n            .setJSMainModulePath(\"index\")\n            .addPackages(new MainReactPackage())\n            .setUseDeveloperSupport(BuildConfig.DEBUG)\n            .setInitialLifecycleState(LifecycleState.RESUMED)\n            .build();\n    }\n    \n    // Method to show React Native screen\n    public void showReactScreen(String moduleName, Bundle launchOptions) {\n        mReactRootView.startReactApplication(\n            mReactInstanceManager,\n            moduleName,\n            launchOptions\n        );\n        \n        setContentView(mReactRootView);\n    }\n}\n*/\n\n// Launching from native Android\n/*\npublic class ProductActivity extends AppCompatActivity {\n    \n    private void openReactNativeProduct(String productId) {\n        Intent intent = new Intent(this, ReactActivity.class);\n        \n        Bundle bundle = new Bundle();\n        bundle.putString(\"productId\", productId);\n        bundle.putBoolean(\"showReviews\", true);\n        \n        intent.putExtra(\"initialProps\", bundle);\n        intent.putExtra(\"moduleName\", \"ProductDetails\");\n        \n        startActivity(intent);\n    }\n}\n*/\n\n// 3. Native Module Bridge\n// iOS Native Module (Objective-C)\n/*\n// UserDataModule.m\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(UserDataModule, NSObject)\n\nRCT_EXTERN_METHOD(getUserData:(NSString *)userId\n                  resolver:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n\nRCT_EXTERN_METHOD(updateUserData:(NSDictionary *)userData\n                  resolver:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n\n@end\n*/\n\n// UserDataModule.swift\n/*\nimport Foundation\nimport React\n\n@objc(UserDataModule)\nclass UserDataModule: NSObject {\n  \n  @objc\n  func getUserData(_ userId: String,\n                   resolver: @escaping RCTPromiseResolveBlock,\n                   rejecter: @escaping RCTPromiseRejectBlock) {\n    \n    // Call existing native SDK\n    NativeUserSDK.shared.fetchUser(userId) { user, error in\n      if let error = error {\n        rejecter(\"ERROR\", error.localizedDescription, error)\n      } else if let user = user {\n        let userData: [String: Any] = [\n          \"id\": user.id,\n          \"name\": user.name,\n          \"email\": user.email\n        ]\n        resolver(userData)\n      }\n    }\n  }\n  \n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return false\n  }\n}\n*/\n\n// React Native side\nimport { NativeModules } from 'react-native';\n\nconst { UserDataModule } = NativeModules;\n\ninterface UserData {\n  id: string;\n  name: string;\n  email: string;\n}\n\nexport class NativeUserService {\n  static async getUserData(userId: string): Promise<UserData> {\n    return UserDataModule.getUserData(userId);\n  }\n  \n  static async updateUserData(userData: Partial<UserData>): Promise<void> {\n    return UserDataModule.updateUserData(userData);\n  }\n}\n\n// Usage in React Native\nfunction ProfileScreen({ userId }: { userId: string }) {\n  const [user, setUser] = useState<UserData | null>(null);\n  \n  useEffect(() => {\n    NativeUserService.getUserData(userId)\n      .then(setUser)\n      .catch(console.error);\n  }, [userId]);\n  \n  return user ? <Profile data={user} /> : <Loading />;\n}\n\n// 4. Navigation Integration\n// Hybrid navigation using react-native-navigation\nimport { Navigation } from 'react-native-navigation';\n\n// Register React Native screens\nNavigation.registerComponent('Profile', () => ProfileScreen);\nNavigation.registerComponent('Settings', () => SettingsScreen);\n\n// Push React Native screen from native\n/*\n// iOS\nlet options = RNNNavigationOptions()\noptions.topBar?.title?.text = \"Profile\"\n\nlet componentId = \"uniqueId\"\nNavigation.push(componentId, component: RNNComponentOptions(\n    name: \"Profile\",\n    passProps: [\"userId\": \"12345\"]\n))\n\n// Android\nNavigationOptions options = new NavigationOptions();\noptions.topBar.title.text = new Text(\"Profile\");\n\nComponentOptions component = new ComponentOptions();\ncomponent.name = new Text(\"Profile\");\ncomponent.passProps = new JSONObject().put(\"userId\", \"12345\");\n\nNavigation.push(componentId, component);\n*/\n\n// 5. Shared Data Layer\n// Using native persistence that both sides can access\nclass SharedPreferences {\n  // iOS: UserDefaults, Android: SharedPreferences\n  static async getString(key: string): Promise<string | null> {\n    if (Platform.OS === 'ios') {\n      return NativeModules.SharedPreferences.getString(key);\n    } else {\n      return NativeModules.SharedPreferences.getString(key);\n    }\n  }\n  \n  static async setString(key: string, value: string): Promise<void> {\n    if (Platform.OS === 'ios') {\n      return NativeModules.SharedPreferences.setString(key, value);\n    } else {\n      return NativeModules.SharedPreferences.setString(key, value);\n    }\n  }\n}\n\n// 6. Gradual Screen Migration\n// Migration tracker\nconst MIGRATED_SCREENS = {\n  profile: true,       // Migrated to React Native\n  settings: true,      // Migrated to React Native\n  home: false,         // Still native\n  checkout: false      // Still native\n};\n\nfunction shouldUseLegacyScreen(screenName: string): boolean {\n  return !MIGRATED_SCREENS[screenName];\n}\n\n// Router that decides native vs RN\nclass HybridRouter {\n  static navigate(screen: string, params?: any) {\n    if (shouldUseLegacyScreen(screen)) {\n      // Use native navigation\n      NativeModules.NavigationModule.navigate(screen, params);\n    } else {\n      // Use React Native navigation\n      Navigation.push('mainStack', {\n        component: { name: screen, passProps: params }\n      });\n    }\n  }\n}\n\n// 7. Feature flag for gradual rollout\nclass MigrationFeatureFlags {\n  static async shouldUseReactNativeScreen(\n    screenName: string,\n    userId: string\n  ): Promise<boolean> {\n    // Check if user is in rollout group\n    const rolloutPercentage = await this.getRolloutPercentage(screenName);\n    const userHash = this.hashUserId(userId);\n    \n    return (userHash % 100) < rolloutPercentage;\n  }\n  \n  private static async getRolloutPercentage(screenName: string): Promise<number> {\n    // Fetch from remote config\n    const config = await remoteConfig().getValue(`migration_${screenName}`);\n    return parseInt(config.asString(), 10);\n  }\n  \n  private static hashUserId(userId: string): number {\n    let hash = 0;\n    for (let i = 0; i < userId.length; i++) {\n      hash = ((hash << 5) - hash) + userId.charCodeAt(i);\n      hash |= 0;\n    }\n    return Math.abs(hash);\n  }\n}\n\n// Usage\nasync function navigateToProfile(userId: string) {\n  const useReactNative = await MigrationFeatureFlags\n    .shouldUseReactNativeScreen('profile', userId);\n  \n  if (useReactNative) {\n    Navigation.push('mainStack', {\n      component: { name: 'Profile', passProps: { userId } }\n    });\n  } else {\n    NativeModules.NavigationModule.navigate('Profile', { userId });\n  }\n}"
    },
    {
      "id": 99,
      "question": "What are React Native Performance Monitoring and Analytics Best Practices?",
      "answer": "Comprehensive monitoring and analytics ensure app quality, identify issues early, and provide insights for optimization.\n\nMonitoring Tools:\n• Firebase Performance Monitoring\n• Sentry for error tracking\n• New Relic\n• Datadog\n• React Native Performance Monitor\n• Flipper\n• Reactotron\n\nKey Metrics:\n• App start time (cold/warm)\n• Screen render time\n• API response time\n• Frame rate (FPS)\n• Memory usage\n• Battery consumption\n• Network usage\n• Crash rate\n• ANR (Application Not Responding)\n\nAnalytics Tracking:\n• User behavior flows\n• Feature adoption\n• Conversion funnels\n• User retention\n• Session duration\n• Error rates by screen\n• Custom events\n\nBest Practices:\n• Set performance budgets\n• Monitor in production\n• Track by device/OS\n• Alert on degradation\n• A/B test performance\n• Correlate with user impact\n• Regular performance reviews",
      "explanation": "React Native performance monitoring uses Firebase Performance, Sentry, and custom metrics to track app start time, render performance, crashes, user flows, and business metrics for continuous optimization.",
      "difficulty": "Hard",
      "code": "// 1. Firebase Performance Monitoring setup\nimport perf, { FirebasePerformanceTypes } from '@react-native-firebase/perf';\n\nclass PerformanceMonitoring {\n  // Screen performance\n  static async monitorScreen(screenName: string, renderFn: () => Promise<void>) {\n    const trace = await perf().startTrace(`screen_${screenName}`);\n    trace.putAttribute('screen_name', screenName);\n    \n    try {\n      await renderFn();\n    } finally {\n      await trace.stop();\n    }\n  }\n  \n  // API call performance\n  static async monitorApiCall<T>(\n    endpoint: string,\n    apiCall: () => Promise<T>\n  ): Promise<T> {\n    const trace = await perf().startTrace(`api_${endpoint}`);\n    const startTime = Date.now();\n    \n    try {\n      const result = await apiCall();\n      const duration = Date.now() - startTime;\n      \n      trace.putMetric('duration_ms', duration);\n      trace.putAttribute('endpoint', endpoint);\n      trace.putAttribute('status', 'success');\n      \n      return result;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      trace.putMetric('duration_ms', duration);\n      trace.putAttribute('status', 'error');\n      trace.putAttribute('error_message', error.message);\n      \n      throw error;\n    } finally {\n      await trace.stop();\n    }\n  }\n  \n  // Custom metrics\n  static async trackCustomMetric(\n    metricName: string,\n    value: number,\n    attributes?: Record<string, string>\n  ) {\n    const trace = await perf().startTrace(metricName);\n    trace.putMetric('value', value);\n    \n    if (attributes) {\n      Object.entries(attributes).forEach(([key, val]) => {\n        trace.putAttribute(key, val);\n      });\n    }\n    \n    await trace.stop();\n  }\n}\n\n// Usage\nfunction HomeScreen() {\n  useEffect(() => {\n    PerformanceMonitoring.monitorScreen('Home', async () => {\n      await loadData();\n    });\n  }, []);\n  \n  const fetchProducts = async () => {\n    return PerformanceMonitoring.monitorApiCall(\n      '/products',\n      () => api.getProducts()\n    );\n  };\n  \n  return <ProductList onLoadMore={fetchProducts} />;\n}\n\n// 2. Sentry Integration for Error Tracking\nimport * as Sentry from '@sentry/react-native';\n\nSentry.init({\n  dsn: Config.SENTRY_DSN,\n  environment: Config.ENVIRONMENT,\n  tracesSampleRate: 1.0,\n  enableAutoSessionTracking: true,\n  sessionTrackingIntervalMillis: 30000,\n  beforeSend(event, hint) {\n    // Filter out known issues\n    if (event.exception?.values?.[0]?.value?.includes('Network request failed')) {\n      return null;\n    }\n    return event;\n  }\n});\n\n// Add user context\nSentry.setUser({\n  id: user.id,\n  email: user.email,\n  username: user.username\n});\n\n// Add custom context\nSentry.setContext('device', {\n  model: DeviceInfo.getModel(),\n  os: Platform.OS,\n  osVersion: Platform.Version,\n  appVersion: DeviceInfo.getVersion()\n});\n\n// Breadcrumbs for debugging\nSentry.addBreadcrumb({\n  category: 'navigation',\n  message: 'Navigated to ProductDetails',\n  level: 'info',\n  data: { productId: '123' }\n});\n\n// Manual error capture\ntry {\n  processPayment();\n} catch (error) {\n  Sentry.captureException(error, {\n    tags: {\n      feature: 'checkout',\n      payment_method: 'credit_card'\n    },\n    extra: {\n      orderId: order.id,\n      amount: order.total\n    }\n  });\n}\n\n// 3. Custom Performance Hooks\nfunction usePerformanceTrace(traceName: string) {\n  const traceRef = useRef<FirebasePerformanceTypes.Trace | null>(null);\n  \n  useEffect(() => {\n    let trace: FirebasePerformanceTypes.Trace;\n    \n    perf()\n      .startTrace(traceName)\n      .then((t) => {\n        trace = t;\n        traceRef.current = t;\n      });\n    \n    return () => {\n      trace?.stop();\n    };\n  }, [traceName]);\n  \n  const addMetric = useCallback((name: string, value: number) => {\n    traceRef.current?.putMetric(name, value);\n  }, []);\n  \n  const addAttribute = useCallback((key: string, value: string) => {\n    traceRef.current?.putAttribute(key, value);\n  }, []);\n  \n  return { addMetric, addAttribute };\n}\n\n// Usage\nfunction ProductList() {\n  const { addMetric, addAttribute } = usePerformanceTrace('product_list_render');\n  \n  useEffect(() => {\n    addMetric('item_count', products.length);\n    addAttribute('category', currentCategory);\n  }, [products, currentCategory]);\n  \n  return <FlatList data={products} renderItem={renderProduct} />;\n}\n\n// 4. App Start Time Measurement\nclass AppStartMetrics {\n  private static appStartTime: number;\n  private static jsLoadTime: number;\n  \n  static markAppStart() {\n    this.appStartTime = Date.now();\n  }\n  \n  static markJSLoad() {\n    this.jsLoadTime = Date.now();\n  }\n  \n  static async reportAppStart() {\n    const appReadyTime = Date.now();\n    const totalStartTime = appReadyTime - this.appStartTime;\n    const jsLoadDuration = this.jsLoadTime - this.appStartTime;\n    \n    await PerformanceMonitoring.trackCustomMetric('app_start_time', totalStartTime, {\n      platform: Platform.OS,\n      js_load_time: jsLoadDuration.toString()\n    });\n    \n    analytics().logEvent('app_start', {\n      total_time: totalStartTime,\n      js_load_time: jsLoadDuration\n    });\n  }\n}\n\n// In index.js\nAppStartMetrics.markAppStart();\n\n// After JS loads\nAppStartMetrics.markJSLoad();\n\n// After app is ready\nuseEffect(() => {\n  AppStartMetrics.reportAppStart();\n}, []);\n\n// 5. React Native Performance Monitor\nimport { InteractionManager } from 'react-native';\n\nclass RenderPerformance {\n  static measureRender(\n    componentName: string,\n    callback: () => void\n  ) {\n    const startMark = `${componentName}_render_start`;\n    const endMark = `${componentName}_render_end`;\n    \n    performance.mark(startMark);\n    \n    callback();\n    \n    InteractionManager.runAfterInteractions(() => {\n      performance.mark(endMark);\n      performance.measure(\n        `${componentName}_render`,\n        startMark,\n        endMark\n      );\n      \n      const measure = performance.getEntriesByName(`${componentName}_render`)[0];\n      \n      if (measure.duration > 16) { // More than one frame (60fps)\n        console.warn(`Slow render: ${componentName} took ${measure.duration}ms`);\n        \n        analytics().logEvent('slow_render', {\n          component: componentName,\n          duration: measure.duration\n        });\n      }\n    });\n  }\n}\n\n// Usage\nfunction HeavyComponent() {\n  useEffect(() => {\n    RenderPerformance.measureRender('HeavyComponent', () => {\n      // Component rendering\n    });\n  }, []);\n  \n  return <View>...</View>;\n}\n\n// 6. Memory Monitoring\nimport { NativeModules } from 'react-native';\n\nclass MemoryMonitor {\n  private static interval: NodeJS.Timer | null = null;\n  \n  static start() {\n    this.interval = setInterval(() => {\n      this.checkMemory();\n    }, 60000); // Every minute\n  }\n  \n  static stop() {\n    if (this.interval) {\n      clearInterval(this.interval);\n      this.interval = null;\n    }\n  }\n  \n  private static async checkMemory() {\n    if (Platform.OS === 'ios') {\n      const memory = await NativeModules.MemoryModule.getMemoryUsage();\n      \n      analytics().logEvent('memory_usage', {\n        used_mb: memory.used / 1024 / 1024,\n        available_mb: memory.available / 1024 / 1024\n      });\n      \n      if (memory.used > 500 * 1024 * 1024) { // 500MB\n        console.warn('High memory usage detected');\n        Sentry.captureMessage('High memory usage', {\n          level: 'warning',\n          extra: { memory }\n        });\n      }\n    }\n  }\n}\n\n// Start monitoring\nMemoryMonitor.start();\n\n// 7. Analytics Best Practices\nclass Analytics {\n  static trackScreen(screenName: string, properties?: Record<string, any>) {\n    analytics().logScreenView({\n      screen_name: screenName,\n      screen_class: screenName,\n      ...properties\n    });\n  }\n  \n  static trackEvent(\n    eventName: string,\n    properties?: Record<string, any>\n  ) {\n    analytics().logEvent(eventName, {\n      timestamp: Date.now(),\n      platform: Platform.OS,\n      app_version: DeviceInfo.getVersion(),\n      ...properties\n    });\n  }\n  \n  static trackUserAction(\n    action: string,\n    target: string,\n    properties?: Record<string, any>\n  ) {\n    this.trackEvent('user_action', {\n      action,\n      target,\n      ...properties\n    });\n  }\n  \n  static trackError(\n    error: Error,\n    context?: Record<string, any>\n  ) {\n    this.trackEvent('error_occurred', {\n      error_message: error.message,\n      error_stack: error.stack,\n      ...context\n    });\n    \n    Sentry.captureException(error, { extra: context });\n  }\n}\n\n// Usage\nfunction ProductScreen({ productId }: { productId: string }) {\n  useEffect(() => {\n    Analytics.trackScreen('ProductDetails', { productId });\n  }, [productId]);\n  \n  const handleAddToCart = () => {\n    Analytics.trackUserAction('click', 'add_to_cart', {\n      product_id: productId\n    });\n    addToCart(productId);\n  };\n  \n  return (\n    <Button title=\"Add to Cart\" onPress={handleAddToCart} />\n  );\n}"
    },
    {
      "id": 100,
      "question": "What is the Complete React Native Development Lifecycle and Best Practices?",
      "answer": "The complete React Native development lifecycle encompasses planning, development, testing, deployment, and maintenance phases with established best practices at each stage.\n\nPlanning Phase:\n• Define requirements and scope\n• Choose architecture patterns\n• Select state management\n• Plan navigation structure\n• Design component hierarchy\n• Estimate timeline and resources\n\nDevelopment Phase:\n• Setup development environment\n• Configure TypeScript and ESLint\n• Implement component library\n• Build features incrementally\n• Code reviews and pair programming\n• Follow style guides\n• Write documentation\n\nTesting Phase:\n• Unit tests (Jest)\n• Integration tests\n• E2E tests (Detox)\n• Manual testing\n• Performance testing\n• Accessibility testing\n• Device compatibility testing\n\nDeployment Phase:\n• Configure CI/CD pipeline\n• Beta testing (TestFlight, Play Console)\n• App Store optimization\n• Staged rollouts\n• Monitor crashes and errors\n• Performance monitoring\n\nMaintenance Phase:\n• Bug fixes and patches\n• Feature enhancements\n• Library updates\n• Security patches\n• Performance optimization\n• User feedback incorporation",
      "explanation": "React Native development lifecycle includes planning with architecture decisions, development with TypeScript and testing, CI/CD deployment with staged rollouts, and ongoing maintenance with monitoring and optimization.",
      "difficulty": "Hard",
      "code": "// 1. Project Setup Checklist\n/*\n# Initialize project\nnpx react-native init MyApp --template react-native-template-typescript\n\n# Essential dependencies\nyarn add @react-navigation/native @react-navigation/native-stack\nyarn add react-native-reanimated react-native-gesture-handler\nyarn add @tanstack/react-query axios\nyarn add zustand\nyarn add react-native-config\nyarn add @react-native-firebase/app @react-native-firebase/analytics\n\n# Development dependencies\nyarn add -D @types/react @types/react-native\nyarn add -D @typescript-eslint/parser @typescript-eslint/eslint-plugin\nyarn add -D prettier eslint-config-prettier eslint-plugin-prettier\nyarn add -D jest @testing-library/react-native @testing-library/jest-native\nyarn add -D detox\n*/\n\n// 2. TypeScript Configuration\n// tsconfig.json\n/*\n{\n  \"compilerOptions\": {\n    \"target\": \"esnext\",\n    \"module\": \"commonjs\",\n    \"lib\": [\"es2019\", \"es2020.promise\", \"es2020.bigint\", \"es2020.string\"],\n    \"jsx\": \"react-native\",\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true,\n    \"moduleResolution\": \"node\",\n    \"allowSyntheticDefaultImports\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"baseUrl\": \"./src\",\n    \"paths\": {\n      \"@components/*\": [\"components/*\"],\n      \"@screens/*\": [\"screens/*\"],\n      \"@utils/*\": [\"utils/*\"],\n      \"@api/*\": [\"api/*\"],\n      \"@types/*\": [\"types/*\"]\n    }\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"**/*.spec.ts\"]\n}\n*/\n\n// 3. ESLint Configuration\n// .eslintrc.js\n/*\nmodule.exports = {\n  root: true,\n  extends: [\n    '@react-native-community',\n    'plugin:@typescript-eslint/recommended',\n    'plugin:prettier/recommended'\n  ],\n  parser: '@typescript-eslint/parser',\n  plugins: ['@typescript-eslint', 'react-hooks'],\n  rules: {\n    'react-hooks/rules-of-hooks': 'error',\n    'react-hooks/exhaustive-deps': 'warn',\n    '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }],\n    '@typescript-eslint/explicit-function-return-type': 'off',\n    'prettier/prettier': ['error', { endOfLine: 'auto' }]\n  }\n};\n*/\n\n// 4. Project Structure\n/*\nsrc/\n├── api/              # API clients and endpoints\n├── assets/           # Images, fonts, etc.\n├── components/       # Reusable components\n│   ├── Button/\n│   │   ├── Button.tsx\n│   │   ├── Button.test.tsx\n│   │   ├── Button.styles.ts\n│   │   └── index.ts\n├── features/         # Feature modules\n│   ├── auth/\n│   ├── products/\n│   └── cart/\n├── hooks/            # Custom hooks\n├── navigation/       # Navigation configuration\n├── screens/          # Screen components\n├── services/         # Business logic services\n├── store/            # State management\n├── types/            # TypeScript types\n├── utils/            # Utility functions\n├── constants/        # Constants\n├── theme/            # Theme configuration\n└── App.tsx\n*/\n\n// 5. CI/CD Pipeline (.github/workflows/ci.yml)\n/*\nname: CI/CD\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main, develop]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Setup Node\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'yarn'\n      \n      - name: Install dependencies\n        run: yarn install --frozen-lockfile\n      \n      - name: Run linter\n        run: yarn lint\n      \n      - name: Run tests\n        run: yarn test --coverage\n      \n      - name: Upload coverage\n        uses: codecov/codecov-action@v3\n\n  build-ios:\n    runs-on: macos-latest\n    needs: test\n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Setup Node\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'yarn'\n      \n      - name: Install dependencies\n        run: yarn install --frozen-lockfile\n      \n      - name: Install Pods\n        run: cd ios && pod install\n      \n      - name: Build iOS\n        run: |\n          xcodebuild -workspace ios/MyApp.xcworkspace \\\n            -scheme MyApp \\\n            -configuration Release \\\n            -sdk iphoneos \\\n            -derivedDataPath ios/build\n\n  build-android:\n    runs-on: ubuntu-latest\n    needs: test\n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Setup Java\n        uses: actions/setup-java@v3\n        with:\n          distribution: 'zulu'\n          java-version: '11'\n      \n      - name: Setup Node\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'yarn'\n      \n      - name: Install dependencies\n        run: yarn install --frozen-lockfile\n      \n      - name: Build Android\n        run: |\n          cd android\n          ./gradlew assembleRelease\n      \n      - name: Upload APK\n        uses: actions/upload-artifact@v3\n        with:\n          name: app-release\n          path: android/app/build/outputs/apk/release/app-release.apk\n*/\n\n// 6. App.tsx - Complete setup\nimport React, { useEffect, useState } from 'react';\nimport { NavigationContainer } from '@react-navigation/native';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { GestureHandlerRootView } from 'react-native-gesture-handler';\nimport SplashScreen from 'react-native-splash-screen';\nimport * as Sentry from '@sentry/react-native';\nimport Config from 'react-native-config';\nimport { RootNavigator } from './navigation';\nimport { ThemeProvider } from './theme';\nimport ErrorBoundary from './components/ErrorBoundary';\n\n// Initialize services\nSentry.init({\n  dsn: Config.SENTRY_DSN,\n  environment: Config.ENVIRONMENT,\n  tracesSampleRate: 1.0\n});\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      retry: 2,\n      staleTime: 5 * 60 * 1000,\n      cacheTime: 10 * 60 * 1000\n    }\n  }\n});\n\nfunction App() {\n  const [isReady, setIsReady] = useState(false);\n  \n  useEffect(() => {\n    async function initialize() {\n      try {\n        // Initialize app services\n        await Promise.all([\n          loadAssets(),\n          initializeAuth(),\n          loadPersistedState()\n        ]);\n      } catch (error) {\n        Sentry.captureException(error);\n      } finally {\n        setIsReady(true);\n        SplashScreen.hide();\n      }\n    }\n    \n    initialize();\n  }, []);\n  \n  if (!isReady) return null;\n  \n  return (\n    <ErrorBoundary>\n      <QueryClientProvider client={queryClient}>\n        <ThemeProvider>\n          <GestureHandlerRootView style={{ flex: 1 }}>\n            <NavigationContainer>\n              <RootNavigator />\n            </NavigationContainer>\n          </GestureHandlerRootView>\n        </ThemeProvider>\n      </QueryClientProvider>\n    </ErrorBoundary>\n  );\n}\n\nexport default Sentry.wrap(App);\n\n// 7. Pre-release Checklist\n/*\nBefore releasing:\n- [ ] All tests passing\n- [ ] No TypeScript errors\n- [ ] No ESLint warnings\n- [ ] Updated version numbers (iOS/Android)\n- [ ] Generated release notes\n- [ ] Updated app store metadata\n- [ ] Created release builds\n- [ ] Tested on real devices\n- [ ] Verified deep links\n- [ ] Tested offline scenarios\n- [ ] Verified analytics\n- [ ] Checked crash reporting\n- [ ] Reviewed permissions\n- [ ] App Store screenshots updated\n- [ ] Privacy policy updated\n- [ ] Terms of service updated\n*/\n\n// 8. Post-release Monitoring\nclass ReleaseMonitoring {\n  static async trackRelease() {\n    const version = DeviceInfo.getVersion();\n    const buildNumber = DeviceInfo.getBuildNumber();\n    \n    // Track successful app start\n    analytics().logEvent('app_start_success', {\n      version,\n      buildNumber,\n      platform: Platform.OS\n    });\n    \n    // Monitor crash rate\n    crashlytics().log(`App started: ${version} (${buildNumber})`);\n  }\n  \n  static setupCrashAlerts() {\n    // Configure alerts for crash rate > 1%\n    // Configure alerts for ANR rate > 0.5%\n    // Configure alerts for slow app starts\n  }\n}\n\nexport { ReleaseMonitoring };"
    }
  ]
}
