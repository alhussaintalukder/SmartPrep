{
  "topic": "React.js",
  "questions": [
    {
      "id": 1,
      "question": "What is React and what are its main features?",
      "answer": "React is a JavaScript library for building user interfaces, developed and maintained by Facebook. It focuses on creating reusable UI components.\n\nKey Features:\n• Component-Based Architecture: Build encapsulated components that manage their own state\n• Virtual DOM: Efficiently updates and renders components by maintaining a virtual representation\n• JSX Syntax: Write HTML-like code in JavaScript for better readability\n• Unidirectional Data Flow: Data flows from parent to child components\n• Declarative: Describe what the UI should look like, React handles the updates\n• React Hooks: Use state and lifecycle features in functional components\n• Rich Ecosystem: Large community with extensive libraries and tools",
      "explanation": "React is a component-based JavaScript library that uses virtual DOM for efficient UI rendering and provides a declarative approach to building interactive user interfaces.",
      "difficulty": "Easy",
      "code": "// Simple React Component Example\nimport React from 'react';\n\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}!</h1>;\n}\n\nexport default Welcome;"
    },
    {
      "id": 2,
      "question": "What is JSX and why is it used in React?",
      "answer": "JSX (JavaScript XML) is a syntax extension for JavaScript that allows you to write HTML-like code within JavaScript. It makes React code more readable and expressive.\n\nKey Characteristics:\n• Syntax Sugar: JSX is transpiled to regular JavaScript by tools like Babel\n• JavaScript Expressions: Can embed JavaScript expressions using curly braces {}\n• Element Creation: JSX creates React elements that represent DOM nodes\n• Type Safety: Helps catch errors at compile time\n• Component Composition: Makes it easier to visualize component structure\n\nBenefits:\n• Improved Readability: Code looks similar to the final UI structure\n• Prevents Injection Attacks: JSX escapes values by default\n• Faster Development: More intuitive than createElement calls",
      "explanation": "JSX is a syntax extension that allows writing HTML-like code in JavaScript, making React components more readable and easier to develop while providing compile-time error checking.",
      "difficulty": "Easy",
      "code": "// JSX Example\nconst element = <h1>Hello, World!</h1>;\n\n// JSX with expressions\nconst name = 'John';\nconst greeting = <h1>Hello, {name}!</h1>;\n\n// JSX transpiles to:\nconst element = React.createElement('h1', null, 'Hello, World!');\n\n// JSX with attributes and children\nconst card = (\n  <div className=\"card\">\n    <h2>{title}</h2>\n    <p>{description}</p>\n  </div>\n);"
    },
    {
      "id": 3,
      "question": "What is the Virtual DOM and how does it work?",
      "answer": "The Virtual DOM is a lightweight JavaScript representation of the actual DOM. React uses it to optimize UI updates by minimizing direct DOM manipulations.\n\nHow It Works:\n• Initial Render: React creates a virtual DOM tree representing the UI\n• State Changes: When state/props change, React creates a new virtual DOM tree\n• Diffing Algorithm: React compares the new virtual DOM with the previous one\n• Reconciliation: React calculates the minimum changes needed\n• Batch Updates: Changes are batched and applied to the real DOM efficiently\n• DOM Update: Only the changed elements are updated in the actual DOM\n\nBenefits:\n• Performance: Reduces expensive DOM operations\n• Cross-Platform: Enables React Native and other renderers\n• Predictability: Declarative approach makes updates predictable",
      "explanation": "Virtual DOM is a JavaScript representation of the real DOM that React uses to efficiently calculate and apply minimal updates by comparing old and new virtual trees before updating the actual DOM.",
      "difficulty": "Easy",
      "code": "// Virtual DOM Example (conceptual)\n// When state changes:\nconst oldVDOM = { type: 'div', props: { children: 'Count: 0' } };\nconst newVDOM = { type: 'div', props: { children: 'Count: 1' } };\n\n// React compares and updates only what changed\n// Instead of replacing the entire div, only text content updates\n\n// In practice:\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n  // Only the <p> text updates, not the entire component\n}"
    },
    {
      "id": 4,
      "question": "What are React components and what types exist?",
      "answer": "React components are independent, reusable pieces of UI that accept inputs (props) and return React elements describing what should appear on the screen.\n\nTypes of Components:\n• Functional Components: JavaScript functions that return JSX\n• Class Components: ES6 classes extending React.Component (legacy)\n• Pure Components: Optimize rendering by implementing shallow prop comparison\n• Higher-Order Components: Functions that take a component and return a new component\n• Controlled Components: Form inputs controlled by React state\n• Uncontrolled Components: Form inputs that maintain their own state\n\nFunctional vs Class:\n• Functional: Simpler syntax, use Hooks for state and lifecycle\n• Class: More verbose, use this.state and lifecycle methods\n• Modern React: Functional components with Hooks are preferred",
      "explanation": "React components are reusable UI building blocks that come in functional and class forms, with modern React favoring functional components using Hooks for state and lifecycle management.",
      "difficulty": "Easy",
      "code": "// Functional Component (Modern)\nfunction Greeting(props) {\n  return <h1>Hello, {props.name}!</h1>;\n}\n\n// Class Component (Legacy)\nclass Greeting extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}!</h1>;\n  }\n}\n\n// Functional Component with Hooks\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>+</button>\n    </div>\n  );\n}"
    },
    {
      "id": 5,
      "question": "What are props in React and how are they used?",
      "answer": "Props (properties) are read-only inputs passed from parent components to child components. They allow data to flow down the component tree.\n\nKey Characteristics:\n• Immutable: Props cannot be modified by the receiving component\n• Unidirectional: Data flows from parent to child only\n• Any Data Type: Can pass strings, numbers, objects, arrays, functions\n• Default Values: Can set default props using defaultProps\n• Prop Types: Can validate props using PropTypes or TypeScript\n\nCommon Use Cases:\n• Passing Data: Send data from parent to child\n• Configuration: Customize component behavior\n• Event Handlers: Pass callback functions to children\n• Composition: Build complex UIs from simple components",
      "explanation": "Props are immutable inputs passed from parent to child components that enable data flow and component customization in React's unidirectional data architecture.",
      "difficulty": "Easy",
      "code": "// Parent Component passing props\nfunction App() {\n  const user = { name: 'John', age: 30 };\n  \n  return (\n    <UserCard \n      name={user.name} \n      age={user.age}\n      onDelete={() => console.log('Delete user')}\n    />\n  );\n}\n\n// Child Component receiving props\nfunction UserCard(props) {\n  return (\n    <div>\n      <h2>{props.name}</h2>\n      <p>Age: {props.age}</p>\n      <button onClick={props.onDelete}>Delete</button>\n    </div>\n  );\n}\n\n// With destructuring\nfunction UserCard({ name, age, onDelete }) {\n  return (\n    <div>\n      <h2>{name}</h2>\n      <p>Age: {age}</p>\n      <button onClick={onDelete}>Delete</button>\n    </div>\n  );\n}"
    },
    {
      "id": 6,
      "question": "What is state in React and how is it different from props?",
      "answer": "State is a built-in object that stores component-specific data that can change over time. Unlike props, state is managed within the component.\n\nState Characteristics:\n• Mutable: Can be changed using setState or useState Hook\n• Local: Belongs to the component that defines it\n• Asynchronous Updates: State updates may be batched for performance\n• Triggers Re-render: Changing state causes component to re-render\n\nState vs Props:\n• State: Internal, mutable, managed by component itself\n• Props: External, immutable, passed from parent\n• State: Can be changed by the component\n• Props: Read-only, cannot be modified by child\n• State: Component's private data\n• Props: Component's configuration from parent",
      "explanation": "State is mutable data managed within a component that triggers re-renders when changed, while props are immutable inputs passed from parent components.",
      "difficulty": "Easy",
      "code": "// State with Hooks (Functional Component)\nimport { useState } from 'react';\n\nfunction Counter() {\n  // Declare state variable\n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\n// State vs Props Example\nfunction Parent() {\n  const [message, setMessage] = useState('Hello');\n  \n  return <Child text={message} />; // text is a prop\n}\n\nfunction Child({ text }) {\n  // text is a prop (immutable)\n  // Cannot do: text = 'New Value'; // Error!\n  return <p>{text}</p>;\n}"
    },
    {
      "id": 7,
      "question": "What is the useState Hook and how do you use it?",
      "answer": "useState is a React Hook that allows you to add state to functional components. It returns a state variable and a function to update it.\n\nKey Features:\n• Initialization: Accepts initial state value\n• Returns Array: Returns [stateValue, setStateFunction]\n• Multiple States: Can call useState multiple times\n• Lazy Initialization: Can pass a function for expensive initial state\n• Functional Updates: Update based on previous state\n• Preserves State: State persists between re-renders\n\nBest Practices:\n• Don't call inside loops or conditions\n• Name state and setter descriptively\n• Use functional updates for state based on previous value\n• Split related state into multiple useState calls",
      "explanation": "useState is a Hook that enables functional components to manage local state by returning a state variable and an updater function.",
      "difficulty": "Easy",
      "code": "import { useState } from 'react';\n\n// Basic usage\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <button onClick={() => setCount(count + 1)}>\n      Count: {count}\n    </button>\n  );\n}\n\n// Multiple state variables\nfunction Form() {\n  const [name, setName] = useState('');\n  const [email, setEmail] = useState('');\n  const [age, setAge] = useState(0);\n  \n  return (\n    <form>\n      <input value={name} onChange={(e) => setName(e.target.value)} />\n      <input value={email} onChange={(e) => setEmail(e.target.value)} />\n    </form>\n  );\n}\n\n// Functional update (important for async updates)\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  const increment = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n  \n  return <button onClick={increment}>Count: {count}</button>;\n}"
    },
    {
      "id": 8,
      "question": "What is the useEffect Hook and when should you use it?",
      "answer": "useEffect is a Hook that lets you perform side effects in functional components. It runs after render and can optionally clean up before the next effect or unmount.\n\nCommon Use Cases:\n• Data Fetching: API calls and data loading\n• Subscriptions: WebSocket connections, event listeners\n• DOM Manipulation: Direct DOM operations\n• Timers: setTimeout, setInterval\n• Logging: Analytics, debugging\n• Synchronization: Syncing with external systems\n\nDependency Array:\n• No array: Runs after every render\n• Empty array []: Runs once after initial render\n• With dependencies [a, b]: Runs when a or b changes\n\nCleanup Function:\n• Return function from useEffect to clean up\n• Runs before next effect and on unmount\n• Important for subscriptions and timers",
      "explanation": "useEffect is a Hook for handling side effects in functional components, running after render with optional cleanup and dependency-based execution control.",
      "difficulty": "Easy",
      "code": "import { useState, useEffect } from 'react';\n\n// Basic data fetching\nfunction UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n  \n  useEffect(() => {\n    fetch(`/api/users/${userId}`)\n      .then(res => res.json())\n      .then(data => setUser(data));\n  }, [userId]); // Re-run when userId changes\n  \n  return user ? <div>{user.name}</div> : <div>Loading...</div>;\n}\n\n// With cleanup\nfunction Timer() {\n  const [seconds, setSeconds] = useState(0);\n  \n  useEffect(() => {\n    const interval = setInterval(() => {\n      setSeconds(s => s + 1);\n    }, 1000);\n    \n    // Cleanup function\n    return () => clearInterval(interval);\n  }, []); // Run once on mount\n  \n  return <div>Seconds: {seconds}</div>;\n}\n\n// Multiple effects\nfunction Component() {\n  useEffect(() => {\n    // Effect 1: Document title\n    document.title = 'My App';\n  }, []);\n  \n  useEffect(() => {\n    // Effect 2: Event listener\n    const handler = () => console.log('Resize');\n    window.addEventListener('resize', handler);\n    return () => window.removeEventListener('resize', handler);\n  }, []);\n}"
    },
    {
      "id": 9,
      "question": "What are keys in React and why are they important?",
      "answer": "Keys are special string attributes used to identify elements in lists. They help React identify which items have changed, been added, or removed.\n\nWhy Keys Matter:\n• Efficient Updates: React can reorder elements without recreating them\n• Component Identity: Preserve component state between renders\n• Performance: Avoid unnecessary re-renders of list items\n• Prevent Bugs: Ensure correct element updates in dynamic lists\n\nKey Requirements:\n• Unique: Must be unique among siblings\n• Stable: Should not change between renders\n• Predictable: Same item should have same key\n\nBad Practices:\n• Using array index as key for dynamic lists\n• Generating random keys on each render\n• Using non-unique values",
      "explanation": "Keys are unique identifiers for list elements that help React efficiently track, update, and reorder items while maintaining component state and performance.",
      "difficulty": "Easy",
      "code": "// Good: Using unique ID as key\nfunction TodoList({ todos }) {\n  return (\n    <ul>\n      {todos.map(todo => (\n        <li key={todo.id}>{todo.text}</li>\n      ))}\n    </ul>\n  );\n}\n\n// Bad: Using index as key (problematic for dynamic lists)\nfunction TodoList({ todos }) {\n  return (\n    <ul>\n      {todos.map((todo, index) => (\n        <li key={index}>{todo.text}</li> // Avoid this!\n      ))}\n    </ul>\n  );\n}\n\n// Example showing why keys matter\nconst todos = [\n  { id: 1, text: 'Learn React' },\n  { id: 2, text: 'Build App' }\n];\n\n// If you remove first item:\n// With proper keys: React removes correct element\n// With index keys: React may update wrong elements\n\n// Complex example with state\nfunction ItemList({ items }) {\n  return items.map(item => (\n    <Item key={item.id} data={item} /> // State preserved on reorder\n  ));\n}"
    },
    {
      "id": 10,
      "question": "What is event handling in React and how is it different from HTML?",
      "answer": "Event handling in React uses camelCase naming and passes functions as event handlers rather than strings.\n\nReact vs HTML Differences:\n• Naming: onClick vs onclick, onChange vs onchange\n• Handler Type: Function reference vs string\n• Preventing Default: Must call event.preventDefault() explicitly\n• Event Object: Synthetic event that wraps native event\n• this Binding: Need to bind this in class components\n\nSynthetic Events:\n• Cross-Browser: Consistent behavior across browsers\n• Pooled: Event objects are reused for performance\n• Same Interface: Same API as native events\n\nCommon Events:\n• onClick, onChange, onSubmit\n• onMouseEnter, onMouseLeave\n• onKeyDown, onKeyUp, onKeyPress\n• onFocus, onBlur",
      "explanation": "React event handling uses camelCase naming and function references with synthetic events that provide cross-browser consistency, differing from HTML's lowercase string-based approach.",
      "difficulty": "Medium",
      "code": "// React event handling\nfunction Button() {\n  const handleClick = (event) => {\n    event.preventDefault();\n    console.log('Button clicked!');\n  };\n  \n  return <button onClick={handleClick}>Click Me</button>;\n}\n\n// HTML event handling (for comparison)\n// <button onclick=\"handleClick()\">Click Me</button>\n\n// Event with parameters\nfunction TodoList() {\n  const handleDelete = (id) => {\n    console.log('Delete todo:', id);\n  };\n  \n  return (\n    <ul>\n      <li>\n        Todo 1\n        <button onClick={() => handleDelete(1)}>Delete</button>\n      </li>\n    </ul>\n  );\n}\n\n// Form events\nfunction Form() {\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    const formData = new FormData(e.target);\n    console.log(formData.get('username'));\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input name=\"username\" />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}"
    },
    {
      "id": 11,
      "question": "What is conditional rendering in React?",
      "answer": "Conditional rendering is the practice of rendering different UI elements or components based on certain conditions, similar to conditional statements in JavaScript.\n\nCommon Techniques:\n• if-else Statements: Use before return statement\n• Ternary Operator: Inline condition ? true : false\n• Logical AND (&&): Render element only if condition is true\n• Logical OR (||): Provide fallback value\n• Switch Statement: Multiple conditions\n• Immediately Invoked Function: Complex logic inline\n\nBest Practices:\n• Keep conditions simple and readable\n• Extract complex logic into variables\n• Use early returns for cleaner code\n• Avoid too many nested ternaries",
      "explanation": "Conditional rendering allows React components to display different content based on conditions using JavaScript operators like ternary, logical AND, or if-else statements.",
      "difficulty": "Easy",
      "code": "// Ternary operator\nfunction Greeting({ isLoggedIn }) {\n  return (\n    <div>\n      {isLoggedIn ? <h1>Welcome back!</h1> : <h1>Please sign in</h1>}\n    </div>\n  );\n}\n\n// Logical AND\nfunction Notifications({ count }) {\n  return (\n    <div>\n      {count > 0 && <span>You have {count} notifications</span>}\n    </div>\n  );\n}\n\n// if-else with early return\nfunction UserStatus({ user }) {\n  if (!user) {\n    return <div>Loading...</div>;\n  }\n  \n  if (user.isPremium) {\n    return <div>Premium User: {user.name}</div>;\n  }\n  \n  return <div>Regular User: {user.name}</div>;\n}\n\n// Element variable\nfunction LoginButton({ isLoggedIn, onLogin, onLogout }) {\n  let button;\n  \n  if (isLoggedIn) {\n    button = <button onClick={onLogout}>Logout</button>;\n  } else {\n    button = <button onClick={onLogin}>Login</button>;\n  }\n  \n  return <div>{button}</div>;\n}"
    },
    {
      "id": 12,
      "question": "What are controlled and uncontrolled components in React?",
      "answer": "Controlled and uncontrolled components refer to how form inputs manage their state.\n\nControlled Components:\n• State Managed by React: Form data handled by component state\n• Single Source of Truth: React state is the source of truth\n• Controlled Updates: Value and onChange handler linked\n• Validation: Easy to validate on every keystroke\n• Full Control: React controls the input value\n\nUncontrolled Components:\n• DOM Manages State: Form data handled by DOM itself\n• Refs for Access: Use refs to get current values\n• Less Code: No need for state and handlers\n• Integration: Easier to integrate with non-React code\n• Default Values: Use defaultValue instead of value\n\nWhen to Use:\n• Controlled: Most cases, validation, formatting\n• Uncontrolled: File inputs, integration with legacy code",
      "explanation": "Controlled components have their form data managed by React state with explicit handlers, while uncontrolled components let the DOM handle the data accessed via refs.",
      "difficulty": "Medium",
      "code": "// Controlled Component\nimport { useState } from 'react';\n\nfunction ControlledForm() {\n  const [name, setName] = useState('');\n  const [email, setEmail] = useState('');\n  \n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log({ name, email });\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        value={name}\n        onChange={(e) => setName(e.target.value)}\n        placeholder=\"Name\"\n      />\n      <input\n        value={email}\n        onChange={(e) => setEmail(e.target.value)}\n        placeholder=\"Email\"\n      />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n\n// Uncontrolled Component\nimport { useRef } from 'react';\n\nfunction UncontrolledForm() {\n  const nameRef = useRef();\n  const emailRef = useRef();\n  \n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log({\n      name: nameRef.current.value,\n      email: emailRef.current.value\n    });\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input ref={nameRef} defaultValue=\"John\" />\n      <input ref={emailRef} defaultValue=\"john@example.com\" />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}"
    },
    {
      "id": 13,
      "question": "What is lifting state up in React?",
      "answer": "Lifting state up is a pattern where shared state is moved to the closest common ancestor of components that need it, enabling data sharing between sibling components.\n\nWhen to Lift State:\n• Multiple Components Need Data: Several children need same state\n• Sibling Communication: Siblings need to share data\n• Data Synchronization: Keep multiple components in sync\n• Single Source of Truth: Avoid duplicate state\n\nImplementation Steps:\n• Identify shared state\n• Move state to common parent\n• Pass state down as props\n• Pass update functions as props\n• Children call functions to update parent state\n\nBenefits:\n• Single Source of Truth: State exists in one place\n• Easier Debugging: State flow is clear\n• Predictable: Data flows down, events flow up",
      "explanation": "Lifting state up moves shared state to a common parent component, allowing sibling components to share and synchronize data through props and callback functions.",
      "difficulty": "Medium",
      "code": "// Before: Separate state (out of sync)\nfunction TemperatureA() {\n  const [temp, setTemp] = useState(0);\n  return <input value={temp} onChange={(e) => setTemp(e.target.value)} />;\n}\n\nfunction TemperatureB() {\n  const [temp, setTemp] = useState(0);\n  return <input value={temp} onChange={(e) => setTemp(e.target.value)} />;\n}\n\n// After: Lifted state (synchronized)\nfunction TemperatureCalculator() {\n  const [temperature, setTemperature] = useState(0);\n  \n  return (\n    <div>\n      <TemperatureInput\n        scale=\"c\"\n        temperature={temperature}\n        onTemperatureChange={setTemperature}\n      />\n      <TemperatureInput\n        scale=\"f\"\n        temperature={temperature}\n        onTemperatureChange={setTemperature}\n      />\n      <BoilingVerdict celsius={temperature} />\n    </div>\n  );\n}\n\nfunction TemperatureInput({ scale, temperature, onTemperatureChange }) {\n  return (\n    <fieldset>\n      <legend>Enter temperature in {scale}:</legend>\n      <input\n        value={temperature}\n        onChange={(e) => onTemperatureChange(e.target.value)}\n      />\n    </fieldset>\n  );\n}"
    },
    {
      "id": 14,
      "question": "What is composition in React and how is it different from inheritance?",
      "answer": "Composition is the practice of combining simpler components to build complex ones. React recommends composition over inheritance for code reuse.\n\nComposition Techniques:\n• Props.children: Pass components as children\n• Props as Components: Pass components as props\n• Specialization: Generic components specialized via props\n• Container Components: Wrap other components\n• Render Props: Share code using props whose value is a function\n\nComposition vs Inheritance:\n• Composition: Flexible, loosely coupled, easier to maintain\n• Inheritance: Rigid, tightly coupled, harder to change\n• React Way: Use composition for all use cases\n• No extends: Rarely need to extend component classes\n\nBenefits:\n• Reusability: Components can be reused in different contexts\n• Flexibility: Easy to change and extend\n• Testability: Easier to test isolated components",
      "explanation": "Composition combines simple components to create complex UIs using props and children, providing more flexibility than inheritance for code reuse in React.",
      "difficulty": "Medium",
      "code": "// Using props.children\nfunction Dialog({ title, children }) {\n  return (\n    <div className=\"dialog\">\n      <h1>{title}</h1>\n      <div className=\"content\">\n        {children}\n      </div>\n    </div>\n  );\n}\n\nfunction WelcomeDialog() {\n  return (\n    <Dialog title=\"Welcome\">\n      <p>Thank you for visiting!</p>\n      <button>Get Started</button>\n    </Dialog>\n  );\n}\n\n// Specialization\nfunction Button({ variant = 'primary', children, ...props }) {\n  return (\n    <button className={`btn btn-${variant}`} {...props}>\n      {children}\n    </button>\n  );\n}\n\nfunction PrimaryButton(props) {\n  return <Button variant=\"primary\" {...props} />;\n}\n\nfunction DangerButton(props) {\n  return <Button variant=\"danger\" {...props} />;\n}\n\n// Container pattern\nfunction Card({ header, footer, children }) {\n  return (\n    <div className=\"card\">\n      {header && <div className=\"card-header\">{header}</div>}\n      <div className=\"card-body\">{children}</div>\n      {footer && <div className=\"card-footer\">{footer}</div>}\n    </div>\n  );\n}"
    },
    {
      "id": 15,
      "question": "What are React fragments and why are they useful?",
      "answer": "Fragments let you group multiple children without adding extra nodes to the DOM. They solve the problem of components needing to return multiple elements.\n\nSyntax Options:\n• Long Form: <React.Fragment>...</React.Fragment>\n• Short Syntax: <>...</>\n• With Key: <Fragment key={item.id}>...</Fragment>\n\nUse Cases:\n• Avoid Wrapper Divs: Return multiple elements without extra DOM nodes\n• Table Elements: Return valid table rows without wrapper\n• List Items: Group elements in lists\n• CSS Layout: Prevent breaking flexbox/grid layouts\n• Performance: Reduce DOM nodes\n\nBenefits:\n• Cleaner DOM: No unnecessary wrapper elements\n• Better Performance: Fewer DOM nodes\n• Valid HTML: Maintain proper HTML structure\n• Styling: Avoid CSS issues from wrapper divs",
      "explanation": "Fragments allow grouping multiple React elements without adding extra DOM nodes, keeping the HTML structure clean and avoiding wrapper div issues.",
      "difficulty": "Easy",
      "code": "// Without Fragment (adds extra div)\nfunction BadList() {\n  return (\n    <div> {/* Extra wrapper div */}\n      <li>Item 1</li>\n      <li>Item 2</li>\n    </div>\n  );\n}\n\n// With Fragment (no extra DOM node)\nfunction GoodList() {\n  return (\n    <>\n      <li>Item 1</li>\n      <li>Item 2</li>\n    </>\n  );\n}\n\n// Fragment with key (for lists)\nfunction Glossary({ items }) {\n  return (\n    <dl>\n      {items.map(item => (\n        <React.Fragment key={item.id}>\n          <dt>{item.term}</dt>\n          <dd>{item.description}</dd>\n        </React.Fragment>\n      ))}\n    </dl>\n  );\n}\n\n// Table example\nfunction TableRow() {\n  return (\n    <>\n      <td>Cell 1</td>\n      <td>Cell 2</td>\n      <td>Cell 3</td>\n    </>\n  );\n}\n\nfunction Table() {\n  return (\n    <table>\n      <tbody>\n        <tr>\n          <TableRow />\n        </tr>\n      </tbody>\n    </table>\n  );\n}"
    },
    {
      "id": 16,
      "question": "What is the useRef Hook and what are its use cases?",
      "answer": "useRef returns a mutable ref object whose .current property is initialized to the passed argument and persists for the component's lifetime.\n\nKey Characteristics:\n• Persistent: Value persists across re-renders\n• No Re-render: Changing .current doesn't trigger re-render\n• Mutable: Can be changed directly\n• Reference: Holds reference to any value\n\nCommon Use Cases:\n• DOM Access: Reference DOM elements directly\n• Previous Values: Store previous state or prop values\n• Timers: Store timer IDs for cleanup\n• Animation: Store animation frame IDs\n• Avoiding Re-renders: Store values without triggering updates\n• Instance Variables: Store any mutable value\n\nRef vs State:\n• Ref: Mutable, no re-render, synchronous\n• State: Immutable, triggers re-render, async updates",
      "explanation": "useRef creates a persistent mutable reference that survives re-renders without triggering updates, commonly used for DOM access and storing values between renders.",
      "difficulty": "Medium",
      "code": "import { useRef, useEffect, useState } from 'react';\n\n// DOM access\nfunction TextInput() {\n  const inputRef = useRef(null);\n  \n  const focusInput = () => {\n    inputRef.current.focus();\n  };\n  \n  return (\n    <div>\n      <input ref={inputRef} />\n      <button onClick={focusInput}>Focus Input</button>\n    </div>\n  );\n}\n\n// Store previous value\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const prevCountRef = useRef();\n  \n  useEffect(() => {\n    prevCountRef.current = count;\n  }, [count]);\n  \n  return (\n    <div>\n      <p>Current: {count}</p>\n      <p>Previous: {prevCountRef.current}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\n// Store timer ID\nfunction Timer() {\n  const [seconds, setSeconds] = useState(0);\n  const intervalRef = useRef();\n  \n  const start = () => {\n    intervalRef.current = setInterval(() => {\n      setSeconds(s => s + 1);\n    }, 1000);\n  };\n  \n  const stop = () => {\n    clearInterval(intervalRef.current);\n  };\n  \n  return (\n    <div>\n      <p>Seconds: {seconds}</p>\n      <button onClick={start}>Start</button>\n      <button onClick={stop}>Stop</button>\n    </div>\n  );\n}"
    },
    {
      "id": 17,
      "question": "What is the Context API and when should you use it?",
      "answer": "Context API provides a way to pass data through the component tree without manually passing props at every level. It's designed for global or widely-used data.\n\nCore Concepts:\n• Context Creation: React.createContext creates a context\n• Provider: Context.Provider supplies value to tree\n• Consumer: useContext Hook or Context.Consumer reads value\n• Default Value: Used when no Provider is above\n\nWhen to Use:\n• Theme: App-wide theme settings\n• Authentication: User login state and data\n• Language: Internationalization and localization\n• Settings: App-wide configuration\n• Avoid Prop Drilling: Data needed by many components\n\nWhen NOT to Use:\n• Frequently Changing Data: Performance issues\n• Local State: State used by few components\n• Complex State Logic: Use state management library instead",
      "explanation": "Context API enables passing data through the component tree without prop drilling, ideal for global data like themes and authentication but not for frequently changing values.",
      "difficulty": "Medium",
      "code": "import { createContext, useContext, useState } from 'react';\n\n// Create context\nconst ThemeContext = createContext('light');\n\n// Provider component\nfunction App() {\n  const [theme, setTheme] = useState('light');\n  \n  return (\n    <ThemeContext.Provider value={{ theme, setTheme }}>\n      <Toolbar />\n    </ThemeContext.Provider>\n  );\n}\n\n// Consumer component (using Hook)\nfunction ThemedButton() {\n  const { theme, setTheme } = useContext(ThemeContext);\n  \n  return (\n    <button\n      style={{ background: theme === 'dark' ? '#333' : '#FFF' }}\n      onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}\n    >\n      Toggle Theme\n    </button>\n  );\n}\n\n// Auth context example\nconst AuthContext = createContext(null);\n\nfunction AuthProvider({ children }) {\n  const [user, setUser] = useState(null);\n  \n  const login = (userData) => setUser(userData);\n  const logout = () => setUser(null);\n  \n  return (\n    <AuthContext.Provider value={{ user, login, logout }}>\n      {children}\n    </AuthContext.Provider>\n  );\n}\n\nfunction useAuth() {\n  return useContext(AuthContext);\n}"
    },
    {
      "id": 18,
      "question": "What are Higher-Order Components (HOCs) in React?",
      "answer": "A Higher-Order Component is a function that takes a component and returns a new enhanced component. It's a pattern for reusing component logic.\n\nKey Characteristics:\n• Pure Function: Doesn't modify input component\n• Composition: Wraps component with additional functionality\n• Props Proxy: Can manipulate props\n• Convention: Name starts with 'with' (e.g., withAuth)\n\nCommon Use Cases:\n• Authentication: Check if user is logged in\n• Loading States: Add loading indicator\n• Error Handling: Wrap components with error boundaries\n• Data Fetching: Inject data from API\n• Analytics: Track component usage\n• Props Manipulation: Transform or add props\n\nModern Alternative:\n• Hooks are now preferred over HOCs\n• Custom Hooks provide similar functionality\n• Hooks are simpler and avoid wrapper hell",
      "explanation": "HOCs are functions that enhance components by wrapping them with additional functionality, though custom Hooks are now the preferred pattern for logic reuse.",
      "difficulty": "Medium",
      "code": "// Basic HOC\nfunction withLoading(Component) {\n  return function WithLoadingComponent({ isLoading, ...props }) {\n    if (isLoading) return <div>Loading...</div>;\n    return <Component {...props} />;\n  };\n}\n\nconst UserListWithLoading = withLoading(UserList);\n\n// HOC with arguments\nfunction withAuth(requiredRole) {\n  return function(Component) {\n    return function WithAuthComponent(props) {\n      const { user } = useAuth();\n      \n      if (!user) return <Navigate to=\"/login\" />;\n      if (user.role !== requiredRole) return <div>Access Denied</div>;\n      \n      return <Component {...props} />;\n    };\n  };\n}\n\nconst AdminPanel = withAuth('admin')(Dashboard);\n\n// Multiple HOCs (composition)\nconst EnhancedComponent = withAuth('user')(\n  withLoading(\n    withErrorBoundary(MyComponent)\n  )\n);\n\n// Modern alternative with custom Hook\nfunction useAuth(requiredRole) {\n  const { user } = useContext(AuthContext);\n  \n  if (!user) return { authorized: false, redirect: '/login' };\n  if (user.role !== requiredRole) return { authorized: false };\n  \n  return { authorized: true, user };\n}\n\nfunction AdminPanel() {\n  const { authorized, redirect } = useAuth('admin');\n  \n  if (!authorized && redirect) return <Navigate to={redirect} />;\n  if (!authorized) return <div>Access Denied</div>;\n  \n  return <Dashboard />;\n}"
    },
    {
      "id": 19,
      "question": "What are render props in React?",
      "answer": "Render props is a pattern where a component's prop is a function that returns React elements, enabling code sharing between components.\n\nKey Concepts:\n• Function as Prop: Pass a function that returns JSX\n• Inversion of Control: Child decides what to render\n• Flexibility: Highly customizable rendering\n• Code Reuse: Share logic without HOCs\n\nCommon Names:\n• render: Traditional name for the prop\n• children: Can use children as render prop\n• Custom names: Any prop name can be render prop\n\nUse Cases:\n• Mouse Tracking: Share mouse position\n• Data Fetching: Share fetched data and loading state\n• Toggle Logic: Share open/close state\n• Animation: Share animation values\n\nModern Alternative:\n• Custom Hooks are now preferred\n• Simpler and more composable",
      "explanation": "Render props is a pattern using a function prop to share component logic, allowing flexible rendering while maintaining separation of concerns, though Hooks are now preferred.",
      "difficulty": "Medium",
      "code": "// Basic render prop\nfunction MouseTracker({ render }) {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n  \n  const handleMouseMove = (e) => {\n    setPosition({ x: e.clientX, y: e.clientY });\n  };\n  \n  return (\n    <div onMouseMove={handleMouseMove}>\n      {render(position)}\n    </div>\n  );\n}\n\n// Usage\nfunction App() {\n  return (\n    <MouseTracker\n      render={({ x, y }) => (\n        <h1>Mouse position: {x}, {y}</h1>\n      )}\n    />\n  );\n}\n\n// Using children as render prop\nfunction Toggle({ children }) {\n  const [on, setOn] = useState(false);\n  const toggle = () => setOn(!on);\n  \n  return children({ on, toggle });\n}\n\nfunction App() {\n  return (\n    <Toggle>\n      {({ on, toggle }) => (\n        <div>\n          <button onClick={toggle}>Toggle</button>\n          {on && <p>Content is visible!</p>}\n        </div>\n      )}\n    </Toggle>\n  );\n}\n\n// Modern alternative with custom Hook\nfunction useMousePosition() {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n  \n  useEffect(() => {\n    const handleMove = (e) => {\n      setPosition({ x: e.clientX, y: e.clientY });\n    };\n    window.addEventListener('mousemove', handleMove);\n    return () => window.removeEventListener('mousemove', handleMove);\n  }, []);\n  \n  return position;\n}\n\nfunction App() {\n  const { x, y } = useMousePosition();\n  return <h1>Mouse: {x}, {y}</h1>;\n}"
    },
    {
      "id": 20,
      "question": "What is React Router and how does it work?",
      "answer": "React Router is a standard library for routing in React applications. It enables navigation between views, URL management, and nested routing.\n\nCore Components:\n• BrowserRouter: Uses HTML5 history API\n• Routes: Container for Route components\n• Route: Defines path and element to render\n• Link: Navigation component (replaces <a>)\n• Navigate: Programmatic navigation\n• Outlet: Renders child routes\n\nKey Features:\n• Dynamic Routing: Routes determined at render time\n• Nested Routes: Routes within routes\n• URL Parameters: Dynamic route segments\n• Query Strings: Parse URL query parameters\n• Protected Routes: Conditional rendering based on auth\n• Code Splitting: Lazy load route components\n\nRouter Types:\n• BrowserRouter: Clean URLs (/about)\n• HashRouter: URLs with hash (#/about)",
      "explanation": "React Router enables client-side routing with dynamic navigation, nested routes, and URL management using declarative components instead of page reloads.",
      "difficulty": "Medium",
      "code": "import { BrowserRouter, Routes, Route, Link, useParams } from 'react-router-dom';\n\n// Basic routing\nfunction App() {\n  return (\n    <BrowserRouter>\n      <nav>\n        <Link to=\"/\">Home</Link>\n        <Link to=\"/about\">About</Link>\n        <Link to=\"/users\">Users</Link>\n      </nav>\n      \n      <Routes>\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/about\" element={<About />} />\n        <Route path=\"/users\" element={<Users />} />\n        <Route path=\"/users/:id\" element={<UserDetail />} />\n        <Route path=\"*\" element={<NotFound />} />\n      </Routes>\n    </BrowserRouter>\n  );\n}\n\n// URL parameters\nfunction UserDetail() {\n  const { id } = useParams();\n  return <h1>User ID: {id}</h1>;\n}\n\n// Nested routes\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<Layout />}>\n        <Route index element={<Home />} />\n        <Route path=\"about\" element={<About />} />\n        <Route path=\"users\" element={<Users />} />\n      </Route>\n    </Routes>\n  );\n}\n\nfunction Layout() {\n  return (\n    <div>\n      <nav>Navigation</nav>\n      <Outlet /> {/* Child routes render here */}\n    </div>\n  );\n}\n\n// Protected route\nfunction ProtectedRoute({ children }) {\n  const { user } = useAuth();\n  \n  if (!user) {\n    return <Navigate to=\"/login\" />;\n  }\n  \n  return children;\n}"
    },
    {
      "id": 21,
      "question": "What is the useReducer Hook and when should you use it?",
      "answer": "useReducer is a Hook for managing complex state logic through a reducer function. It's an alternative to useState for more complex state updates.\n\nCore Concepts:\n• Reducer Function: (state, action) => newState\n• Dispatch: Function to send actions to reducer\n• Actions: Objects describing what happened\n• State Transitions: Predictable state changes\n\nWhen to Use:\n• Complex State Logic: Multiple sub-values or complex updates\n• State Depends on Previous: Next state depends on previous\n• Related State Updates: Multiple state values change together\n• Testing: Easier to test reducer function\n• Performance: Avoid passing callbacks down deeply\n\nuseReducer vs useState:\n• useReducer: Complex state logic, multiple related values\n• useState: Simple independent state values",
      "explanation": "useReducer manages complex state through a reducer function that handles actions, providing predictable state updates ideal for intricate state logic and related values.",
      "difficulty": "Medium",
      "code": "import { useReducer } from 'react';\n\n// Reducer function\nfunction counterReducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return { count: state.count + 1 };\n    case 'decrement':\n      return { count: state.count - 1 };\n    case 'reset':\n      return { count: 0 };\n    default:\n      return state;\n  }\n}\n\n// Using useReducer\nfunction Counter() {\n  const [state, dispatch] = useReducer(counterReducer, { count: 0 });\n  \n  return (\n    <div>\n      <p>Count: {state.count}</p>\n      <button onClick={() => dispatch({ type: 'increment' })}>+</button>\n      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>\n      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>\n    </div>\n  );\n}\n\n// Complex example: Todo list\nfunction todoReducer(state, action) {\n  switch (action.type) {\n    case 'add':\n      return [...state, { id: Date.now(), text: action.text, done: false }];\n    case 'toggle':\n      return state.map(todo =>\n        todo.id === action.id ? { ...todo, done: !todo.done } : todo\n      );\n    case 'delete':\n      return state.filter(todo => todo.id !== action.id);\n    default:\n      return state;\n  }\n}\n\nfunction TodoList() {\n  const [todos, dispatch] = useReducer(todoReducer, []);\n  \n  return (\n    <div>\n      {todos.map(todo => (\n        <div key={todo.id}>\n          <span style={{ textDecoration: todo.done ? 'line-through' : 'none' }}>\n            {todo.text}\n          </span>\n          <button onClick={() => dispatch({ type: 'toggle', id: todo.id })}>\n            Toggle\n          </button>\n          <button onClick={() => dispatch({ type: 'delete', id: todo.id })}>\n            Delete\n          </button>\n        </div>\n      ))}\n    </div>\n  );\n}"
    },
    {
      "id": 22,
      "question": "What is the useCallback Hook and why is it used?",
      "answer": "useCallback returns a memoized callback function that only changes if dependencies change. It's used to optimize performance by preventing unnecessary re-renders.\n\nKey Characteristics:\n• Memoization: Caches function between renders\n• Dependency Array: Function recreated only when dependencies change\n• Reference Equality: Returns same function reference\n• Performance: Prevents child re-renders\n\nWhen to Use:\n• Passing to Memoized Components: Child uses React.memo\n• Dependency of useEffect: Function used in effect dependencies\n• Props for Child Components: Avoid unnecessary re-renders\n• Event Handlers: Expensive child components\n\nWhen NOT to Use:\n• Simple Components: Overhead not worth it\n• No Performance Issue: Premature optimization\n• Functions Not Passed Down: Local functions that aren't props",
      "explanation": "useCallback memoizes callback functions to maintain reference equality across renders, preventing unnecessary child re-renders when passed as props to optimized components.",
      "difficulty": "Medium",
      "code": "import { useState, useCallback, memo } from 'react';\n\n// Without useCallback (Child re-renders on every parent render)\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  const [other, setOther] = useState(0);\n  \n  // New function created on every render\n  const handleClick = () => {\n    console.log('Clicked');\n  };\n  \n  return (\n    <div>\n      <button onClick={() => setOther(other + 1)}>Other: {other}</button>\n      <Child onClick={handleClick} /> {/* Re-renders even when count doesn't change */}\n    </div>\n  );\n}\n\n// With useCallback (Child only re-renders when dependencies change)\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  const [other, setOther] = useState(0);\n  \n  // Function memoized, same reference unless count changes\n  const handleClick = useCallback(() => {\n    console.log('Count:', count);\n  }, [count]);\n  \n  return (\n    <div>\n      <button onClick={() => setOther(other + 1)}>Other: {other}</button>\n      <Child onClick={handleClick} /> {/* No re-render when other changes */}\n    </div>\n  );\n}\n\n// Memoized child component\nconst Child = memo(({ onClick }) => {\n  console.log('Child rendered');\n  return <button onClick={onClick}>Click Me</button>;\n});\n\n// With useEffect dependency\nfunction SearchComponent() {\n  const [query, setQuery] = useState('');\n  \n  const fetchResults = useCallback(async () => {\n    const response = await fetch(`/api/search?q=${query}`);\n    const data = await response.json();\n    return data;\n  }, [query]);\n  \n  useEffect(() => {\n    fetchResults();\n  }, [fetchResults]); // Won't cause infinite loop\n  \n  return <input value={query} onChange={(e) => setQuery(e.target.value)} />;\n}"
    },
    {
      "id": 23,
      "question": "What is the useMemo Hook and how does it differ from useCallback?",
      "answer": "useMemo returns a memoized value that only recomputes when dependencies change. It's used to optimize expensive calculations.\n\nKey Characteristics:\n• Memoization: Caches computed value\n• Dependency Array: Recalculates only when dependencies change\n• Performance: Avoids expensive computations\n• Returns Value: Returns computed value (not function)\n\nuseMemo vs useCallback:\n• useMemo: Memoizes computed value, returns result\n• useCallback: Memoizes function, returns function\n• useMemo(() => fn, deps): Equivalent to useCallback(fn, deps)\n• Use Case: useMemo for expensive calculations, useCallback for functions\n\nWhen to Use:\n• Expensive Calculations: Complex computations\n• Derived State: Compute values from state\n• Referential Equality: Object/array props for memoized components\n• Filtering/Sorting: Large lists",
      "explanation": "useMemo memoizes computed values to avoid expensive recalculations, while useCallback memoizes functions; both maintain referential equality across renders when dependencies don't change.",
      "difficulty": "Medium",
      "code": "import { useState, useMemo, useCallback } from 'react';\n\n// useMemo example\nfunction ExpensiveComponent({ items }) {\n  // Without useMemo: Recalculates on every render\n  const total = items.reduce((sum, item) => sum + item.price, 0);\n  \n  // With useMemo: Recalculates only when items change\n  const total = useMemo(() => {\n    console.log('Calculating total...');\n    return items.reduce((sum, item) => sum + item.price, 0);\n  }, [items]);\n  \n  return <div>Total: ${total}</div>;\n}\n\n// useMemo vs useCallback comparison\nfunction Component() {\n  // useMemo returns the computed value\n  const expensiveValue = useMemo(() => {\n    return computeExpensiveValue();\n  }, [dependency]);\n  \n  // useCallback returns the function itself\n  const memoizedCallback = useCallback(() => {\n    doSomething();\n  }, [dependency]);\n  \n  // These are equivalent:\n  const memoizedFn1 = useCallback(() => doSomething(), []);\n  const memoizedFn2 = useMemo(() => () => doSomething(), []);\n}\n\n// Practical example: Filtering large list\nfunction UserList({ users, searchTerm }) {\n  const filteredUsers = useMemo(() => {\n    console.log('Filtering users...');\n    return users.filter(user =>\n      user.name.toLowerCase().includes(searchTerm.toLowerCase())\n    );\n  }, [users, searchTerm]);\n  \n  return (\n    <ul>\n      {filteredUsers.map(user => (\n        <li key={user.id}>{user.name}</li>\n      ))}\n    </ul>\n  );\n}\n\n// Memoizing object for React.memo\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  \n  // Without useMemo: New object on every render\n  const config = { theme: 'dark', lang: 'en' };\n  \n  // With useMemo: Same object reference\n  const config = useMemo(() => ({ theme: 'dark', lang: 'en' }), []);\n  \n  return <Child config={config} />;\n}"
    },
    {
      "id": 24,
      "question": "What is React.memo and when should you use it?",
      "answer": "React.memo is a higher-order component that memoizes a component, preventing re-renders if props haven't changed. It performs a shallow comparison of props.\n\nKey Features:\n• Shallow Comparison: Compares props by reference\n• Performance Optimization: Skips unnecessary renders\n• Custom Comparison: Can provide custom comparison function\n• Functional Components: Works with functional components only\n\nWhen to Use:\n• Pure Components: Component output depends only on props\n• Expensive Renders: Component is slow to render\n• Frequent Parent Renders: Parent re-renders often\n• Stable Props: Props don't change often\n\nWhen NOT to Use:\n• Props Change Often: No benefit from memoization\n• Simple Components: Overhead not worth it\n• Already Fast: No performance problem exists\n\nBest Practices:\n• Combine with useCallback and useMemo for props\n• Measure before optimizing\n• Use custom comparison for complex props",
      "explanation": "React.memo prevents component re-renders when props haven't changed through shallow comparison, optimizing performance for components with stable props or expensive rendering.",
      "difficulty": "Medium",
      "code": "import { memo, useState, useCallback } from 'react';\n\n// Without memo: Re-renders on every parent update\nfunction Child({ name, onClick }) {\n  console.log('Child rendered');\n  return <button onClick={onClick}>{name}</button>;\n}\n\n// With memo: Only re-renders when props change\nconst Child = memo(function Child({ name, onClick }) {\n  console.log('Child rendered');\n  return <button onClick={onClick}>{name}</button>;\n});\n\n// Parent component\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  const [name, setName] = useState('Click');\n  \n  // Must use useCallback to prevent Child re-render\n  const handleClick = useCallback(() => {\n    console.log('Clicked');\n  }, []);\n  \n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)}>Count: {count}</button>\n      <Child name={name} onClick={handleClick} />\n      {/* Child doesn't re-render when count changes */}\n    </div>\n  );\n}\n\n// Custom comparison function\nconst User = memo(\n  function User({ user, theme }) {\n    return <div style={{ color: theme }}>{user.name}</div>;\n  },\n  (prevProps, nextProps) => {\n    // Return true if passing same props (don't re-render)\n    // Return false if props changed (re-render)\n    return prevProps.user.id === nextProps.user.id &&\n           prevProps.theme === nextProps.theme;\n  }\n);\n\n// Complex example\nconst ExpensiveComponent = memo(function ExpensiveComponent({ data }) {\n  // Expensive calculations or rendering\n  const result = expensiveCalculation(data);\n  \n  return <div>{result}</div>;\n});"
    },
    {
      "id": 25,
      "question": "What are custom Hooks and how do you create them?",
      "answer": "Custom Hooks are JavaScript functions that use React Hooks and allow you to extract and reuse stateful logic between components.\n\nRules for Custom Hooks:\n• Name Convention: Must start with 'use' prefix\n• Composition: Can call other Hooks inside\n• Reusability: Share logic without changing component hierarchy\n• Isolation: Each call has isolated state\n\nBenefits:\n• Code Reuse: Share stateful logic across components\n• Separation of Concerns: Extract logic from UI\n• Testability: Test logic independently\n• Readability: Cleaner component code\n• Composition: Combine multiple Hooks\n\nCommon Patterns:\n• Data Fetching: useApi, useFetch\n• Form Handling: useForm, useInput\n• Local Storage: useLocalStorage\n• Window Size: useWindowSize\n• Previous Value: usePrevious",
      "explanation": "Custom Hooks are reusable functions starting with 'use' that encapsulate stateful logic using React Hooks, enabling code sharing across components without wrapper components.",
      "difficulty": "Medium",
      "code": "import { useState, useEffect } from 'react';\n\n// Simple custom Hook: useLocalStorage\nfunction useLocalStorage(key, initialValue) {\n  const [value, setValue] = useState(() => {\n    const stored = localStorage.getItem(key);\n    return stored ? JSON.parse(stored) : initialValue;\n  });\n  \n  useEffect(() => {\n    localStorage.setItem(key, JSON.stringify(value));\n  }, [key, value]);\n  \n  return [value, setValue];\n}\n\n// Usage\nfunction Component() {\n  const [name, setName] = useLocalStorage('name', '');\n  return <input value={name} onChange={(e) => setName(e.target.value)} />;\n}\n\n// Data fetching Hook\nfunction useFetch(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    setLoading(true);\n    fetch(url)\n      .then(res => res.json())\n      .then(data => {\n        setData(data);\n        setLoading(false);\n      })\n      .catch(err => {\n        setError(err);\n        setLoading(false);\n      });\n  }, [url]);\n  \n  return { data, loading, error };\n}\n\n// Usage\nfunction UserProfile({ userId }) {\n  const { data, loading, error } = useFetch(`/api/users/${userId}`);\n  \n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n  return <div>{data.name}</div>;\n}\n\n// Form handling Hook\nfunction useForm(initialValues) {\n  const [values, setValues] = useState(initialValues);\n  \n  const handleChange = (e) => {\n    setValues({\n      ...values,\n      [e.target.name]: e.target.value\n    });\n  };\n  \n  const reset = () => setValues(initialValues);\n  \n  return { values, handleChange, reset };\n}"
    },
    {
      "id": 26,
      "question": "What is React Strict Mode and why should you use it?",
      "answer": "React Strict Mode is a development tool that activates additional checks and warnings for its descendants, helping identify potential problems in an application.\n\nKey Features:\n• Double Rendering: Components render twice in development to detect side effects\n• Deprecated APIs: Warns about legacy APIs and patterns\n• Unsafe Lifecycles: Identifies problematic lifecycle methods\n• Legacy Context: Warns about legacy context API usage\n• Side Effect Detection: Helps find unexpected side effects\n\nActivated Checks:\n• Unsafe lifecycle methods detection\n• Legacy string ref API usage warning\n• Deprecated findDOMNode usage warning\n• Unexpected side effects detection\n• Legacy context API detection\n\nBenefits:\n• Early Problem Detection: Find issues during development\n• Future-Proof: Prepares app for React features\n• Best Practices: Encourages proper patterns\n• No Production Impact: Only runs in development mode",
      "explanation": "Strict Mode activates additional development checks including double rendering to detect side effects and warnings for deprecated APIs, helping catch potential problems early.",
      "difficulty": "Easy",
      "code": "import { StrictMode } from 'react';\nimport ReactDOM from 'react-dom/client';\n\n// Enable for entire app\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>\n);\n\n// Enable for specific components\nfunction App() {\n  return (\n    <div>\n      <Header />\n      <StrictMode>\n        <ComponentToCheck />\n        <AnotherComponent />\n      </StrictMode>\n      <Footer />\n    </div>\n  );\n}\n\n// Component that benefits from Strict Mode\nfunction ProblematicComponent() {\n  // Double render will help catch side effects\n  const [count, setCount] = useState(0);\n  \n  // This side effect will be caught\n  console.log('Component rendered'); // Logs twice in dev\n  \n  // Proper way: Side effects in useEffect\n  useEffect(() => {\n    console.log('Effect ran');\n  }, []);\n  \n  return <div>Count: {count}</div>;\n}\n\n// Strict Mode helps catch:\n// 1. Components with side effects in render\n// 2. Usage of deprecated lifecycle methods\n// 3. Legacy context API\n// 4. Unexpected behavior"
    },
    {
      "id": 27,
      "question": "What is the useLayoutEffect Hook and how is it different from useEffect?",
      "answer": "useLayoutEffect is similar to useEffect but fires synchronously after all DOM mutations and before the browser paints. It's used for DOM measurements and synchronous updates.\n\nKey Differences:\n• Timing: useLayoutEffect runs before paint, useEffect runs after paint\n• Synchronous: useLayoutEffect blocks painting, useEffect doesn't\n• Use Cases: DOM measurements vs side effects\n• Performance: useLayoutEffect can cause layout thrashing\n\nWhen to Use useLayoutEffect:\n• DOM Measurements: Read layout from DOM\n• Synchronous Updates: Prevent visual flicker\n• Tooltips: Position based on element size\n• Scroll Position: Restore scroll position\n• Animations: Measure before animating\n\nWhen to Use useEffect:\n• Data Fetching: API calls\n• Subscriptions: Event listeners\n• Logging: Analytics tracking\n• Most Cases: Default choice for side effects",
      "explanation": "useLayoutEffect fires synchronously after DOM mutations but before browser paint, used for DOM measurements and preventing flicker, while useEffect runs asynchronously after paint.",
      "difficulty": "Medium",
      "code": "import { useEffect, useLayoutEffect, useState, useRef } from 'react';\n\n// useLayoutEffect: Prevent flicker\nfunction Tooltip() {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n  const tooltipRef = useRef();\n  \n  useLayoutEffect(() => {\n    // Runs before paint, no flicker\n    const rect = tooltipRef.current.getBoundingClientRect();\n    if (rect.right > window.innerWidth) {\n      setPosition({ x: window.innerWidth - rect.width, y: rect.y });\n    }\n  }, []);\n  \n  return (\n    <div ref={tooltipRef} style={{ left: position.x, top: position.y }}>\n      Tooltip content\n    </div>\n  );\n}\n\n// Comparison: useEffect vs useLayoutEffect\nfunction Component() {\n  const [color, setColor] = useState('red');\n  \n  // useEffect: Runs after paint (might see flash)\n  useEffect(() => {\n    if (color === 'red') {\n      setColor('blue');\n    }\n  }, [color]);\n  \n  // useLayoutEffect: Runs before paint (no flash)\n  useLayoutEffect(() => {\n    if (color === 'red') {\n      setColor('blue');\n    }\n  }, [color]);\n  \n  return <div style={{ color }}>Text</div>;\n}\n\n// Measuring element size\nfunction MeasureExample() {\n  const [height, setHeight] = useState(0);\n  const divRef = useRef();\n  \n  useLayoutEffect(() => {\n    // Measure synchronously before paint\n    setHeight(divRef.current.offsetHeight);\n  }, []);\n  \n  return (\n    <div>\n      <div ref={divRef}>Content to measure</div>\n      <p>Height: {height}px</p>\n    </div>\n  );\n}\n\n// General rule:\n// Use useEffect by default\n// Use useLayoutEffect only when you need synchronous DOM access"
    },
    {
      "id": 28,
      "question": "What is prop drilling and how can you avoid it?",
      "answer": "Prop drilling is the process of passing props through multiple levels of components to reach a deeply nested child component, even when intermediate components don't need the props.\n\nProblems with Prop Drilling:\n• Maintenance: Hard to track prop usage\n• Refactoring: Changes affect many components\n• Readability: Clutters intermediate components\n• Performance: Unnecessary re-renders\n• Coupling: Creates tight coupling between components\n\nSolutions:\n• Context API: Share data without passing props\n• Component Composition: Use children prop\n• State Management: Redux, Zustand, Recoil\n• Custom Hooks: Encapsulate data access\n• Render Props: Flexible component composition\n\nBest Practices:\n• Use Context for global data\n• Use composition for UI patterns\n• Keep state close to where it's used\n• Evaluate if data truly needs to be global",
      "explanation": "Prop drilling passes data through many component layers unnecessarily, solved by Context API, composition patterns, or state management libraries for cleaner, maintainable code.",
      "difficulty": "Medium",
      "code": "// Problem: Prop Drilling\nfunction App() {\n  const [user, setUser] = useState({ name: 'John' });\n  return <Parent user={user} />;\n}\n\nfunction Parent({ user }) {\n  return <Child user={user} />; // Just passing through\n}\n\nfunction Child({ user }) {\n  return <GrandChild user={user} />; // Just passing through\n}\n\nfunction GrandChild({ user }) {\n  return <div>{user.name}</div>; // Finally uses it\n}\n\n// Solution 1: Context API\nconst UserContext = createContext();\n\nfunction App() {\n  const [user, setUser] = useState({ name: 'John' });\n  \n  return (\n    <UserContext.Provider value={user}>\n      <Parent />\n    </UserContext.Provider>\n  );\n}\n\nfunction Parent() {\n  return <Child />; // No props needed\n}\n\nfunction Child() {\n  return <GrandChild />; // No props needed\n}\n\nfunction GrandChild() {\n  const user = useContext(UserContext); // Direct access\n  return <div>{user.name}</div>;\n}\n\n// Solution 2: Component Composition\nfunction App() {\n  const [user, setUser] = useState({ name: 'John' });\n  \n  return (\n    <Parent>\n      <Child>\n        <GrandChild user={user} />\n      </Child>\n    </Parent>\n  );\n}\n\nfunction Parent({ children }) {\n  return <div>{children}</div>;\n}\n\nfunction Child({ children }) {\n  return <div>{children}</div>;\n}\n\n// Solution 3: Custom Hook\nfunction useUser() {\n  return useContext(UserContext);\n}\n\nfunction GrandChild() {\n  const user = useUser();\n  return <div>{user.name}</div>;\n}"
    },
    {
      "id": 29,
      "question": "What are Error Boundaries and how do they work?",
      "answer": "Error Boundaries are React components that catch JavaScript errors anywhere in their child component tree, log errors, and display a fallback UI instead of crashing the whole app.\n\nKey Features:\n• Catch Errors: Catches errors during rendering, lifecycle, and constructors\n• Fallback UI: Display alternative UI when error occurs\n• Error Logging: Log errors to error reporting services\n• Isolation: Prevent entire app crash\n• Class Component: Must be implemented as class component\n\nWhat They Catch:\n• Rendering errors\n• Lifecycle method errors\n• Constructor errors in child tree\n\nWhat They Don't Catch:\n• Event handlers (use try-catch)\n• Asynchronous code (setTimeout, promises)\n• Server-side rendering errors\n• Errors in Error Boundary itself\n\nBest Practices:\n• Wrap route components\n• Granular boundaries for better UX\n• Log errors to monitoring service",
      "explanation": "Error Boundaries catch errors in child component trees during rendering and lifecycle methods, displaying fallback UI to prevent app crashes while logging errors.",
      "difficulty": "Medium",
      "code": "import React from 'react';\n\n// Error Boundary Component (must be class component)\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n  \n  static getDerivedStateFromError(error) {\n    // Update state to show fallback UI\n    return { hasError: true };\n  }\n  \n  componentDidCatch(error, errorInfo) {\n    // Log error to error reporting service\n    console.error('Error caught:', error, errorInfo);\n    // logErrorToService(error, errorInfo);\n  }\n  \n  render() {\n    if (this.state.hasError) {\n      return (\n        <div>\n          <h1>Something went wrong.</h1>\n          <button onClick={() => this.setState({ hasError: false })}>\n            Try again\n          </button>\n        </div>\n      );\n    }\n    \n    return this.props.children;\n  }\n}\n\n// Usage\nfunction App() {\n  return (\n    <ErrorBoundary>\n      <Header />\n      <ErrorBoundary>\n        <MainContent /> {/* Isolated error boundary */}\n      </ErrorBoundary>\n      <Footer />\n    </ErrorBoundary>\n  );\n}\n\n// Component that might throw error\nfunction BuggyComponent({ user }) {\n  if (!user) {\n    throw new Error('User is required!');\n  }\n  return <div>{user.name}</div>;\n}\n\n// For event handlers (not caught by Error Boundary)\nfunction Component() {\n  const handleClick = () => {\n    try {\n      // Code that might throw\n      riskyOperation();\n    } catch (error) {\n      console.error('Error in event handler:', error);\n    }\n  };\n  \n  return <button onClick={handleClick}>Click</button>;\n}"
    },
    {
      "id": 30,
      "question": "What is reconciliation in React and how does it work?",
      "answer": "Reconciliation is the process React uses to diff the old and new virtual DOM trees to determine the minimal set of changes needed to update the real DOM.\n\nHow It Works:\n• Tree Comparison: React compares old and new virtual DOM trees\n• Element Type Check: Checks if element type changed\n• Attributes Comparison: Compares element attributes\n• Children Reconciliation: Recursively compares children\n• Key-Based Matching: Uses keys to identify elements in lists\n• Minimal Updates: Calculates minimum changes needed\n\nReconciliation Rules:\n• Different Types: React tears down old tree and builds new\n• Same Type: React keeps DOM node and updates attributes\n• Component Elements: Instance stays same, props update\n• Keys: Help identify which items changed, added, or removed\n\nOptimizations:\n• Component keys prevent unnecessary re-renders\n• shouldComponentUpdate or React.memo skip reconciliation\n• Batch updates improve performance",
      "explanation": "Reconciliation is React's diffing algorithm that compares virtual DOM trees to calculate minimal real DOM updates, using element types and keys for efficient updates.",
      "difficulty": "Medium",
      "code": "// Example 1: Element type changed (full re-render)\n// Before:\n<div>\n  <Counter />\n</div>\n\n// After:\n<span>\n  <Counter /> {/* Counter unmounts and remounts */}\n</span>\n\n// Example 2: Same type (update in place)\n// Before:\n<div className=\"before\" title=\"old\">\n  Content\n</div>\n\n// After:\n<div className=\"after\" title=\"new\">\n  Content\n</div>\n// React updates className and title attributes only\n\n// Example 3: List reconciliation without keys (inefficient)\nfunction TodoList() {\n  const [todos, setTodos] = useState(['A', 'B', 'C']);\n  \n  // Without keys: React might update all items\n  return (\n    <ul>\n      {todos.map((todo, index) => (\n        <li>{todo}</li> // No key\n      ))}\n    </ul>\n  );\n}\n\n// Example 4: List reconciliation with keys (efficient)\nfunction TodoList() {\n  const [todos, setTodos] = useState([\n    { id: 1, text: 'A' },\n    { id: 2, text: 'B' },\n    { id: 3, text: 'C' }\n  ]);\n  \n  // With keys: React knows which items changed\n  return (\n    <ul>\n      {todos.map(todo => (\n        <li key={todo.id}>{todo.text}</li>\n      ))}\n    </ul>\n  );\n  \n  // If we insert at beginning:\n  // [{ id: 0, text: 'New' }, { id: 1, text: 'A' }, ...]\n  // React knows to add one element, not update all\n}\n\n// Example 5: Optimizing reconciliation\nconst TodoItem = React.memo(function TodoItem({ todo }) {\n  // Only re-renders if todo prop changes\n  return <li>{todo.text}</li>;\n});"
    },
    {
      "id": 31,
      "question": "What is code splitting and lazy loading in React?",
      "answer": "Code splitting is the practice of splitting your app into smaller chunks that can be loaded on demand, reducing initial load time. Lazy loading loads components only when needed.\n\nKey Concepts:\n• Dynamic Imports: Import modules at runtime\n• React.lazy: Lazy load components\n• Suspense: Show fallback while loading\n• Route-Based Splitting: Split by routes\n• Component-Based Splitting: Split by features\n\nBenefits:\n• Faster Initial Load: Smaller bundle size\n• Better Performance: Load only what's needed\n• Improved UX: Faster time to interactive\n• Bandwidth Savings: Users download less code\n\nImplementation:\n• Use React.lazy for component imports\n• Wrap with Suspense for loading states\n• Split at route boundaries\n• Split large features and libraries",
      "explanation": "Code splitting divides your app into smaller chunks loaded on demand using React.lazy and Suspense, reducing initial bundle size and improving performance.",
      "difficulty": "Medium",
      "code": "import { lazy, Suspense } from 'react';\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\n\n// Lazy load components\nconst Home = lazy(() => import('./pages/Home'));\nconst About = lazy(() => import('./pages/About'));\nconst Dashboard = lazy(() => import('./pages/Dashboard'));\n\n// App with code splitting\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Suspense fallback={<div>Loading...</div>}>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/about\" element={<About />} />\n          <Route path=\"/dashboard\" element={<Dashboard />} />\n        </Routes>\n      </Suspense>\n    </BrowserRouter>\n  );\n}\n\n// Component-based splitting\nfunction Modal() {\n  const [showChart, setShowChart] = useState(false);\n  \n  // Only load chart when needed\n  const Chart = lazy(() => import('./Chart'));\n  \n  return (\n    <div>\n      <button onClick={() => setShowChart(true)}>Show Chart</button>\n      {showChart && (\n        <Suspense fallback={<div>Loading chart...</div>}>\n          <Chart />\n        </Suspense>\n      )}\n    </div>\n  );\n}\n\n// Named exports require wrapper\nconst MyComponent = lazy(() =>\n  import('./MyComponent').then(module => ({\n    default: module.MyComponent\n  }))\n);\n\n// Multiple suspense boundaries\nfunction App() {\n  return (\n    <div>\n      <Header />\n      <Suspense fallback={<div>Loading sidebar...</div>}>\n        <Sidebar />\n      </Suspense>\n      <Suspense fallback={<div>Loading content...</div>}>\n        <Content />\n      </Suspense>\n    </div>\n  );\n}\n\n// Error boundaries with lazy loading\nfunction App() {\n  return (\n    <ErrorBoundary>\n      <Suspense fallback={<Loading />}>\n        <LazyComponent />\n      </Suspense>\n    </ErrorBoundary>\n  );\n}"
    },
    {
      "id": 32,
      "question": "What is the useImperativeHandle Hook and when is it used?",
      "answer": "useImperativeHandle customizes the instance value exposed to parent components when using ref, allowing child components to expose specific methods to parents.\n\nKey Features:\n• Ref Customization: Control what parent can access\n• Imperative API: Expose specific methods\n• Encapsulation: Hide internal implementation\n• Used with forwardRef: Must wrap component\n\nWhen to Use:\n• Focus Management: Expose focus methods\n• Form Controls: Expose validation, reset methods\n• Media Controls: Expose play, pause, seek methods\n• Custom Inputs: Expose value access methods\n• Animation Control: Expose animation methods\n\nBest Practices:\n• Use sparingly: Prefer props when possible\n• Clear API: Expose only necessary methods\n• Documentation: Document exposed methods\n• Avoid overuse: Can make code harder to understand",
      "explanation": "useImperativeHandle customizes ref values exposed to parents, enabling controlled imperative APIs while maintaining encapsulation, used with forwardRef for component method exposure.",
      "difficulty": "Hard",
      "code": "import { useRef, useImperativeHandle, forwardRef } from 'react';\n\n// Custom input with exposed methods\nconst CustomInput = forwardRef((props, ref) => {\n  const inputRef = useRef();\n  \n  useImperativeHandle(ref, () => ({\n    // Only expose these methods to parent\n    focus: () => {\n      inputRef.current.focus();\n    },\n    clear: () => {\n      inputRef.current.value = '';\n    },\n    getValue: () => {\n      return inputRef.current.value;\n    }\n  }));\n  \n  return <input ref={inputRef} {...props} />;\n});\n\n// Parent using the custom input\nfunction Form() {\n  const inputRef = useRef();\n  \n  const handleSubmit = () => {\n    console.log(inputRef.current.getValue());\n    inputRef.current.clear();\n  };\n  \n  useEffect(() => {\n    inputRef.current.focus();\n  }, []);\n  \n  return (\n    <div>\n      <CustomInput ref={inputRef} />\n      <button onClick={handleSubmit}>Submit</button>\n    </div>\n  );\n}\n\n// Video player example\nconst VideoPlayer = forwardRef((props, ref) => {\n  const videoRef = useRef();\n  \n  useImperativeHandle(ref, () => ({\n    play: () => videoRef.current.play(),\n    pause: () => videoRef.current.pause(),\n    seek: (time) => {\n      videoRef.current.currentTime = time;\n    },\n    getCurrentTime: () => videoRef.current.currentTime\n  }));\n  \n  return <video ref={videoRef} src={props.src} />;\n});\n\nfunction App() {\n  const playerRef = useRef();\n  \n  return (\n    <div>\n      <VideoPlayer ref={playerRef} src=\"video.mp4\" />\n      <button onClick={() => playerRef.current.play()}>Play</button>\n      <button onClick={() => playerRef.current.pause()}>Pause</button>\n      <button onClick={() => playerRef.current.seek(10)}>Skip to 10s</button>\n    </div>\n  );\n}"
    },
    {
      "id": 33,
      "question": "What is the difference between server-side rendering (SSR) and client-side rendering (CSR)?",
      "answer": "Server-side rendering generates HTML on the server for each request, while client-side rendering generates HTML in the browser using JavaScript.\n\nServer-Side Rendering (SSR):\n• HTML Generated: Server generates full HTML\n• SEO Friendly: Search engines can crawl content\n• Faster First Paint: Content visible immediately\n• Server Load: Higher server resource usage\n• Frameworks: Next.js, Gatsby\n\nClient-Side Rendering (CSR):\n• JavaScript Required: Browser runs React to generate HTML\n• SEO Challenges: Requires additional configuration\n• Slower First Paint: Wait for JavaScript download and execution\n• Better Interactivity: Smooth transitions after initial load\n• Lower Server Load: Processing done on client\n\nHybrid Approach:\n• Static Generation: Pre-render at build time\n• Incremental Static Regeneration: Update static content\n• Hydration: SSR HTML then React takes over",
      "explanation": "SSR generates HTML on the server for better SEO and faster first paint, while CSR renders in the browser with JavaScript, offering better interactivity but slower initial load.",
      "difficulty": "Medium",
      "code": "// Client-Side Rendering (Create React App)\nimport ReactDOM from 'react-dom/client';\n\nfunction App() {\n  const [data, setData] = useState(null);\n  \n  useEffect(() => {\n    // Data fetched after component mounts\n    fetch('/api/data')\n      .then(res => res.json())\n      .then(setData);\n  }, []);\n  \n  return <div>{data ? data.title : 'Loading...'}</div>;\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<App />);\n\n// Server-Side Rendering (Next.js)\n// pages/index.js\nexport async function getServerSideProps() {\n  // Data fetched on server\n  const res = await fetch('https://api.example.com/data');\n  const data = await res.json();\n  \n  return {\n    props: { data }\n  };\n}\n\nfunction Page({ data }) {\n  // HTML already contains data\n  return <div>{data.title}</div>;\n}\n\nexport default Page;\n\n// Static Site Generation (Next.js)\nexport async function getStaticProps() {\n  // Data fetched at build time\n  const res = await fetch('https://api.example.com/data');\n  const data = await res.json();\n  \n  return {\n    props: { data },\n    revalidate: 60 // Regenerate every 60 seconds\n  };\n}\n\n// Hydration example\n// Server sends HTML:\n// <div id=\"root\"><div>Hello World</div></div>\n\n// Client hydrates:\nimport { hydrateRoot } from 'react-dom/client';\n\nfunction App() {\n  return <div>Hello World</div>;\n}\n\nhydrateRoot(document.getElementById('root'), <App />);\n// React attaches event handlers to existing HTML"
    },
    {
      "id": 34,
      "question": "What is React Fiber and how does it improve React performance?",
      "answer": "React Fiber is the reconciliation engine introduced in React 16. It's a complete rewrite of React's core algorithm that enables incremental rendering and better handling of updates.\n\nKey Features:\n• Incremental Rendering: Break work into chunks\n• Pause and Resume: Interrupt rendering if needed\n• Priority: Assign priority to different updates\n• Abort Work: Discard work if not needed\n• Reuse Work: Reuse previous work when possible\n• Multiple Renderers: Support different render targets\n\nBenefits:\n• Better Performance: Smooth animations and interactions\n• Time Slicing: Spread work over multiple frames\n• Suspense: Better loading state handling\n• Error Boundaries: Better error handling\n• Concurrent Features: Enable concurrent rendering\n\nKey Concepts:\n• Work Units: Rendering broken into units (fibers)\n• Two Phases: Render phase (interruptible) and commit phase (synchronous)\n• Priority Levels: High priority (user input) vs low priority (data updates)",
      "explanation": "React Fiber is the reconciliation engine that enables incremental rendering by breaking work into chunks, allowing React to pause, prioritize, and resume rendering for smoother performance.",
      "difficulty": "Hard",
      "code": "// React Fiber enables these features:\n\n// 1. Time Slicing - spread work over frames\nfunction HeavyComponent() {\n  // Fiber can pause rendering if frame budget exceeded\n  const items = Array.from({ length: 10000 }, (_, i) => i);\n  \n  return (\n    <div>\n      {items.map(i => <Item key={i} value={i} />)}\n    </div>\n  );\n}\n\n// 2. Suspense for data fetching\nfunction Profile() {\n  const user = use(fetchUser()); // Suspense integration\n  \n  return <div>{user.name}</div>;\n}\n\nfunction App() {\n  return (\n    <Suspense fallback={<Loading />}>\n      <Profile />\n    </Suspense>\n  );\n}\n\n// 3. Priority-based rendering\nfunction SearchComponent() {\n  const [query, setQuery] = useState('');\n  const [deferredQuery, setDeferredQuery] = useState('');\n  \n  const handleChange = (e) => {\n    // High priority: Update input immediately\n    setQuery(e.target.value);\n    \n    // Low priority: Update results with delay\n    startTransition(() => {\n      setDeferredQuery(e.target.value);\n    });\n  };\n  \n  return (\n    <div>\n      <input value={query} onChange={handleChange} />\n      <Results query={deferredQuery} />\n    </div>\n  );\n}\n\n// 4. Concurrent rendering\nimport { useTransition } from 'react';\n\nfunction TabContainer() {\n  const [isPending, startTransition] = useTransition();\n  const [tab, setTab] = useState('about');\n  \n  const selectTab = (nextTab) => {\n    startTransition(() => {\n      // This update is marked as low priority\n      setTab(nextTab);\n    });\n  };\n  \n  return (\n    <div>\n      <button onClick={() => selectTab('about')}>\n        About {isPending && '(Loading...)'}\n      </button>\n      <button onClick={() => selectTab('posts')}>\n        Posts\n      </button>\n      {tab === 'about' ? <About /> : <Posts />}\n    </div>\n  );\n}\n\n// Behind the scenes, Fiber maintains a tree structure:\n// Each component is a fiber node with:\n// - type: component type\n// - props: component props\n// - stateNode: DOM node or component instance\n// - alternate: previous version of fiber\n// - effectTag: what kind of work needed"
    },
    {
      "id": 35,
      "question": "What are portals in React and when should you use them?",
      "answer": "Portals provide a way to render children into a DOM node that exists outside the parent component's DOM hierarchy, useful for modals, tooltips, and overlays.\n\nKey Features:\n• Render Outside: Render into different DOM node\n• Event Bubbling: Events still bubble through React tree\n• Context Access: Child can access parent context\n• Positioning: Escape CSS overflow and z-index issues\n\nCommon Use Cases:\n• Modals and Dialogs: Render on top of everything\n• Tooltips: Avoid overflow issues\n• Dropdowns: Escape parent clipping\n• Popovers: Position relative to viewport\n• Notifications: Global notification system\n\nBenefits:\n• CSS Independence: Avoid parent styles affecting portal content\n• Stacking Context: Control z-index properly\n• Layout Freedom: Not constrained by parent positioning\n• React Features: Still get context, event bubbling",
      "explanation": "Portals render components outside their parent DOM hierarchy while maintaining React's event bubbling and context, ideal for modals, tooltips, and overlays escaping CSS constraints.",
      "difficulty": "Medium",
      "code": "import { createPortal } from 'react-dom';\nimport { useState } from 'react';\n\n// Basic Portal\nfunction Modal({ children, isOpen }) {\n  if (!isOpen) return null;\n  \n  // Render into body instead of parent component\n  return createPortal(\n    <div className=\"modal-overlay\">\n      <div className=\"modal-content\">\n        {children}\n      </div>\n    </div>,\n    document.body\n  );\n}\n\n// Usage\nfunction App() {\n  const [showModal, setShowModal] = useState(false);\n  \n  return (\n    <div className=\"app\">\n      <button onClick={() => setShowModal(true)}>Open Modal</button>\n      \n      <Modal isOpen={showModal}>\n        <h2>Modal Title</h2>\n        <p>Modal content</p>\n        <button onClick={() => setShowModal(false)}>Close</button>\n      </Modal>\n    </div>\n  );\n}\n\n// Portal with custom container\nfunction Tooltip({ children, content, targetRef }) {\n  // Create portal container\n  const [container] = useState(() => {\n    const div = document.createElement('div');\n    document.body.appendChild(div);\n    return div;\n  });\n  \n  // Clean up on unmount\n  useEffect(() => {\n    return () => container.remove();\n  }, [container]);\n  \n  return (\n    <>\n      {children}\n      {createPortal(\n        <div className=\"tooltip\">{content}</div>,\n        container\n      )}\n    </>\n  );\n}\n\n// Event bubbling through portals\nfunction Parent() {\n  const handleClick = () => {\n    console.log('Click bubbled to parent!');\n  };\n  \n  return (\n    <div onClick={handleClick}>\n      <Modal>\n        <button>Click me</button>\n        {/* Click event bubbles through portal to parent */}\n      </Modal>\n    </div>\n  );\n}\n\n// Portal with multiple root containers\nfunction NotificationSystem() {\n  return createPortal(\n    <div className=\"notifications\">\n      {notifications.map(n => (\n        <Notification key={n.id} {...n} />\n      ))}\n    </div>,\n    document.getElementById('notifications-root')\n  );\n}"
    },
    {
      "id": 36,
      "question": "What is the difference between useMemo, useCallback, and React.memo?",
      "answer": "These are React optimization techniques that prevent unnecessary computations and re-renders through memoization, but they serve different purposes.\n\nuseMemo:\n• Memoizes Values: Caches computed values\n• Returns Value: Returns the memoized value\n• Use For: Expensive calculations\n• Syntax: useMemo(() => computeValue(), [deps])\n\nuseCallback:\n• Memoizes Functions: Caches function references\n• Returns Function: Returns the memoized function\n• Use For: Callbacks passed to optimized components\n• Syntax: useCallback(() => doSomething(), [deps])\n\nReact.memo:\n• Memoizes Components: Prevents component re-renders\n• HOC: Wraps functional component\n• Use For: Components with expensive rendering\n• Syntax: const Memoized = memo(Component)\n\nWhen to Use Together:\n• React.memo + useCallback: Prevent child re-renders\n• useMemo for values, useCallback for functions",
      "explanation": "useMemo caches computed values, useCallback caches functions, and React.memo prevents component re-renders; they work together to optimize performance by maintaining referential equality.",
      "difficulty": "Medium",
      "code": "import { useMemo, useCallback, memo } from 'react';\n\n// Component optimization example\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  const [other, setOther] = useState(0);\n  \n  // useMemo: Cache expensive calculation\n  const expensiveValue = useMemo(() => {\n    console.log('Computing expensive value...');\n    return count * 2;\n  }, [count]); // Only recompute when count changes\n  \n  // useCallback: Cache function reference\n  const handleIncrement = useCallback(() => {\n    setCount(c => c + 1);\n  }, []); // Function never changes\n  \n  const handleWithCount = useCallback(() => {\n    console.log('Current count:', count);\n  }, [count]); // Function changes when count changes\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <p>Expensive Value: {expensiveValue}</p>\n      <button onClick={() => setOther(other + 1)}>Other: {other}</button>\n      <MemoizedChild onIncrement={handleIncrement} />\n    </div>\n  );\n}\n\n// React.memo: Prevent component re-render\nconst MemoizedChild = memo(function Child({ onIncrement }) {\n  console.log('Child rendered');\n  return <button onClick={onIncrement}>Increment</button>;\n});\n\n// Comparison of all three\nfunction App() {\n  const [count, setCount] = useState(0);\n  \n  // Without optimization\n  const value1 = count * 2; // Recalculated every render\n  const fn1 = () => console.log(count); // New function every render\n  const child1 = <Child value={value1} onClick={fn1} />; // Child re-renders always\n  \n  // With optimization\n  const value2 = useMemo(() => count * 2, [count]); // Cached value\n  const fn2 = useCallback(() => console.log(count), [count]); // Cached function\n  const child2 = <MemoizedChild value={value2} onClick={fn2} />; // Optimized renders\n  \n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)}>Count: {count}</button>\n      {child2}\n    </div>\n  );\n}\n\n// When NOT to use\nfunction SimpleComponent({ name }) {\n  // Don't do this - overhead not worth it for simple cases\n  const greeting = useMemo(() => `Hello ${name}`, [name]);\n  const handleClick = useCallback(() => console.log(name), [name]);\n  \n  // Just do this:\n  const greeting = `Hello ${name}`;\n  const handleClick = () => console.log(name);\n  \n  return <div>{greeting}</div>;\n}"
    },
    {
      "id": 37,
      "question": "What are React hooks rules and why are they important?",
      "answer": "React hooks have strict rules that must be followed to ensure they work correctly and maintain component state properly.\n\nTwo Main Rules:\n• Only Call at Top Level: Don't call hooks inside loops, conditions, or nested functions\n• Only Call in React Functions: Call hooks only in functional components or custom hooks\n\nWhy These Rules:\n• Hook Order: React relies on call order to track state\n• State Preservation: Ensure state persists between renders\n• Consistency: Hooks must be called in same order every render\n• Dependencies: Hook dependencies must be reliable\n\nESLint Plugin:\n• eslint-plugin-react-hooks: Enforces hook rules\n• Automatic Detection: Catches rule violations\n• Dependency Warnings: Suggests missing dependencies\n\nCommon Mistakes:\n• Conditional hooks\n• Hooks in loops\n• Hooks in regular JavaScript functions\n• Missing dependencies in arrays",
      "explanation": "React hooks must be called at the top level in the same order every render within React functions, enforced by ESLint to maintain state consistency and proper functionality.",
      "difficulty": "Medium",
      "code": "// WRONG: Conditional hook call\nfunction Component({ shouldLoad }) {\n  if (shouldLoad) {\n    const [data, setData] = useState(null); // ❌ Hook in condition\n  }\n  return <div>Component</div>;\n}\n\n// CORRECT: Hook at top level, condition inside\nfunction Component({ shouldLoad }) {\n  const [data, setData] = useState(null); // ✅ Hook at top level\n  \n  useEffect(() => {\n    if (shouldLoad) {\n      fetchData().then(setData);\n    }\n  }, [shouldLoad]);\n  \n  return <div>Component</div>;\n}\n\n// WRONG: Hook in loop\nfunction Component({ items }) {\n  return items.map(item => {\n    const [count, setCount] = useState(0); // ❌ Hook in loop\n    return <div>{count}</div>;\n  });\n}\n\n// CORRECT: Component with hook for each item\nfunction Item({ item }) {\n  const [count, setCount] = useState(0); // ✅ Hook in component\n  return <div>{count}</div>;\n}\n\nfunction Component({ items }) {\n  return items.map(item => <Item key={item.id} item={item} />);\n}\n\n// WRONG: Hook in regular function\nfunction useDataFetch() { // ❌ Not a React function (no 'use' convention)\n  const [data, setData] = useState(null);\n  return data;\n}\n\nfunction regularFunction() {\n  const data = useDataFetch(); // ❌ Hook in regular function\n}\n\n// CORRECT: Custom hook (starts with 'use')\nfunction useDataFetch() { // ✅ Custom hook\n  const [data, setData] = useState(null);\n  \n  useEffect(() => {\n    fetch('/api/data').then(res => res.json()).then(setData);\n  }, []);\n  \n  return data;\n}\n\nfunction Component() { // ✅ Called in React component\n  const data = useDataFetch();\n  return <div>{data}</div>;\n}\n\n// WRONG: Missing dependency\nfunction Component() {\n  const [count, setCount] = useState(0);\n  \n  useEffect(() => {\n    console.log(count);\n  }, []); // ❌ Missing 'count' dependency\n}\n\n// CORRECT: Include all dependencies\nfunction Component() {\n  const [count, setCount] = useState(0);\n  \n  useEffect(() => {\n    console.log(count);\n  }, [count]); // ✅ All dependencies included\n}"
    },
    {
      "id": 38,
      "question": "What is useDebugValue and when should you use it?",
      "answer": "useDebugValue is a Hook that lets you display a custom label for custom hooks in React DevTools, helping with debugging and development.\n\nKey Features:\n• DevTools Integration: Shows custom value in React DevTools\n• Custom Hooks Only: Only use in custom hooks, not components\n• Development Tool: Only affects development, not production\n• Formatting: Can provide format function for expensive values\n\nWhen to Use:\n• Shared Custom Hooks: Hooks used across multiple projects\n• Complex State: When internal state is hard to understand\n• Library Development: Building reusable hook libraries\n• Team Projects: Help other developers understand hook state\n\nBest Practices:\n• Use for shared hooks, not every hook\n• Keep labels concise and meaningful\n• Use format function for expensive calculations\n• Don't overuse - only when value adds clarity",
      "explanation": "useDebugValue displays custom labels for custom hooks in React DevTools, improving debugging experience by showing meaningful information about hook state during development.",
      "difficulty": "Easy",
      "code": "import { useDebugValue, useState, useEffect } from 'react';\n\n// Basic usage\nfunction useOnlineStatus() {\n  const [isOnline, setIsOnline] = useState(navigator.onLine);\n  \n  useEffect(() => {\n    const handleOnline = () => setIsOnline(true);\n    const handleOffline = () => setIsOnline(false);\n    \n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n    \n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, []);\n  \n  // Show \"Online\" or \"Offline\" in DevTools\n  useDebugValue(isOnline ? 'Online' : 'Offline');\n  \n  return isOnline;\n}\n\n// With format function (for expensive values)\nfunction useUser(userId) {\n  const [user, setUser] = useState(null);\n  \n  useEffect(() => {\n    fetch(`/api/users/${userId}`)\n      .then(res => res.json())\n      .then(setUser);\n  }, [userId]);\n  \n  // Format function only called when DevTools inspects\n  useDebugValue(user, (u) => {\n    return u ? `User: ${u.name} (${u.id})` : 'No user';\n  });\n  \n  return user;\n}\n\n// Complex example with multiple values\nfunction useAuth() {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  // Show comprehensive status in DevTools\n  useDebugValue(\n    loading ? 'Loading...' :\n    error ? `Error: ${error.message}` :\n    user ? `Authenticated: ${user.email}` :\n    'Not authenticated'\n  );\n  \n  return { user, loading, error };\n}\n\n// Using the hooks\nfunction Component() {\n  const isOnline = useOnlineStatus();\n  const user = useUser(123);\n  const auth = useAuth();\n  \n  // In React DevTools, you'll see:\n  // useOnlineStatus: \"Online\"\n  // useUser: \"User: John (123)\"\n  // useAuth: \"Authenticated: john@example.com\"\n  \n  return <div>Component</div>;\n}\n\n// Without useDebugValue\nfunction useCounter() {\n  const [count, setCount] = useState(0);\n  // DevTools shows: State: 0\n  return [count, setCount];\n}\n\n// With useDebugValue\nfunction useCounter() {\n  const [count, setCount] = useState(0);\n  useDebugValue(`Count: ${count}`);\n  // DevTools shows: useCounter: \"Count: 0\"\n  return [count, setCount];\n}"
    },
    {
      "id": 39,
      "question": "What is the useId Hook and what problem does it solve?",
      "answer": "useId generates unique IDs that are stable across server and client renders, solving hydration mismatch issues in server-side rendering.\n\nKey Features:\n• Unique IDs: Generates unique identifier\n• SSR Safe: Same ID on server and client\n• Hydration: Prevents hydration mismatches\n• No Collisions: IDs are guaranteed unique\n• Tree-Stable: IDs stay consistent in component tree\n\nProblems It Solves:\n• Accessibility: Generate unique IDs for ARIA attributes\n• Form Labels: Connect labels to inputs\n• SSR Hydration: Avoid server/client ID mismatches\n• Multiple Instances: Same component used multiple times\n\nWhen to Use:\n• Form Accessibility: htmlFor, aria-describedby\n• Multiple Instances: Component rendered multiple times\n• SSR Applications: Server-rendered React apps\n• Dynamic IDs: Need unique IDs without counting\n\nNot For:\n• List Keys: Use stable IDs from data instead\n• Database IDs: Use actual database identifiers",
      "explanation": "useId generates unique, stable IDs that match between server and client renders, solving hydration issues and enabling accessible form controls without manual ID management.",
      "difficulty": "Easy",
      "code": "import { useId } from 'react';\n\n// Basic usage for form accessibility\nfunction TextField({ label }) {\n  const id = useId();\n  \n  return (\n    <div>\n      <label htmlFor={id}>{label}</label>\n      <input id={id} type=\"text\" />\n    </div>\n  );\n}\n\n// Multiple IDs in same component\nfunction Form() {\n  const id = useId();\n  \n  return (\n    <div>\n      <label htmlFor={`${id}-name`}>Name:</label>\n      <input id={`${id}-name`} />\n      \n      <label htmlFor={`${id}-email`}>Email:</label>\n      <input id={`${id}-email`} />\n    </div>\n  );\n}\n\n// ARIA attributes\nfunction Tooltip({ children, content }) {\n  const id = useId();\n  \n  return (\n    <>\n      <button aria-describedby={id}>\n        {children}\n      </button>\n      <div role=\"tooltip\" id={id}>\n        {content}\n      </div>\n    </>\n  );\n}\n\n// SSR example (preventing hydration mismatch)\n// Before useId (causes hydration error):\nfunction BadComponent() {\n  const [id] = useState(() => Math.random()); // Different on server/client!\n  return <input id={id} />;\n}\n\n// After useId (no hydration error):\nfunction GoodComponent() {\n  const id = useId(); // Same on server and client\n  return <input id={id} />;\n}\n\n// Multiple instances of same component\nfunction App() {\n  return (\n    <div>\n      <TextField label=\"First Name\" />\n      <TextField label=\"Last Name\" />\n      <TextField label=\"Email\" />\n      {/* Each TextField gets unique ID */}\n    </div>\n  );\n}\n\n// Complex form with sections\nfunction ComplexForm() {\n  const formId = useId();\n  \n  return (\n    <form>\n      <fieldset aria-labelledby={`${formId}-personal-heading`}>\n        <legend id={`${formId}-personal-heading`}>Personal Info</legend>\n        <label htmlFor={`${formId}-name`}>Name:</label>\n        <input id={`${formId}-name`} />\n      </fieldset>\n      \n      <fieldset aria-labelledby={`${formId}-contact-heading`}>\n        <legend id={`${formId}-contact-heading`}>Contact</legend>\n        <label htmlFor={`${formId}-email`}>Email:</label>\n        <input id={`${formId}-email`} />\n      </fieldset>\n    </form>\n  );\n}"
    },
    {
      "id": 40,
      "question": "What is React Suspense and how does it work?",
      "answer": "Suspense is a component that lets you display a fallback while waiting for child components to load, enabling declarative loading states.\n\nKey Concepts:\n• Fallback UI: Show loading state while waiting\n• Async Components: Works with lazy-loaded components\n• Data Fetching: Will support data fetching (experimental)\n• Concurrent Rendering: Enables concurrent features\n• Error Boundaries: Combine with error boundaries for errors\n\nUse Cases:\n• Code Splitting: Lazy load components with React.lazy\n• Data Loading: Suspend while fetching data (with frameworks)\n• Images: Wait for images to load\n• Nested Loading: Multiple suspense boundaries\n\nBenefits:\n• Declarative: Describe loading states declaratively\n• Coordination: Coordinate multiple loading states\n• User Experience: Show content as it becomes ready\n• Reduced Complexity: Less loading state management",
      "explanation": "Suspense enables declarative loading states by displaying fallback UI while child components load or fetch data, supporting code splitting and async rendering patterns.",
      "difficulty": "Medium",
      "code": "import { Suspense, lazy } from 'react';\n\n// Basic usage with lazy loading\nconst LazyComponent = lazy(() => import('./LazyComponent'));\n\nfunction App() {\n  return (\n    <div>\n      <h1>My App</h1>\n      <Suspense fallback={<div>Loading component...</div>}>\n        <LazyComponent />\n      </Suspense>\n    </div>\n  );\n}\n\n// Multiple suspense boundaries\nfunction App() {\n  return (\n    <div>\n      <Header />\n      \n      <Suspense fallback={<Skeleton />}>\n        <Sidebar />\n      </Suspense>\n      \n      <Suspense fallback={<ContentSkeleton />}>\n        <MainContent />\n      </Suspense>\n    </div>\n  );\n}\n\n// Nested suspense\nfunction App() {\n  return (\n    <Suspense fallback={<PageLoader />}>\n      <Navigation />\n      \n      <Suspense fallback={<SidebarLoader />}>\n        <Sidebar />\n      </Suspense>\n      \n      <Suspense fallback={<ContentLoader />}>\n        <Content>\n          <Suspense fallback={<CommentsLoader />}>\n            <Comments />\n          </Suspense>\n        </Content>\n      </Suspense>\n    </Suspense>\n  );\n}\n\n// With error boundary\nfunction App() {\n  return (\n    <ErrorBoundary fallback={<ErrorMessage />}>\n      <Suspense fallback={<Loading />}>\n        <LazyComponent />\n      </Suspense>\n    </ErrorBoundary>\n  );\n}\n\n// Route-based code splitting\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\n\nconst Home = lazy(() => import('./pages/Home'));\nconst About = lazy(() => import('./pages/About'));\nconst Dashboard = lazy(() => import('./pages/Dashboard'));\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Suspense fallback={<RouteLoader />}>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/about\" element={<About />} />\n          <Route path=\"/dashboard\" element={<Dashboard />} />\n        </Routes>\n      </Suspense>\n    </BrowserRouter>\n  );\n}\n\n// Data fetching (experimental with frameworks like Next.js)\nfunction Profile({ userId }) {\n  const user = use(fetchUser(userId)); // Suspends until data loads\n  return <div>{user.name}</div>;\n}\n\nfunction App() {\n  return (\n    <Suspense fallback={<ProfileSkeleton />}>\n      <Profile userId={123} />\n    </Suspense>\n  );\n}"
    },
    {
      "id": 41,
      "question": "How do controlled and uncontrolled components work in React forms?",
      "answer": "Controlled and uncontrolled components are two approaches to handling form inputs in React.\n\nControlled Components:\n• React state is the single source of truth\n• Input values are controlled by React state\n• Changes trigger state updates via onChange handlers\n• Provides full control over form data\n• Better for validation and conditional logic\n• Can be verbose for large forms\n\nUncontrolled Components:\n• DOM is the source of truth\n• Use refs to access input values\n• Less code but less control\n• Better for simple forms or integrating non-React code\n• Values are read when needed (e.g., on submit)\n\nWhen to Use:\n• Controlled: Complex forms, real-time validation, conditional fields\n• Uncontrolled: Simple forms, file inputs, integrating with legacy code",
      "explanation": "Controlled components manage form state in React, while uncontrolled components rely on DOM refs. Controlled components offer more control but require more code, while uncontrolled are simpler but less flexible.",
      "difficulty": "Medium",
      "code": "// Controlled Component\nfunction ControlledForm() {\n  const [formData, setFormData] = useState({\n    username: '',\n    email: ''\n  });\n\n  const handleChange = (e) => {\n    setFormData({\n      ...formData,\n      [e.target.name]: e.target.value\n    });\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log('Form data:', formData);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        name=\"username\"\n        value={formData.username}\n        onChange={handleChange}\n        placeholder=\"Username\"\n      />\n      <input\n        name=\"email\"\n        value={formData.email}\n        onChange={handleChange}\n        placeholder=\"Email\"\n      />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n\n// Uncontrolled Component\nfunction UncontrolledForm() {\n  const usernameRef = useRef();\n  const emailRef = useRef();\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log('Form data:', {\n      username: usernameRef.current.value,\n      email: emailRef.current.value\n    });\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        ref={usernameRef}\n        defaultValue=\"\"\n        placeholder=\"Username\"\n      />\n      <input\n        ref={emailRef}\n        defaultValue=\"\"\n        placeholder=\"Email\"\n      />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}"
    },
    {
      "id": 42,
      "question": "What are synthetic events in React and how do they differ from native DOM events?",
      "answer": "Synthetic events are React's cross-browser wrapper around native browser events, providing a consistent API across all browsers.\n\nKey Features:\n• Cross-Browser Compatibility: Same API works in all browsers\n• Event Pooling (React 16): Events are reused for performance (removed in React 17)\n• Automatic Binding: No need to bind event handlers in class components\n• Native Event Access: Can access native event via e.nativeEvent\n• Consistent Properties: Same properties regardless of browser\n• Event Delegation: React uses event delegation at the root level\n\nDifferences from Native Events:\n• Event pooling (pre-React 17) means async access requires e.persist()\n• Some events have different names (onChange vs onInput)\n• Event delegation happens at root, not individual elements\n• Cannot return false to prevent default; must call e.preventDefault()\n\nEvent Delegation:\n• React attaches one event listener at the root\n• Improves performance for many elements\n• Changed from document to root element in React 17",
      "explanation": "Synthetic events are React's normalized event system that provides cross-browser consistency, uses event delegation for performance, and wraps native browser events with a unified API.",
      "difficulty": "Medium",
      "code": "function EventExample() {\n  const handleClick = (e) => {\n    // e is a SyntheticEvent\n    console.log(e.type); // 'click'\n    console.log(e.target); // DOM element\n    console.log(e.nativeEvent); // Native browser event\n    \n    // Prevent default behavior\n    e.preventDefault();\n    \n    // Stop event propagation\n    e.stopPropagation();\n  };\n\n  const handleChange = (e) => {\n    // In React 16, would need e.persist() for async access\n    // In React 17+, no longer needed\n    console.log(e.target.value);\n    \n    // Async access (React 17+)\n    setTimeout(() => {\n      console.log(e.target.value); // Works in React 17+\n    }, 100);\n  };\n\n  // Custom event handler with parameters\n  const handleCustomClick = (id, e) => {\n    console.log('Clicked item:', id);\n    console.log('Event:', e);\n  };\n\n  return (\n    <div>\n      <button onClick={handleClick}>Click Me</button>\n      <input onChange={handleChange} />\n      <button onClick={(e) => handleCustomClick(123, e)}>\n        Custom Handler\n      </button>\n    </div>\n  );\n}\n\n// Accessing native event\nfunction NativeEventAccess() {\n  const handleEvent = (e) => {\n    // Synthetic event properties\n    console.log(e.bubbles, e.cancelable, e.currentTarget);\n    \n    // Native event\n    const nativeEvent = e.nativeEvent;\n    console.log(nativeEvent instanceof MouseEvent); // true\n  };\n\n  return <button onClick={handleEvent}>Check Event</button>;\n}"
    },
    {
      "id": 43,
      "question": "What is React.StrictMode and why should you use it?",
      "answer": "React.StrictMode is a development tool that highlights potential problems in an application by activating additional checks and warnings.\n\nWhat It Does:\n• Identifies Unsafe Lifecycles: Warns about deprecated lifecycle methods\n• Legacy API Warnings: Detects usage of legacy string refs and findDOMNode\n• Unexpected Side Effects: Detects side effects by double-invoking functions\n• Legacy Context API: Warns about deprecated context API usage\n• Ensures Reusable State: Helps prepare for features like Fast Refresh\n• Double Rendering: Intentionally double-renders components to find bugs\n\nDouble Invocation (Development Only):\n• Constructor, render, and setState updater functions called twice\n• useEffect, useMemo, useReducer called twice\n• Helps detect side effects that should be pure\n• Only in development mode, not production\n\nBenefits:\n• Early Bug Detection: Catch issues before they reach production\n• Future-Proof: Prepares code for concurrent rendering\n• Better Practices: Encourages writing more resilient components\n• No Runtime Cost: Only active in development",
      "explanation": "React.StrictMode is a development tool that activates additional checks and warnings to identify potential problems, unsafe patterns, and deprecated APIs, helping developers write better React code.",
      "difficulty": "Medium",
      "code": "// Wrapping app with StrictMode\nimport { StrictMode } from 'react';\nimport ReactDOM from 'react-dom/client';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>\n);\n\n// Wrapping specific components\nfunction App() {\n  return (\n    <div>\n      <Header />\n      <StrictMode>\n        <Sidebar /> {/* Only this component runs in strict mode */}\n      </StrictMode>\n      <Content />\n    </div>\n  );\n}\n\n// Example: Detecting side effects\nfunction ProblematicComponent() {\n  // Bad: Side effect in render\n  // StrictMode will call this twice, making the bug obvious\n  const data = [];\n  data.push(Math.random()); // This will have different values!\n\n  useEffect(() => {\n    // This will run twice in StrictMode\n    console.log('Effect running');\n    \n    return () => {\n      // Cleanup also runs\n      console.log('Cleanup');\n    };\n  }, []);\n\n  return <div>{data[0]}</div>;\n}\n\n// Good: Pure component\nfunction GoodComponent() {\n  const [data, setData] = useState([]);\n\n  useEffect(() => {\n    // Side effects in useEffect are OK\n    setData([Math.random()]);\n  }, []);\n\n  return <div>{data[0]}</div>;\n}\n\n// StrictMode warnings example\nclass LegacyComponent extends React.Component {\n  // StrictMode warns about this deprecated lifecycle\n  componentWillMount() {\n    console.log('Unsafe lifecycle!');\n  }\n\n  render() {\n    // Using string refs (deprecated)\n    return <input ref=\"myInput\" />; // StrictMode warns\n  }\n}"
    },
    {
      "id": 44,
      "question": "What is React.Children and when would you use it?",
      "answer": "React.Children is a utility API for working with the props.children opaque data structure, providing methods to manipulate and transform children.\n\nAvailable Methods:\n• React.Children.map(children, fn): Map over children and return array\n• React.Children.forEach(children, fn): Iterate without returning\n• React.Children.count(children): Count number of children\n• React.Children.only(children): Verify only one child exists\n• React.Children.toArray(children): Convert children to flat array with keys\n\nUse Cases:\n• Wrapping/Modifying Children: Add props or wrap each child\n• Validating Children: Ensure correct number or type of children\n• Filtering Children: Remove or conditionally render children\n• Reordering Children: Change order or group children\n• Compound Components: Build component systems with specific child relationships\n\nWhy Not Just Use children.map?\n• children can be undefined, single element, or array\n• React.Children handles all cases consistently\n• Properly handles keys and fragments",
      "explanation": "React.Children is a utility API that provides safe methods to manipulate, transform, and validate the props.children data structure, handling edge cases like undefined children or single elements.",
      "difficulty": "Hard",
      "code": "// Wrapping each child with additional props\nfunction List({ children }) {\n  return (\n    <ul>\n      {React.Children.map(children, (child, index) => {\n        // Clone element and add props\n        return React.cloneElement(child, {\n          index,\n          className: 'list-item'\n        });\n      })}\n    </ul>\n  );\n}\n\n// Usage\n<List>\n  <li>Item 1</li>\n  <li>Item 2</li>\n  <li>Item 3</li>\n</List>\n\n// Validating single child\nfunction SingleChildWrapper({ children }) {\n  // Throws error if not exactly one child\n  const child = React.Children.only(children);\n  return <div className=\"wrapper\">{child}</div>;\n}\n\n// Counting and filtering children\nfunction TabContainer({ children }) {\n  const count = React.Children.count(children);\n  \n  // Filter only Tab components\n  const tabs = React.Children.toArray(children).filter(\n    child => child.type === Tab\n  );\n\n  return (\n    <div>\n      <div className=\"tab-header\">\n        {tabs.length} tabs available\n      </div>\n      <div className=\"tab-content\">{tabs}</div>\n    </div>\n  );\n}\n\n// Advanced: Compound component pattern\nfunction Accordion({ children }) {\n  const [openIndex, setOpenIndex] = useState(0);\n\n  return (\n    <div>\n      {React.Children.map(children, (child, index) => {\n        if (child.type === AccordionItem) {\n          return React.cloneElement(child, {\n            isOpen: index === openIndex,\n            onToggle: () => setOpenIndex(index),\n            index\n          });\n        }\n        return child;\n      })}\n    </div>\n  );\n}\n\nfunction AccordionItem({ title, children, isOpen, onToggle }) {\n  return (\n    <div>\n      <button onClick={onToggle}>{title}</button>\n      {isOpen && <div>{children}</div>}\n    </div>\n  );\n}\n\n// Usage\n<Accordion>\n  <AccordionItem title=\"Section 1\">\n    Content 1\n  </AccordionItem>\n  <AccordionItem title=\"Section 2\">\n    Content 2\n  </AccordionItem>\n</Accordion>\n\n// Converting to array safely\nfunction SafeChildrenHandler({ children }) {\n  // Handles single child, array, or undefined\n  const childArray = React.Children.toArray(children);\n  \n  return (\n    <div>\n      {childArray.map((child, i) => (\n        <div key={i} className=\"item\">{child}</div>\n      ))}\n    </div>\n  );\n}"
    },
    {
      "id": 45,
      "question": "What is forwardRef and when should you use it?",
      "answer": "forwardRef is a React API that allows components to pass refs through to child DOM elements or components, enabling parent components to access child DOM nodes.\n\nKey Concepts:\n• Ref Forwarding: Pass refs through component boundaries\n• DOM Access: Parent can access child's DOM element\n• Higher-Order Pattern: Works with HOCs and wrapper components\n• Functional Components: Required for functional components to receive refs\n• Component Libraries: Essential for reusable UI component libraries\n\nWhen to Use:\n• Input Components: Custom input wrappers that need focus/blur\n• Animation Libraries: Third-party libraries needing DOM access\n• Measuring Elements: Getting element dimensions or position\n• Focus Management: Programmatic focus control\n• Wrapper Components: HOCs that shouldn't hide ref access\n\nCombining with useImperativeHandle:\n• Customize the ref value exposed to parent\n• Expose specific methods instead of full DOM node\n• Better encapsulation and API control",
      "explanation": "forwardRef allows components to forward refs to child elements, enabling parent components to access child DOM nodes or expose custom imperative APIs, essential for reusable component libraries.",
      "difficulty": "Medium",
      "code": "// Basic forwardRef usage\nconst TextInput = forwardRef((props, ref) => {\n  return (\n    <input\n      ref={ref}\n      type=\"text\"\n      {...props}\n    />\n  );\n});\n\n// Parent using the ref\nfunction Form() {\n  const inputRef = useRef();\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    // Access child's DOM element\n    inputRef.current.focus();\n    console.log(inputRef.current.value);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <TextInput ref={inputRef} placeholder=\"Enter text\" />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n\n// Advanced: with useImperativeHandle\nconst FancyInput = forwardRef((props, ref) => {\n  const inputRef = useRef();\n\n  // Expose custom API instead of DOM element\n  useImperativeHandle(ref, () => ({\n    focus: () => {\n      inputRef.current.focus();\n    },\n    shake: () => {\n      inputRef.current.classList.add('shake');\n      setTimeout(() => {\n        inputRef.current.classList.remove('shake');\n      }, 500);\n    },\n    getValue: () => inputRef.current.value\n  }));\n\n  return <input ref={inputRef} {...props} />;\n});\n\n// Using custom ref API\nfunction App() {\n  const fancyInputRef = useRef();\n\n  const handleClick = () => {\n    fancyInputRef.current.focus();\n    const value = fancyInputRef.current.getValue();\n    if (!value) {\n      fancyInputRef.current.shake();\n    }\n  };\n\n  return (\n    <div>\n      <FancyInput ref={fancyInputRef} />\n      <button onClick={handleClick}>Validate</button>\n    </div>\n  );\n}\n\n// With HOC\nfunction withLogger(Component) {\n  const WithLogger = forwardRef((props, ref) => {\n    useEffect(() => {\n      console.log('Component mounted');\n    }, []);\n\n    // Forward ref to wrapped component\n    return <Component ref={ref} {...props} />;\n  });\n\n  return WithLogger;\n}\n\nconst LoggedInput = withLogger(TextInput);\n\n// Using in parent\nfunction ParentComponent() {\n  const ref = useRef();\n  // ref still works through the HOC\n  return <LoggedInput ref={ref} />;\n}"
    },
    {
      "id": 46,
      "question": "What is the difference between React.createElement and React.cloneElement?",
      "answer": "React.createElement and React.cloneElement are both used to create React elements, but they serve different purposes.\n\nReact.createElement:\n• Creates a new React element from scratch\n• Takes type (component or tag), props, and children\n• Used by JSX transpilation under the hood\n• Returns a new element with specified props and children\n• First argument: element type (string or component)\n• Second argument: props object\n• Remaining arguments: children\n\nReact.cloneElement:\n• Clones an existing React element\n• Preserves the original element's type and key\n• Merges new props with original props\n• Can replace children if provided\n• Used for modifying existing elements\n• Useful in component composition patterns\n\nWhen to Use:\n• createElement: Building elements from scratch, JSX alternative\n• cloneElement: Modifying children, adding props to existing elements, compound components",
      "explanation": "createElement creates new React elements from scratch and is used by JSX, while cloneElement copies existing elements and merges new props, useful for modifying children in composition patterns.",
      "difficulty": "Medium",
      "code": "// React.createElement\nconst element1 = React.createElement(\n  'div',\n  { className: 'container', id: 'main' },\n  'Hello World'\n);\n\n// Equivalent JSX\nconst element2 = <div className=\"container\" id=\"main\">Hello World</div>;\n\n// Creating component elements\nconst componentElement = React.createElement(\n  MyComponent,\n  { name: 'John', age: 30 },\n  'Child content'\n);\n\n// React.cloneElement - modifying children\nfunction Parent({ children }) {\n  // Clone child and add extra props\n  const childWithProps = React.cloneElement(children, {\n    additionalProp: 'value',\n    onClick: () => console.log('Clicked')\n  });\n\n  return <div>{childWithProps}</div>;\n}\n\n// Usage\n<Parent>\n  <Button>Click me</Button>\n</Parent>\n// Button receives additionalProp and onClick\n\n// Practical example: Adding props to all children\nfunction List({ children }) {\n  return (\n    <ul>\n      {React.Children.map(children, (child, index) => {\n        // Clone each child with index prop\n        return React.cloneElement(child, {\n          index,\n          key: index,\n          className: `item item-${index}`\n        });\n      })}\n    </ul>\n  );\n}\n\n// Complex example: Tabs component\nfunction Tabs({ children, activeIndex }) {\n  return (\n    <div>\n      {React.Children.map(children, (child, index) => {\n        // Clone with additional props\n        return React.cloneElement(child, {\n          isActive: index === activeIndex,\n          tabIndex: index\n        });\n      })}\n    </div>\n  );\n}\n\nfunction Tab({ isActive, tabIndex, children }) {\n  return (\n    <div className={isActive ? 'active' : ''}>\n      {children}\n    </div>\n  );\n}\n\n// createElement vs cloneElement comparison\nconst original = <Button color=\"blue\">Click</Button>;\n\n// Create new element (ignores original)\nconst newElement = React.createElement(\n  Button,\n  { color: 'red' },\n  'New Button'\n);\n\n// Clone and modify (preserves original, adds/overrides props)\nconst clonedElement = React.cloneElement(\n  original,\n  { color: 'red' }, // Overrides blue\n  'Modified Button' // Replaces children\n);"
    },
    {
      "id": 47,
      "question": "What is automatic batching in React 18 and how does it improve performance?",
      "answer": "Automatic batching is a React 18 feature that automatically groups multiple state updates into a single re-render for better performance, regardless of where they occur.\n\nBefore React 18:\n• Only batched updates in React event handlers\n• Updates in promises, setTimeout, native events caused separate re-renders\n• Required manual batching with unstable_batchedUpdates\n\nReact 18 Automatic Batching:\n• Batches all state updates automatically\n• Works in timeouts, promises, native event handlers\n• Applies to all updates regardless of origin\n• Reduces unnecessary re-renders significantly\n• Improves performance automatically\n\nHow It Works:\n• React queues state updates\n• Combines multiple setState calls\n• Performs single re-render with all changes\n• Happens automatically in concurrent features\n\nOpting Out:\n• Use flushSync to force immediate synchronous update\n• Needed for reading DOM after update\n• Generally not recommended\n\nBenefits:\n• Better Performance: Fewer re-renders\n• Consistent Behavior: Same in all scenarios\n• Automatic: No code changes needed",
      "explanation": "React 18's automatic batching groups all state updates into a single re-render regardless of where they occur (promises, timeouts, event handlers), improving performance by reducing unnecessary renders.",
      "difficulty": "Medium",
      "code": "// React 17 behavior\nfunction handleClick() {\n  setCount(c => c + 1); // Re-render 1\n  setFlag(f => !f);     // Re-render 2\n  // React 17: 1 re-render (batched in event handlers)\n}\n\nsetTimeout(() => {\n  setCount(c => c + 1); // Re-render 1\n  setFlag(f => !f);     // Re-render 2\n  // React 17: 2 re-renders (not batched in async)\n}, 1000);\n\n// React 18 behavior\nfunction handleClick() {\n  setCount(c => c + 1);\n  setFlag(f => !f);\n  // React 18: 1 re-render (batched)\n}\n\nsetTimeout(() => {\n  setCount(c => c + 1);\n  setFlag(f => !f);\n  // React 18: 1 re-render (automatically batched!)\n}, 1000);\n\nfetch('/api/data').then(() => {\n  setData(newData);\n  setLoading(false);\n  setError(null);\n  // React 18: 1 re-render for all three updates\n});\n\n// Native event handler\ndocument.addEventListener('click', () => {\n  setCount(c => c + 1);\n  setFlag(f => !f);\n  // React 18: 1 re-render (batched)\n  // React 17: 2 re-renders (not batched)\n});\n\n// Opting out with flushSync\nimport { flushSync } from 'react-dom';\n\nfunction handleClick() {\n  flushSync(() => {\n    setCount(c => c + 1);\n  });\n  // React flushes this immediately - 1 re-render\n  \n  flushSync(() => {\n    setFlag(f => !f);\n  });\n  // React flushes this immediately - another re-render\n  \n  // Total: 2 re-renders instead of 1\n}\n\n// Practical example\nfunction SearchComponent() {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n  const [loading, setLoading] = useState(false);\n\n  const handleSearch = async (searchTerm) => {\n    setLoading(true);\n    setQuery(searchTerm);\n    // React 18: Batched into 1 re-render\n\n    const data = await fetchResults(searchTerm);\n    \n    setResults(data);\n    setLoading(false);\n    // React 18: Batched into 1 re-render (even in async!)\n    // React 17: Would be 2 separate re-renders\n  };\n\n  return (\n    <div>\n      <input onChange={(e) => handleSearch(e.target.value)} />\n      {loading ? <Spinner /> : <Results data={results} />}\n    </div>\n  );\n}\n\n// Example showing render count\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const [double, setDouble] = useState(0);\n  const renderCount = useRef(0);\n\n  useEffect(() => {\n    renderCount.current += 1;\n  });\n\n  const handleClick = () => {\n    setTimeout(() => {\n      setCount(c => c + 1);\n      setDouble(c => c + 2);\n      // React 18: 1 render\n      // React 17: 2 renders\n    }, 100);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <p>Double: {double}</p>\n      <p>Renders: {renderCount.current}</p>\n      <button onClick={handleClick}>Update</button>\n    </div>\n  );\n}"
    },
    {
      "id": 48,
      "question": "What is flushSync and when should you use it?",
      "answer": "flushSync is a React API that forces synchronous updates, immediately flushing pending state updates and re-rendering the component before continuing execution.\n\nWhat It Does:\n• Forces immediate synchronous DOM update\n• Bypasses automatic batching\n• Blocks execution until update completes\n• Updates DOM before continuing to next line\n• Triggers re-render immediately\n\nWhen to Use:\n• Reading DOM After Update: Need immediate DOM measurements\n• Third-Party Libraries: Integrating libraries expecting immediate updates\n• Print Functionality: Ensuring state reflects before printing\n• Scroll Position: Setting scroll after rendering new content\n• Focus Management: Focusing elements immediately after creation\n\nWhen NOT to Use:\n• Normal State Updates: Automatic batching is better\n• Performance Critical Code: flushSync is slower\n• Most Use Cases: Rarely needed in typical React apps\n\nCaveats:\n• Hurts Performance: Causes extra re-renders\n• Use Sparingly: Only when truly necessary\n• Escape Hatch: Consider it a last resort\n• May Suspend: Can trigger suspense boundaries",
      "explanation": "flushSync forces immediate synchronous state updates and DOM rendering, bypassing automatic batching. Use it sparingly when you need to read DOM values immediately after an update, as it hurts performance.",
      "difficulty": "Hard",
      "code": "import { flushSync } from 'react-dom';\n\n// Problem: Reading DOM after state update\nfunction ScrollExample() {\n  const [items, setItems] = useState([]);\n  const listRef = useRef();\n\n  const addItem = () => {\n    setItems([...items, `Item ${items.length + 1}`]);\n    \n    // Without flushSync: scrollHeight is stale\n    console.log(listRef.current.scrollHeight); // Old height!\n    listRef.current.scrollTop = listRef.current.scrollHeight; // Wrong!\n  };\n\n  const addItemCorrectly = () => {\n    flushSync(() => {\n      setItems([...items, `Item ${items.length + 1}`]);\n    });\n    // DOM is updated immediately\n    console.log(listRef.current.scrollHeight); // New height!\n    listRef.current.scrollTop = listRef.current.scrollHeight; // Correct!\n  };\n\n  return (\n    <div>\n      <div ref={listRef} style={{ height: 200, overflow: 'auto' }}>\n        {items.map((item, i) => <div key={i}>{item}</div>)}\n      </div>\n      <button onClick={addItemCorrectly}>Add Item</button>\n    </div>\n  );\n}\n\n// Example: Multiple flushSync calls\nfunction MultipleUpdates() {\n  const [count1, setCount1] = useState(0);\n  const [count2, setCount2] = useState(0);\n\n  const handleClick = () => {\n    // Normal batching (1 re-render)\n    setCount1(c => c + 1);\n    setCount2(c => c + 1);\n\n    // Force separate updates (2 re-renders)\n    flushSync(() => {\n      setCount1(c => c + 1);\n    });\n    // count1 is updated in DOM here\n    \n    flushSync(() => {\n      setCount2(c => c + 1);\n    });\n    // count2 is updated in DOM here\n  };\n\n  return (\n    <div>\n      <p>Count1: {count1}</p>\n      <p>Count2: {count2}</p>\n      <button onClick={handleClick}>Update</button>\n    </div>\n  );\n}\n\n// Practical: Focus management\nfunction TodoList() {\n  const [todos, setTodos] = useState([]);\n  const inputRef = useRef();\n\n  const addTodo = (text) => {\n    flushSync(() => {\n      setTodos([...todos, { id: Date.now(), text }]);\n    });\n    // DOM updated, can safely focus new element\n    const newInput = document.getElementById(`todo-${todos.length}`);\n    if (newInput) newInput.focus();\n  };\n\n  return (\n    <div>\n      {todos.map((todo, index) => (\n        <input\n          key={todo.id}\n          id={`todo-${index}`}\n          defaultValue={todo.text}\n        />\n      ))}\n      <button onClick={() => addTodo('New Todo')}>Add</button>\n    </div>\n  );\n}\n\n// Measuring DOM elements\nfunction ResizablePanel() {\n  const [content, setContent] = useState([]);\n  const [height, setHeight] = useState(0);\n  const panelRef = useRef();\n\n  const addContent = () => {\n    flushSync(() => {\n      setContent([...content, 'New paragraph']);\n    });\n    // Immediately measure new height\n    const newHeight = panelRef.current.offsetHeight;\n    setHeight(newHeight);\n    console.log('Panel height:', newHeight);\n  };\n\n  return (\n    <div>\n      <div ref={panelRef}>\n        {content.map((text, i) => <p key={i}>{text}</p>)}\n      </div>\n      <div>Current height: {height}px</div>\n      <button onClick={addContent}>Add Content</button>\n    </div>\n  );\n}\n\n// Bad example: Unnecessary flushSync\nfunction BadExample() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () => {\n    // Don't do this! No need for flushSync here\n    flushSync(() => {\n      setCount(c => c + 1);\n    });\n    // Just use: setCount(c => c + 1);\n  };\n\n  return <button onClick={handleClick}>Count: {count}</button>;\n}"
    },
    {
      "id": 49,
      "question": "What are transitions in React 18 (useTransition) and how do they work?",
      "answer": "useTransition is a React 18 hook that lets you mark state updates as non-urgent transitions, allowing React to keep the UI responsive during expensive updates.\n\nKey Concepts:\n• Urgent vs Non-Urgent Updates: Separate immediate from deferrable updates\n• User Input Priority: Keep typing, clicking responsive\n• Background Updates: Heavy computations don't block UI\n• Interruptible Rendering: React can pause and resume work\n• No Loading States Needed: Keeps showing old UI until ready\n• Automatic Batching: Works with concurrent features\n\nHow It Works:\n• startTransition marks updates as transitions\n• React keeps current UI interactive\n• Transition updates can be interrupted\n• React prioritizes urgent updates\n• Shows new UI only when ready\n• isPending indicates transition in progress\n\nWhen to Use:\n• Slow Rendering: Large lists, complex computations\n• Navigation: Route changes with heavy components\n• Tab Switching: Switching between expensive views\n• Search/Filtering: Heavy filtering operations\n• Data Visualization: Rendering charts/graphs\n\nBenefits:\n• Better UX: UI stays responsive\n• No Flickering: Avoids loading spinners\n• Smooth Interactions: Typing remains smooth",
      "explanation": "useTransition marks state updates as non-urgent, allowing React to keep the UI responsive during expensive updates by prioritizing user interactions over background rendering work.",
      "difficulty": "Hard",
      "code": "import { useState, useTransition } from 'react';\n\n// Basic usage\nfunction TabContainer() {\n  const [tab, setTab] = useState('home');\n  const [isPending, startTransition] = useTransition();\n\n  const handleTabChange = (newTab) => {\n    // Urgent: Update immediately\n    // setTab(newTab); // Old way: might freeze UI\n\n    // Non-urgent: Mark as transition\n    startTransition(() => {\n      setTab(newTab);\n    });\n    // UI stays responsive while rendering new tab\n  };\n\n  return (\n    <div>\n      <button onClick={() => handleTabChange('home')}>Home</button>\n      <button onClick={() => handleTabChange('posts')}>Posts</button>\n      <button onClick={() => handleTabChange('contact')}>Contact</button>\n      \n      {isPending ? <Spinner /> : null}\n      \n      <div style={{ opacity: isPending ? 0.7 : 1 }}>\n        {tab === 'home' && <HomeTab />}\n        {tab === 'posts' && <PostsTab />} {/* Expensive */}\n        {tab === 'contact' && <ContactTab />}\n      </div>\n    </div>\n  );\n}\n\n// Search with transition\nfunction SearchResults() {\n  const [query, setQuery] = useState('');\n  const [searchTerm, setSearchTerm] = useState('');\n  const [isPending, startTransition] = useTransition();\n\n  const handleChange = (e) => {\n    const value = e.target.value;\n    // Urgent: Update input immediately\n    setQuery(value);\n\n    // Non-urgent: Defer expensive search\n    startTransition(() => {\n      setSearchTerm(value);\n    });\n  };\n\n  return (\n    <div>\n      <input\n        value={query}\n        onChange={handleChange}\n        placeholder=\"Search...\"\n      />\n      {isPending && <span>Searching...</span>}\n      <Results searchTerm={searchTerm} />\n    </div>\n  );\n}\n\n// Results component (expensive)\nfunction Results({ searchTerm }) {\n  const items = useMemo(() => {\n    // Expensive filtering/computation\n    return hugeList.filter(item =>\n      item.toLowerCase().includes(searchTerm.toLowerCase())\n    );\n  }, [searchTerm]);\n\n  return (\n    <ul>\n      {items.map(item => <li key={item}>{item}</li>)}\n    </ul>\n  );\n}\n\n// Complex example: Multiple transitions\nfunction Dashboard() {\n  const [filter, setFilter] = useState('all');\n  const [sortBy, setSortBy] = useState('date');\n  const [isPending, startTransition] = useTransition();\n\n  const updateView = (newFilter, newSort) => {\n    startTransition(() => {\n      // Batch multiple updates in transition\n      setFilter(newFilter);\n      setSortBy(newSort);\n    });\n  };\n\n  return (\n    <div>\n      <Controls\n        onFilterChange={(f) => updateView(f, sortBy)}\n        onSortChange={(s) => updateView(filter, s)}\n      />\n      {isPending && <div>Updating view...</div>}\n      <DataGrid filter={filter} sortBy={sortBy} />\n    </div>\n  );\n}\n\n// Comparing with and without transition\nfunction Comparison() {\n  const [input, setInput] = useState('');\n  const [list, setList] = useState([]);\n  const [isPending, startTransition] = useTransition();\n\n  // Without transition: UI freezes during update\n  const updateWithoutTransition = (value) => {\n    setInput(value);\n    setList(generateHugeList(value)); // Blocks UI!\n  };\n\n  // With transition: UI stays responsive\n  const updateWithTransition = (value) => {\n    setInput(value); // Urgent\n    startTransition(() => {\n      setList(generateHugeList(value)); // Non-urgent\n    });\n  };\n\n  return (\n    <div>\n      <input\n        value={input}\n        onChange={(e) => updateWithTransition(e.target.value)}\n      />\n      {isPending && <p>Updating list...</p>}\n      <HugeList items={list} />\n    </div>\n  );\n}\n\nfunction generateHugeList(query) {\n  const items = [];\n  for (let i = 0; i < 10000; i++) {\n    items.push(`${query} - Item ${i}`);\n  }\n  return items;\n}"
    },
    {
      "id": 50,
      "question": "What is useDeferredValue and how does it differ from useTransition?",
      "answer": "useDeferredValue is a React 18 hook that defers updating a value until more urgent updates finish, similar to debouncing but integrated with React's rendering system.\n\nHow It Works:\n• Accepts a value and returns a deferred version\n• React shows old value while new value renders\n• Updates only when React has idle time\n• Automatically interrupted by urgent updates\n• No need to manage pending state manually\n• Works with concurrent rendering\n\nuseDeferredValue vs useTransition:\n• useDeferredValue: Defer a value (you don't control the state)\n• useTransition: Defer a state update (you control the state)\n• useDeferredValue: Use when value comes from props/parent\n• useTransition: Use when you own the state\n• useDeferredValue: No isPending flag\n• useTransition: Provides isPending for loading indicators\n\nWhen to Use:\n• Value from Props: Parent controls the state\n• Expensive Derived State: Heavy computations from props\n• Third-Party Components: Can't modify their state updates\n• List Filtering: Filter based on external search term\n• Real-time Updates: Charts, visualizations from props\n\nBenefits:\n• Simple API: Just wrap the value\n• Automatic: No manual state management\n• Responsive UI: Keeps interactions smooth",
      "explanation": "useDeferredValue defers updating a value until urgent updates finish, similar to useTransition but for values you don't control. Use it for expensive renders triggered by props or external state.",
      "difficulty": "Hard",
      "code": "import { useDeferredValue, useState, memo } from 'react';\n\n// Basic usage\nfunction SearchApp() {\n  const [query, setQuery] = useState('');\n  // Defer the search query\n  const deferredQuery = useDeferredValue(query);\n\n  return (\n    <div>\n      <input\n        value={query}\n        onChange={(e) => setQuery(e.target.value)}\n        placeholder=\"Search...\"\n      />\n      {/* Input stays responsive */}\n      <Results query={deferredQuery} />\n      {/* Results update when React has time */}\n    </div>\n  );\n}\n\n// Expensive Results component\nconst Results = memo(function Results({ query }) {\n  const items = useMemo(() => {\n    // Expensive computation\n    return hugeList.filter(item =>\n      item.toLowerCase().includes(query.toLowerCase())\n    );\n  }, [query]);\n\n  return (\n    <ul>\n      {items.map((item, i) => <li key={i}>{item}</li>)}\n    </ul>\n  );\n});\n\n// Showing loading state with deferred value\nfunction SearchWithLoading() {\n  const [query, setQuery] = useState('');\n  const deferredQuery = useDeferredValue(query);\n  const isStale = query !== deferredQuery;\n\n  return (\n    <div>\n      <input\n        value={query}\n        onChange={(e) => setQuery(e.target.value)}\n      />\n      <div style={{ opacity: isStale ? 0.5 : 1 }}>\n        {isStale && <span>Loading...</span>}\n        <Results query={deferredQuery} />\n      </div>\n    </div>\n  );\n}\n\n// Comparison: useDeferredValue vs useTransition\n\n// Option 1: Using useDeferredValue\nfunction WithDeferredValue() {\n  const [input, setInput] = useState('');\n  const deferredInput = useDeferredValue(input);\n\n  return (\n    <div>\n      <input value={input} onChange={(e) => setInput(e.target.value)} />\n      <SlowList text={deferredInput} />\n    </div>\n  );\n}\n\n// Option 2: Using useTransition\nfunction WithTransition() {\n  const [input, setInput] = useState('');\n  const [deferredInput, setDeferredInput] = useState('');\n  const [isPending, startTransition] = useTransition();\n\n  const handleChange = (e) => {\n    setInput(e.target.value);\n    startTransition(() => {\n      setDeferredInput(e.target.value);\n    });\n  };\n\n  return (\n    <div>\n      <input value={input} onChange={handleChange} />\n      {isPending && <Spinner />}\n      <SlowList text={deferredInput} />\n    </div>\n  );\n}\n\n// Real-world example: Live chart\nfunction ChartDashboard() {\n  const [range, setRange] = useState(100);\n  const deferredRange = useDeferredValue(range);\n  const isStale = range !== deferredRange;\n\n  return (\n    <div>\n      <label>\n        Data points: {range}\n        <input\n          type=\"range\"\n          min=\"100\"\n          max=\"10000\"\n          value={range}\n          onChange={(e) => setRange(Number(e.target.value))}\n        />\n      </label>\n      <div style={{ opacity: isStale ? 0.6 : 1 }}>\n        {isStale && <div>Updating chart...</div>}\n        <ExpensiveChart dataPoints={deferredRange} />\n      </div>\n    </div>\n  );\n}\n\n// With derived expensive computation\nfunction DataTable({ data, sortBy }) {\n  const deferredSortBy = useDeferredValue(sortBy);\n  \n  const sortedData = useMemo(() => {\n    // Expensive sorting\n    return [...data].sort((a, b) => {\n      if (deferredSortBy === 'name') return a.name.localeCompare(b.name);\n      if (deferredSortBy === 'date') return a.date - b.date;\n      return 0;\n    });\n  }, [data, deferredSortBy]);\n\n  return (\n    <table>\n      <tbody>\n        {sortedData.map(item => (\n          <tr key={item.id}>\n            <td>{item.name}</td>\n            <td>{item.value}</td>\n          </tr>\n        ))}\n      </tbody>\n    </table>\n  );\n}\n\n// Parent component\nfunction TableContainer() {\n  const [sortBy, setSortBy] = useState('name');\n  const data = useData(); // Large dataset\n\n  return (\n    <div>\n      <select value={sortBy} onChange={(e) => setSortBy(e.target.value)}>\n        <option value=\"name\">Name</option>\n        <option value=\"date\">Date</option>\n        <option value=\"value\">Value</option>\n      </select>\n      {/* Select stays responsive while table re-sorts */}\n      <DataTable data={data} sortBy={sortBy} />\n    </div>\n  );\n}"
    },
    {
      "id": 51,
      "question": "Explain the component lifecycle in React class components and their equivalents in hooks.",
      "answer": "Component lifecycle refers to the phases a component goes through from creation to removal. Class components have lifecycle methods, while functional components use hooks.\n\nClass Component Lifecycle Phases:\n• Mounting: Component is being created and inserted into DOM\n• Updating: Component is being re-rendered due to props or state changes\n• Unmounting: Component is being removed from DOM\n• Error Handling: Component catches errors from children\n\nMounting Phase:\n• constructor(): Initialize state and bind methods\n• static getDerivedStateFromProps(): Sync state with props\n• render(): Return JSX to be rendered\n• componentDidMount(): Side effects, API calls, subscriptions\n\nUpdating Phase:\n• static getDerivedStateFromProps(): Sync state with props\n• shouldComponentUpdate(): Optimize rendering\n• render(): Re-render component\n• getSnapshotBeforeUpdate(): Capture DOM info before update\n• componentDidUpdate(): Side effects after update\n\nUnmounting Phase:\n• componentWillUnmount(): Cleanup subscriptions, timers\n\nHooks Equivalents:\n• useState: Replaces constructor and state\n• useEffect: Replaces componentDidMount, componentDidUpdate, componentWillUnmount\n• useLayoutEffect: Replaces componentDidMount (synchronous)\n• useMemo/useCallback: Replaces shouldComponentUpdate logic",
      "explanation": "Component lifecycle includes mounting, updating, and unmounting phases. Class components use lifecycle methods while functional components use hooks like useEffect to achieve the same functionality more simply.",
      "difficulty": "Medium",
      "code": "// Class Component Lifecycle\nclass UserProfile extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      user: null,\n      loading: true\n    };\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    // Sync state with props if needed\n    if (props.userId !== state.prevUserId) {\n      return {\n        prevUserId: props.userId,\n        user: null,\n        loading: true\n      };\n    }\n    return null;\n  }\n\n  componentDidMount() {\n    // Called once after first render\n    this.fetchUser();\n    this.timer = setInterval(this.updateTime, 1000);\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    // Called after updates (not initial render)\n    if (prevProps.userId !== this.props.userId) {\n      this.fetchUser();\n    }\n  }\n\n  componentWillUnmount() {\n    // Cleanup before component removes\n    clearInterval(this.timer);\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    // Optimize rendering\n    return nextProps.userId !== this.props.userId ||\n           nextState.user !== this.state.user;\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    // Capture info from DOM before update\n    if (prevProps.list.length < this.props.list.length) {\n      return this.listRef.scrollHeight;\n    }\n    return null;\n  }\n\n  fetchUser = async () => {\n    const user = await api.getUser(this.props.userId);\n    this.setState({ user, loading: false });\n  };\n\n  render() {\n    if (this.state.loading) return <Spinner />;\n    return <div>{this.state.user.name}</div>;\n  }\n}\n\n// Functional Component with Hooks Equivalent\nfunction UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  // componentDidMount + componentDidUpdate + componentWillUnmount\n  useEffect(() => {\n    setLoading(true);\n    \n    // Fetch user (mount and when userId changes)\n    api.getUser(userId).then(data => {\n      setUser(data);\n      setLoading(false);\n    });\n\n    // Setup timer\n    const timer = setInterval(updateTime, 1000);\n\n    // Cleanup (unmount)\n    return () => {\n      clearInterval(timer);\n    };\n  }, [userId]); // Dependency array\n\n  // shouldComponentUpdate equivalent\n  const MemoizedChild = useMemo(() => {\n    return <ChildComponent user={user} />;\n  }, [user]);\n\n  if (loading) return <Spinner />;\n  return <div>{user.name}</div>;\n}\n\n// Multiple useEffect for different lifecycles\nfunction ComplexComponent({ id, filter }) {\n  const [data, setData] = useState(null);\n\n  // Run only on mount\n  useEffect(() => {\n    console.log('Component mounted');\n    return () => console.log('Component unmounted');\n  }, []);\n\n  // Run when id changes\n  useEffect(() => {\n    fetchData(id).then(setData);\n  }, [id]);\n\n  // Run when filter changes\n  useEffect(() => {\n    filterData(filter);\n  }, [filter]);\n\n  // Run on every render\n  useEffect(() => {\n    console.log('Component rendered');\n  });\n\n  return <div>{data?.name}</div>;\n}\n\n// useLayoutEffect (synchronous componentDidMount)\nfunction LayoutEffectExample() {\n  const [width, setWidth] = useState(0);\n  const divRef = useRef();\n\n  useLayoutEffect(() => {\n    // Runs synchronously after DOM mutations\n    // Before browser paints\n    setWidth(divRef.current.offsetWidth);\n  }, []);\n\n  return <div ref={divRef}>Width: {width}</div>;\n}"
    },
    {
      "id": 52,
      "question": "What are the key differences between class components and functional components with hooks?",
      "answer": "Class components and functional components with hooks represent two paradigms for building React components, with modern React favoring hooks.\n\nSyntax and Complexity:\n• Class: More boilerplate, need constructor, this binding\n• Functional: Simpler, less code, no this keyword\n• Class: Extends React.Component\n• Functional: Plain JavaScript functions\n\nState Management:\n• Class: this.state object, this.setState()\n• Functional: useState hook, multiple state variables\n• Class: State must be object\n• Functional: State can be any type\n\nLifecycle:\n• Class: Lifecycle methods (componentDidMount, etc.)\n• Functional: useEffect hook handles all lifecycle\n• Class: Logic spread across multiple methods\n• Functional: Related logic grouped together\n\nCode Reusability:\n• Class: HOCs, render props patterns\n• Functional: Custom hooks for logic reuse\n• Class: Can be complex and nested\n• Functional: Simpler composition\n\nPerformance:\n• Class: Slightly heavier\n• Functional: Lighter, better tree shaking\n• Both: Similar runtime performance\n\nModern Best Practices:\n• Use functional components with hooks\n• Classes maintained for legacy support\n• Hooks provide better code organization",
      "explanation": "Functional components with hooks are simpler, more concise, and easier to test than class components. They provide better code reusability through custom hooks and are the modern standard in React development.",
      "difficulty": "Medium",
      "code": "// Class Component\nclass Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0,\n      name: 'Counter'\n    };\n    // Need to bind methods\n    this.increment = this.increment.bind(this);\n  }\n\n  componentDidMount() {\n    document.title = `Count: ${this.state.count}`;\n  }\n\n  componentDidUpdate() {\n    document.title = `Count: ${this.state.count}`;\n  }\n\n  componentWillUnmount() {\n    console.log('Cleanup');\n  }\n\n  increment() {\n    this.setState({ count: this.state.count + 1 });\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>{this.state.name}</h1>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment</button>\n      </div>\n    );\n  }\n}\n\n// Functional Component with Hooks (Equivalent)\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const [name, setName] = useState('Counter');\n\n  // Combines componentDidMount and componentDidUpdate\n  useEffect(() => {\n    document.title = `Count: ${count}`;\n  }, [count]);\n\n  // componentWillUnmount equivalent\n  useEffect(() => {\n    return () => {\n      console.log('Cleanup');\n    };\n  }, []);\n\n  // No need to bind\n  const increment = () => {\n    setCount(count + 1);\n  };\n\n  return (\n    <div>\n      <h1>{name}</h1>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n}\n\n// Complex example: Data fetching\n\n// Class Component\nclass UserList extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      users: [],\n      loading: true,\n      error: null\n    };\n  }\n\n  componentDidMount() {\n    this.fetchUsers();\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.filter !== this.props.filter) {\n      this.fetchUsers();\n    }\n  }\n\n  async fetchUsers() {\n    try {\n      this.setState({ loading: true });\n      const users = await api.getUsers(this.props.filter);\n      this.setState({ users, loading: false });\n    } catch (error) {\n      this.setState({ error, loading: false });\n    }\n  }\n\n  render() {\n    if (this.state.loading) return <Spinner />;\n    if (this.state.error) return <Error error={this.state.error} />;\n    return (\n      <ul>\n        {this.state.users.map(user => (\n          <li key={user.id}>{user.name}</li>\n        ))}\n      </ul>\n    );\n  }\n}\n\n// Functional Component (Cleaner)\nfunction UserList({ filter }) {\n  const [users, setUsers] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    let cancelled = false;\n\n    async function fetchUsers() {\n      try {\n        setLoading(true);\n        const data = await api.getUsers(filter);\n        if (!cancelled) {\n          setUsers(data);\n          setLoading(false);\n        }\n      } catch (err) {\n        if (!cancelled) {\n          setError(err);\n          setLoading(false);\n        }\n      }\n    }\n\n    fetchUsers();\n\n    return () => {\n      cancelled = true;\n    };\n  }, [filter]);\n\n  if (loading) return <Spinner />;\n  if (error) return <Error error={error} />;\n  return (\n    <ul>\n      {users.map(user => (\n        <li key={user.id}>{user.name}</li>\n      ))}\n    </ul>\n  );\n}\n\n// Custom Hook (Not possible with classes)\nfunction useUsers(filter) {\n  const [users, setUsers] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    let cancelled = false;\n\n    api.getUsers(filter)\n      .then(data => !cancelled && setUsers(data))\n      .catch(err => !cancelled && setError(err))\n      .finally(() => !cancelled && setLoading(false));\n\n    return () => { cancelled = true; };\n  }, [filter]);\n\n  return { users, loading, error };\n}\n\n// Use custom hook\nfunction UserList({ filter }) {\n  const { users, loading, error } = useUsers(filter);\n\n  if (loading) return <Spinner />;\n  if (error) return <Error error={error} />;\n  return (\n    <ul>\n      {users.map(user => <li key={user.id}>{user.name}</li>)}\n    </ul>\n  );\n}"
    },
    {
      "id": 53,
      "question": "What is getDerivedStateFromProps and when should you use it?",
      "answer": "getDerivedStateFromProps is a static lifecycle method that allows a component to update its state based on changes in props before rendering.\n\nKey Characteristics:\n• Static Method: No access to this or instance methods\n• Called Before Render: Runs on mount and every update\n• Returns State Object: Return object to update state, null for no update\n• Replaces componentWillReceiveProps: Safer alternative\n• Rare Use Case: Most components don't need it\n• No Side Effects: Pure function, no API calls\n\nWhen to Use (Rarely):\n• Deriving State from Props: Compute state from prop changes\n• Props-Driven Animations: Reset animation state on prop change\n• Form Reset: Reset form when editing different item\n• Controlled-Uncontrolled Hybrid: Rare edge case\n\nWhen NOT to Use (Usually):\n• Side Effects: Use componentDidUpdate instead\n• Fetching Data: Use componentDidMount/useEffect\n• Can Derive in Render: Just compute during render\n• Callbacks: Use componentDidUpdate\n\nBetter Alternatives:\n• Fully Controlled Component: Lift state up\n• Fully Uncontrolled with Key: Reset with key prop\n• Memoization: Use useMemo in functional components\n• useEffect: In functional components",
      "explanation": "getDerivedStateFromProps is a static lifecycle method for deriving state from props before render. It's rarely needed and alternatives like controlled components or key prop are usually better.",
      "difficulty": "Hard",
      "code": "// Basic usage\nclass EmailInput extends React.Component {\n  state = {\n    email: this.props.defaultEmail || ''\n  };\n\n  static getDerivedStateFromProps(props, state) {\n    // Called on every render (mount and update)\n    // Update state if prop changes\n    if (props.defaultEmail !== state.prevDefaultEmail) {\n      return {\n        email: props.defaultEmail,\n        prevDefaultEmail: props.defaultEmail\n      };\n    }\n    return null; // No state update\n  }\n\n  handleChange = (e) => {\n    this.setState({ email: e.target.value });\n  };\n\n  render() {\n    return (\n      <input\n        value={this.state.email}\n        onChange={this.handleChange}\n      />\n    );\n  }\n}\n\n// Problem: Erases user input\nclass ProblematicComponent extends React.Component {\n  state = { text: '' };\n\n  static getDerivedStateFromProps(props, state) {\n    // BAD: This runs on every render!\n    // Erases user's typing\n    return { text: props.value };\n  }\n\n  render() {\n    return (\n      <input\n        value={this.state.text}\n        onChange={(e) => this.setState({ text: e.target.value })}\n      />\n    );\n  }\n}\n\n// Better Alternative 1: Fully Controlled\nfunction ControlledComponent({ value, onChange }) {\n  // No local state, parent controls everything\n  return <input value={value} onChange={onChange} />;\n}\n\n// Better Alternative 2: Key Prop Reset\nfunction FormWithReset({ userId }) {\n  // Key changes when userId changes, completely resets component\n  return <UserForm key={userId} userId={userId} />;\n}\n\nfunction UserForm({ userId }) {\n  const [name, setName] = useState('');\n  const [email, setEmail] = useState('');\n\n  useEffect(() => {\n    // Fetch user data when userId changes\n    api.getUser(userId).then(user => {\n      setName(user.name);\n      setEmail(user.email);\n    });\n  }, [userId]);\n\n  return (\n    <form>\n      <input value={name} onChange={(e) => setName(e.target.value)} />\n      <input value={email} onChange={(e) => setEmail(e.target.value)} />\n    </form>\n  );\n}\n\n// Better Alternative 3: useEffect in hooks\nfunction EmailInput({ defaultEmail }) {\n  const [email, setEmail] = useState(defaultEmail);\n\n  // Only update when defaultEmail changes\n  useEffect(() => {\n    setEmail(defaultEmail);\n  }, [defaultEmail]);\n\n  return (\n    <input\n      value={email}\n      onChange={(e) => setEmail(e.target.value)}\n    />\n  );\n}\n\n// Legitimate use case: Animation reset\nclass ScrollView extends React.Component {\n  state = {\n    scrollTop: 0,\n    prevItemId: this.props.itemId\n  };\n\n  static getDerivedStateFromProps(props, state) {\n    // Reset scroll when viewing different item\n    if (props.itemId !== state.prevItemId) {\n      return {\n        scrollTop: 0,\n        prevItemId: props.itemId\n      };\n    }\n    return null;\n  }\n\n  render() {\n    return (\n      <div\n        style={{ overflow: 'auto' }}\n        scrollTop={this.state.scrollTop}\n      >\n        {this.props.children}\n      </div>\n    );\n  }\n}\n\n// Hooks equivalent (better)\nfunction ScrollView({ itemId, children }) {\n  const [scrollTop, setScrollTop] = useState(0);\n  const divRef = useRef();\n\n  useEffect(() => {\n    // Reset scroll when item changes\n    if (divRef.current) {\n      divRef.current.scrollTop = 0;\n    }\n    setScrollTop(0);\n  }, [itemId]);\n\n  return (\n    <div ref={divRef} style={{ overflow: 'auto' }}>\n      {children}\n    </div>\n  );\n}"
    },
    {
      "id": 54,
      "question": "How do refs work in class components vs functional components?",
      "answer": "Refs provide a way to access DOM nodes or React component instances directly, with different approaches in class and functional components.\n\nClass Components:\n• createRef(): Create ref object in constructor\n• String Refs: Legacy, deprecated, don't use\n• Callback Refs: Function that receives element\n• Access via this.myRef.current\n• Can reference DOM elements or class components\n• Attached via ref attribute\n\nFunctional Components:\n• useRef(): Hook to create ref\n• Returns mutable ref object\n• Persists across renders\n• Access via refName.current\n• Cannot reference function components (use forwardRef)\n• Can store any mutable value\n\nCommon Use Cases:\n• DOM Manipulation: Focus, scroll, measure\n• Third-Party Libraries: Integration requiring DOM nodes\n• Animations: Imperative animations\n• Previous Values: Store previous prop/state\n• Timers: Store timeout/interval IDs\n• Instance Values: Values that don't trigger re-render\n\nBest Practices:\n• Avoid Overuse: Prefer declarative React patterns\n• DOM Refs: Use when declarative approach insufficient\n• Forward Refs: Expose refs through components",
      "explanation": "Refs allow direct access to DOM nodes or component instances. Class components use createRef() or callback refs, while functional components use useRef() hook. Both provide escape hatches for imperative operations.",
      "difficulty": "Medium",
      "code": "// Class Component - createRef\nclass TextInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.inputRef = React.createRef();\n    this.divRef = React.createRef();\n  }\n\n  componentDidMount() {\n    // Access DOM element\n    this.inputRef.current.focus();\n    console.log(this.divRef.current.offsetHeight);\n  }\n\n  handleClick = () => {\n    this.inputRef.current.select();\n  };\n\n  render() {\n    return (\n      <div ref={this.divRef}>\n        <input ref={this.inputRef} type=\"text\" />\n        <button onClick={this.handleClick}>Select Text</button>\n      </div>\n    );\n  }\n}\n\n// Class Component - Callback Ref\nclass CallbackRefExample extends React.Component {\n  setInputRef = (element) => {\n    // Called with element on mount, null on unmount\n    this.inputRef = element;\n  };\n\n  componentDidMount() {\n    if (this.inputRef) {\n      this.inputRef.focus();\n    }\n  }\n\n  render() {\n    return <input ref={this.setInputRef} />;\n  }\n}\n\n// Functional Component - useRef\nfunction TextInput() {\n  const inputRef = useRef(null);\n  const divRef = useRef(null);\n\n  useEffect(() => {\n    // Access DOM element\n    inputRef.current.focus();\n    console.log(divRef.current.offsetHeight);\n  }, []);\n\n  const handleClick = () => {\n    inputRef.current.select();\n  };\n\n  return (\n    <div ref={divRef}>\n      <input ref={inputRef} type=\"text\" />\n      <button onClick={handleClick}>Select Text</button>\n    </div>\n  );\n}\n\n// Functional Component - Callback Ref\nfunction CallbackRefExample() {\n  const [height, setHeight] = useState(0);\n\n  const measureRef = useCallback((node) => {\n    if (node !== null) {\n      setHeight(node.offsetHeight);\n    }\n  }, []);\n\n  return (\n    <div>\n      <div ref={measureRef}>Measure me</div>\n      <p>Height: {height}px</p>\n    </div>\n  );\n}\n\n// Ref to Class Component\nclass ChildClass extends React.Component {\n  getValue() {\n    return 'value from child';\n  }\n\n  render() {\n    return <div>Child</div>;\n  }\n}\n\nfunction ParentWithClassRef() {\n  const childRef = useRef();\n\n  const handleClick = () => {\n    // Can call child methods\n    console.log(childRef.current.getValue());\n  };\n\n  return (\n    <div>\n      <ChildClass ref={childRef} />\n      <button onClick={handleClick}>Get Value</button>\n    </div>\n  );\n}\n\n// Cannot ref functional component (need forwardRef)\nfunction ChildFunction() {\n  return <div>Child</div>;\n}\n\n// This doesn't work:\n// function Parent() {\n//   const childRef = useRef();\n//   return <ChildFunction ref={childRef} />; // Error!\n// }\n\n// Need forwardRef:\nconst ChildFunction = forwardRef((props, ref) => {\n  return <div ref={ref}>Child</div>;\n});\n\nfunction Parent() {\n  const childRef = useRef();\n  \n  useEffect(() => {\n    console.log(childRef.current); // Now works!\n  }, []);\n\n  return <ChildFunction ref={childRef} />;\n}\n\n// Storing mutable values (not DOM)\nfunction Timer() {\n  const [count, setCount] = useState(0);\n  const intervalRef = useRef();\n\n  useEffect(() => {\n    // Store interval ID in ref\n    intervalRef.current = setInterval(() => {\n      setCount(c => c + 1);\n    }, 1000);\n\n    return () => {\n      clearInterval(intervalRef.current);\n    };\n  }, []);\n\n  const handleStop = () => {\n    clearInterval(intervalRef.current);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={handleStop}>Stop</button>\n    </div>\n  );\n}\n\n// Storing previous value\nfunction usePrevious(value) {\n  const ref = useRef();\n  \n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  \n  return ref.current;\n}\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const prevCount = usePrevious(count);\n\n  return (\n    <div>\n      <p>Current: {count}</p>\n      <p>Previous: {prevCount}</p>\n      <button onClick={() => setCount(count + 1)}>+</button>\n    </div>\n  );\n}"
    },
    {
      "id": 55,
      "question": "What are error boundaries and how do you implement them?",
      "answer": "Error boundaries are React components that catch JavaScript errors in their child component tree, log errors, and display fallback UI instead of crashing the whole app.\n\nKey Features:\n• Error Catching: Catches errors during rendering, lifecycle, constructors\n• Fallback UI: Display error message or alternative UI\n• Error Logging: Log errors to error reporting service\n• Granular Control: Place at different levels in tree\n• Class Components Only: Must be class component (no hook equivalent yet)\n• Declarative Error Handling: Handle errors declaratively\n\nWhat They Catch:\n• Rendering errors\n• Lifecycle method errors\n• Constructor errors in child components\n\nWhat They Don't Catch:\n• Event handlers (use try-catch)\n• Async code (setTimeout, promises)\n• Server-side rendering\n• Errors in error boundary itself\n• Errors thrown in event handlers\n\nImplementation:\n• Use componentDidCatch: Log error information\n• Use static getDerivedStateFromError: Update state for fallback UI\n• Wrap components that might error\n• Can have multiple boundaries at different levels",
      "explanation": "Error boundaries are special class components that catch errors in child components, display fallback UI, and prevent entire app crashes. They use componentDidCatch and getDerivedStateFromError lifecycle methods.",
      "difficulty": "Medium",
      "code": "// Basic Error Boundary\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state to show fallback UI\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // Log error to error reporting service\n    console.error('Error caught:', error);\n    console.error('Error info:', errorInfo);\n    \n    // Send to logging service\n    logErrorToService(error, errorInfo);\n    \n    this.setState({\n      error,\n      errorInfo\n    });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div>\n          <h1>Something went wrong.</h1>\n          <details style={{ whiteSpace: 'pre-wrap' }}>\n            {this.state.error && this.state.error.toString()}\n            <br />\n            {this.state.errorInfo.componentStack}\n          </details>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n// Usage\nfunction App() {\n  return (\n    <ErrorBoundary>\n      <UserProfile />\n      <Dashboard />\n    </ErrorBoundary>\n  );\n}\n\n// Advanced Error Boundary with Reset\nclass AdvancedErrorBoundary extends React.Component {\n  state = {\n    hasError: false,\n    error: null\n  };\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    logErrorToService(error, errorInfo);\n  }\n\n  resetErrorBoundary = () => {\n    this.setState({ hasError: false, error: null });\n  };\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div>\n          <h2>Oops! Something went wrong.</h2>\n          <p>{this.state.error.message}</p>\n          <button onClick={this.resetErrorBoundary}>\n            Try Again\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n// Multiple Error Boundaries\nfunction App() {\n  return (\n    <div>\n      <ErrorBoundary fallback={<h2>Sidebar error</h2>}>\n        <Sidebar />\n      </ErrorBoundary>\n      \n      <ErrorBoundary fallback={<h2>Content error</h2>}>\n        <MainContent />\n      </ErrorBoundary>\n    </div>\n  );\n}\n\n// Custom Fallback Component\nclass ErrorBoundaryWithFallback extends React.Component {\n  state = { hasError: false, error: null };\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    logErrorToService(error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      const { fallback } = this.props;\n      return typeof fallback === 'function'\n        ? fallback(this.state.error)\n        : fallback;\n    }\n\n    return this.props.children;\n  }\n}\n\n// Usage with custom fallback\n<ErrorBoundaryWithFallback\n  fallback={(error) => <ErrorPage error={error} />}\n>\n  <App />\n</ErrorBoundaryWithFallback>\n\n// Component that throws error\nfunction BuggyComponent({ shouldError }) {\n  if (shouldError) {\n    throw new Error('I crashed!');\n  }\n  return <div>All good!</div>;\n}\n\n// Event handler errors (NOT caught by error boundary)\nfunction EventErrorExample() {\n  const handleClick = () => {\n    try {\n      // Error boundaries don't catch this\n      throw new Error('Button error');\n    } catch (error) {\n      // Handle manually\n      console.error(error);\n    }\n  };\n\n  return <button onClick={handleClick}>Click</button>;\n}\n\n// React Query style error boundary\nclass QueryErrorBoundary extends React.Component {\n  state = { hasError: false };\n\n  static getDerivedStateFromError() {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    if (error.name === 'ChunkLoadError') {\n      // Handle code splitting errors\n      window.location.reload();\n    }\n    logErrorToService(error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div>\n          <h2>Failed to load component</h2>\n          <button onClick={() => window.location.reload()}>\n            Reload Page\n          </button>\n        </div>\n      );\n    }\n    return this.props.children;\n  }\n}"
    },
    {
      "id": 56,
      "question": "What is React.PureComponent and how does it differ from React.Component?",
      "answer": "PureComponent is a base class similar to Component but implements shouldComponentUpdate with shallow prop and state comparison for performance optimization.\n\nKey Differences:\n• Automatic shouldComponentUpdate: PureComponent implements it automatically\n• Shallow Comparison: Compares props and state shallowly\n• Re-render Optimization: Skips re-renders when props/state haven't changed\n• Component: Always re-renders when parent re-renders\n• Performance: PureComponent is faster for certain cases\n\nShallow Comparison:\n• Compares primitive values by value\n• Compares objects/arrays by reference only\n• Doesn't check nested object properties\n• Can miss updates if mutating objects directly\n\nWhen to Use PureComponent:\n• Props and state are primitives or immutable objects\n• Frequent parent re-renders with same props\n• Component renders same output for same props/state\n• Performance bottleneck identified\n\nWhen NOT to Use:\n• Complex nested data structures\n• Mutating props or state directly\n• Props contain functions created inline\n• Unpredictable prop changes\n\nFunctional Equivalent:\n• React.memo for functional components\n• Similar shallow comparison behavior",
      "explanation": "PureComponent implements shouldComponentUpdate with shallow comparison to prevent unnecessary re-renders, improving performance when props/state haven't changed. Use with immutable data patterns for best results.",
      "difficulty": "Medium",
      "code": "// Regular Component (always re-renders)\nclass RegularComponent extends React.Component {\n  render() {\n    console.log('RegularComponent render');\n    return <div>{this.props.name}</div>;\n  }\n}\n\n// PureComponent (skips re-render if props unchanged)\nclass PureComponentExample extends React.PureComponent {\n  render() {\n    console.log('PureComponent render');\n    return <div>{this.props.name}</div>;\n  }\n}\n\n// Parent component\nclass Parent extends React.Component {\n  state = { count: 0 };\n\n  render() {\n    return (\n      <div>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n          Count: {this.state.count}\n        </button>\n        {/* RegularComponent re-renders every time */}\n        <RegularComponent name=\"John\" />\n        {/* PureComponent skips re-render (name unchanged) */}\n        <PureComponentExample name=\"John\" />\n      </div>\n    );\n  }\n}\n\n// Manual shouldComponentUpdate (equivalent to PureComponent)\nclass ManualOptimization extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    // Shallow comparison\n    return (\n      nextProps.name !== this.props.name ||\n      nextState.value !== this.state.value\n    );\n  }\n\n  render() {\n    return <div>{this.props.name}</div>;\n  }\n}\n\n// Problem: Mutation breaks PureComponent\nclass ProblematicPureComponent extends React.PureComponent {\n  render() {\n    return (\n      <ul>\n        {this.props.items.map(item => <li key={item}>{item}</li>)}\n      </ul>\n    );\n  }\n}\n\nclass ProblematicParent extends React.Component {\n  state = { items: ['a', 'b'] };\n\n  addItem = () => {\n    // BAD: Mutates array directly\n    this.state.items.push('c');\n    this.setState({ items: this.state.items });\n    // PureComponent won't detect change (same reference)\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.addItem}>Add Item</button>\n        <ProblematicPureComponent items={this.state.items} />\n      </div>\n    );\n  }\n}\n\n// Solution: Immutable updates\nclass CorrectParent extends React.Component {\n  state = { items: ['a', 'b'] };\n\n  addItem = () => {\n    // GOOD: Creates new array\n    this.setState({ \n      items: [...this.state.items, 'c'] \n    });\n    // PureComponent detects change (new reference)\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.addItem}>Add Item</button>\n        <ProblematicPureComponent items={this.state.items} />\n      </div>\n    );\n  }\n}\n\n// Problem: Inline functions\nclass InlineFunctionProblem extends React.Component {\n  render() {\n    return (\n      <div>\n        {/* New function every render, PureComponent always re-renders */}\n        <PureChild onClick={() => console.log('clicked')} />\n      </div>\n    );\n  }\n}\n\n// Solution: Bind in constructor or use class field\nclass InlineFunctionSolution extends React.Component {\n  handleClick = () => {\n    console.log('clicked');\n  };\n\n  render() {\n    return (\n      <div>\n        {/* Same function reference, PureComponent can skip render */}\n        <PureChild onClick={this.handleClick} />\n      </div>\n    );\n  }\n}\n\n// Functional component equivalent: React.memo\nconst MemoComponent = React.memo(function MyComponent({ name }) {\n  console.log('MemoComponent render');\n  return <div>{name}</div>;\n});\n\n// Custom comparison function\nconst CustomMemo = React.memo(\n  function MyComponent({ user }) {\n    return <div>{user.name}</div>;\n  },\n  (prevProps, nextProps) => {\n    // Return true if props are equal (skip render)\n    return prevProps.user.id === nextProps.user.id;\n  }\n);\n\n// Nested object comparison pitfall\nclass NestedObjectPitfall extends React.PureComponent {\n  render() {\n    // Won't detect deep changes in user object\n    return <div>{this.props.user.profile.name}</div>;\n  }\n}\n\nclass ParentWithNestedObject extends React.Component {\n  state = {\n    user: {\n      id: 1,\n      profile: { name: 'John' }\n    }\n  };\n\n  updateName = () => {\n    // BAD: Mutates nested object\n    this.state.user.profile.name = 'Jane';\n    this.setState({ user: this.state.user });\n    // PureComponent won't re-render (same reference)\n  };\n\n  updateNameCorrectly = () => {\n    // GOOD: Creates new object hierarchy\n    this.setState({\n      user: {\n        ...this.state.user,\n        profile: {\n          ...this.state.user.profile,\n          name: 'Jane'\n        }\n      }\n    });\n    // PureComponent detects change\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.updateNameCorrectly}>Update</button>\n        <NestedObjectPitfall user={this.state.user} />\n      </div>\n    );\n  }\n}"
    },
    {
      "id": 57,
      "question": "What is shouldComponentUpdate and how can you use it for performance optimization?",
      "answer": "shouldComponentUpdate is a lifecycle method that determines whether a component should re-render, allowing manual control over rendering performance.\n\nHow It Works:\n• Called before rendering when props or state change\n• Receives nextProps and nextState as arguments\n• Returns true (re-render) or false (skip render)\n• Default behavior: always returns true\n• PureComponent implements it with shallow comparison\n• Not called on initial render or with forceUpdate()\n\nOptimization Strategies:\n• Primitive Comparison: Compare simple values directly\n• Reference Comparison: Check if object references changed\n• Selective Comparison: Only compare relevant props/state\n• Deep Comparison: Use libraries for complex objects (expensive)\n• Immutable Data: Makes comparison easier and faster\n\nWhen to Use:\n• Performance Bottlenecks: Identified through profiling\n• Expensive Renders: Complex calculations or large lists\n• Frequent Updates: Parent re-renders often with same props\n• Known Patterns: Can predict when updates aren't needed\n\nBest Practices:\n• Profile First: Measure before optimizing\n• Prefer PureComponent or React.memo: Automatic optimization\n• Immutable Updates: Makes comparison reliable\n• Avoid Premature Optimization: Only optimize when needed",
      "explanation": "shouldComponentUpdate allows manual control over re-rendering by comparing current and next props/state. Return false to skip render. Use with immutable data patterns for reliable performance optimization.",
      "difficulty": "Medium",
      "code": "// Basic shouldComponentUpdate\nclass OptimizedComponent extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    // Only re-render if name or count changed\n    return (\n      nextProps.name !== this.props.name ||\n      nextState.count !== this.state.count\n    );\n  }\n\n  render() {\n    console.log('Render called');\n    return (\n      <div>\n        <p>{this.props.name}</p>\n        <p>{this.state.count}</p>\n      </div>\n    );\n  }\n}\n\n// Complex comparison example\nclass ListComponent extends React.Component {\n  shouldComponentUpdate(nextProps) {\n    // Check if array length changed\n    if (nextProps.items.length !== this.props.items.length) {\n      return true;\n    }\n\n    // Check if any item changed (shallow comparison)\n    for (let i = 0; i < nextProps.items.length; i++) {\n      if (nextProps.items[i] !== this.props.items[i]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  render() {\n    return (\n      <ul>\n        {this.props.items.map(item => <li key={item.id}>{item.name}</li>)}\n      </ul>\n    );\n  }\n}\n\n// Selective prop comparison\nclass UserProfile extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    // Only care about specific props\n    return (\n      nextProps.userId !== this.props.userId ||\n      nextProps.isActive !== this.props.isActive\n    );\n    // Ignore other props like callbacks, style, etc.\n  }\n\n  render() {\n    return <div>{this.props.userName}</div>;\n  }\n}\n\n// Performance comparison\nclass WithoutOptimization extends React.Component {\n  render() {\n    console.log('WithoutOptimization render');\n    return <div>{this.props.value}</div>;\n  }\n}\n\nclass WithOptimization extends React.Component {\n  shouldComponentUpdate(nextProps) {\n    return nextProps.value !== this.props.value;\n  }\n\n  render() {\n    console.log('WithOptimization render');\n    return <div>{this.props.value}</div>;\n  }\n}\n\nclass Parent extends React.Component {\n  state = { count: 0, unrelated: 0 };\n\n  render() {\n    return (\n      <div>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n          Update Value: {this.state.count}\n        </button>\n        <button onClick={() => this.setState({ unrelated: this.state.unrelated + 1 })}>\n          Unrelated Update: {this.state.unrelated}\n        </button>\n        \n        {/* Renders on every parent update */}\n        <WithoutOptimization value={this.state.count} />\n        \n        {/* Only renders when value changes */}\n        <WithOptimization value={this.state.count} />\n      </div>\n    );\n  }\n}\n\n// Deep comparison (expensive, use sparingly)\nimport isEqual from 'lodash/isEqual';\n\nclass DeepComparisonComponent extends React.Component {\n  shouldComponentUpdate(nextProps) {\n    // Deep equality check (expensive!)\n    return !isEqual(nextProps.data, this.props.data);\n  }\n\n  render() {\n    return <div>{JSON.stringify(this.props.data)}</div>;\n  }\n}\n\n// Functional component equivalent with React.memo\nconst OptimizedFunctional = React.memo(\n  function MyComponent({ name, count }) {\n    console.log('Render called');\n    return (\n      <div>\n        <p>{name}</p>\n        <p>{count}</p>\n      </div>\n    );\n  },\n  (prevProps, nextProps) => {\n    // Return true if props are equal (skip render)\n    return (\n      prevProps.name === nextProps.name &&\n      prevProps.count === nextProps.count\n    );\n  }\n);\n\n// Common pitfall: Always returning same reference\nclass PitfallComponent extends React.Component {\n  shouldComponentUpdate(nextProps) {\n    // BAD: Object/array comparison by reference\n    return nextProps.config !== this.props.config;\n  }\n\n  render() {\n    return <div>{this.props.config.theme}</div>;\n  }\n}\n\nclass PitfallParent extends React.Component {\n  render() {\n    // Creates new object every render\n    const config = { theme: 'dark' };\n    // PitfallComponent always re-renders (new reference)\n    return <PitfallComponent config={config} />;\n  }\n}\n\n// Solution: Stable references\nclass SolutionParent extends React.Component {\n  config = { theme: 'dark' }; // Stable reference\n\n  render() {\n    return <PitfallComponent config={this.config} />;\n  }\n}\n\n// Advanced: Multiple optimization strategies\nclass AdvancedOptimization extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    // Strategy 1: Primitive props\n    if (nextProps.id !== this.props.id) return true;\n    if (nextState.localCount !== this.state.localCount) return true;\n\n    // Strategy 2: Array length check\n    if (nextProps.items.length !== this.props.items.length) return true;\n\n    // Strategy 3: Version/timestamp check\n    if (nextProps.dataVersion !== this.props.dataVersion) return true;\n\n    // Strategy 4: Selective deep check (only if needed)\n    if (nextProps.criticalData) {\n      return !shallowEqual(nextProps.criticalData, this.props.criticalData);\n    }\n\n    return false;\n  }\n\n  render() {\n    return <div>Optimized Content</div>;\n  }\n}\n\nfunction shallowEqual(obj1, obj2) {\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  \n  if (keys1.length !== keys2.length) return false;\n  \n  for (let key of keys1) {\n    if (obj1[key] !== obj2[key]) return false;\n  }\n  \n  return true;\n}"
    },
    {
      "id": 58,
      "question": "What are the best practices for React performance optimization?",
      "answer": "React performance optimization involves identifying bottlenecks and applying appropriate techniques to improve rendering speed and user experience.\n\nCore Optimization Techniques:\n• React.memo: Prevent re-renders of functional components\n• useMemo: Memoize expensive calculations\n• useCallback: Memoize callback functions\n• Code Splitting: Lazy load components with React.lazy\n• Virtual Lists: Render only visible items in long lists\n• Debouncing/Throttling: Limit expensive operations\n• Production Build: Use optimized production builds\n• Key Optimization: Proper keys for lists\n\nState Management:\n• Local State: Keep state as local as possible\n• State Colocation: Move state close to where it's used\n• Context Optimization: Split contexts to avoid unnecessary updates\n• State Structure: Flatten state, avoid nested objects\n• Immutable Updates: Enable shallow comparison optimizations\n\nRendering Optimization:\n• Avoid Inline Functions: Stable function references\n• Avoid Inline Objects: Stable object references\n• Conditional Rendering: Skip rendering unnecessary parts\n• Fragment Usage: Avoid extra DOM nodes\n• CSS-in-JS Optimization: Use static styles when possible\n\nProfiling and Measurement:\n• React DevTools Profiler: Identify slow components\n• Performance API: Measure actual performance\n• User-Centric Metrics: FCP, LCP, TTI\n• Before Optimizing: Always profile first",
      "explanation": "React performance optimization requires profiling to identify bottlenecks, then applying techniques like memoization, code splitting, virtual lists, and proper state management to improve rendering speed and user experience.",
      "difficulty": "Hard",
      "code": "// 1. React.memo for component memoization\nconst ExpensiveComponent = React.memo(({ data }) => {\n  console.log('Expensive render');\n  return <div>{data.map(item => <div key={item.id}>{item.name}</div>)}</div>;\n});\n\n// 2. useMemo for expensive calculations\nfunction DataList({ items, filter }) {\n  // Memoize expensive filtering\n  const filteredItems = useMemo(() => {\n    console.log('Filtering items...');\n    return items.filter(item => \n      item.name.toLowerCase().includes(filter.toLowerCase())\n    );\n  }, [items, filter]); // Only recalculate when dependencies change\n\n  return (\n    <ul>\n      {filteredItems.map(item => <li key={item.id}>{item.name}</li>)}\n    </ul>\n  );\n}\n\n// 3. useCallback for stable function references\nfunction ParentComponent() {\n  const [count, setCount] = useState(0);\n  const [text, setText] = useState('');\n\n  // Without useCallback: new function every render\n  // const handleClick = () => console.log(text);\n\n  // With useCallback: stable reference\n  const handleClick = useCallback(() => {\n    console.log(text);\n  }, [text]);\n\n  return (\n    <div>\n      <input value={text} onChange={(e) => setText(e.target.value)} />\n      <button onClick={() => setCount(count + 1)}>Count: {count}</button>\n      {/* ExpensiveComponent won't re-render when count changes */}\n      <ExpensiveComponent onClick={handleClick} />\n    </div>\n  );\n}\n\nconst ExpensiveComponent = React.memo(({ onClick }) => {\n  console.log('ExpensiveComponent render');\n  return <button onClick={onClick}>Click me</button>;\n});\n\n// 4. Code splitting with React.lazy\nconst HeavyComponent = React.lazy(() => import('./HeavyComponent'));\n\nfunction App() {\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <HeavyComponent />\n    </Suspense>\n  );\n}\n\n// 5. Virtual list for long lists\nimport { FixedSizeList } from 'react-window';\n\nfunction VirtualList({ items }) {\n  const Row = ({ index, style }) => (\n    <div style={style}>{items[index].name}</div>\n  );\n\n  return (\n    <FixedSizeList\n      height={400}\n      itemCount={items.length}\n      itemSize={35}\n      width=\"100%\"\n    >\n      {Row}\n    </FixedSizeList>\n  );\n}\n\n// 6. Debouncing expensive operations\nfunction SearchComponent() {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n\n  // Debounce search\n  const debouncedSearch = useMemo(\n    () => debounce(async (searchQuery) => {\n      const data = await api.search(searchQuery);\n      setResults(data);\n    }, 300),\n    []\n  );\n\n  useEffect(() => {\n    if (query) {\n      debouncedSearch(query);\n    }\n  }, [query, debouncedSearch]);\n\n  return (\n    <div>\n      <input value={query} onChange={(e) => setQuery(e.target.value)} />\n      <Results data={results} />\n    </div>\n  );\n}\n\n// 7. Avoid inline objects and functions\n// BAD: Creates new object every render\nfunction BadExample() {\n  return <Component style={{ margin: 10 }} />;\n}\n\n// GOOD: Stable reference\nconst style = { margin: 10 };\nfunction GoodExample() {\n  return <Component style={style} />;\n}\n\n// 8. Context optimization\n// BAD: Entire context updates\nconst AppContext = createContext();\n\nfunction Provider({ children }) {\n  const [user, setUser] = useState(null);\n  const [theme, setTheme] = useState('light');\n  \n  const value = { user, setUser, theme, setTheme };\n  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;\n}\n\n// GOOD: Split contexts\nconst UserContext = createContext();\nconst ThemeContext = createContext();\n\nfunction BetterProvider({ children }) {\n  const [user, setUser] = useState(null);\n  const [theme, setTheme] = useState('light');\n  \n  return (\n    <UserContext.Provider value={{ user, setUser }}>\n      <ThemeContext.Provider value={{ theme, setTheme }}>\n        {children}\n      </ThemeContext.Provider>\n    </UserContext.Provider>\n  );\n}\n\n// 9. State colocation\n// BAD: Global state for local UI\nfunction BadForm() {\n  const [formData, setFormData] = useGlobalState('form');\n  return <form>...</form>;\n}\n\n// GOOD: Local state\nfunction GoodForm() {\n  const [formData, setFormData] = useState({});\n  return <form>...</form>;\n}\n\n// 10. Proper list keys\n// BAD: Using index as key\nfunction BadList({ items }) {\n  return items.map((item, index) => <div key={index}>{item}</div>);\n}\n\n// GOOD: Using unique ID\nfunction GoodList({ items }) {\n  return items.map(item => <div key={item.id}>{item.name}</div>);\n}\n\n// 11. Profiling with React DevTools\nfunction ProfiledComponent() {\n  return (\n    <Profiler id=\"MyComponent\" onRender={onRenderCallback}>\n      <MyComponent />\n    </Profiler>\n  );\n}\n\nfunction onRenderCallback(\n  id, phase, actualDuration, baseDuration, startTime, commitTime\n) {\n  console.log(`${id} (${phase}) took ${actualDuration}ms`);\n}\n\n// 12. Conditional rendering optimization\nfunction OptimizedConditional({ show, heavyData }) {\n  // Only render heavy component when needed\n  if (!show) return null;\n  \n  return <HeavyComponent data={heavyData} />;\n}\n\n// 13. Transition API for non-urgent updates\nfunction SearchWithTransition() {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n  const [isPending, startTransition] = useTransition();\n\n  const handleSearch = (value) => {\n    setQuery(value);\n    startTransition(() => {\n      setResults(expensiveFilter(value));\n    });\n  };\n\n  return (\n    <div>\n      <input value={query} onChange={(e) => handleSearch(e.target.value)} />\n      {isPending && <Spinner />}\n      <Results data={results} />\n    </div>\n  );\n}"
    },
    {
      "id": 59,
      "question": "What is the React Profiler and how do you use it for performance analysis?",
      "answer": "The React Profiler is a built-in tool for measuring rendering performance, identifying bottlenecks, and understanding why components re-render.\n\nReact DevTools Profiler:\n• Visual Performance Analysis: Flame graphs, ranked charts\n• Component Render Times: See which components are slow\n• Render Causes: Why components re-rendered\n• Commit Information: What changed in each render\n• Filter Options: Focus on specific components\n• Record Sessions: Capture user interactions\n\nProfiler API:\n• Programmatic Profiling: Measure specific components\n• onRender Callback: Called when component renders\n• Phase Information: Mount vs update\n• Duration Metrics: Actual and base duration\n• Production Profiling: Can enable in production\n\nKey Metrics:\n• Actual Duration: Time to render component tree\n• Base Duration: Time without memoization\n• Start Time: When render started\n• Commit Time: When changes committed\n• Interactions: Track user interactions\n\nAnalysis Approach:\n• Record Interaction: Profile user workflow\n• Identify Slow Components: Yellow/red in flame graph\n• Check Render Frequency: How often component renders\n• Investigate Causes: Props changes, state updates\n• Optimize: Apply memoization, code splitting, etc.\n• Re-profile: Verify improvements",
      "explanation": "React Profiler is a performance analysis tool that visualizes rendering behavior, identifies slow components, and explains why re-renders occur. Use it to find bottlenecks before and after optimization.",
      "difficulty": "Medium",
      "code": "// Using Profiler API\nimport { Profiler } from 'react';\n\nfunction App() {\n  return (\n    <Profiler id=\"App\" onRender={onRenderCallback}>\n      <Navigation />\n      <Main />\n      <Sidebar />\n    </Profiler>\n  );\n}\n\nfunction onRenderCallback(\n  id,                  // \"App\" - Profiler id\n  phase,              // \"mount\" or \"update\"\n  actualDuration,     // Time to render committed update\n  baseDuration,       // Estimated time without memoization\n  startTime,          // When render started\n  commitTime,         // When React committed update\n  interactions        // Set of interactions being traced\n) {\n  console.log(`${id} rendered in ${actualDuration}ms`);\n  console.log(`Phase: ${phase}`);\n  console.log(`Base duration: ${baseDuration}ms`);\n  \n  // Send to analytics\n  if (actualDuration > 16) { // Slower than 60fps\n    logSlowRender({\n      component: id,\n      phase,\n      duration: actualDuration,\n      timestamp: commitTime\n    });\n  }\n}\n\n// Multiple Profilers for different sections\nfunction Dashboard() {\n  return (\n    <div>\n      <Profiler id=\"Header\" onRender={onRenderCallback}>\n        <Header />\n      </Profiler>\n      \n      <Profiler id=\"Charts\" onRender={onRenderCallback}>\n        <ChartsSection />\n      </Profiler>\n      \n      <Profiler id=\"DataTable\" onRender={onRenderCallback}>\n        <DataTable />\n      </Profiler>\n    </div>\n  );\n}\n\n// Advanced: Conditional profiling\nfunction ConditionalProfiling({ enableProfiling, children }) {\n  if (enableProfiling) {\n    return (\n      <Profiler id=\"ConditionalSection\" onRender={onRenderCallback}>\n        {children}\n      </Profiler>\n    );\n  }\n  return children;\n}\n\n// Collecting performance metrics\nclass PerformanceMonitor {\n  constructor() {\n    this.renders = [];\n    this.threshold = 16; // 60fps\n  }\n\n  onRender = (id, phase, actualDuration, baseDuration, startTime, commitTime) => {\n    const render = {\n      id,\n      phase,\n      actualDuration,\n      baseDuration,\n      startTime,\n      commitTime,\n      timestamp: Date.now()\n    };\n\n    this.renders.push(render);\n\n    // Alert on slow renders\n    if (actualDuration > this.threshold) {\n      console.warn(`Slow render detected: ${id} took ${actualDuration}ms`);\n    }\n\n    // Track render frequency\n    this.trackRenderFrequency(id);\n  };\n\n  trackRenderFrequency(componentId) {\n    const recentRenders = this.renders\n      .filter(r => r.id === componentId)\n      .filter(r => Date.now() - r.timestamp < 1000); // Last second\n\n    if (recentRenders.length > 10) {\n      console.warn(`${componentId} rendered ${recentRenders.length} times in 1s`);\n    }\n  }\n\n  getStats(componentId) {\n    const componentRenders = this.renders.filter(r => r.id === componentId);\n    const durations = componentRenders.map(r => r.actualDuration);\n\n    return {\n      count: componentRenders.length,\n      avgDuration: durations.reduce((a, b) => a + b, 0) / durations.length,\n      maxDuration: Math.max(...durations),\n      minDuration: Math.min(...durations)\n    };\n  }\n\n  reset() {\n    this.renders = [];\n  }\n}\n\nconst performanceMonitor = new PerformanceMonitor();\n\nfunction MonitoredApp() {\n  return (\n    <Profiler id=\"App\" onRender={performanceMonitor.onRender}>\n      <App />\n    </Profiler>\n  );\n}\n\n// Display performance stats\nfunction PerformanceStats() {\n  const [stats, setStats] = useState(null);\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setStats(performanceMonitor.getStats('App'));\n    }, 1000);\n\n    return () => clearInterval(interval);\n  }, []);\n\n  if (!stats) return null;\n\n  return (\n    <div style={{ \n      position: 'fixed', \n      bottom: 10, \n      right: 10, \n      background: 'rgba(0,0,0,0.8)', \n      color: 'white',\n      padding: '10px',\n      borderRadius: '5px',\n      fontSize: '12px'\n    }}>\n      <div>Renders: {stats.count}</div>\n      <div>Avg: {stats.avgDuration.toFixed(2)}ms</div>\n      <div>Max: {stats.maxDuration.toFixed(2)}ms</div>\n      <div>Min: {stats.minDuration.toFixed(2)}ms</div>\n    </div>\n  );\n}\n\n// Production profiling (opt-in)\n// In development, profiling is always enabled\n// In production, use profiling build:\n// react-dom/profiling and scheduler/tracing-profiling\n\n// Example usage with interaction tracking\nimport { unstable_trace as trace } from 'scheduler/tracing';\n\nfunction TrackedButton() {\n  const handleClick = () => {\n    trace('Button Click', performance.now(), () => {\n      // Expensive operation\n      performExpensiveOperation();\n    });\n  };\n\n  return <button onClick={handleClick}>Click Me</button>;\n}\n\n// Custom hook for profiling\nfunction useProfiler(componentName) {\n  const renderCount = useRef(0);\n  const renderTimes = useRef([]);\n\n  useEffect(() => {\n    renderCount.current += 1;\n    const renderTime = performance.now();\n    renderTimes.current.push(renderTime);\n\n    if (renderCount.current % 10 === 0) {\n      console.log(`${componentName} rendered ${renderCount.current} times`);\n    }\n\n    return () => {\n      const duration = performance.now() - renderTime;\n      if (duration > 16) {\n        console.warn(`${componentName} slow render: ${duration}ms`);\n      }\n    };\n  });\n\n  return renderCount.current;\n}\n\n// Usage\nfunction MyComponent() {\n  const renderCount = useProfiler('MyComponent');\n  \n  return <div>Rendered {renderCount} times</div>;\n}"
    },
    {
      "id": 60,
      "question": "How do you implement windowing/virtualization for large lists in React?",
      "answer": "Windowing (or virtualization) is a technique for rendering only visible items in large lists, dramatically improving performance by reducing DOM nodes.\n\nCore Concept:\n• Render Only Visible: Only render items in viewport\n• Calculate Positions: Position items using absolute positioning\n• Handle Scrolling: Update visible range on scroll\n• Preserve Scroll: Maintain scroll position during updates\n• Variable Heights: Handle dynamic item heights\n\nPopular Libraries:\n• react-window: Lightweight, simple API\n• react-virtualized: Feature-rich, larger bundle\n• react-virtual: Hooks-based, flexible\n• TanStack Virtual: Modern, framework-agnostic\n\nPerformance Benefits:\n• Reduced DOM Nodes: Only ~20-30 items instead of thousands\n• Faster Initial Render: Less work for browser\n• Lower Memory Usage: Fewer components in memory\n• Smooth Scrolling: Consistent performance\n• Better User Experience: No lag with large datasets\n\nImplementation Considerations:\n• Item Height: Fixed vs variable heights\n• Overscan: Render extra items for smooth scrolling\n• Scroll Restoration: Maintain position on updates\n• Accessibility: Ensure screen reader compatibility\n• Keyboard Navigation: Handle focus management",
      "explanation": "Windowing/virtualization renders only visible list items in the viewport, dramatically improving performance for large lists. Use libraries like react-window or implement custom solutions for fixed or variable height items.",
      "difficulty": "Hard",
      "code": "// Using react-window (recommended)\nimport { FixedSizeList } from 'react-window';\n\nfunction VirtualizedList({ items }) {\n  // Render individual row\n  const Row = ({ index, style }) => (\n    <div style={style} className=\"list-item\">\n      {items[index].name}\n    </div>\n  );\n\n  return (\n    <FixedSizeList\n      height={600}         // Container height\n      itemCount={items.length}\n      itemSize={50}        // Each item height\n      width=\"100%\"\n      overscanCount={5}    // Extra items to render\n    >\n      {Row}\n    </FixedSizeList>\n  );\n}\n\n// Variable height items\nimport { VariableSizeList } from 'react-window';\n\nfunction VariableHeightList({ items }) {\n  const listRef = useRef();\n  \n  // Function to get item height\n  const getItemSize = (index) => {\n    // Dynamic height based on content\n    return items[index].content.length > 100 ? 100 : 50;\n  };\n\n  // Reset cache when items change\n  useEffect(() => {\n    listRef.current?.resetAfterIndex(0);\n  }, [items]);\n\n  const Row = ({ index, style }) => (\n    <div style={style}>\n      <h3>{items[index].title}</h3>\n      <p>{items[index].content}</p>\n    </div>\n  );\n\n  return (\n    <VariableSizeList\n      ref={listRef}\n      height={600}\n      itemCount={items.length}\n      itemSize={getItemSize}\n      width=\"100%\"\n    >\n      {Row}\n    </VariableSizeList>\n  );\n}\n\n// Grid virtualization\nimport { FixedSizeGrid } from 'react-window';\n\nfunction VirtualizedGrid({ items, columnCount }) {\n  const Cell = ({ columnIndex, rowIndex, style }) => {\n    const index = rowIndex * columnCount + columnIndex;\n    if (index >= items.length) return null;\n\n    return (\n      <div style={style} className=\"grid-cell\">\n        <img src={items[index].imageUrl} alt={items[index].name} />\n        <p>{items[index].name}</p>\n      </div>\n    );\n  };\n\n  return (\n    <FixedSizeGrid\n      columnCount={columnCount}\n      columnWidth={200}\n      height={600}\n      rowCount={Math.ceil(items.length / columnCount)}\n      rowHeight={200}\n      width={800}\n    >\n      {Cell}\n    </FixedSizeGrid>\n  );\n}\n\n// Custom implementation (educational)\nfunction SimpleVirtualList({ items, itemHeight = 50, containerHeight = 600 }) {\n  const [scrollTop, setScrollTop] = useState(0);\n  const containerRef = useRef();\n\n  // Calculate visible range\n  const startIndex = Math.floor(scrollTop / itemHeight);\n  const endIndex = Math.ceil((scrollTop + containerHeight) / itemHeight);\n  const visibleItems = items.slice(startIndex, endIndex + 1);\n\n  // Total height of all items\n  const totalHeight = items.length * itemHeight;\n\n  // Handle scroll\n  const handleScroll = (e) => {\n    setScrollTop(e.target.scrollTop);\n  };\n\n  return (\n    <div\n      ref={containerRef}\n      style={{ height: containerHeight, overflow: 'auto' }}\n      onScroll={handleScroll}\n    >\n      {/* Spacer for total height */}\n      <div style={{ height: totalHeight, position: 'relative' }}>\n        {/* Only render visible items */}\n        {visibleItems.map((item, index) => (\n          <div\n            key={startIndex + index}\n            style={{\n              position: 'absolute',\n              top: (startIndex + index) * itemHeight,\n              height: itemHeight,\n              width: '100%'\n            }}\n          >\n            {item.name}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n\n// With scroll restoration\nfunction ScrollRestorationList({ items }) {\n  const listRef = useRef();\n  const [selectedId, setSelectedId] = useState(null);\n\n  // Scroll to specific item\n  const scrollToItem = (index) => {\n    listRef.current?.scrollToItem(index, 'center');\n  };\n\n  useEffect(() => {\n    if (selectedId) {\n      const index = items.findIndex(item => item.id === selectedId);\n      if (index !== -1) {\n        scrollToItem(index);\n      }\n    }\n  }, [selectedId, items]);\n\n  const Row = ({ index, style }) => (\n    <div\n      style={{\n        ...style,\n        backgroundColor: items[index].id === selectedId ? '#e0e0e0' : 'white'\n      }}\n      onClick={() => setSelectedId(items[index].id)}\n    >\n      {items[index].name}\n    </div>\n  );\n\n  return (\n    <FixedSizeList\n      ref={listRef}\n      height={600}\n      itemCount={items.length}\n      itemSize={50}\n      width=\"100%\"\n    >\n      {Row}\n    </FixedSizeList>\n  );\n}\n\n// With infinite loading\nimport { FixedSizeList } from 'react-window';\nimport InfiniteLoader from 'react-window-infinite-loader';\n\nfunction InfiniteList() {\n  const [items, setItems] = useState([]);\n  const [hasMore, setHasMore] = useState(true);\n\n  const loadMoreItems = async (startIndex, stopIndex) => {\n    const newItems = await fetchItems(startIndex, stopIndex);\n    setItems(prev => [...prev, ...newItems]);\n    if (newItems.length === 0) setHasMore(false);\n  };\n\n  const isItemLoaded = (index) => !hasMore || index < items.length;\n\n  const Row = ({ index, style }) => {\n    if (!isItemLoaded(index)) {\n      return <div style={style}>Loading...</div>;\n    }\n    return <div style={style}>{items[index].name}</div>;\n  };\n\n  return (\n    <InfiniteLoader\n      isItemLoaded={isItemLoaded}\n      itemCount={hasMore ? items.length + 1 : items.length}\n      loadMoreItems={loadMoreItems}\n    >\n      {({ onItemsRendered, ref }) => (\n        <FixedSizeList\n          ref={ref}\n          height={600}\n          itemCount={items.length}\n          itemSize={50}\n          width=\"100%\"\n          onItemsRendered={onItemsRendered}\n        >\n          {Row}\n        </FixedSizeList>\n      )}\n    </InfiniteLoader>\n  );\n}"
    },
    {
      "id": 61,
      "question": "How do you test React components with Jest and React Testing Library?",
      "answer": "Testing React components involves verifying that components render correctly, handle user interactions, and integrate with other parts of the application.\n\nReact Testing Library Philosophy:\n• Test User Behavior: Focus on how users interact with app\n• Avoid Implementation Details: Don't test internal state\n• Accessibility First: Query elements like users do\n• Integration Over Unit: Test components together\n• Confidence in Production: Tests mirror real usage\n\nCommon Testing Patterns:\n• Rendering Tests: Component renders without crashing\n• Props Tests: Component handles different props correctly\n• User Interaction: Click, type, submit work as expected\n• Async Behavior: API calls, loading states, error handling\n• Accessibility: Proper ARIA labels, keyboard navigation\n• Conditional Rendering: Shows/hides based on state\n\nQuery Methods:\n• getBy: Throws error if not found (assertions)\n• queryBy: Returns null if not found (absence tests)\n• findBy: Async, waits for element (async operations)\n• getAllBy: Multiple elements\n\nBest Practices:\n• Use semantic queries: getByRole, getByLabelText\n• Avoid testId: Only as last resort\n• Mock API calls: Use msw or mock functions\n• Test accessibility: Include aria labels\n• Keep tests simple: One concept per test",
      "explanation": "React Testing Library promotes testing components from the user's perspective using semantic queries and interactions. Focus on behavior rather than implementation details for more maintainable and reliable tests.",
      "difficulty": "Medium",
      "code": "// Basic component test\nimport { render, screen } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport Button from './Button';\n\ntest('renders button with text', () => {\n  render(<Button>Click me</Button>);\n  \n  const button = screen.getByRole('button', { name: /click me/i });\n  expect(button).toBeInTheDocument();\n});\n\n// Testing user interactions\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\n\ntest('calls onClick when button is clicked', async () => {\n  const handleClick = jest.fn();\n  const user = userEvent.setup();\n  \n  render(<Button onClick={handleClick}>Click me</Button>);\n  \n  const button = screen.getByRole('button');\n  await user.click(button);\n  \n  expect(handleClick).toHaveBeenCalledTimes(1);\n});\n\n// Testing form input\ntest('updates input value on change', async () => {\n  const user = userEvent.setup();\n  render(<SearchForm />);\n  \n  const input = screen.getByRole('textbox', { name: /search/i });\n  await user.type(input, 'React');\n  \n  expect(input).toHaveValue('React');\n});\n\n// Testing async behavior\ntest('displays user data after loading', async () => {\n  // Mock API\n  jest.spyOn(api, 'getUser').mockResolvedValue({\n    id: 1,\n    name: 'John Doe'\n  });\n  \n  render(<UserProfile userId={1} />);\n  \n  // Loading state\n  expect(screen.getByText(/loading/i)).toBeInTheDocument();\n  \n  // Wait for user data\n  const userName = await screen.findByText('John Doe');\n  expect(userName).toBeInTheDocument();\n  \n  // Loading should be gone\n  expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();\n});\n\n// Testing error handling\ntest('displays error message on API failure', async () => {\n  // Mock failed API call\n  jest.spyOn(api, 'getUser').mockRejectedValue(\n    new Error('Failed to fetch')\n  );\n  \n  render(<UserProfile userId={1} />);\n  \n  const errorMessage = await screen.findByText(/failed to fetch/i);\n  expect(errorMessage).toBeInTheDocument();\n});\n\n// Testing conditional rendering\ntest('shows delete button only for admin users', () => {\n  const { rerender } = render(<UserCard user={regularUser} />);\n  expect(screen.queryByRole('button', { name: /delete/i })).not.toBeInTheDocument();\n  \n  rerender(<UserCard user={adminUser} />);\n  expect(screen.getByRole('button', { name: /delete/i })).toBeInTheDocument();\n});\n\n// Testing with context\ntest('uses theme from context', () => {\n  render(\n    <ThemeProvider value=\"dark\">\n      <ThemedButton />\n    </ThemeProvider>\n  );\n  \n  const button = screen.getByRole('button');\n  expect(button).toHaveClass('dark-theme');\n});\n\n// Testing custom hooks\nimport { renderHook, act } from '@testing-library/react';\n\ntest('useCounter increments count', () => {\n  const { result } = renderHook(() => useCounter());\n  \n  expect(result.current.count).toBe(0);\n  \n  act(() => {\n    result.current.increment();\n  });\n  \n  expect(result.current.count).toBe(1);\n});\n\n// Testing with props\ntest('displays correct user information', () => {\n  const user = {\n    name: 'John Doe',\n    email: 'john@example.com',\n    role: 'admin'\n  };\n  \n  render(<UserProfile user={user} />);\n  \n  expect(screen.getByText(user.name)).toBeInTheDocument();\n  expect(screen.getByText(user.email)).toBeInTheDocument();\n  expect(screen.getByText(/admin/i)).toBeInTheDocument();\n});\n\n// Testing accessibility\ntest('has accessible form fields', () => {\n  render(<LoginForm />);\n  \n  const emailInput = screen.getByLabelText(/email/i);\n  const passwordInput = screen.getByLabelText(/password/i);\n  \n  expect(emailInput).toHaveAttribute('type', 'email');\n  expect(passwordInput).toHaveAttribute('type', 'password');\n  expect(emailInput).toBeRequired();\n});\n\n// Complete example: Form submission test\ntest('submits form with correct data', async () => {\n  const handleSubmit = jest.fn();\n  const user = userEvent.setup();\n  \n  render(<ContactForm onSubmit={handleSubmit} />);\n  \n  // Fill form\n  await user.type(screen.getByLabelText(/name/i), 'John Doe');\n  await user.type(screen.getByLabelText(/email/i), 'john@example.com');\n  await user.type(screen.getByLabelText(/message/i), 'Hello World');\n  \n  // Submit\n  await user.click(screen.getByRole('button', { name: /submit/i }));\n  \n  // Verify\n  expect(handleSubmit).toHaveBeenCalledWith({\n    name: 'John Doe',\n    email: 'john@example.com',\n    message: 'Hello World'\n  });\n});\n\n// Setup file (setupTests.js)\nimport '@testing-library/jest-dom';\nimport { server } from './mocks/server';\n\n// Establish API mocking before all tests\nbeforeAll(() => server.listen());\n\n// Reset handlers after each test\nafterEach(() => server.resetHandlers());\n\n// Clean up after all tests\nafterAll(() => server.close());"
    },
    {
      "id": 62,
      "question": "How do you mock API calls and async operations in React tests?",
      "answer": "Mocking API calls in tests allows you to test component behavior without making real network requests, ensuring fast, reliable, and isolated tests.\n\nMocking Strategies:\n• Jest Mock Functions: jest.fn(), jest.spyOn()\n• Mock Service Worker (MSW): Intercept requests at network level\n• Manual Mocks: Create mock modules\n• Inline Mocks: Mock specific implementations\n• Axios Mock Adapter: For axios-specific mocking\n\nJest Mocking:\n• jest.fn(): Create mock function\n• jest.spyOn(): Spy on existing method\n• mockResolvedValue: Mock successful promise\n• mockRejectedValue: Mock failed promise\n• mockImplementation: Custom mock logic\n\nMSW Advantages:\n• Network Level: Intercepts actual requests\n• Reusable: Same mocks for tests and development\n• Realistic: Mimics real network behavior\n• Type Safe: Works with TypeScript\n• Framework Agnostic: Not tied to React\n\nAsync Testing Patterns:\n• waitFor: Wait for assertion to pass\n• findBy: Async query that waits\n• act: Wrap state updates\n• flush-promises: Wait for all promises\n\nBest Practices:\n• Reset mocks: Between tests\n• Mock at boundaries: Service/API layer\n• Test loading states: While pending\n• Test error states: Failed requests\n• Keep mocks realistic: Match real API",
      "explanation": "Mock API calls using Jest mock functions or Mock Service Worker (MSW) to test components in isolation. Handle loading, success, and error states while keeping tests fast and reliable.",
      "difficulty": "Medium",
      "code": "// Method 1: Jest mock functions\nimport { render, screen, waitFor } from '@testing-library/react';\nimport * as api from './api';\n\ntest('loads and displays user data', async () => {\n  // Mock the API function\n  const mockUser = { id: 1, name: 'John Doe' };\n  jest.spyOn(api, 'fetchUser').mockResolvedValue(mockUser);\n  \n  render(<UserProfile userId={1} />);\n  \n  // Wait for data to load\n  await waitFor(() => {\n    expect(screen.getByText('John Doe')).toBeInTheDocument();\n  });\n  \n  // Verify API was called\n  expect(api.fetchUser).toHaveBeenCalledWith(1);\n  expect(api.fetchUser).toHaveBeenCalledTimes(1);\n  \n  // Cleanup\n  jest.restoreAllMocks();\n});\n\n// Method 2: Mock Service Worker (MSW)\nimport { rest } from 'msw';\nimport { setupServer } from 'msw/node';\n\n// Define handlers\nconst handlers = [\n  rest.get('/api/user/:id', (req, res, ctx) => {\n    const { id } = req.params;\n    return res(\n      ctx.status(200),\n      ctx.json({\n        id: Number(id),\n        name: 'John Doe',\n        email: 'john@example.com'\n      })\n    );\n  }),\n  \n  rest.post('/api/users', async (req, res, ctx) => {\n    const data = await req.json();\n    return res(\n      ctx.status(201),\n      ctx.json({ id: 1, ...data })\n    );\n  })\n];\n\n// Create server\nconst server = setupServer(...handlers);\n\n// Setup\nbeforeAll(() => server.listen());\nafterEach(() => server.resetHandlers());\nafterAll(() => server.close());\n\n// Test with MSW\ntest('creates new user', async () => {\n  const user = userEvent.setup();\n  render(<CreateUserForm />);\n  \n  await user.type(screen.getByLabelText(/name/i), 'Jane');\n  await user.type(screen.getByLabelText(/email/i), 'jane@example.com');\n  await user.click(screen.getByRole('button', { name: /submit/i }));\n  \n  await waitFor(() => {\n    expect(screen.getByText(/user created/i)).toBeInTheDocument();\n  });\n});\n\n// Testing loading state\ntest('shows loading state while fetching', async () => {\n  // Delay the response\n  server.use(\n    rest.get('/api/user/:id', async (req, res, ctx) => {\n      await ctx.delay(100);\n      return res(ctx.json({ id: 1, name: 'John' }));\n    })\n  );\n  \n  render(<UserProfile userId={1} />);\n  \n  // Should show loading\n  expect(screen.getByText(/loading/i)).toBeInTheDocument();\n  \n  // Wait for data\n  await screen.findByText('John');\n  \n  // Loading should be gone\n  expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();\n});\n\n// Testing error handling\ntest('displays error on API failure', async () => {\n  // Mock API error\n  jest.spyOn(api, 'fetchUser').mockRejectedValue(\n    new Error('Network error')\n  );\n  \n  render(<UserProfile userId={1} />);\n  \n  const errorMessage = await screen.findByText(/network error/i);\n  expect(errorMessage).toBeInTheDocument();\n});\n\n// MSW error response\ntest('handles 404 error', async () => {\n  server.use(\n    rest.get('/api/user/:id', (req, res, ctx) => {\n      return res(\n        ctx.status(404),\n        ctx.json({ message: 'User not found' })\n      );\n    })\n  );\n  \n  render(<UserProfile userId={999} />);\n  \n  await screen.findByText(/user not found/i);\n});\n\n// Mock with different responses\ntest('handles pagination', async () => {\n  const user = userEvent.setup();\n  let page = 1;\n  \n  server.use(\n    rest.get('/api/users', (req, res, ctx) => {\n      const requestedPage = req.url.searchParams.get('page');\n      return res(\n        ctx.json({\n          users: [\n            { id: requestedPage, name: `User ${requestedPage}` }\n          ],\n          page: Number(requestedPage),\n          hasMore: Number(requestedPage) < 3\n        })\n      );\n    })\n  );\n  \n  render(<UserList />);\n  \n  // Initial load\n  await screen.findByText('User 1');\n  \n  // Load more\n  await user.click(screen.getByRole('button', { name: /load more/i }));\n  await screen.findByText('User 2');\n});\n\n// Axios mock adapter\nimport axios from 'axios';\nimport MockAdapter from 'axios-mock-adapter';\n\nconst mock = new MockAdapter(axios);\n\nbeforeEach(() => {\n  mock.reset();\n});\n\ntest('fetches data with axios', async () => {\n  const mockData = { id: 1, name: 'John' };\n  mock.onGet('/api/user/1').reply(200, mockData);\n  \n  render(<UserProfile userId={1} />);\n  \n  await screen.findByText('John');\n});\n\n// Mock module\njest.mock('./api', () => ({\n  fetchUser: jest.fn(),\n  createUser: jest.fn(),\n  updateUser: jest.fn()\n}));\n\ntest('uses mocked module', async () => {\n  const mockUser = { id: 1, name: 'John' };\n  api.fetchUser.mockResolvedValue(mockUser);\n  \n  render(<UserProfile userId={1} />);\n  \n  await screen.findByText('John');\n});\n\n// Testing race conditions\ntest('handles rapid API calls', async () => {\n  let callCount = 0;\n  \n  jest.spyOn(api, 'searchUsers').mockImplementation(async (query) => {\n    const currentCall = ++callCount;\n    await new Promise(resolve => setTimeout(resolve, 100 * (4 - currentCall)));\n    \n    return currentCall === 3 \n      ? [{ id: 1, name: 'Final Result' }]\n      : [{ id: currentCall, name: `Result ${currentCall}` }];\n  });\n  \n  const user = userEvent.setup();\n  render(<SearchUsers />);\n  \n  const input = screen.getByRole('textbox');\n  \n  // Rapid typing\n  await user.type(input, 'a');\n  await user.type(input, 'b');\n  await user.type(input, 'c');\n  \n  // Should only show final result\n  await screen.findByText('Final Result');\n  expect(screen.queryByText('Result 1')).not.toBeInTheDocument();\n});\n\n// Custom test helper\nfunction renderWithProviders(ui, { initialState = {}, ...options } = {}) {\n  function Wrapper({ children }) {\n    return (\n      <Provider store={createStore(initialState)}>\n        <ThemeProvider>\n          {children}\n        </ThemeProvider>\n      </Provider>\n    );\n  }\n  \n  return render(ui, { wrapper: Wrapper, ...options });\n}\n\ntest('component with providers', async () => {\n  jest.spyOn(api, 'fetchUser').mockResolvedValue({ id: 1, name: 'John' });\n  \n  renderWithProviders(<UserProfile userId={1} />, {\n    initialState: { theme: 'dark' }\n  });\n  \n  await screen.findByText('John');\n});"
    },
    {
      "id": 63,
      "question": "How do you test React hooks with React Testing Library?",
      "answer": "Testing React hooks requires special consideration since hooks can only be called inside React components. Use renderHook utility for isolated hook testing.\n\nrenderHook API:\n• Renders hook in test component\n• Returns result.current with hook's return value\n• Provides rerender function for prop changes\n• Includes unmount for cleanup testing\n• Works with hook dependencies and effects\n\nTesting Patterns:\n• State Hooks: Test state updates and derived values\n• Effect Hooks: Verify side effects occur correctly\n• Context Hooks: Test with context providers\n• Custom Hooks: Test hook logic in isolation\n• Async Hooks: Handle promises and loading states\n• Hook Dependencies: Test with changing deps\n\nUsing act():\n• Wraps state updates\n• Ensures effects have run\n• Flushes pending effects\n• Required for synchronous updates\n\nBest Practices:\n• Test hooks through components when possible\n• Use renderHook for complex custom hooks\n• Test edge cases: empty arrays, null values\n• Mock external dependencies\n• Test cleanup functions\n• Verify ref updates\n\nCommon Scenarios:\n• useState: Test initial value and updates\n• useEffect: Verify side effects and cleanup\n• useCallback/useMemo: Test memoization\n• useReducer: Test state transitions\n• Custom hooks: Test complete functionality",
      "explanation": "Test hooks using renderHook utility from React Testing Library, which renders hooks in isolation. Wrap updates in act() and test state changes, side effects, and cleanup functions.",
      "difficulty": "Medium",
      "code": "import { renderHook, act, waitFor } from '@testing-library/react';\n\n// Testing useState hook\ntest('useCounter increments and decrements', () => {\n  const { result } = renderHook(() => useCounter(0));\n  \n  expect(result.current.count).toBe(0);\n  \n  act(() => {\n    result.current.increment();\n  });\n  \n  expect(result.current.count).toBe(1);\n  \n  act(() => {\n    result.current.decrement();\n  });\n  \n  expect(result.current.count).toBe(0);\n});\n\n// Testing useEffect hook\ntest('useDocumentTitle updates document title', () => {\n  const { rerender } = renderHook(\n    ({ title }) => useDocumentTitle(title),\n    { initialProps: { title: 'Initial Title' } }\n  );\n  \n  expect(document.title).toBe('Initial Title');\n  \n  rerender({ title: 'Updated Title' });\n  \n  expect(document.title).toBe('Updated Title');\n});\n\n// Testing async hooks\ntest('useFetch loads data', async () => {\n  const mockData = { id: 1, name: 'John' };\n  jest.spyOn(global, 'fetch').mockResolvedValue({\n    json: async () => mockData\n  });\n  \n  const { result } = renderHook(() => useFetch('/api/user/1'));\n  \n  // Initial loading state\n  expect(result.current.loading).toBe(true);\n  expect(result.current.data).toBe(null);\n  \n  // Wait for data\n  await waitFor(() => {\n    expect(result.current.loading).toBe(false);\n  });\n  \n  expect(result.current.data).toEqual(mockData);\n  expect(result.current.error).toBe(null);\n});\n\n// Testing error handling in hooks\ntest('useFetch handles errors', async () => {\n  const error = new Error('Failed to fetch');\n  jest.spyOn(global, 'fetch').mockRejectedValue(error);\n  \n  const { result } = renderHook(() => useFetch('/api/user/1'));\n  \n  await waitFor(() => {\n    expect(result.current.loading).toBe(false);\n  });\n  \n  expect(result.current.error).toEqual(error);\n  expect(result.current.data).toBe(null);\n});\n\n// Testing hooks with context\ntest('useAuth returns user from context', () => {\n  const wrapper = ({ children }) => (\n    <AuthProvider value={{ user: { id: 1, name: 'John' } }}>\n      {children}\n    </AuthProvider>\n  );\n  \n  const { result } = renderHook(() => useAuth(), { wrapper });\n  \n  expect(result.current.user).toEqual({ id: 1, name: 'John' });\n});\n\n// Testing hook cleanup\ntest('useInterval cleans up on unmount', () => {\n  jest.useFakeTimers();\n  const callback = jest.fn();\n  \n  const { unmount } = renderHook(() => useInterval(callback, 1000));\n  \n  // Fast-forward time\n  act(() => {\n    jest.advanceTimersByTime(3000);\n  });\n  \n  expect(callback).toHaveBeenCalledTimes(3);\n  \n  // Unmount\n  unmount();\n  \n  // Callback should not be called anymore\n  act(() => {\n    jest.advanceTimersByTime(2000);\n  });\n  \n  expect(callback).toHaveBeenCalledTimes(3);\n  \n  jest.useRealTimers();\n});\n\n// Testing useMemo\ntest('useMemo memoizes expensive calculation', () => {\n  const expensiveCalculation = jest.fn((num) => num * 2);\n  \n  function useExpensiveValue(num) {\n    return useMemo(() => expensiveCalculation(num), [num]);\n  }\n  \n  const { result, rerender } = renderHook(\n    ({ num }) => useExpensiveValue(num),\n    { initialProps: { num: 5 } }\n  );\n  \n  expect(result.current).toBe(10);\n  expect(expensiveCalculation).toHaveBeenCalledTimes(1);\n  \n  // Rerender with same value\n  rerender({ num: 5 });\n  expect(expensiveCalculation).toHaveBeenCalledTimes(1); // Not called again\n  \n  // Rerender with new value\n  rerender({ num: 10 });\n  expect(result.current).toBe(20);\n  expect(expensiveCalculation).toHaveBeenCalledTimes(2);\n});\n\n// Testing useCallback\ntest('useCallback memoizes callback', () => {\n  function useCallbackHook(dep) {\n    return useCallback(() => console.log(dep), [dep]);\n  }\n  \n  const { result, rerender } = renderHook(\n    ({ dep }) => useCallbackHook(dep),\n    { initialProps: { dep: 'a' } }\n  );\n  \n  const callback1 = result.current;\n  \n  // Rerender with same dep\n  rerender({ dep: 'a' });\n  const callback2 = result.current;\n  \n  expect(callback1).toBe(callback2); // Same reference\n  \n  // Rerender with new dep\n  rerender({ dep: 'b' });\n  const callback3 = result.current;\n  \n  expect(callback1).not.toBe(callback3); // Different reference\n});\n\n// Testing useReducer\ntest('useReducer handles actions', () => {\n  const initialState = { count: 0 };\n  \n  function reducer(state, action) {\n    switch (action.type) {\n      case 'increment':\n        return { count: state.count + 1 };\n      case 'decrement':\n        return { count: state.count - 1 };\n      case 'reset':\n        return initialState;\n      default:\n        return state;\n    }\n  }\n  \n  function useCounter() {\n    return useReducer(reducer, initialState);\n  }\n  \n  const { result } = renderHook(() => useCounter());\n  \n  const [state, dispatch] = result.current;\n  expect(state.count).toBe(0);\n  \n  act(() => {\n    dispatch({ type: 'increment' });\n  });\n  expect(result.current[0].count).toBe(1);\n  \n  act(() => {\n    dispatch({ type: 'increment' });\n  });\n  expect(result.current[0].count).toBe(2);\n  \n  act(() => {\n    dispatch({ type: 'reset' });\n  });\n  expect(result.current[0].count).toBe(0);\n});\n\n// Testing custom hook with multiple features\nfunction useLocalStorage(key, initialValue) {\n  const [value, setValue] = useState(() => {\n    const stored = localStorage.getItem(key);\n    return stored ? JSON.parse(stored) : initialValue;\n  });\n  \n  useEffect(() => {\n    localStorage.setItem(key, JSON.stringify(value));\n  }, [key, value]);\n  \n  return [value, setValue];\n}\n\ntest('useLocalStorage stores and retrieves value', () => {\n  const { result } = renderHook(() => useLocalStorage('test-key', 'initial'));\n  \n  const [value, setValue] = result.current;\n  expect(value).toBe('initial');\n  \n  act(() => {\n    setValue('updated');\n  });\n  \n  expect(result.current[0]).toBe('updated');\n  expect(localStorage.getItem('test-key')).toBe(JSON.stringify('updated'));\n  \n  localStorage.clear();\n});\n\n// Testing hook with ref\ntest('usePrevious returns previous value', () => {\n  function usePrevious(value) {\n    const ref = useRef();\n    useEffect(() => {\n      ref.current = value;\n    }, [value]);\n    return ref.current;\n  }\n  \n  const { result, rerender } = renderHook(\n    ({ value }) => usePrevious(value),\n    { initialProps: { value: 0 } }\n  );\n  \n  expect(result.current).toBeUndefined();\n  \n  rerender({ value: 1 });\n  expect(result.current).toBe(0);\n  \n  rerender({ value: 2 });\n  expect(result.current).toBe(1);\n});"
    },
    {
      "id": 64,
      "question": "What are the best practices for testing accessibility in React components?",
      "answer": "Testing accessibility ensures your React applications are usable by people with disabilities, including those using screen readers, keyboard navigation, and other assistive technologies.\n\nAccessibility Testing Tools:\n• jest-axe: Automated accessibility testing\n• eslint-plugin-jsx-a11y: Linting for accessibility\n• React Testing Library: Built-in accessible queries\n• axe DevTools: Browser extension for manual testing\n• WAVE: Web accessibility evaluation tool\n\nKey Accessibility Features:\n• Semantic HTML: Use proper elements (button, nav, etc.)\n• ARIA Labels: Provide labels for screen readers\n• Keyboard Navigation: Tab, Enter, Escape support\n• Focus Management: Proper focus order and visibility\n• Color Contrast: Sufficient contrast ratios\n• Alt Text: Images have descriptive alt attributes\n• Form Labels: All inputs have associated labels\n\nTesting Approaches:\n• Automated Testing: jest-axe for common issues\n• Keyboard Testing: Verify tab order and keyboard controls\n• Screen Reader Testing: Test with actual screen readers\n• Semantic Queries: Use getByRole, getByLabelText\n• Focus Testing: Verify focus management\n\nBest Practices:\n• Test with real assistive technology\n• Use semantic queries in tests\n• Test keyboard navigation\n• Verify ARIA attributes\n• Check color contrast\n• Test focus states",
      "explanation": "Accessibility testing ensures components work with assistive technologies. Use jest-axe for automated testing, semantic queries for better tests, and verify keyboard navigation, ARIA labels, and focus management.",
      "difficulty": "Medium",
      "code": "// Setup jest-axe\nimport { axe, toHaveNoViolations } from 'jest-axe';\n\nexpect.extend(toHaveNoViolations);\n\n// Basic accessibility test\nimport { render } from '@testing-library/react';\n\ntest('should not have accessibility violations', async () => {\n  const { container } = render(<LoginForm />);\n  const results = await axe(container);\n  expect(results).toHaveNoViolations();\n});\n\n// Testing with semantic queries\ntest('form fields are accessible', () => {\n  render(<ContactForm />);\n  \n  // Good: Using accessible queries\n  const nameInput = screen.getByLabelText(/name/i);\n  const emailInput = screen.getByLabelText(/email/i);\n  const submitButton = screen.getByRole('button', { name: /submit/i });\n  \n  expect(nameInput).toBeInTheDocument();\n  expect(emailInput).toHaveAttribute('type', 'email');\n  expect(submitButton).toBeEnabled();\n});\n\n// Testing keyboard navigation\nimport userEvent from '@testing-library/user-event';\n\ntest('modal can be closed with Escape key', async () => {\n  const user = userEvent.setup();\n  const onClose = jest.fn();\n  \n  render(<Modal isOpen={true} onClose={onClose} />);\n  \n  await user.keyboard('{Escape}');\n  \n  expect(onClose).toHaveBeenCalled();\n});\n\ntest('menu is navigable with keyboard', async () => {\n  const user = userEvent.setup();\n  render(<Dropdown items={['Option 1', 'Option 2', 'Option 3']} />);\n  \n  const trigger = screen.getByRole('button');\n  trigger.focus();\n  \n  // Open with Enter\n  await user.keyboard('{Enter}');\n  \n  // Navigate with arrow keys\n  await user.keyboard('{ArrowDown}');\n  expect(screen.getByRole('option', { name: 'Option 1' })).toHaveFocus();\n  \n  await user.keyboard('{ArrowDown}');\n  expect(screen.getByRole('option', { name: 'Option 2' })).toHaveFocus();\n  \n  // Select with Enter\n  await user.keyboard('{Enter}');\n  expect(trigger).toHaveTextContent('Option 2');\n});\n\n// Testing focus management\ntest('dialog traps focus', async () => {\n  const user = userEvent.setup();\n  render(<Dialog />);\n  \n  const closeButton = screen.getByRole('button', { name: /close/i });\n  const input = screen.getByRole('textbox');\n  const submitButton = screen.getByRole('button', { name: /submit/i });\n  \n  // First element should be focused\n  expect(input).toHaveFocus();\n  \n  // Tab through elements\n  await user.tab();\n  expect(submitButton).toHaveFocus();\n  \n  await user.tab();\n  expect(closeButton).toHaveFocus();\n  \n  // Should wrap back to first element\n  await user.tab();\n  expect(input).toHaveFocus();\n  \n  // Shift+Tab should go backwards\n  await user.tab({ shift: true });\n  expect(closeButton).toHaveFocus();\n});\n\n// Testing ARIA attributes\ntest('loading state has proper ARIA attributes', () => {\n  render(<DataTable loading={true} />);\n  \n  const spinner = screen.getByRole('status');\n  expect(spinner).toHaveAttribute('aria-live', 'polite');\n  expect(spinner).toHaveAttribute('aria-busy', 'true');\n  \n  const table = screen.queryByRole('table');\n  expect(table).toHaveAttribute('aria-hidden', 'true');\n});\n\ntest('error message is announced to screen readers', () => {\n  render(<Form hasError={true} errorMessage=\"Invalid email\" />);\n  \n  const error = screen.getByRole('alert');\n  expect(error).toHaveTextContent('Invalid email');\n  expect(error).toHaveAttribute('aria-live', 'assertive');\n});\n\n// Testing form accessibility\ntest('form has accessible labels and validation', async () => {\n  const user = userEvent.setup();\n  render(<SignupForm />);\n  \n  // All inputs should have labels\n  const emailInput = screen.getByLabelText(/email/i);\n  const passwordInput = screen.getByLabelText(/password/i);\n  \n  // Required fields should be marked\n  expect(emailInput).toBeRequired();\n  expect(emailInput).toHaveAttribute('aria-required', 'true');\n  \n  // Submit with invalid data\n  await user.click(screen.getByRole('button', { name: /submit/i }));\n  \n  // Error should be associated with input\n  const emailError = await screen.findByText(/invalid email/i);\n  expect(emailInput).toHaveAttribute('aria-invalid', 'true');\n  expect(emailInput).toHaveAttribute('aria-describedby', emailError.id);\n});\n\n// Testing image accessibility\ntest('images have alt text', () => {\n  render(<ProductCard product={mockProduct} />);\n  \n  const image = screen.getByAltText(/product name/i);\n  expect(image).toHaveAttribute('src', mockProduct.imageUrl);\n});\n\ntest('decorative images are hidden from screen readers', () => {\n  render(<Card />);\n  \n  const decorativeImage = screen.getByRole('img', { hidden: true });\n  expect(decorativeImage).toHaveAttribute('alt', '');\n  expect(decorativeImage).toHaveAttribute('aria-hidden', 'true');\n});\n\n// Testing button accessibility\ntest('icon button has accessible label', () => {\n  render(<IconButton icon={<TrashIcon />} onClick={handleDelete} />);\n  \n  const button = screen.getByRole('button', { name: /delete/i });\n  expect(button).toHaveAttribute('aria-label', 'Delete');\n});\n\n// Testing live regions\ntest('status updates are announced', async () => {\n  render(<SaveButton />);\n  \n  const button = screen.getByRole('button', { name: /save/i });\n  await userEvent.click(button);\n  \n  const status = await screen.findByRole('status');\n  expect(status).toHaveTextContent('Saved successfully');\n  expect(status).toHaveAttribute('aria-live', 'polite');\n});\n\n// Testing skip links\ntest('skip to content link is present', async () => {\n  const user = userEvent.setup();\n  render(<Layout />);\n  \n  // Tab to skip link\n  await user.tab();\n  \n  const skipLink = screen.getByRole('link', { name: /skip to content/i });\n  expect(skipLink).toHaveFocus();\n  \n  // Activating skip link focuses main content\n  await user.click(skipLink);\n  \n  const mainContent = screen.getByRole('main');\n  expect(mainContent).toHaveFocus();\n});\n\n// Custom accessibility helper\nfunction renderWithA11y(ui) {\n  const view = render(ui);\n  \n  return {\n    ...view,\n    checkA11y: async () => {\n      const results = await axe(view.container);\n      expect(results).toHaveNoViolations();\n    }\n  };\n}\n\ntest('component is accessible', async () => {\n  const { checkA11y } = renderWithA11y(<MyComponent />);\n  await checkA11y();\n});"
    },
    {
      "id": 65,
      "question": "How do you test components that use Redux or other state management libraries?",
      "answer": "Testing Redux-connected components requires providing store context and handling state management complexity while keeping tests focused and maintainable.\n\nTesting Approaches:\n• Integration Tests: Test components with real store\n• Unit Tests: Test connected and presentational components separately\n• Mock Store: Use mock store for isolation\n• Custom Render: Create render helper with providers\n• Action Tests: Test action creators and thunks\n• Reducer Tests: Test reducers in isolation\n• Selector Tests: Test selector functions\n\nRedux Testing Patterns:\n• Real Store: Use createStore for integration tests\n• Mock Store: redux-mock-store for unit tests\n• Initial State: Provide specific state for test scenarios\n• Action Dispatch: Verify actions are dispatched correctly\n• State Updates: Check state changes after actions\n\nBest Practices:\n• Test presentational components without Redux\n• Test connected components with store\n• Keep reducers pure and easy to test\n• Test selectors independently\n• Mock async actions (thunks, sagas)\n• Use proper TypeScript types\n• Avoid testing implementation details\n\nCommon Pitfalls:\n• Testing too much at once\n• Not providing required context\n• Forgetting to cleanup store\n• Over-mocking dependencies",
      "explanation": "Test Redux components by providing store context through custom render helpers. Test reducers, actions, and selectors in isolation. Use real or mock stores based on whether you're doing integration or unit tests.",
      "difficulty": "Hard",
      "code": "// Setup: Custom render with Redux\nimport { render } from '@testing-library/react';\nimport { Provider } from 'react-redux';\nimport { createStore } from 'redux';\nimport rootReducer from './reducers';\n\nfunction renderWithRedux(\n  component,\n  { initialState, store = createStore(rootReducer, initialState) } = {}\n) {\n  function Wrapper({ children }) {\n    return <Provider store={store}>{children}</Provider>;\n  }\n  \n  return {\n    ...render(component, { wrapper: Wrapper }),\n    store\n  };\n}\n\n// Testing connected component\nimport { screen, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\n\ntest('displays user data from Redux store', () => {\n  const initialState = {\n    user: {\n      id: 1,\n      name: 'John Doe',\n      email: 'john@example.com'\n    }\n  };\n  \n  renderWithRedux(<UserProfile />, { initialState });\n  \n  expect(screen.getByText('John Doe')).toBeInTheDocument();\n  expect(screen.getByText('john@example.com')).toBeInTheDocument();\n});\n\n// Testing dispatch actions\ntest('increments counter when button is clicked', async () => {\n  const user = userEvent.setup();\n  const { store } = renderWithRedux(<Counter />, {\n    initialState: { count: 0 }\n  });\n  \n  const button = screen.getByRole('button', { name: /increment/i });\n  await user.click(button);\n  \n  expect(store.getState().count).toBe(1);\n  expect(screen.getByText('Count: 1')).toBeInTheDocument();\n});\n\n// Using redux-mock-store\nimport configureStore from 'redux-mock-store';\nimport thunk from 'redux-thunk';\n\nconst middlewares = [thunk];\nconst mockStore = configureStore(middlewares);\n\ntest('dispatches correct actions', async () => {\n  const store = mockStore({ users: [] });\n  const user = userEvent.setup();\n  \n  render(\n    <Provider store={store}>\n      <UserList />\n    </Provider>\n  );\n  \n  const loadButton = screen.getByRole('button', { name: /load users/i });\n  await user.click(loadButton);\n  \n  const actions = store.getActions();\n  expect(actions[0]).toEqual({ type: 'FETCH_USERS_REQUEST' });\n});\n\n// Testing async actions (thunks)\nimport { fetchUser } from './actions';\nimport * as api from './api';\n\ntest('fetchUser dispatches correct actions on success', async () => {\n  const mockUser = { id: 1, name: 'John' };\n  jest.spyOn(api, 'getUser').mockResolvedValue(mockUser);\n  \n  const store = mockStore({ users: [] });\n  \n  await store.dispatch(fetchUser(1));\n  \n  const actions = store.getActions();\n  expect(actions).toEqual([\n    { type: 'FETCH_USER_REQUEST', payload: 1 },\n    { type: 'FETCH_USER_SUCCESS', payload: mockUser }\n  ]);\n});\n\ntest('fetchUser dispatches correct actions on failure', async () => {\n  const error = new Error('Failed to fetch');\n  jest.spyOn(api, 'getUser').mockRejectedValue(error);\n  \n  const store = mockStore({ users: [] });\n  \n  await store.dispatch(fetchUser(1));\n  \n  const actions = store.getActions();\n  expect(actions[1]).toEqual({\n    type: 'FETCH_USER_FAILURE',\n    payload: error\n  });\n});\n\n// Testing reducers\nimport counterReducer from './counterReducer';\n\ntest('counter reducer handles INCREMENT', () => {\n  const initialState = { count: 0 };\n  const action = { type: 'INCREMENT' };\n  \n  const newState = counterReducer(initialState, action);\n  \n  expect(newState.count).toBe(1);\n});\n\ntest('counter reducer handles DECREMENT', () => {\n  const initialState = { count: 5 };\n  const action = { type: 'DECREMENT' };\n  \n  const newState = counterReducer(initialState, action);\n  \n  expect(newState.count).toBe(4);\n});\n\ntest('counter reducer returns initial state for unknown action', () => {\n  const initialState = { count: 0 };\n  const action = { type: 'UNKNOWN' };\n  \n  const newState = counterReducer(initialState, action);\n  \n  expect(newState).toEqual(initialState);\n});\n\n// Testing selectors\nimport { selectUser, selectIsAdmin } from './selectors';\n\ntest('selectUser returns user from state', () => {\n  const state = {\n    users: {\n      currentUser: { id: 1, name: 'John' }\n    }\n  };\n  \n  const user = selectUser(state);\n  \n  expect(user).toEqual({ id: 1, name: 'John' });\n});\n\ntest('selectIsAdmin returns true for admin users', () => {\n  const state = {\n    users: {\n      currentUser: { id: 1, role: 'admin' }\n    }\n  };\n  \n  const isAdmin = selectIsAdmin(state);\n  \n  expect(isAdmin).toBe(true);\n});\n\n// Testing with Redux Toolkit\nimport { configureStore } from '@reduxjs/toolkit';\nimport userReducer from './userSlice';\n\nfunction renderWithStore(component, preloadedState) {\n  const store = configureStore({\n    reducer: {\n      user: userReducer\n    },\n    preloadedState\n  });\n  \n  return renderWithRedux(component, { store });\n}\n\ntest('Redux Toolkit slice', async () => {\n  const user = userEvent.setup();\n  const { store } = renderWithStore(<UserProfile />, {\n    user: { name: 'John', age: 30 }\n  });\n  \n  const button = screen.getByRole('button', { name: /update name/i });\n  await user.click(button);\n  \n  expect(store.getState().user.name).toBe('Updated Name');\n});\n\n// Testing with Context API (alternative to Redux)\nconst UserContext = createContext();\n\nfunction renderWithContext(component, contextValue) {\n  return render(\n    <UserContext.Provider value={contextValue}>\n      {component}\n    </UserContext.Provider>\n  );\n}\n\ntest('component uses context value', () => {\n  const user = { id: 1, name: 'John' };\n  renderWithContext(<UserDisplay />, user);\n  \n  expect(screen.getByText('John')).toBeInTheDocument();\n});\n\n// Complete test helper with multiple providers\nfunction renderWithProviders(\n  component,\n  {\n    initialState = {},\n    store = createStore(rootReducer, initialState),\n    theme = 'light',\n    ...options\n  } = {}\n) {\n  function AllProviders({ children }) {\n    return (\n      <Provider store={store}>\n        <ThemeProvider theme={theme}>\n          <Router>\n            {children}\n          </Router>\n        </ThemeProvider>\n      </Provider>\n    );\n  }\n  \n  return {\n    ...render(component, { wrapper: AllProviders, ...options }),\n    store\n  };\n}\n\ntest('component with all providers', () => {\n  renderWithProviders(<App />, {\n    initialState: { user: { name: 'John' } },\n    theme: 'dark'\n  });\n  \n  expect(screen.getByText('John')).toBeInTheDocument();\n});"
    },
    {
      "id": 66,
      "question": "What is Redux and how does it compare to React Context for state management?",
      "answer": "Redux is a predictable state container for JavaScript apps, while React Context is a built-in React feature for passing data through the component tree. Each has specific use cases.\n\nRedux Core Concepts:\n• Single Source of Truth: One global store\n• State is Read-Only: Only modified through actions\n• Pure Reducers: Changes made with pure functions\n• Predictable State Updates: Same input, same output\n• Time-Travel Debugging: Replay state changes\n• Middleware Support: Async actions, logging, etc.\n\nReact Context:\n• Built into React: No additional dependencies\n• Multiple Contexts: Separate contexts for different data\n• Simple API: Provider and Consumer/useContext\n• Component-Level: Suitable for component state sharing\n• No Dev Tools: Limited debugging capabilities\n• Performance: Can cause unnecessary re-renders\n\nWhen to Use Redux:\n• Large applications with complex state\n• State shared across many components\n• State updates need tracking/debugging\n• Need middleware (thunks, sagas)\n• Time-travel debugging required\n• Strict state update patterns needed\n\nWhen to Use Context:\n• Small to medium applications\n• Theme, locale, user auth\n• No complex state logic\n• Want to avoid dependencies\n• Local component state sharing\n• Simple read-mostly data\n\nModern Alternatives:\n• Zustand: Simpler Redux alternative\n• Jotai: Atomic state management\n• Recoil: Facebook's state library\n• MobX: Observable state",
      "explanation": "Redux provides a predictable global state container with middleware and dev tools, best for complex apps. Context is simpler and built-in, suitable for smaller apps or specific use cases like themes and auth.",
      "difficulty": "Medium",
      "code": "// Redux Example\nimport { createStore } from 'redux';\nimport { Provider, useSelector, useDispatch } from 'react-redux';\n\n// Action types\nconst INCREMENT = 'INCREMENT';\nconst DECREMENT = 'DECREMENT';\n\n// Actions\nconst increment = () => ({ type: INCREMENT });\nconst decrement = () => ({ type: DECREMENT });\n\n// Reducer\nfunction counterReducer(state = { count: 0 }, action) {\n  switch (action.type) {\n    case INCREMENT:\n      return { count: state.count + 1 };\n    case DECREMENT:\n      return { count: state.count - 1 };\n    default:\n      return state;\n  }\n}\n\nconst store = createStore(counterReducer);\n\n// Component\nfunction Counter() {\n  const count = useSelector(state => state.count);\n  const dispatch = useDispatch();\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => dispatch(increment())}>+</button>\n      <button onClick={() => dispatch(decrement())}>-</button>\n    </div>\n  );\n}\n\n// App with Provider\nfunction App() {\n  return (\n    <Provider store={store}>\n      <Counter />\n    </Provider>\n  );\n}\n\n// React Context Example\nconst CountContext = createContext();\n\nfunction CountProvider({ children }) {\n  const [count, setCount] = useState(0);\n  \n  const increment = () => setCount(c => c + 1);\n  const decrement = () => setCount(c => c - 1);\n  \n  const value = { count, increment, decrement };\n  \n  return (\n    <CountContext.Provider value={value}>\n      {children}\n    </CountContext.Provider>\n  );\n}\n\nfunction Counter() {\n  const { count, increment, decrement } = useContext(CountContext);\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>+</button>\n      <button onClick={decrement}>-</button>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <CountProvider>\n      <Counter />\n    </CountProvider>\n  );\n}\n\n// Redux Toolkit (Modern Redux)\nimport { configureStore, createSlice } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: { count: 0 },\n  reducers: {\n    increment: state => { state.count += 1; },\n    decrement: state => { state.count -= 1; },\n    incrementByAmount: (state, action) => {\n      state.count += action.payload;\n    }\n  }\n});\n\nconst store = configureStore({\n  reducer: {\n    counter: counterSlice.reducer\n  }\n});\n\nconst { increment, decrement, incrementByAmount } = counterSlice.actions;\n\n// Zustand (Simple Alternative)\nimport create from 'zustand';\n\nconst useStore = create(set => ({\n  count: 0,\n  increment: () => set(state => ({ count: state.count + 1 })),\n  decrement: () => set(state => ({ count: state.count - 1 }))\n}));\n\nfunction Counter() {\n  const { count, increment, decrement } = useStore();\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>+</button>\n      <button onClick={decrement}>-</button>\n    </div>\n  );\n}\n\n// Context Performance Optimization\n// Split contexts to avoid unnecessary re-renders\nconst CountStateContext = createContext();\nconst CountDispatchContext = createContext();\n\nfunction CountProvider({ children }) {\n  const [count, setCount] = useState(0);\n  \n  const increment = useCallback(() => setCount(c => c + 1), []);\n  const decrement = useCallback(() => setCount(c => c - 1), []);\n  \n  const dispatch = useMemo(() => ({ increment, decrement }), [increment, decrement]);\n  \n  return (\n    <CountStateContext.Provider value={count}>\n      <CountDispatchContext.Provider value={dispatch}>\n        {children}\n      </CountDispatchContext.Provider>\n    </CountStateContext.Provider>\n  );\n}\n\n// Components that only need count\nfunction CountDisplay() {\n  const count = useContext(CountStateContext);\n  return <p>Count: {count}</p>;\n}\n\n// Components that only need actions\nfunction CountControls() {\n  const { increment, decrement } = useContext(CountDispatchContext);\n  return (\n    <div>\n      <button onClick={increment}>+</button>\n      <button onClick={decrement}>-</button>\n    </div>\n  );\n}"
    },
    {
      "id": 67,
      "question": "What is PropTypes and how do you use it for prop validation?",
      "answer": "PropTypes is a runtime type checking library for React component props, helping catch bugs by validating props passed to components.\n\nKey Features:\n• Runtime Validation: Checks props at runtime in development\n• Type Checking: Ensures props have correct types\n• Required Props: Mark props as required or optional\n• Custom Validators: Create custom validation logic\n• Development Only: Warnings only in development mode\n• Documentation: Serves as inline documentation\n\nCommon PropTypes:\n• PropTypes.string: String values\n• PropTypes.number: Numeric values\n• PropTypes.bool: Boolean values\n• PropTypes.array: Arrays\n• PropTypes.object: Objects\n• PropTypes.func: Functions\n• PropTypes.node: Anything renderable\n• PropTypes.element: React element\n• PropTypes.elementType: Component type\n\nAdvanced PropTypes:\n• PropTypes.shape(): Specific object structure\n• PropTypes.arrayOf(): Array of specific type\n• PropTypes.oneOf(): Enum values\n• PropTypes.oneOfType(): Multiple allowed types\n• PropTypes.instanceOf(): Class instance\n• PropTypes.exact(): Exact object shape\n\nModern Alternative:\n• TypeScript: Compile-time type checking\n• Better IDE support\n• Type inference\n• No runtime overhead\n• More powerful type system",
      "explanation": "PropTypes provides runtime prop validation for React components, helping catch bugs and serving as documentation. For new projects, TypeScript is preferred for compile-time type checking.",
      "difficulty": "Easy",
      "code": "import PropTypes from 'prop-types';\n\n// Basic prop types\nfunction UserCard({ name, age, email, isActive }) {\n  return (\n    <div>\n      <h2>{name}</h2>\n      <p>Age: {age}</p>\n      <p>Email: {email}</p>\n      <p>Status: {isActive ? 'Active' : 'Inactive'}</p>\n    </div>\n  );\n}\n\nUserCard.propTypes = {\n  name: PropTypes.string.isRequired,\n  age: PropTypes.number.isRequired,\n  email: PropTypes.string.isRequired,\n  isActive: PropTypes.bool\n};\n\nUserCard.defaultProps = {\n  isActive: true\n};\n\n// Array and object prop types\nfunction ProductList({ products, category, onProductClick }) {\n  return (\n    <div>\n      <h2>{category.name}</h2>\n      {products.map(product => (\n        <div key={product.id} onClick={() => onProductClick(product.id)}>\n          {product.name}\n        </div>\n      ))}\n    </div>\n  );\n}\n\nProductList.propTypes = {\n  products: PropTypes.arrayOf(\n    PropTypes.shape({\n      id: PropTypes.number.isRequired,\n      name: PropTypes.string.isRequired,\n      price: PropTypes.number.isRequired\n    })\n  ).isRequired,\n  category: PropTypes.shape({\n    id: PropTypes.number,\n    name: PropTypes.string.isRequired\n  }),\n  onProductClick: PropTypes.func.isRequired\n};\n\n// Enum values with oneOf\nfunction Alert({ type, message }) {\n  return <div className={`alert-${type}`}>{message}</div>;\n}\n\nAlert.propTypes = {\n  type: PropTypes.oneOf(['success', 'error', 'warning', 'info']).isRequired,\n  message: PropTypes.string.isRequired\n};\n\n// Multiple types with oneOfType\nfunction Icon({ size, color }) {\n  return <span style={{ fontSize: size, color }}></span>;\n}\n\nIcon.propTypes = {\n  size: PropTypes.oneOfType([\n    PropTypes.number,\n    PropTypes.string\n  ]),\n  color: PropTypes.string\n};\n\n// React node and element\nfunction Container({ children, header }) {\n  return (\n    <div>\n      {header}\n      <div>{children}</div>\n    </div>\n  );\n}\n\nContainer.propTypes = {\n  children: PropTypes.node.isRequired,\n  header: PropTypes.element\n};\n\n// Component type\nfunction Wrapper({ component: Component, props }) {\n  return <Component {...props} />;\n}\n\nWrapper.propTypes = {\n  component: PropTypes.elementType.isRequired,\n  props: PropTypes.object\n};\n\n// Custom validator\nfunction RangeInput({ value }) {\n  return <input type=\"range\" value={value} />;\n}\n\nRangeInput.propTypes = {\n  value: function(props, propName, componentName) {\n    const value = props[propName];\n    \n    if (value == null) {\n      return new Error(`${propName} is required`);\n    }\n    \n    if (typeof value !== 'number') {\n      return new Error(`${propName} must be a number`);\n    }\n    \n    if (value < 0 || value > 100) {\n      return new Error(\n        `${propName} in ${componentName} must be between 0 and 100`\n      );\n    }\n  }\n};\n\n// Exact object shape\nfunction Settings({ config }) {\n  return <div>{config.theme}</div>;\n}\n\nSettings.propTypes = {\n  config: PropTypes.exact({\n    theme: PropTypes.string.isRequired,\n    language: PropTypes.string.isRequired\n  })\n};\n\n// Class instance\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nfunction PersonDisplay({ person }) {\n  return <div>{person.name}</div>;\n}\n\nPersonDisplay.propTypes = {\n  person: PropTypes.instanceOf(Person).isRequired\n};\n\n// TypeScript Alternative (Preferred)\ninterface UserCardProps {\n  name: string;\n  age: number;\n  email: string;\n  isActive?: boolean;\n}\n\nfunction UserCard({ name, age, email, isActive = true }: UserCardProps) {\n  return (\n    <div>\n      <h2>{name}</h2>\n      <p>Age: {age}</p>\n      <p>Email: {email}</p>\n      <p>Status: {isActive ? 'Active' : 'Inactive'}</p>\n    </div>\n  );\n}\n\n// Complex TypeScript types\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n}\n\ninterface Category {\n  id?: number;\n  name: string;\n}\n\ninterface ProductListProps {\n  products: Product[];\n  category: Category;\n  onProductClick: (id: number) => void;\n}\n\nfunction ProductList({ products, category, onProductClick }: ProductListProps) {\n  return (\n    <div>\n      <h2>{category.name}</h2>\n      {products.map(product => (\n        <div key={product.id} onClick={() => onProductClick(product.id)}>\n          {product.name}\n        </div>\n      ))}\n    </div>\n  );\n}"
    },
    {
      "id": 68,
      "question": "How do you implement and use Context API effectively in React?",
      "answer": "Context API provides a way to pass data through the component tree without prop drilling, ideal for global state like themes, auth, and preferences.\n\nCore Concepts:\n• createContext: Creates context object\n• Provider: Supplies value to tree\n• Consumer: Consumes context value (legacy)\n• useContext: Hook to consume context (modern)\n• Default Value: Fallback when no provider\n• Multiple Contexts: Use several contexts together\n\nContext Best Practices:\n• Split Contexts: Separate concerns to avoid re-renders\n• Memoize Values: Prevent unnecessary updates\n• Context + Reducer: Complex state logic\n• Custom Hooks: Encapsulate context usage\n• Provider Composition: Combine multiple providers\n• Error Boundaries: Handle context errors\n\nPerformance Considerations:\n• Context Changes: All consumers re-render\n• Split State and Dispatch: Optimize updates\n• Use Memo: Memoize expensive computations\n• Selector Pattern: Select specific values\n• Multiple Providers: Granular updates\n\nCommon Use Cases:\n• Theme/UI Mode: Dark/light mode\n• Authentication: User session, permissions\n• Localization: Language, translations\n• Feature Flags: A/B testing\n• Form State: Shared form data\n• Toast/Notifications: Global notifications\n\nWhen NOT to Use:\n• Frequent Updates: High-frequency state changes\n• Large State: Complex state with many updates\n• Non-React Libraries: Third-party integrations",
      "explanation": "Context API shares data across component tree without prop drilling. Create context with createContext, provide value with Provider, consume with useContext. Optimize by splitting contexts and memoizing values.",
      "difficulty": "Medium",
      "code": "// Basic Context Usage\nimport { createContext, useContext, useState } from 'react';\n\n// Create context\nconst ThemeContext = createContext();\n\n// Provider component\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n  \n  const toggleTheme = () => {\n    setTheme(prev => prev === 'light' ? 'dark' : 'light');\n  };\n  \n  const value = { theme, toggleTheme };\n  \n  return (\n    <ThemeContext.Provider value={value}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\n// Custom hook for consuming context\nfunction useTheme() {\n  const context = useContext(ThemeContext);\n  \n  if (context === undefined) {\n    throw new Error('useTheme must be used within ThemeProvider');\n  }\n  \n  return context;\n}\n\n// Using the context\nfunction Button() {\n  const { theme, toggleTheme } = useTheme();\n  \n  return (\n    <button\n      style={{ background: theme === 'dark' ? '#333' : '#fff' }}\n      onClick={toggleTheme}\n    >\n      Toggle Theme\n    </button>\n  );\n}\n\nfunction App() {\n  return (\n    <ThemeProvider>\n      <Button />\n    </ThemeProvider>\n  );\n}\n\n// Context with useReducer for complex state\nconst CartContext = createContext();\n\nfunction cartReducer(state, action) {\n  switch (action.type) {\n    case 'ADD_ITEM':\n      return {\n        ...state,\n        items: [...state.items, action.payload]\n      };\n    case 'REMOVE_ITEM':\n      return {\n        ...state,\n        items: state.items.filter(item => item.id !== action.payload)\n      };\n    case 'CLEAR_CART':\n      return { items: [] };\n    default:\n      return state;\n  }\n}\n\nfunction CartProvider({ children }) {\n  const [state, dispatch] = useReducer(cartReducer, { items: [] });\n  \n  return (\n    <CartContext.Provider value={{ state, dispatch }}>\n      {children}\n    </CartContext.Provider>\n  );\n}\n\nfunction useCart() {\n  const context = useContext(CartContext);\n  if (!context) {\n    throw new Error('useCart must be used within CartProvider');\n  }\n  return context;\n}\n\n// Split contexts for performance\nconst AuthStateContext = createContext();\nconst AuthDispatchContext = createContext();\n\nfunction AuthProvider({ children }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  \n  const login = useCallback(async (credentials) => {\n    setLoading(true);\n    const user = await api.login(credentials);\n    setUser(user);\n    setLoading(false);\n  }, []);\n  \n  const logout = useCallback(() => {\n    setUser(null);\n  }, []);\n  \n  // Memoize dispatch methods\n  const dispatch = useMemo(\n    () => ({ login, logout }),\n    [login, logout]\n  );\n  \n  return (\n    <AuthStateContext.Provider value={{ user, loading }}>\n      <AuthDispatchContext.Provider value={dispatch}>\n        {children}\n      </AuthDispatchContext.Provider>\n    </AuthStateContext.Provider>\n  );\n}\n\n// Components only re-render when their context changes\nfunction UserDisplay() {\n  const { user } = useContext(AuthStateContext);\n  return <div>{user?.name}</div>;\n}\n\nfunction LoginButton() {\n  const { login } = useContext(AuthDispatchContext);\n  return <button onClick={() => login({})}>Login</button>;\n}\n\n// Multiple contexts composed\nfunction AppProviders({ children }) {\n  return (\n    <ThemeProvider>\n      <AuthProvider>\n        <CartProvider>\n          {children}\n        </CartProvider>\n      </AuthProvider>\n    </ThemeProvider>\n  );\n}\n\n// Context with localStorage persistence\nfunction LocalStorageProvider({ children }) {\n  const [settings, setSettings] = useState(() => {\n    const saved = localStorage.getItem('settings');\n    return saved ? JSON.parse(saved) : { notifications: true };\n  });\n  \n  useEffect(() => {\n    localStorage.setItem('settings', JSON.stringify(settings));\n  }, [settings]);\n  \n  const value = useMemo(\n    () => ({ settings, setSettings }),\n    [settings]\n  );\n  \n  return (\n    <SettingsContext.Provider value={value}>\n      {children}\n    </SettingsContext.Provider>\n  );\n}\n\n// Selector pattern for optimization\nfunction createSelector(selector) {\n  return function useSelector() {\n    const state = useContext(StateContext);\n    return selector(state);\n  };\n}\n\nconst useUser = createSelector(state => state.user);\nconst useCart = createSelector(state => state.cart);\n\nfunction UserProfile() {\n  const user = useUser(); // Only re-renders when user changes\n  return <div>{user.name}</div>;\n}\n\n// Context with TypeScript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface AuthContextType {\n  user: User | null;\n  login: (credentials: LoginCredentials) => Promise<void>;\n  logout: () => void;\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\nfunction useAuth(): AuthContextType {\n  const context = useContext(AuthContext);\n  \n  if (context === undefined) {\n    throw new Error('useAuth must be used within AuthProvider');\n  }\n  \n  return context;\n}"
    },
    {
      "id": 69,
      "question": "What is Zustand and how does it compare to Redux?",
      "answer": "Zustand is a small, fast state management library with a simplified API compared to Redux, offering a modern approach to global state without boilerplate.\n\nZustand Features:\n• Minimal Boilerplate: No actions, reducers, providers\n• Hooks-Based: Simple hooks API\n• Small Bundle: ~1KB minified + gzipped\n• No Context: Direct store access, no providers needed\n• TypeScript Support: Excellent TypeScript integration\n• DevTools: Redux DevTools compatible\n• Middleware: Custom middleware support\n• Transient Updates: Temporary state without re-renders\n\nZustand vs Redux:\n• Setup: Zustand much simpler\n• Boilerplate: Redux requires more code\n• Learning Curve: Zustand easier to learn\n• Ecosystem: Redux has larger ecosystem\n• DevTools: Both support debugging\n• Performance: Both similar, Zustand slightly lighter\n• TypeScript: Zustand simpler types\n\nZustand Patterns:\n• Single Store: Or multiple stores\n• Slices Pattern: Split store into sections\n• Immer Integration: Mutable updates\n• Persist Middleware: LocalStorage persistence\n• Computed Values: Derived state\n• Async Actions: Built-in async support\n\nWhen to Use Zustand:\n• Want simple API\n• Don't need Redux ecosystem\n• Starting new project\n• Small to medium apps\n• Prefer hooks-based approach",
      "explanation": "Zustand is a lightweight Redux alternative with minimal boilerplate and hooks-based API. It's simpler to learn and use while providing similar functionality without context providers or action creators.",
      "difficulty": "Medium",
      "code": "// Basic Zustand store\nimport create from 'zustand';\n\nconst useStore = create((set) => ({\n  count: 0,\n  increment: () => set((state) => ({ count: state.count + 1 })),\n  decrement: () => set((state) => ({ count: state.count - 1 })),\n  reset: () => set({ count: 0 })\n}));\n\n// Using the store\nfunction Counter() {\n  const count = useStore(state => state.count);\n  const increment = useStore(state => state.increment);\n  const decrement = useStore(state => state.decrement);\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>+</button>\n      <button onClick={decrement}>-</button>\n    </div>\n  );\n}\n\n// Selecting specific state (optimized)\nfunction CountDisplay() {\n  const count = useStore(state => state.count);\n  // Only re-renders when count changes\n  return <p>Count: {count}</p>;\n}\n\nfunction CountButtons() {\n  const { increment, decrement } = useStore(\n    state => ({ increment: state.increment, decrement: state.decrement }),\n    shallow // Shallow comparison\n  );\n  // Doesn't re-render when count changes\n  return (\n    <div>\n      <button onClick={increment}>+</button>\n      <button onClick={decrement}>-</button>\n    </div>\n  );\n}\n\n// Async actions\nconst useUserStore = create((set) => ({\n  user: null,\n  loading: false,\n  error: null,\n  fetchUser: async (id) => {\n    set({ loading: true, error: null });\n    try {\n      const user = await api.getUser(id);\n      set({ user, loading: false });\n    } catch (error) {\n      set({ error: error.message, loading: false });\n    }\n  }\n}));\n\n// Using async actions\nfunction UserProfile({ userId }) {\n  const { user, loading, error, fetchUser } = useUserStore();\n  \n  useEffect(() => {\n    fetchUser(userId);\n  }, [userId, fetchUser]);\n  \n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error}</div>;\n  return <div>{user?.name}</div>;\n}\n\n// Slices pattern for large stores\nconst createUserSlice = (set) => ({\n  user: null,\n  setUser: (user) => set({ user }),\n  clearUser: () => set({ user: null })\n});\n\nconst createCartSlice = (set) => ({\n  items: [],\n  addItem: (item) => set((state) => ({\n    items: [...state.items, item]\n  })),\n  removeItem: (id) => set((state) => ({\n    items: state.items.filter(item => item.id !== id)\n  }))\n});\n\nconst useStore = create((set) => ({\n  ...createUserSlice(set),\n  ...createCartSlice(set)\n}));\n\n// With Immer middleware (mutable updates)\nimport produce from 'immer';\nimport { immer } from 'zustand/middleware/immer';\n\nconst useStore = create(\n  immer((set) => ({\n    items: [],\n    addItem: (item) => set((state) => {\n      state.items.push(item); // Mutable update!\n    }),\n    updateItem: (id, data) => set((state) => {\n      const item = state.items.find(item => item.id === id);\n      if (item) {\n        Object.assign(item, data);\n      }\n    })\n  }))\n);\n\n// With persist middleware (localStorage)\nimport { persist } from 'zustand/middleware';\n\nconst useStore = create(\n  persist(\n    (set) => ({\n      theme: 'light',\n      setTheme: (theme) => set({ theme })\n    }),\n    {\n      name: 'app-storage', // localStorage key\n      getStorage: () => localStorage\n    }\n  )\n);\n\n// DevTools middleware\nimport { devtools } from 'zustand/middleware';\n\nconst useStore = create(\n  devtools(\n    (set) => ({\n      count: 0,\n      increment: () => set((state) => ({ count: state.count + 1 }))\n    }),\n    { name: 'CounterStore' }\n  )\n);\n\n// TypeScript support\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface UserStore {\n  user: User | null;\n  loading: boolean;\n  error: string | null;\n  fetchUser: (id: number) => Promise<void>;\n  setUser: (user: User) => void;\n}\n\nconst useUserStore = create<UserStore>((set) => ({\n  user: null,\n  loading: false,\n  error: null,\n  fetchUser: async (id) => {\n    set({ loading: true, error: null });\n    try {\n      const user = await api.getUser(id);\n      set({ user, loading: false });\n    } catch (error) {\n      set({ error: (error as Error).message, loading: false });\n    }\n  },\n  setUser: (user) => set({ user })\n}));\n\n// Transient updates (no re-renders)\nconst useStore = create((set) => ({\n  mousePosition: { x: 0, y: 0 },\n  setMousePosition: (pos) => set({ mousePosition: pos })\n}));\n\n// Use transient updates\nfunction MouseTracker() {\n  useEffect(() => {\n    const handleMouseMove = (e) => {\n      // Update without re-rendering\n      useStore.setState({ \n        mousePosition: { x: e.clientX, y: e.clientY } \n      }, true); // true = replace state\n    };\n    \n    window.addEventListener('mousemove', handleMouseMove);\n    return () => window.removeEventListener('mousemove', handleMouseMove);\n  }, []);\n  \n  return null;\n}\n\n// Computed values\nconst useStore = create((set, get) => ({\n  items: [],\n  getTotal: () => get().items.reduce((sum, item) => sum + item.price, 0),\n  addItem: (item) => set((state) => ({\n    items: [...state.items, item]\n  }))\n}));\n\nfunction Cart() {\n  const items = useStore(state => state.items);\n  const getTotal = useStore(state => state.getTotal);\n  \n  return (\n    <div>\n      <p>Total: ${getTotal()}</p>\n    </div>\n  );\n}"
    },
    {
      "id": 70,
      "question": "What are advanced patterns for managing complex state in React applications?",
      "answer": "Complex state management requires patterns that handle scalability, performance, and maintainability while keeping code organized and testable.\n\nState Management Patterns:\n• Compound State: Related state values grouped together\n• State Machines: Finite states and transitions\n• Reducer Pattern: Predictable state updates\n• Normalized State: Flat data structures\n• Optimistic Updates: Update UI before server response\n• Derived State: Compute values from state\n• State Colocation: Keep state close to where it's used\n• Lifting State: Move state to common ancestor\n\nComplex State Strategies:\n• useReducer: Complex state logic\n• Context + Reducer: Global state management\n• State Slicing: Split large state into pieces\n• Selector Pattern: Compute derived values\n• Command Pattern: Encapsulate actions\n• Observer Pattern: Subscribe to changes\n\nPerformance Patterns:\n• Memoization: Cache expensive computations\n• State Splitting: Separate frequently changing state\n• Lazy Initialization: Defer expensive initialization\n• Batching Updates: Group multiple updates\n• Immutable Updates: Enable optimizations\n\nArchitectural Patterns:\n• Feature-Based: Organize by feature\n• Domain-Driven: Model business domain\n• Layered Architecture: Separate concerns\n• Flux Architecture: Unidirectional data flow\n• CQRS: Separate reads and writes",
      "explanation": "Complex state management requires patterns like state machines, normalized data, reducers, and optimization techniques. Choose patterns based on application needs, balancing simplicity, performance, and maintainability.",
      "difficulty": "Hard",
      "code": "// State Machine Pattern with XState\nimport { createMachine, assign } from 'xstate';\nimport { useMachine } from '@xstate/react';\n\nconst fetchMachine = createMachine({\n  id: 'fetch',\n  initial: 'idle',\n  context: {\n    data: null,\n    error: null\n  },\n  states: {\n    idle: {\n      on: { FETCH: 'loading' }\n    },\n    loading: {\n      invoke: {\n        src: 'fetchData',\n        onDone: {\n          target: 'success',\n          actions: assign({ data: (_, event) => event.data })\n        },\n        onError: {\n          target: 'failure',\n          actions: assign({ error: (_, event) => event.data })\n        }\n      }\n    },\n    success: {\n      on: { FETCH: 'loading' }\n    },\n    failure: {\n      on: { RETRY: 'loading' }\n    }\n  }\n}, {\n  services: {\n    fetchData: async () => {\n      const response = await fetch('/api/data');\n      return response.json();\n    }\n  }\n});\n\nfunction DataFetcher() {\n  const [state, send] = useMachine(fetchMachine);\n  \n  return (\n    <div>\n      {state.matches('idle') && (\n        <button onClick={() => send('FETCH')}>Load Data</button>\n      )}\n      {state.matches('loading') && <div>Loading...</div>}\n      {state.matches('success') && <div>{state.context.data}</div>}\n      {state.matches('failure') && (\n        <div>\n          <p>Error: {state.context.error.message}</p>\n          <button onClick={() => send('RETRY')}>Retry</button>\n        </div>\n      )}\n    </div>\n  );\n}\n\n// Normalized State Pattern\n// BAD: Nested state\nconst badState = {\n  posts: [\n    {\n      id: 1,\n      title: 'Post 1',\n      author: { id: 1, name: 'John' },\n      comments: [\n        { id: 1, text: 'Comment 1', author: { id: 2, name: 'Jane' } }\n      ]\n    }\n  ]\n};\n\n// GOOD: Normalized state\nconst normalizedState = {\n  posts: {\n    byId: {\n      1: { id: 1, title: 'Post 1', authorId: 1, commentIds: [1] }\n    },\n    allIds: [1]\n  },\n  users: {\n    byId: {\n      1: { id: 1, name: 'John' },\n      2: { id: 2, name: 'Jane' }\n    },\n    allIds: [1, 2]\n  },\n  comments: {\n    byId: {\n      1: { id: 1, text: 'Comment 1', authorId: 2 }\n    },\n    allIds: [1]\n  }\n};\n\n// Selectors for normalized state\nconst selectPost = (state, postId) => state.posts.byId[postId];\nconst selectPostWithAuthor = (state, postId) => {\n  const post = selectPost(state, postId);\n  const author = state.users.byId[post.authorId];\n  return { ...post, author };\n};\n\n// Optimistic Updates Pattern\nfunction useOptimisticUpdate() {\n  const [data, setData] = useState([]);\n  const [optimisticUpdates, setOptimisticUpdates] = useState({});\n  \n  const updateItem = async (id, updates) => {\n    // Optimistically update UI\n    setOptimisticUpdates(prev => ({\n      ...prev,\n      [id]: updates\n    }));\n    \n    try {\n      // Send to server\n      const result = await api.updateItem(id, updates);\n      \n      // Update with server response\n      setData(prev => prev.map(item => \n        item.id === id ? result : item\n      ));\n      \n      // Clear optimistic update\n      setOptimisticUpdates(prev => {\n        const { [id]: _, ...rest } = prev;\n        return rest;\n      });\n    } catch (error) {\n      // Revert optimistic update on error\n      setOptimisticUpdates(prev => {\n        const { [id]: _, ...rest } = prev;\n        return rest;\n      });\n      console.error('Update failed:', error);\n    }\n  };\n  \n  // Merge data with optimistic updates\n  const displayData = data.map(item => ({\n    ...item,\n    ...optimisticUpdates[item.id]\n  }));\n  \n  return { data: displayData, updateItem };\n}\n\n// Command Pattern for Complex Actions\nclass Command {\n  execute() {\n    throw new Error('Must implement execute');\n  }\n  undo() {\n    throw new Error('Must implement undo');\n  }\n}\n\nclass AddItemCommand extends Command {\n  constructor(item) {\n    super();\n    this.item = item;\n  }\n  \n  execute(state) {\n    return { items: [...state.items, this.item] };\n  }\n  \n  undo(state) {\n    return {\n      items: state.items.filter(item => item.id !== this.item.id)\n    };\n  }\n}\n\nfunction useCommandPattern() {\n  const [state, setState] = useState({ items: [] });\n  const [history, setHistory] = useState([]);\n  const [currentIndex, setCurrentIndex] = useState(-1);\n  \n  const execute = (command) => {\n    const newState = command.execute(state);\n    setState(newState);\n    \n    const newHistory = history.slice(0, currentIndex + 1);\n    setHistory([...newHistory, command]);\n    setCurrentIndex(currentIndex + 1);\n  };\n  \n  const undo = () => {\n    if (currentIndex >= 0) {\n      const command = history[currentIndex];\n      const newState = command.undo(state);\n      setState(newState);\n      setCurrentIndex(currentIndex - 1);\n    }\n  };\n  \n  const redo = () => {\n    if (currentIndex < history.length - 1) {\n      const command = history[currentIndex + 1];\n      const newState = command.execute(state);\n      setState(newState);\n      setCurrentIndex(currentIndex + 1);\n    }\n  };\n  \n  return { state, execute, undo, redo };\n}\n\n// Advanced useReducer with middleware\nfunction createReducerWithMiddleware(reducer, middleware) {\n  return (state, action) => {\n    const newState = reducer(state, action);\n    middleware.forEach(mw => mw(state, action, newState));\n    return newState;\n  };\n}\n\nconst logger = (prevState, action, nextState) => {\n  console.group(action.type);\n  console.log('Previous State:', prevState);\n  console.log('Action:', action);\n  console.log('Next State:', nextState);\n  console.groupEnd();\n};\n\nconst analytics = (prevState, action) => {\n  if (action.type.startsWith('USER_')) {\n    trackEvent(action.type, action.payload);\n  }\n};\n\nfunction MyComponent() {\n  const reducer = createReducerWithMiddleware(\n    myReducer,\n    [logger, analytics]\n  );\n  \n  const [state, dispatch] = useReducer(reducer, initialState);\n  \n  return <div>{/* ... */}</div>;\n}"
    },
    {
      "id": 71,
      "question": "What are advanced patterns for custom hooks and when should you use them?",
      "answer": "Advanced custom hooks patterns help create reusable, composable, and maintainable logic that can be shared across components.\n\nCustom Hook Patterns:\n• Data Fetching Hooks: Encapsulate API calls and state\n• State Machine Hooks: Manage complex state transitions\n• Subscription Hooks: Handle event listeners and cleanup\n• Debounce/Throttle Hooks: Control function execution rate\n• Local Storage Hooks: Persist state to storage\n• Media Query Hooks: Responsive design logic\n• Form Hooks: Form state and validation\n• Animation Hooks: Animation state management\n\nBest Practices:\n• Single Responsibility: One purpose per hook\n• Composability: Combine hooks together\n• Return Objects/Arrays: Flexible return values\n• Error Handling: Handle errors gracefully\n• TypeScript: Strong typing for better DX\n• Testing: Test hooks in isolation\n• Documentation: Clear usage examples\n• Naming: Start with use prefix\n\nCommon Patterns:\n• Return Arrays: Like useState [value, setter]\n• Return Objects: Named properties\n• Return Functions: Callbacks and utilities\n• Provide Options: Configuration object\n• Support Async: Handle promises\n• Cleanup: Always cleanup side effects\n\nWhen to Create Custom Hooks:\n• Repeated Logic: Same code in multiple components\n• Complex State: Intricate state management\n• Side Effects: Reusable effects logic\n• Third-Party Integration: Wrap external libraries\n• Testing: Easier to test isolated logic",
      "explanation": "Custom hooks encapsulate reusable logic, combining React primitives into higher-level abstractions. Use them for data fetching, subscriptions, state management, and any repeated logic across components.",
      "difficulty": "Hard",
      "code": "// Advanced data fetching hook\nfunction useFetch(url, options = {}) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const abortControllerRef = useRef();\n\n  useEffect(() => {\n    abortControllerRef.current = new AbortController();\n    \n    async function fetchData() {\n      setLoading(true);\n      setError(null);\n      \n      try {\n        const response = await fetch(url, {\n          ...options,\n          signal: abortControllerRef.current.signal\n        });\n        \n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const json = await response.json();\n        setData(json);\n      } catch (err) {\n        if (err.name !== 'AbortError') {\n          setError(err.message);\n        }\n      } finally {\n        setLoading(false);\n      }\n    }\n    \n    fetchData();\n    \n    return () => {\n      abortControllerRef.current.abort();\n    };\n  }, [url]);\n\n  const refetch = useCallback(() => {\n    setData(null);\n    setLoading(true);\n    setError(null);\n  }, []);\n\n  return { data, loading, error, refetch };\n}\n\n// Debounce hook\nfunction useDebounce(value, delay = 500) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => {\n      clearTimeout(timer);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n\n// Usage\nfunction SearchComponent() {\n  const [searchTerm, setSearchTerm] = useState('');\n  const debouncedSearchTerm = useDebounce(searchTerm, 300);\n  const { data } = useFetch(`/api/search?q=${debouncedSearchTerm}`);\n\n  return (\n    <div>\n      <input\n        value={searchTerm}\n        onChange={(e) => setSearchTerm(e.target.value)}\n        placeholder=\"Search...\"\n      />\n      <Results data={data} />\n    </div>\n  );\n}\n\n// Local storage hook\nfunction useLocalStorage(key, initialValue) {\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.error(error);\n      return initialValue;\n    }\n  });\n\n  const setValue = useCallback((value) => {\n    try {\n      const valueToStore = value instanceof Function ? value(storedValue) : value;\n      setStoredValue(valueToStore);\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      console.error(error);\n    }\n  }, [key, storedValue]);\n\n  return [storedValue, setValue];\n}\n\n// Media query hook\nfunction useMediaQuery(query) {\n  const [matches, setMatches] = useState(\n    () => window.matchMedia(query).matches\n  );\n\n  useEffect(() => {\n    const mediaQuery = window.matchMedia(query);\n    \n    const handleChange = (e) => {\n      setMatches(e.matches);\n    };\n\n    mediaQuery.addEventListener('change', handleChange);\n    \n    return () => {\n      mediaQuery.removeEventListener('change', handleChange);\n    };\n  }, [query]);\n\n  return matches;\n}\n\n// Usage\nfunction ResponsiveComponent() {\n  const isMobile = useMediaQuery('(max-width: 768px)');\n  const isDarkMode = useMediaQuery('(prefers-color-scheme: dark)');\n\n  return (\n    <div>\n      {isMobile ? <MobileView /> : <DesktopView />}\n      {isDarkMode && <DarkModeStyles />}\n    </div>\n  );\n}\n\n// Interval hook\nfunction useInterval(callback, delay) {\n  const savedCallback = useRef(callback);\n\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n\n  useEffect(() => {\n    if (delay === null) return;\n\n    const id = setInterval(() => savedCallback.current(), delay);\n    return () => clearInterval(id);\n  }, [delay]);\n}\n\n// Previous value hook\nfunction usePrevious(value) {\n  const ref = useRef();\n  \n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  \n  return ref.current;\n}\n\n// Toggle hook\nfunction useToggle(initialValue = false) {\n  const [value, setValue] = useState(initialValue);\n  \n  const toggle = useCallback(() => {\n    setValue(v => !v);\n  }, []);\n  \n  const setTrue = useCallback(() => {\n    setValue(true);\n  }, []);\n  \n  const setFalse = useCallback(() => {\n    setValue(false);\n  }, []);\n  \n  return [value, { toggle, setTrue, setFalse }];\n}\n\n// Form hook\nfunction useForm(initialValues, validate) {\n  const [values, setValues] = useState(initialValues);\n  const [errors, setErrors] = useState({});\n  const [touched, setTouched] = useState({});\n\n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    setValues(prev => ({ ...prev, [name]: value }));\n  };\n\n  const handleBlur = (e) => {\n    const { name } = e.target;\n    setTouched(prev => ({ ...prev, [name]: true }));\n    \n    if (validate) {\n      const validationErrors = validate(values);\n      setErrors(validationErrors);\n    }\n  };\n\n  const handleSubmit = (onSubmit) => (e) => {\n    e.preventDefault();\n    const validationErrors = validate ? validate(values) : {};\n    setErrors(validationErrors);\n    \n    if (Object.keys(validationErrors).length === 0) {\n      onSubmit(values);\n    }\n  };\n\n  const reset = () => {\n    setValues(initialValues);\n    setErrors({});\n    setTouched({});\n  };\n\n  return {\n    values,\n    errors,\n    touched,\n    handleChange,\n    handleBlur,\n    handleSubmit,\n    reset\n  };\n}\n\n// Async hook with retry\nfunction useAsync(asyncFunction, immediate = true) {\n  const [status, setStatus] = useState('idle');\n  const [data, setData] = useState(null);\n  const [error, setError] = useState(null);\n\n  const execute = useCallback(async (...params) => {\n    setStatus('pending');\n    setData(null);\n    setError(null);\n\n    try {\n      const response = await asyncFunction(...params);\n      setData(response);\n      setStatus('success');\n      return response;\n    } catch (error) {\n      setError(error);\n      setStatus('error');\n      throw error;\n    }\n  }, [asyncFunction]);\n\n  useEffect(() => {\n    if (immediate) {\n      execute();\n    }\n  }, [execute, immediate]);\n\n  return { execute, status, data, error };\n}"
    },
    {
      "id": 72,
      "question": "What are dependency arrays in hooks and what are common pitfalls?",
      "answer": "Dependency arrays in React hooks specify when effects and memoizations should re-run, crucial for correctness and performance.\n\nDependency Array Rules:\n• Include All Dependencies: Every value used inside the effect\n• Primitive Values: Compare by value\n• Objects/Arrays: Compare by reference\n• Functions: Should be stable or in deps\n• Props/State: Must be included if used\n• Omit Constants: Values that never change\n\nCommon Patterns:\n• Empty Array []: Run once on mount\n• No Array: Run on every render\n• With Dependencies [dep1, dep2]: Run when deps change\n• Stable Functions: Use useCallback\n• Stable Objects: Use useMemo\n\nCommon Pitfalls:\n• Missing Dependencies: Stale closures\n• Object Dependencies: Reference comparison issues\n• Inline Objects: New reference every render\n• Inline Functions: New reference every render\n• Exhaustive Deps: ESLint rule violations\n• Over-dependencies: Too many re-runs\n\nSolutions:\n• ESLint Plugin: react-hooks/exhaustive-deps\n• useCallback: Stable function references\n• useMemo: Stable object references\n• Refs: Mutable values without triggers\n• State Updater Functions: Access current state\n• Split Effects: Separate concerns\n\nAdvanced Techniques:\n• Custom Comparisons: useEffect with custom logic\n• Selective Updates: Only update what changed\n• Debouncing: Limit effect frequency\n• Effect Dependencies: Chain effects properly",
      "explanation": "Dependency arrays tell React when to re-run effects and recompute memoized values. Include all dependencies used inside, stabilize references with useCallback/useMemo, and follow ESLint's exhaustive-deps rule.",
      "difficulty": "Hard",
      "code": "// Missing dependency pitfall\nfunction BadExample() {\n  const [count, setCount] = useState(0);\n  const [multiplier, setMultiplier] = useState(2);\n\n  useEffect(() => {\n    // BAD: Uses multiplier but not in deps\n    console.log(count * multiplier);\n  }, [count]); // Missing multiplier!\n\n  return <div>...</div>;\n}\n\n// Correct implementation\nfunction GoodExample() {\n  const [count, setCount] = useState(0);\n  const [multiplier, setMultiplier] = useState(2);\n\n  useEffect(() => {\n    // GOOD: All dependencies included\n    console.log(count * multiplier);\n  }, [count, multiplier]);\n\n  return <div>...</div>;\n}\n\n// Inline object/function pitfall\nfunction BadObjectDeps({ userId }) {\n  const [user, setUser] = useState(null);\n\n  useEffect(() => {\n    // BAD: New object every render\n    fetchUser({ id: userId, include: 'posts' }).then(setUser);\n  }, [{ id: userId, include: 'posts' }]); // Always different reference!\n\n  return <div>{user?.name}</div>;\n}\n\n// Solution 1: Extract to variable outside\nfunction GoodObjectDeps({ userId }) {\n  const [user, setUser] = useState(null);\n\n  // GOOD: Stable reference\n  const options = useMemo(\n    () => ({ id: userId, include: 'posts' }),\n    [userId]\n  );\n\n  useEffect(() => {\n    fetchUser(options).then(setUser);\n  }, [options]);\n\n  return <div>{user?.name}</div>;\n}\n\n// Solution 2: Include primitive values\nfunction BetterObjectDeps({ userId }) {\n  const [user, setUser] = useState(null);\n\n  useEffect(() => {\n    fetchUser({ id: userId, include: 'posts' }).then(setUser);\n  }, [userId]); // Only primitive dependency\n\n  return <div>{user?.name}</div>;\n}\n\n// Function dependency pitfall\nfunction BadFunctionDeps() {\n  const [count, setCount] = useState(0);\n\n  const logCount = () => {\n    console.log(count);\n  };\n\n  useEffect(() => {\n    logCount();\n  }, [logCount]); // logCount changes every render!\n\n  return <button onClick={() => setCount(count + 1)}>Count: {count}</button>;\n}\n\n// Solution: useCallback\nfunction GoodFunctionDeps() {\n  const [count, setCount] = useState(0);\n\n  const logCount = useCallback(() => {\n    console.log(count);\n  }, [count]);\n\n  useEffect(() => {\n    logCount();\n  }, [logCount]); // Stable reference\n\n  return <button onClick={() => setCount(count + 1)}>Count: {count}</button>;\n}\n\n// State updater function pattern\nfunction StateUpdaterPattern() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      // GOOD: No count dependency needed\n      setCount(c => c + 1);\n    }, 1000);\n\n    return () => clearInterval(id);\n  }, []); // Empty deps works!\n\n  return <div>Count: {count}</div>;\n}\n\n// Wrong: count in deps causes interval reset\nfunction BadIntervalPattern() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(count + 1); // Stale closure!\n    }, 1000);\n\n    return () => clearInterval(id);\n  }, [count]); // Interval resets every second!\n\n  return <div>Count: {count}</div>;\n}\n\n// Using refs for values that don't need re-runs\nfunction RefPattern({ onUpdate }) {\n  const [count, setCount] = useState(0);\n  const onUpdateRef = useRef(onUpdate);\n\n  // Keep ref current\n  useEffect(() => {\n    onUpdateRef.current = onUpdate;\n  }, [onUpdate]);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      // Use latest callback without re-creating interval\n      onUpdateRef.current(count);\n    }, 1000);\n\n    return () => clearInterval(id);\n  }, [count]);\n\n  return <div>Count: {count}</div>;\n}\n\n// Split effects pattern\nfunction SplitEffects({ userId, theme }) {\n  const [user, setUser] = useState(null);\n\n  // Effect 1: Fetch user when userId changes\n  useEffect(() => {\n    fetchUser(userId).then(setUser);\n  }, [userId]);\n\n  // Effect 2: Update theme (separate concern)\n  useEffect(() => {\n    document.body.className = theme;\n  }, [theme]);\n\n  return <div>{user?.name}</div>;\n}\n\n// Custom comparison hook\nfunction useDeepCompareEffect(effect, deps) {\n  const ref = useRef();\n  const signalRef = useRef(0);\n\n  if (!isEqual(deps, ref.current)) {\n    ref.current = deps;\n    signalRef.current += 1;\n  }\n\n  useEffect(effect, [signalRef.current]);\n}\n\n// Usage\nfunction DeepCompareExample({ config }) {\n  useDeepCompareEffect(() => {\n    // Runs only when config deeply changes\n    console.log('Config changed:', config);\n  }, [config]);\n\n  return <div>...</div>;\n}\n\n// Debounced effect\nfunction useDebouncedEffect(effect, deps, delay = 500) {\n  useEffect(() => {\n    const timer = setTimeout(effect, delay);\n    return () => clearTimeout(timer);\n  }, [...deps, delay]);\n}\n\n// Usage\nfunction SearchWithDebounce() {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n\n  useDebouncedEffect(() => {\n    if (query) {\n      searchAPI(query).then(setResults);\n    }\n  }, [query], 300);\n\n  return (\n    <div>\n      <input value={query} onChange={(e) => setQuery(e.target.value)} />\n      <Results data={results} />\n    </div>\n  );\n}\n\n// Conditional dependencies\nfunction ConditionalDeps({ shouldFetch, userId }) {\n  const [user, setUser] = useState(null);\n\n  useEffect(() => {\n    if (shouldFetch && userId) {\n      fetchUser(userId).then(setUser);\n    }\n  }, [shouldFetch, userId]); // Include both conditions\n\n  return <div>{user?.name}</div>;\n}"
    },
    {
      "id": 73,
      "question": "How do you create and use compound custom hooks?",
      "answer": "Compound custom hooks combine multiple hooks together to create powerful, reusable abstractions that encapsulate complex logic.\n\nCompound Hook Patterns:\n• Hook Composition: Combine simple hooks\n• Hook Chaining: One hook uses another\n• Hook Factories: Functions that create hooks\n• Hook with Context: Hooks that provide/consume context\n• Hook Libraries: Collections of related hooks\n• Stateful Hooks: Manage complex state machines\n\nComposition Strategies:\n• Single Responsibility: Each hook does one thing\n• Progressive Enhancement: Build on simpler hooks\n• Separation of Concerns: Split logic appropriately\n• Reusability: Make hooks generic and flexible\n• Type Safety: Strong TypeScript types\n• Documentation: Clear examples and docs\n\nAdvanced Patterns:\n• Factory Hooks: Generate configured hooks\n• Provider Hooks: Context + custom logic\n• State Machine Hooks: Complex state management\n• Effect Coordination: Multiple synced effects\n• Resource Management: Lifecycle management\n• Error Recovery: Automatic retry and fallback\n\nBest Practices:\n• Test Independently: Unit test each hook\n• Avoid Over-Abstraction: Keep it simple\n• Document Dependencies: Clear input/output\n• Handle Edge Cases: Null, undefined, errors\n• Performance: Memoize appropriately\n• Clean Up: Always cleanup effects",
      "explanation": "Compound custom hooks combine multiple hooks to create reusable logic. Build from simple hooks, compose them together, and create factory functions for configurable hooks. Focus on reusability and clarity.",
      "difficulty": "Hard",
      "code": "// Simple hooks to compose\nfunction useLocalStorage(key, initialValue) {\n  const [storedValue, setStoredValue] = useState(() => {\n    const item = localStorage.getItem(key);\n    return item ? JSON.parse(item) : initialValue;\n  });\n\n  const setValue = (value) => {\n    setStoredValue(value);\n    localStorage.setItem(key, JSON.stringify(value));\n  };\n\n  return [storedValue, setValue];\n}\n\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    const timer = setTimeout(() => setDebouncedValue(value), delay);\n    return () => clearTimeout(timer);\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n\n// Compound hook: Combines storage and debounce\nfunction useDebouncedStorage(key, initialValue, delay = 500) {\n  const [value, setValue] = useLocalStorage(key, initialValue);\n  const debouncedValue = useDebounce(value, delay);\n\n  return [debouncedValue, setValue];\n}\n\n// Usage\nfunction SearchSettings() {\n  const [searchHistory, setSearchHistory] = useDebouncedStorage(\n    'searchHistory',\n    [],\n    1000\n  );\n\n  return <div>{/* ... */}</div>;\n}\n\n// Advanced: Data fetching with caching\nfunction useDataFetching(url, options = {}) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const cache = useRef({});\n\n  useEffect(() => {\n    // Check cache first\n    if (cache.current[url]) {\n      setData(cache.current[url]);\n      setLoading(false);\n      return;\n    }\n\n    const abortController = new AbortController();\n\n    async function fetchData() {\n      try {\n        setLoading(true);\n        const response = await fetch(url, {\n          ...options,\n          signal: abortController.signal\n        });\n        const json = await response.json();\n        \n        // Update cache\n        cache.current[url] = json;\n        setData(json);\n        setError(null);\n      } catch (err) {\n        if (err.name !== 'AbortError') {\n          setError(err);\n        }\n      } finally {\n        setLoading(false);\n      }\n    }\n\n    fetchData();\n\n    return () => abortController.abort();\n  }, [url]);\n\n  const invalidate = useCallback(() => {\n    delete cache.current[url];\n    setData(null);\n    setLoading(true);\n  }, [url]);\n\n  return { data, loading, error, invalidate };\n}\n\n// Factory hook pattern\nfunction createResourceHook(resourceName) {\n  return function useResource(id) {\n    const [resource, setResource] = useState(null);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    useEffect(() => {\n      if (!id) return;\n\n      setLoading(true);\n      fetch(`/api/${resourceName}/${id}`)\n        .then(res => res.json())\n        .then(data => {\n          setResource(data);\n          setError(null);\n        })\n        .catch(err => setError(err))\n        .finally(() => setLoading(false));\n    }, [id]);\n\n    const update = useCallback(async (updates) => {\n      try {\n        const response = await fetch(`/api/${resourceName}/${id}`, {\n          method: 'PATCH',\n          body: JSON.stringify(updates)\n        });\n        const updated = await response.json();\n        setResource(updated);\n        return updated;\n      } catch (err) {\n        setError(err);\n        throw err;\n      }\n    }, [id]);\n\n    const remove = useCallback(async () => {\n      try {\n        await fetch(`/api/${resourceName}/${id}`, {\n          method: 'DELETE'\n        });\n        setResource(null);\n      } catch (err) {\n        setError(err);\n        throw err;\n      }\n    }, [id]);\n\n    return { resource, loading, error, update, remove };\n  };\n}\n\n// Create specific resource hooks\nconst useUser = createResourceHook('users');\nconst usePost = createResourceHook('posts');\nconst useComment = createResourceHook('comments');\n\n// Usage\nfunction UserProfile({ userId }) {\n  const { resource: user, loading, update } = useUser(userId);\n\n  if (loading) return <div>Loading...</div>;\n\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <button onClick={() => update({ name: 'New Name' })}>\n        Update Name\n      </button>\n    </div>\n  );\n}\n\n// Context + Hook pattern\nconst ToastContext = createContext();\n\nfunction ToastProvider({ children }) {\n  const [toasts, setToasts] = useState([]);\n\n  const addToast = useCallback((message, type = 'info') => {\n    const id = Date.now();\n    setToasts(prev => [...prev, { id, message, type }]);\n    \n    setTimeout(() => {\n      setToasts(prev => prev.filter(toast => toast.id !== id));\n    }, 3000);\n  }, []);\n\n  const removeToast = useCallback((id) => {\n    setToasts(prev => prev.filter(toast => toast.id !== id));\n  }, []);\n\n  return (\n    <ToastContext.Provider value={{ toasts, addToast, removeToast }}>\n      {children}\n      <ToastContainer toasts={toasts} onRemove={removeToast} />\n    </ToastContext.Provider>\n  );\n}\n\nfunction useToast() {\n  const context = useContext(ToastContext);\n  if (!context) {\n    throw new Error('useToast must be used within ToastProvider');\n  }\n  return context;\n}\n\n// Compound hook with retry logic\nfunction useAsyncWithRetry(asyncFunction, maxRetries = 3) {\n  const [status, setStatus] = useState('idle');\n  const [data, setData] = useState(null);\n  const [error, setError] = useState(null);\n  const [retryCount, setRetryCount] = useState(0);\n\n  const execute = useCallback(async (...params) => {\n    setStatus('pending');\n    setError(null);\n\n    let attempt = 0;\n    while (attempt < maxRetries) {\n      try {\n        const result = await asyncFunction(...params);\n        setData(result);\n        setStatus('success');\n        setRetryCount(0);\n        return result;\n      } catch (err) {\n        attempt++;\n        setRetryCount(attempt);\n        \n        if (attempt >= maxRetries) {\n          setError(err);\n          setStatus('error');\n          throw err;\n        }\n        \n        // Exponential backoff\n        await new Promise(resolve => \n          setTimeout(resolve, Math.pow(2, attempt) * 1000)\n        );\n      }\n    }\n  }, [asyncFunction, maxRetries]);\n\n  return { execute, status, data, error, retryCount };\n}\n\n// Compound hook: Form with validation and submission\nfunction useFormWithValidation(initialValues, validationRules, onSubmit) {\n  const [values, setValues] = useState(initialValues);\n  const [errors, setErrors] = useState({});\n  const [touched, setTouched] = useState({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  const validate = useCallback((fieldValues) => {\n    const newErrors = {};\n    \n    Object.keys(validationRules).forEach(field => {\n      const rule = validationRules[field];\n      const value = fieldValues[field];\n      \n      if (rule.required && !value) {\n        newErrors[field] = `${field} is required`;\n      } else if (rule.pattern && !rule.pattern.test(value)) {\n        newErrors[field] = rule.message || `${field} is invalid`;\n      }\n    });\n    \n    return newErrors;\n  }, [validationRules]);\n\n  const handleChange = useCallback((e) => {\n    const { name, value } = e.target;\n    setValues(prev => ({ ...prev, [name]: value }));\n    \n    if (touched[name]) {\n      const fieldErrors = validate({ ...values, [name]: value });\n      setErrors(prev => ({ ...prev, [name]: fieldErrors[name] }));\n    }\n  }, [values, touched, validate]);\n\n  const handleBlur = useCallback((e) => {\n    const { name } = e.target;\n    setTouched(prev => ({ ...prev, [name]: true }));\n    \n    const fieldErrors = validate(values);\n    setErrors(prev => ({ ...prev, [name]: fieldErrors[name] }));\n  }, [values, validate]);\n\n  const handleSubmit = useCallback(async (e) => {\n    e.preventDefault();\n    \n    const newErrors = validate(values);\n    setErrors(newErrors);\n    \n    if (Object.keys(newErrors).length === 0) {\n      setIsSubmitting(true);\n      try {\n        await onSubmit(values);\n      } finally {\n        setIsSubmitting(false);\n      }\n    }\n  }, [values, validate, onSubmit]);\n\n  return {\n    values,\n    errors,\n    touched,\n    isSubmitting,\n    handleChange,\n    handleBlur,\n    handleSubmit\n  };\n}"
    },
    {
      "id": 74,
      "question": "What are the rules of hooks and why are they important?",
      "answer": "Rules of Hooks are requirements that must be followed to ensure hooks work correctly and predictably in React applications.\n\nThe Two Rules:\n• Only Call Hooks at Top Level: Never in loops, conditions, or nested functions\n• Only Call Hooks from React Functions: From components or custom hooks only\n\nWhy Top Level Only:\n• Hook Call Order: React relies on hook call order\n• State Tracking: Hooks are stored in a list\n• Consistency: Same hooks called in same order every render\n• Fiber Architecture: React's internal data structure\n• Multiple Renders: Hooks must be consistent across renders\n\nWhy React Functions Only:\n• Context Access: Hooks need React context\n• Lifecycle Integration: Hooks connect to React lifecycle\n• Error Boundaries: Proper error handling\n• DevTools: Debugging support\n• Concurrent Features: React 18 features\n\nCommon Violations:\n• Conditional Hooks: if statements around hooks\n• Loops with Hooks: forEach, map with hooks\n• Early Returns: Return before all hooks\n• Regular Functions: Non-React functions\n• Class Methods: Hooks in class components\n• Event Handlers: Calling hooks in callbacks\n\nEnforcement:\n• ESLint Plugin: eslint-plugin-react-hooks\n• Automatic Detection: Catches violations\n• Build Errors: Fails in development\n• Best Practices: Follow conventions\n\nWorkarounds:\n• Extract Logic: Move to separate functions\n• Conditional Values: Use inside hook\n• Dynamic Arrays: Use in effect, not hook calls",
      "explanation": "Rules of Hooks ensure hooks work correctly by maintaining consistent call order. Always call hooks at top level of function components or custom hooks, never conditionally or in loops. Use ESLint to enforce.",
      "difficulty": "Medium",
      "code": "// WRONG: Conditional hook\nfunction BadConditional({ shouldFetch }) {\n  if (shouldFetch) {\n    // WRONG: Hook in condition\n    const [data, setData] = useState(null);\n  }\n  return <div>...</div>;\n}\n\n// RIGHT: Conditional logic inside hook\nfunction GoodConditional({ shouldFetch }) {\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n    // RIGHT: Condition inside effect\n    if (shouldFetch) {\n      fetchData().then(setData);\n    }\n  }, [shouldFetch]);\n\n  return <div>{data}</div>;\n}\n\n// WRONG: Early return before hooks\nfunction BadEarlyReturn({ isLoading }) {\n  if (isLoading) {\n    return <Spinner />; // WRONG: Returns before hooks\n  }\n\n  const [data, setData] = useState(null); // This won't be called if isLoading\n  return <div>{data}</div>;\n}\n\n// RIGHT: Hooks first, then conditional rendering\nfunction GoodEarlyReturn({ isLoading }) {\n  const [data, setData] = useState(null);\n\n  // RIGHT: All hooks called first\n  if (isLoading) {\n    return <Spinner />;\n  }\n\n  return <div>{data}</div>;\n}\n\n// WRONG: Hook in loop\nfunction BadLoop({ items }) {\n  return items.map(item => {\n    // WRONG: Hook in loop\n    const [selected, setSelected] = useState(false);\n    return <div onClick={() => setSelected(!selected)}>{item}</div>;\n  });\n}\n\n// RIGHT: Component for each item\nfunction GoodLoop({ items }) {\n  return items.map(item => <Item key={item.id} item={item} />);\n}\n\nfunction Item({ item }) {\n  // RIGHT: Hook in component\n  const [selected, setSelected] = useState(false);\n  return <div onClick={() => setSelected(!selected)}>{item.name}</div>;\n}\n\n// WRONG: Hook in event handler\nfunction BadEventHandler() {\n  const handleClick = () => {\n    // WRONG: Hook in callback\n    const [count, setCount] = useState(0);\n    setCount(count + 1);\n  };\n\n  return <button onClick={handleClick}>Click</button>;\n}\n\n// RIGHT: Hook at top level\nfunction GoodEventHandler() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () => {\n    // RIGHT: Using hook value in callback\n    setCount(count + 1);\n  };\n\n  return <button onClick={handleClick}>Count: {count}</button>;\n}\n\n// WRONG: Hook in regular function\nfunction regularFunction() {\n  // WRONG: Not a React component or custom hook\n  const [value, setValue] = useState(0);\n  return value;\n}\n\n// RIGHT: Custom hook (starts with use)\nfunction useCustomHook() {\n  // RIGHT: Custom hook can use hooks\n  const [value, setValue] = useState(0);\n  return [value, setValue];\n}\n\n// WRONG: Hook in class method\nclass BadClass extends React.Component {\n  handleClick = () => {\n    // WRONG: Hooks can't be used in classes\n    const [count, setCount] = useState(0);\n  };\n\n  render() {\n    return <button onClick={this.handleClick}>Click</button>;\n  }\n}\n\n// RIGHT: Functional component\nfunction GoodFunction() {\n  const [count, setCount] = useState(0);\n  return <button onClick={() => setCount(count + 1)}>Count: {count}</button>;\n}\n\n// Dynamic number of hooks (WRONG)\nfunction BadDynamicHooks({ count }) {\n  // WRONG: Different number of hooks each render\n  for (let i = 0; i < count; i++) {\n    const [value, setValue] = useState(0);\n  }\n  return <div>...</div>;\n}\n\n// RIGHT: Fixed number of hooks\nfunction GoodDynamicState({ count }) {\n  // RIGHT: Single hook with array\n  const [values, setValues] = useState(\n    Array(count).fill(0)\n  );\n\n  return (\n    <div>\n      {values.map((value, i) => (\n        <div key={i}>\n          {value}\n          <button onClick={() => {\n            const newValues = [...values];\n            newValues[i] += 1;\n            setValues(newValues);\n          }}>\n            +\n          </button>\n        </div>\n      ))}\n    </div>\n  );\n}\n\n// ESLint configuration\n// .eslintrc.js\nmodule.exports = {\n  plugins: ['react-hooks'],\n  rules: {\n    'react-hooks/rules-of-hooks': 'error', // Enforce Rules of Hooks\n    'react-hooks/exhaustive-deps': 'warn'  // Check effect dependencies\n  }\n};\n\n// Why order matters (internal React behavior)\nlet hookIndex = 0;\nlet hooks = [];\n\nfunction useState(initialValue) {\n  const currentIndex = hookIndex;\n  hooks[currentIndex] = hooks[currentIndex] || initialValue;\n\n  const setState = (newValue) => {\n    hooks[currentIndex] = newValue;\n    render(); // Re-render component\n  };\n\n  hookIndex++;\n  return [hooks[currentIndex], setState];\n}\n\nfunction resetHooks() {\n  hookIndex = 0; // Reset for next render\n}\n\n// This is why conditional hooks break:\nfunction BrokenExample({ showCount }) {\n  // First render: showCount = true\n  // Hook 0: useState('name')\n  // Hook 1: useState(0)\n  \n  // Second render: showCount = false\n  // Hook 0: useState('name')\n  // Hook 1 is SKIPPED!\n  // React expects Hook 1 to be useState(0) but finds nothing\n  \n  const [name, setName] = useState('John');\n  \n  if (showCount) {\n    const [count, setCount] = useState(0); // Conditional hook!\n  }\n  \n  return <div>{name}</div>;\n}"
    },
    {
      "id": 75,
      "question": "How do you optimize custom hooks for performance and reusability?",
      "answer": "Optimizing custom hooks ensures they're performant, reusable, and maintainable across different components and use cases.\n\nPerformance Optimization:\n• Memoization: useCallback and useMemo\n• Dependency Management: Minimize dependencies\n• Stable References: Avoid recreating objects\n• Lazy Initialization: Defer expensive operations\n• Cleanup: Always cleanup side effects\n• Debouncing/Throttling: Control execution frequency\n• Selective Updates: Only update what changed\n\nReusability Patterns:\n• Generic Types: TypeScript generics\n• Configuration Options: Flexible parameters\n• Sensible Defaults: Default values\n• Return Objects: Named returns for flexibility\n• Error Handling: Graceful error management\n• Documentation: Clear examples\n• Testing: Comprehensive tests\n\nAPI Design:\n• Consistent Naming: Follow conventions\n• Single Responsibility: One purpose\n• Composability: Work with other hooks\n• No Side Effects: Pure when possible\n• Predictable Behavior: Same input, same output\n\nCommon Optimizations:\n• Avoid Inline Objects: Stable references\n• Avoid Inline Functions: Use useCallback\n• Split Large Hooks: Smaller focused hooks\n• Cache Results: Memoize expensive computations\n• Conditional Effects: Run only when needed\n• Ref for Callbacks: Latest callback without deps\n\nTesting Strategy:\n• Unit Tests: Test hook in isolation\n• Integration Tests: Test with components\n• Edge Cases: Null, undefined, errors\n• Performance Tests: Measure impact\n• Type Tests: TypeScript type checking",
      "explanation": "Optimize custom hooks by memoizing values and callbacks, minimizing dependencies, providing flexible APIs, and ensuring proper cleanup. Design for reusability with TypeScript, good defaults, and comprehensive documentation.",
      "difficulty": "Hard",
      "code": "// Poorly optimized hook\nfunction useBadFetch(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n\n  useEffect(() => {\n    setLoading(true);\n    fetch(url)\n      .then(res => res.json())\n      .then(data => {\n        setData(data);\n        setLoading(false);\n      });\n  }, [url]);\n\n  // BAD: Returns new object every render\n  return { data, loading };\n}\n\n// Optimized hook\nfunction useOptimizedFetch(url, options = {}) {\n  const [state, setState] = useState({\n    data: null,\n    loading: true,\n    error: null\n  });\n\n  // Memoize options to prevent effect re-runs\n  const stableOptions = useMemo(() => options, [JSON.stringify(options)]);\n\n  useEffect(() => {\n    let cancelled = false;\n    const abortController = new AbortController();\n\n    async function fetchData() {\n      setState(prev => ({ ...prev, loading: true, error: null }));\n\n      try {\n        const response = await fetch(url, {\n          ...stableOptions,\n          signal: abortController.signal\n        });\n        \n        if (!response.ok) throw new Error(`HTTP ${response.status}`);\n        \n        const data = await response.json();\n        \n        if (!cancelled) {\n          setState({ data, loading: false, error: null });\n        }\n      } catch (error) {\n        if (!cancelled && error.name !== 'AbortError') {\n          setState({ data: null, loading: false, error });\n        }\n      }\n    }\n\n    fetchData();\n\n    return () => {\n      cancelled = true;\n      abortController.abort();\n    };\n  }, [url, stableOptions]);\n\n  // Memoize refetch function\n  const refetch = useCallback(() => {\n    setState(prev => ({ ...prev, loading: true }));\n  }, []);\n\n  // Return memoized object\n  return useMemo(\n    () => ({ ...state, refetch }),\n    [state, refetch]\n  );\n}\n\n// Generic TypeScript hook\nfunction useAsync<T, Args extends any[]>(\n  asyncFunction: (...args: Args) => Promise<T>,\n  options: {\n    immediate?: boolean;\n    onSuccess?: (data: T) => void;\n    onError?: (error: Error) => void;\n  } = {}\n) {\n  const { immediate = true, onSuccess, onError } = options;\n\n  const [state, setState] = useState<{\n    data: T | null;\n    loading: boolean;\n    error: Error | null;\n  }>({\n    data: null,\n    loading: immediate,\n    error: null\n  });\n\n  // Stable callback references\n  const onSuccessRef = useRef(onSuccess);\n  const onErrorRef = useRef(onError);\n\n  useEffect(() => {\n    onSuccessRef.current = onSuccess;\n    onErrorRef.current = onError;\n  }, [onSuccess, onError]);\n\n  const execute = useCallback(\n    async (...args: Args) => {\n      setState({ data: null, loading: true, error: null });\n\n      try {\n        const data = await asyncFunction(...args);\n        setState({ data, loading: false, error: null });\n        onSuccessRef.current?.(data);\n        return data;\n      } catch (error) {\n        const err = error as Error;\n        setState({ data: null, loading: false, error: err });\n        onErrorRef.current?.(err);\n        throw err;\n      }\n    },\n    [asyncFunction]\n  );\n\n  useEffect(() => {\n    if (immediate) {\n      execute();\n    }\n  }, [execute, immediate]);\n\n  return { ...state, execute };\n}\n\n// Usage\nfunction UserProfile({ userId }: { userId: number }) {\n  const { data, loading, error, execute } = useAsync(\n    (id: number) => fetch(`/api/users/${id}`).then(r => r.json()),\n    {\n      onSuccess: (data) => console.log('User loaded:', data),\n      onError: (error) => console.error('Failed:', error)\n    }\n  );\n\n  return (\n    <div>\n      {loading && <div>Loading...</div>}\n      {error && <div>Error: {error.message}</div>}\n      {data && <div>{data.name}</div>}\n      <button onClick={() => execute(userId)}>Reload</button>\n    </div>\n  );\n}\n\n// Composable hooks\nfunction useDebounce<T>(value: T, delay: number): T {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    const timer = setTimeout(() => setDebouncedValue(value), delay);\n    return () => clearTimeout(timer);\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n\nfunction useDebouncedAsync<T>(\n  asyncFunction: (query: string) => Promise<T>,\n  delay: number = 300\n) {\n  const [query, setQuery] = useState('');\n  const debouncedQuery = useDebounce(query, delay);\n  const asyncState = useAsync(\n    asyncFunction,\n    { immediate: false }\n  );\n\n  useEffect(() => {\n    if (debouncedQuery) {\n      asyncState.execute(debouncedQuery);\n    }\n  }, [debouncedQuery]);\n\n  return { query, setQuery, ...asyncState };\n}\n\n// Factory pattern for hooks\nfunction createResourceHook<T>(baseUrl: string) {\n  return function useResource(id: string | number) {\n    const { data, loading, error } = useOptimizedFetch(\n      `${baseUrl}/${id}`\n    );\n\n    const update = useCallback(\n      async (updates: Partial<T>) => {\n        const response = await fetch(`${baseUrl}/${id}`, {\n          method: 'PATCH',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify(updates)\n        });\n        return response.json();\n      },\n      [id]\n    );\n\n    return { data: data as T, loading, error, update };\n  };\n}\n\n// Create typed hooks\nconst useUser = createResourceHook<User>('/api/users');\nconst usePost = createResourceHook<Post>('/api/posts');\n\n// Performance testing\nfunction useWithPerformanceTracking<T>(\n  hookName: string,\n  hookFn: () => T\n): T {\n  const startTime = useRef(performance.now());\n  const renderCount = useRef(0);\n\n  useEffect(() => {\n    renderCount.current++;\n    const duration = performance.now() - startTime.current;\n\n    if (duration > 16) { // Slower than 60fps\n      console.warn(\n        `${hookName} render ${renderCount.current} took ${duration}ms`\n      );\n    }\n\n    startTime.current = performance.now();\n  });\n\n  return hookFn();\n}\n\n// Usage\nfunction MyComponent() {\n  const data = useWithPerformanceTracking(\n    'useExpensiveHook',\n    () => useExpensiveHook()\n  );\n\n  return <div>{data}</div>;\n}"
    },
    {
      "id": 76,
      "question": "What is concurrent rendering in React and how does it work?",
      "answer": "Concurrent rendering allows React to interrupt rendering work to handle high-priority updates, making apps more responsive by yielding to the browser between rendering work.\n\nKey Concepts:\n• Interruptible Rendering: React can pause and resume rendering\n• Time Slicing: Spread work across multiple frames\n• Priority Levels: Different updates have different priorities\n• Yielding: Give control back to browser for urgent work\n• Non-Blocking: UI remains responsive during renders\n\nEnabled Features:\n• useTransition: Mark updates as non-urgent\n• useDeferredValue: Defer expensive re-renders\n• Suspense: Better loading states\n• Automatic Batching: Batch all updates by default\n\nBenefits:\n• Responsiveness: UI stays interactive during heavy renders\n• Better UX: Prioritize user interactions\n• Smooth Animations: Keep animations fluid\n• Progressive Rendering: Show content incrementally",
      "explanation": "Concurrent rendering enables React to interrupt and prioritize rendering work, keeping the UI responsive by yielding to urgent updates like user input during expensive renders.",
      "difficulty": "Hard",
      "code": "import { useTransition, useDeferredValue, useState } from 'react';\n\n// Without concurrent features (blocks UI)\nfunction SlowList({ items }) {\n  return (\n    <ul>\n      {items.map(item => <SlowItem key={item.id} item={item} />)}\n    </ul>\n  );\n}\n\nfunction App() {\n  const [query, setQuery] = useState('');\n  const [items, setItems] = useState(largeDataset);\n  \n  const handleChange = (e) => {\n    setQuery(e.target.value);\n    // This blocks UI while filtering\n    setItems(filterItems(largeDataset, e.target.value));\n  };\n  \n  return (\n    <div>\n      <input value={query} onChange={handleChange} />\n      <SlowList items={items} /> {/* Blocks typing */}\n    </div>\n  );\n}\n\n// With useTransition (non-blocking)\nfunction App() {\n  const [query, setQuery] = useState('');\n  const [items, setItems] = useState(largeDataset);\n  const [isPending, startTransition] = useTransition();\n  \n  const handleChange = (e) => {\n    // High priority: Update input immediately\n    setQuery(e.target.value);\n    \n    // Low priority: Defer list update\n    startTransition(() => {\n      setItems(filterItems(largeDataset, e.target.value));\n    });\n  };\n  \n  return (\n    <div>\n      <input value={query} onChange={handleChange} />\n      {isPending && <span>Updating...</span>}\n      <SlowList items={items} /> {/* Doesn't block typing */}\n    </div>\n  );\n}\n\n// With useDeferredValue\nfunction App() {\n  const [query, setQuery] = useState('');\n  const deferredQuery = useDeferredValue(query);\n  \n  return (\n    <div>\n      <input\n        value={query}\n        onChange={(e) => setQuery(e.target.value)}\n      />\n      {/* Uses stale value while new one renders */}\n      <SlowList query={deferredQuery} />\n    </div>\n  );\n}\n\n// Priority example\nfunction SearchApp() {\n  const [inputValue, setInputValue] = useState('');\n  const [searchQuery, setSearchQuery] = useState('');\n  const [isPending, startTransition] = useTransition();\n  \n  const handleChange = (e) => {\n    // Urgent: Show what user types immediately\n    setInputValue(e.target.value);\n    \n    // Non-urgent: Can be interrupted\n    startTransition(() => {\n      setSearchQuery(e.target.value);\n    });\n  };\n  \n  return (\n    <div>\n      <input value={inputValue} onChange={handleChange} />\n      <Results query={searchQuery} isPending={isPending} />\n    </div>\n  );\n}"
    },
    {
      "id": 77,
      "question": "What is the useTransition Hook and when should you use it?",
      "answer": "useTransition lets you mark state updates as non-urgent (transitions) so React can keep the UI responsive by interrupting them for more urgent updates.\n\nReturned Values:\n• isPending: Boolean indicating if transition is in progress\n• startTransition: Function to mark updates as transitions\n\nKey Features:\n• Non-Blocking: Doesn't block UI during updates\n• Interruptible: Can be interrupted by urgent updates\n• Prioritization: React prioritizes user input over transitions\n• Status Tracking: isPending shows transition progress\n\nWhen to Use:\n• Slow Rendering: Component takes time to render\n• Large Lists: Filtering or sorting large datasets\n• Navigation: Switching between views\n• Search: Live search with expensive results\n• Data Visualization: Updating charts or graphs\n\nWhen NOT to Use:\n• Controlled Inputs: Input value should update immediately\n• Focus Management: Don't defer focus changes\n• Simple Updates: No benefit for fast renders",
      "explanation": "useTransition marks updates as non-urgent transitions that can be interrupted, keeping the UI responsive during expensive renders by prioritizing user interactions over background updates.",
      "difficulty": "Hard",
      "code": "import { useState, useTransition } from 'react';\n\n// Basic useTransition\nfunction TabContainer() {\n  const [tab, setTab] = useState('about');\n  const [isPending, startTransition] = useTransition();\n  \n  const selectTab = (nextTab) => {\n    startTransition(() => {\n      setTab(nextTab); // This is now interruptible\n    });\n  };\n  \n  return (\n    <div>\n      <button onClick={() => selectTab('about')}>\n        About\n      </button>\n      <button onClick={() => selectTab('posts')}>\n        Posts {isPending && '(Loading...)'}\n      </button>\n      <button onClick={() => selectTab('contact')}>\n        Contact\n      </button>\n      <hr />\n      {tab === 'about' && <AboutTab />}\n      {tab === 'posts' && <PostsTab />} {/* Slow to render */}\n      {tab === 'contact' && <ContactTab />}\n    </div>\n  );\n}\n\n// Search with transition\nfunction SearchApp() {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n  const [isPending, startTransition] = useTransition();\n  \n  const handleSearch = (value) => {\n    // High priority: Update input\n    setQuery(value);\n    \n    // Low priority: Update results\n    startTransition(() => {\n      const filtered = expensiveSearch(value);\n      setResults(filtered);\n    });\n  };\n  \n  return (\n    <div>\n      <input\n        value={query}\n        onChange={(e) => handleSearch(e.target.value)}\n        placeholder=\"Search...\"\n      />\n      {isPending && <Spinner />}\n      <ResultsList results={results} />\n    </div>\n  );\n}\n\n// Router navigation with transition\nfunction App() {\n  const [page, setPage] = useState('home');\n  const [isPending, startTransition] = useTransition();\n  \n  const navigate = (newPage) => {\n    startTransition(() => {\n      setPage(newPage);\n    });\n  };\n  \n  return (\n    <div>\n      <nav style={{ opacity: isPending ? 0.7 : 1 }}>\n        <button onClick={() => navigate('home')}>Home</button>\n        <button onClick={() => navigate('profile')}>Profile</button>\n        <button onClick={() => navigate('settings')}>Settings</button>\n      </nav>\n      {isPending && <TopLoadingBar />}\n      <PageContent page={page} />\n    </div>\n  );\n}\n\n// Comparison: With vs Without transition\nfunction WithoutTransition() {\n  const [items, setItems] = useState(bigList);\n  \n  const filter = (text) => {\n    // Blocks UI while filtering\n    setItems(bigList.filter(item => item.includes(text)));\n  };\n  \n  return <input onChange={(e) => filter(e.target.value)} />;\n}\n\nfunction WithTransition() {\n  const [items, setItems] = useState(bigList);\n  const [isPending, startTransition] = useTransition();\n  \n  const filter = (text) => {\n    startTransition(() => {\n      // Doesn't block UI, can be interrupted\n      setItems(bigList.filter(item => item.includes(text)));\n    });\n  };\n  \n  return (\n    <div>\n      <input onChange={(e) => filter(e.target.value)} />\n      {isPending && <span>Filtering...</span>}\n    </div>\n  );\n}"
    },
    {
      "id": 78,
      "question": "What is useDeferredValue and how does it differ from useTransition?",
      "answer": "useDeferredValue returns a deferred version of a value that lags behind, allowing React to show stale content while new content renders in the background.\n\nKey Features:\n• Deferred Updates: Shows old value while new one renders\n• Automatic: Automatically defers without manual control\n• Rendering Priority: Allows urgent updates to interrupt\n• Stale Content: Old value shown during update\n\nuseDeferredValue vs useTransition:\n• useDeferredValue: For values you don't control (props)\n• useTransition: For state updates you control\n• useDeferredValue: Automatic deferral\n• useTransition: Manual control with startTransition\n• useDeferredValue: No loading state\n• useTransition: Provides isPending flag\n\nWhen to Use:\n• Expensive Rendering: Child component slow to render\n• Third-Party Components: Can't modify component code\n• Derived Values: Value computed from props\n• Real-Time Updates: Typing, scrolling, resizing",
      "explanation": "useDeferredValue defers value updates to keep UI responsive by showing stale content during expensive renders, automatically prioritizing urgent updates without manual transition control.",
      "difficulty": "Hard",
      "code": "import { useState, useDeferredValue, memo } from 'react';\n\n// Basic useDeferredValue\nfunction App() {\n  const [text, setText] = useState('');\n  const deferredText = useDeferredValue(text);\n  \n  return (\n    <div>\n      <input value={text} onChange={(e) => setText(e.target.value)} />\n      {/* Input updates immediately, list uses deferred value */}\n      <SlowList text={deferredText} />\n    </div>\n  );\n}\n\nconst SlowList = memo(function SlowList({ text }) {\n  // Expensive computation\n  const items = useMemo(() => {\n    return filterLargeList(text);\n  }, [text]);\n  \n  return (\n    <ul>\n      {items.map(item => <li key={item.id}>{item.name}</li>)}\n    </ul>\n  );\n});\n\n// Show loading indicator for deferred updates\nfunction App() {\n  const [query, setQuery] = useState('');\n  const deferredQuery = useDeferredValue(query);\n  const isStale = query !== deferredQuery;\n  \n  return (\n    <div>\n      <input\n        value={query}\n        onChange={(e) => setQuery(e.target.value)}\n      />\n      <div style={{ opacity: isStale ? 0.5 : 1 }}>\n        {isStale && <span>Updating...</span>}\n        <SearchResults query={deferredQuery} />\n      </div>\n    </div>\n  );\n}\n\n// Comparison: useDeferredValue vs useTransition\n\n// With useDeferredValue (for values you receive)\nfunction SearchWithDeferred({ externalQuery }) {\n  const deferredQuery = useDeferredValue(externalQuery);\n  \n  return <Results query={deferredQuery} />;\n}\n\n// With useTransition (for state you control)\nfunction SearchWithTransition() {\n  const [query, setQuery] = useState('');\n  const [searchQuery, setSearchQuery] = useState('');\n  const [isPending, startTransition] = useTransition();\n  \n  const handleChange = (value) => {\n    setQuery(value);\n    startTransition(() => {\n      setSearchQuery(value);\n    });\n  };\n  \n  return (\n    <div>\n      <input value={query} onChange={(e) => handleChange(e.target.value)} />\n      {isPending && <Spinner />}\n      <Results query={searchQuery} />\n    </div>\n  );\n}\n\n// Real-time chart example\nfunction ChartApp() {\n  const [data, setData] = useState(generateData());\n  const deferredData = useDeferredValue(data);\n  \n  useEffect(() => {\n    // Update data in real-time\n    const interval = setInterval(() => {\n      setData(generateData());\n    }, 100);\n    return () => clearInterval(interval);\n  }, []);\n  \n  return (\n    <div>\n      <div>Live Data: {data.length} points</div>\n      {/* Chart uses deferred data, won't lag UI */}\n      <ExpensiveChart data={deferredData} />\n    </div>\n  );\n}"
    },
    {
      "id": 79,
      "question": "What is automatic batching in React 18 and how does it work?",
      "answer": "Automatic batching groups multiple state updates into a single re-render for better performance. React 18 batches updates everywhere, not just in event handlers.\n\nKey Changes in React 18:\n• All Updates Batched: Timeouts, promises, native events all batched\n• React 17: Only batched in event handlers\n• Opt-Out: Use flushSync to opt out of batching\n• Performance: Fewer re-renders automatically\n\nWhere Batching Now Works:\n• setTimeout, setInterval\n• Promise callbacks (then, catch)\n• Native event handlers\n• Async functions\n• Any React event\n\nBenefits:\n• Better Performance: Fewer renders by default\n• No Code Changes: Works automatically\n• Consistent Behavior: Same everywhere\n• Reduced Complexity: Don't need to manually batch\n\nOpting Out:\n• flushSync: Force synchronous render\n• Use sparingly: Usually not needed",
      "explanation": "React 18's automatic batching groups all state updates into single re-renders everywhere, not just event handlers, improving performance automatically without code changes.",
      "difficulty": "Medium",
      "code": "import { useState } from 'react';\nimport { flushSync } from 'react-dom';\n\n// React 18: Automatic batching everywhere\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [flag, setFlag] = useState(false);\n  \n  const handleClick = () => {\n    // React 17 & 18: Batched (1 render)\n    setCount(c => c + 1);\n    setFlag(f => !f);\n  };\n  \n  const handleTimeout = () => {\n    setTimeout(() => {\n      // React 17: 2 renders\n      // React 18: 1 render (batched!)\n      setCount(c => c + 1);\n      setFlag(f => !f);\n    }, 1000);\n  };\n  \n  const handleFetch = () => {\n    fetch('/api/data').then(() => {\n      // React 17: 2 renders\n      // React 18: 1 render (batched!)\n      setCount(c => c + 1);\n      setFlag(f => !f);\n    });\n  };\n  \n  const handleNative = () => {\n    document.addEventListener('click', () => {\n      // React 17: 2 renders\n      // React 18: 1 render (batched!)\n      setCount(c => c + 1);\n      setFlag(f => !f);\n    });\n  };\n  \n  console.log('Render'); // Logs once per batch\n  \n  return (\n    <div>\n      <p>Count: {count}, Flag: {flag.toString()}</p>\n      <button onClick={handleClick}>Sync Update</button>\n      <button onClick={handleTimeout}>Timeout Update</button>\n      <button onClick={handleFetch}>Fetch Update</button>\n    </div>\n  );\n}\n\n// Opting out with flushSync\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [flag, setFlag] = useState(false);\n  \n  const handleClick = () => {\n    flushSync(() => {\n      setCount(c => c + 1);\n    });\n    // This runs after count is updated and rendered\n    flushSync(() => {\n      setFlag(f => !f);\n    });\n    // Total: 2 renders instead of 1\n  };\n  \n  return <button onClick={handleClick}>Click</button>;\n}\n\n// Example showing render count\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const [delta, setDelta] = useState(1);\n  \n  console.log('Rendered'); // Track renders\n  \n  const handleClick = () => {\n    // Only 1 render despite 3 updates\n    setCount(c => c + delta);\n    setDelta(d => d + 1);\n    setCount(c => c + 1);\n  };\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={handleClick}>Increment</button>\n    </div>\n  );\n}\n\n// Async example\nfunction App() {\n  const [count, setCount] = useState(0);\n  \n  const handleAsync = async () => {\n    await someAsyncWork();\n    \n    // React 18: These are batched (1 render)\n    setCount(1);\n    setCount(2);\n    setCount(3);\n    // Final count: 3, only 1 render\n  };\n  \n  return <button onClick={handleAsync}>Async Update</button>;\n}"
    },
    {
      "id": 80,
      "question": "What is flushSync and when should you use it?",
      "answer": "flushSync forces React to flush updates synchronously and immediately, opting out of automatic batching. It should be used sparingly as it can hurt performance.\n\nKey Features:\n• Synchronous: Updates applied immediately\n• Blocks Batching: Prevents automatic batching\n• DOM Access: Ensures DOM is updated before continuing\n• Rare Use: Usually not needed\n\nWhen to Use:\n• DOM Measurements: Need updated DOM immediately\n• Third-Party Integrations: Library expects DOM to be updated\n• Scroll Position: Managing scroll after update\n• Focus Management: Moving focus after update\n• Print/Screenshots: Ensuring UI is ready\n\nWhen NOT to Use:\n• Regular Updates: Let React batch automatically\n• Performance Critical: flushSync hurts performance\n• Most Cases: Automatic batching is better\n\nAlternatives:\n• useLayoutEffect: For DOM measurements\n• refs: Access DOM without forcing render\n• Wait for React: Let batching work naturally",
      "explanation": "flushSync forces immediate synchronous rendering, opting out of batching for cases requiring instant DOM updates like measurements or third-party integrations, but hurts performance.",
      "difficulty": "Hard",
      "code": "import { useState, useRef } from 'react';\nimport { flushSync } from 'react-dom';\n\n// Without flushSync (batched, async)\nfunction WithoutFlushSync() {\n  const [items, setItems] = useState([]);\n  const listRef = useRef();\n  \n  const addItem = () => {\n    setItems([...items, `Item ${items.length}`]);\n    \n    // DOM not updated yet!\n    console.log(listRef.current.children.length); // Old count\n    \n    // Need to wait for render\n    setTimeout(() => {\n      console.log(listRef.current.children.length); // New count\n    }, 0);\n  };\n  \n  return (\n    <div>\n      <button onClick={addItem}>Add Item</button>\n      <ul ref={listRef}>\n        {items.map((item, i) => <li key={i}>{item}</li>)}\n      </ul>\n    </div>\n  );\n}\n\n// With flushSync (immediate DOM update)\nfunction WithFlushSync() {\n  const [items, setItems] = useState([]);\n  const listRef = useRef();\n  \n  const addItem = () => {\n    flushSync(() => {\n      setItems([...items, `Item ${items.length}`]);\n    });\n    \n    // DOM is already updated!\n    console.log(listRef.current.children.length); // New count immediately\n  };\n  \n  return (\n    <div>\n      <button onClick={addItem}>Add Item</button>\n      <ul ref={listRef}>\n        {items.map((item, i) => <li key={i}>{item}</li>)}\n      </ul>\n    </div>\n  );\n}\n\n// Scroll position example\nfunction ChatMessages({ messages }) {\n  const [messageList, setMessageList] = useState(messages);\n  const scrollRef = useRef();\n  \n  const addMessage = (message) => {\n    flushSync(() => {\n      setMessageList([...messageList, message]);\n    });\n    \n    // Scroll to bottom after DOM updated\n    scrollRef.current.scrollTop = scrollRef.current.scrollHeight;\n  };\n  \n  return (\n    <div ref={scrollRef} style={{ height: 300, overflow: 'auto' }}>\n      {messageList.map((msg, i) => <div key={i}>{msg}</div>)}\n    </div>\n  );\n}\n\n// Multiple flushSync calls\nfunction App() {\n  const [count, setCount] = useState(0);\n  \n  const handleClick = () => {\n    flushSync(() => {\n      setCount(1);\n    }); // Render 1\n    \n    flushSync(() => {\n      setCount(2);\n    }); // Render 2\n    \n    flushSync(() => {\n      setCount(3);\n    }); // Render 3\n    \n    // Total: 3 renders (bad for performance)\n  };\n  \n  return <button onClick={handleClick}>Click</button>;\n}\n\n// Better alternative: useLayoutEffect\nfunction BetterApproach() {\n  const [items, setItems] = useState([]);\n  const listRef = useRef();\n  \n  useLayoutEffect(() => {\n    // Runs after DOM update but before paint\n    console.log(listRef.current.children.length);\n  }, [items]);\n  \n  const addItem = () => {\n    // Let React batch naturally\n    setItems([...items, `Item ${items.length}`]);\n  };\n  \n  return (\n    <div>\n      <button onClick={addItem}>Add Item</button>\n      <ul ref={listRef}>\n        {items.map((item, i) => <li key={i}>{item}</li>)}\n      </ul>\n    </div>\n  );\n}"
    },
    {
      "id": 81,
      "question": "What are React Server Components and how do they work?",
      "answer": "React Server Components (RSC) are components that render exclusively on the server, sending only the rendered output to the client, reducing bundle size and improving performance.\n\nKey Features:\n• Zero Bundle Size: Don't ship to client\n• Direct Backend Access: Query databases directly\n• Automatic Code Splitting: Only client components bundled\n• Streaming: Send UI progressively\n• No Client Interactivity: Cannot use hooks or event handlers\n\nServer vs Client Components:\n• Server: Render on server, no JavaScript sent\n• Client: Traditional React components\n• Mixing: Can compose both types\n• Serialization: Props must be serializable\n\nBenefits:\n• Smaller Bundles: Less JavaScript to download\n• Better Performance: Faster initial load\n• SEO: Fully rendered HTML\n• Security: Keep secrets on server\n• Direct Data Access: No API layer needed\n\nFrameworks:\n• Next.js 13+: App Router with RSC\n• Experimental: Still evolving feature",
      "explanation": "React Server Components render exclusively on the server without sending JavaScript to the client, reducing bundle size and enabling direct backend access while streaming progressive UI updates.",
      "difficulty": "Hard",
      "code": "// Server Component (default in Next.js App Router)\n// app/page.js\nasync function HomePage() {\n  // Direct database access on server\n  const posts = await db.posts.findMany();\n  \n  return (\n    <div>\n      <h1>Posts</h1>\n      {posts.map(post => (\n        <PostCard key={post.id} post={post} />\n      ))}\n    </div>\n  );\n}\n\n// Client Component (with 'use client' directive)\n// components/LikeButton.js\n'use client';\n\nimport { useState } from 'react';\n\nexport function LikeButton({ postId }) {\n  const [likes, setLikes] = useState(0);\n  \n  // Can use hooks and event handlers\n  const handleClick = () => setLikes(likes + 1);\n  \n  return (\n    <button onClick={handleClick}>\n      Likes: {likes}\n    </button>\n  );\n}\n\n// Mixing Server and Client Components\n// app/post/[id]/page.js\nimport { LikeButton } from './LikeButton';\n\nasync function PostPage({ params }) {\n  // Server: Direct database query\n  const post = await db.posts.findUnique({\n    where: { id: params.id }\n  });\n  \n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <p>{post.content}</p>\n      {/* Client component for interactivity */}\n      <LikeButton postId={post.id} />\n    </article>\n  );\n}\n\n// Streaming with Suspense\n// app/dashboard/page.js\nimport { Suspense } from 'react';\n\nasync function UserData() {\n  const user = await fetchUser();\n  return <div>{user.name}</div>;\n}\n\nasync function Posts() {\n  const posts = await fetchPosts(); // Slow query\n  return <PostsList posts={posts} />;\n}\n\nexport default function Dashboard() {\n  return (\n    <div>\n      {/* Show immediately */}\n      <Suspense fallback={<UserSkeleton />}>\n        <UserData />\n      </Suspense>\n      \n      {/* Stream when ready */}\n      <Suspense fallback={<PostsSkeleton />}>\n        <Posts />\n      </Suspense>\n    </div>\n  );\n}\n\n// Data fetching patterns\n// Server Component\nasync function ProductList() {\n  // No fetch wrapper needed\n  const products = await db.query('SELECT * FROM products');\n  \n  return products.map(p => <ProductCard key={p.id} product={p} />);\n}\n\n// Client Component\n'use client';\nfunction ProductList() {\n  const [products, setProducts] = useState([]);\n  \n  useEffect(() => {\n    // Must fetch via API\n    fetch('/api/products')\n      .then(r => r.json())\n      .then(setProducts);\n  }, []);\n  \n  return products.map(p => <ProductCard key={p.id} product={p} />);\n}"
    },
    {
      "id": 82,
      "question": "What is hydration in React and what are hydration errors?",
      "answer": "Hydration is the process where React attaches event listeners and makes server-rendered HTML interactive. Hydration errors occur when server and client HTML don't match.\n\nHydration Process:\n• Server Renders: Generate initial HTML\n• Client Receives: Browser gets static HTML\n• React Loads: JavaScript downloads and executes\n• Hydration: React attaches to existing DOM\n• Interactive: Event handlers and state work\n\nHydration Errors:\n• Mismatch: Server and client HTML differ\n• Extra Elements: Client has elements server doesn't\n• Missing Elements: Server has elements client doesn't\n• Different Text: Text content differs\n• Wrong Attributes: Attributes don't match\n\nCommon Causes:\n• Random Values: Math.random(), Date.now()\n• Browser APIs: window, localStorage in render\n• Third-Party Scripts: Modify DOM outside React\n• Conditional Rendering: Different on server/client\n• useEffect Content: Content rendered only on client",
      "explanation": "Hydration attaches React to server-rendered HTML to make it interactive, with errors occurring when server and client HTML mismatch due to non-deterministic rendering or browser-only code.",
      "difficulty": "Medium",
      "code": "// Hydration error examples\n\n// ❌ Bad: Random values differ\nfunction BadComponent() {\n  return <div id={Math.random()}>Content</div>;\n  // Server generates: <div id=\"0.123\">Content</div>\n  // Client generates: <div id=\"0.456\">Content</div>\n  // Hydration error!\n}\n\n// ✅ Good: Use useId for stable IDs\nimport { useId } from 'react';\n\nfunction GoodComponent() {\n  const id = useId();\n  return <div id={id}>Content</div>;\n  // Same ID on server and client\n}\n\n// ❌ Bad: Date in render\nfunction BadDateTime() {\n  return <div>{new Date().toString()}</div>;\n  // Server time !== client time\n}\n\n// ✅ Good: Date in useEffect\nfunction GoodDateTime() {\n  const [date, setDate] = useState(null);\n  \n  useEffect(() => {\n    setDate(new Date().toString());\n  }, []);\n  \n  return <div>{date || 'Loading...'}</div>;\n}\n\n// ❌ Bad: window in render\nfunction BadBrowser() {\n  const width = window.innerWidth; // Error on server!\n  return <div>Width: {width}</div>;\n}\n\n// ✅ Good: Check if window exists\nfunction GoodBrowser() {\n  const [width, setWidth] = useState(0);\n  \n  useEffect(() => {\n    setWidth(window.innerWidth);\n  }, []);\n  \n  return <div>Width: {width}</div>;\n}\n\n// Suppressing hydration warnings (use sparingly)\nfunction TimeDisplay() {\n  return (\n    <time suppressHydrationWarning>\n      {new Date().toLocaleString()}\n    </time>\n  );\n}\n\n// Client-only content pattern\nfunction ClientOnly({ children }) {\n  const [hasMounted, setHasMounted] = useState(false);\n  \n  useEffect(() => {\n    setHasMounted(true);\n  }, []);\n  \n  if (!hasMounted) return null;\n  \n  return children;\n}\n\n// Usage\nfunction App() {\n  return (\n    <div>\n      <h1>My App</h1>\n      <ClientOnly>\n        <BrowserOnlyComponent />\n      </ClientOnly>\n    </div>\n  );\n}\n\n// Next.js dynamic import for client-only\nimport dynamic from 'next/dynamic';\n\nconst ClientComponent = dynamic(\n  () => import('./ClientComponent'),\n  { ssr: false }\n);\n\nfunction Page() {\n  return (\n    <div>\n      <ServerContent />\n      <ClientComponent /> {/* Only renders on client */}\n    </div>\n  );\n}"
    },
    {
      "id": 83,
      "question": "What is streaming SSR and how does it improve performance?",
      "answer": "Streaming SSR sends HTML to the browser progressively as it's generated, rather than waiting for the entire page to render, improving Time to First Byte and perceived performance.\n\nKey Concepts:\n• Progressive Rendering: Send HTML chunks as ready\n• Suspense Boundaries: Mark sections that can stream\n• TTFB: Faster Time to First Byte\n• Parallel Loading: Load data in parallel\n• Out-of-Order Streaming: Send ready content first\n\nHow It Works:\n• Server Starts Rendering: Begin HTML generation\n• Suspense Fallback: Send fallback immediately\n• Stream Chunks: Send HTML as components resolve\n• Replace Fallbacks: JavaScript replaces fallbacks with real content\n• Hydration: Make everything interactive\n\nBenefits:\n• Faster TTFB: User sees content sooner\n• Better Perceived Performance: Progressive loading\n• Parallel Data Fetching: Don't wait for slow queries\n• Prioritization: Show important content first\n• Reduced Server Load: Process incrementally",
      "explanation": "Streaming SSR progressively sends HTML chunks as they're ready using Suspense boundaries, improving TTFB and perceived performance by showing content before the entire page renders.",
      "difficulty": "Hard",
      "code": "// Next.js Streaming SSR example\nimport { Suspense } from 'react';\n\n// Fast component (streams immediately)\nfunction Header() {\n  return <header>My App</header>;\n}\n\n// Slow component (streams when ready)\nasync function UserProfile() {\n  const user = await fetchUser(); // Slow query\n  return (\n    <div>\n      <h2>{user.name}</h2>\n      <p>{user.email}</p>\n    </div>\n  );\n}\n\nasync function Posts() {\n  const posts = await fetchPosts(); // Even slower query\n  return (\n    <ul>\n      {posts.map(post => <li key={post.id}>{post.title}</li>)}\n    </ul>\n  );\n}\n\n// Main page component\nexport default function Page() {\n  return (\n    <div>\n      {/* Sent immediately */}\n      <Header />\n      \n      {/* Streams when user data ready */}\n      <Suspense fallback={<ProfileSkeleton />}>\n        <UserProfile />\n      </Suspense>\n      \n      {/* Streams when posts ready (can be out of order) */}\n      <Suspense fallback={<PostsSkeleton />}>\n        <Posts />\n      </Suspense>\n    </div>\n  );\n}\n\n// Timeline of streaming:\n// 1. Server sends: <Header /> + <ProfileSkeleton /> + <PostsSkeleton />\n// 2. Browser displays immediately (fast TTFB)\n// 3. User data resolves -> stream <UserProfile /> HTML\n// 4. Posts data resolves -> stream <Posts /> HTML\n// 5. JavaScript replaces fallbacks with real content\n// 6. Hydration makes everything interactive\n\n// Parallel data fetching\nfunction Dashboard() {\n  return (\n    <div>\n      {/* All fetch in parallel */}\n      <Suspense fallback={<Skeleton />}>\n        <UserData /> {/* fetch('/api/user') */}\n      </Suspense>\n      \n      <Suspense fallback={<Skeleton />}>\n        <Analytics /> {/* fetch('/api/analytics') */}\n      </Suspense>\n      \n      <Suspense fallback={<Skeleton />}>\n        <Notifications /> {/* fetch('/api/notifications') */}\n      </Suspense>\n    </div>\n  );\n}\n\n// Nested suspense for progressive enhancement\nfunction BlogPost({ id }) {\n  return (\n    <Suspense fallback={<PageSkeleton />}>\n      <PostContent id={id}>\n        <Suspense fallback={<CommentsSkeleton />}>\n          <Comments postId={id} />\n        </Suspense>\n        \n        <Suspense fallback={<RelatedSkeleton />}>\n          <RelatedPosts postId={id} />\n        </Suspense>\n      </PostContent>\n    </Suspense>\n  );\n  // Content streams first, then comments and related posts\n}\n\n// renderToPipeableStream (Node.js)\nimport { renderToPipeableStream } from 'react-dom/server';\n\nconst { pipe } = renderToPipeableStream(<App />, {\n  onShellReady() {\n    // Send initial HTML shell\n    res.statusCode = 200;\n    res.setHeader('Content-Type', 'text/html');\n    pipe(res);\n  },\n  onAllReady() {\n    // All content ready (for crawlers)\n  }\n});"
    },
    {
      "id": 84,
      "question": "What are the best practices for Next.js App Router with React Server Components?",
      "answer": "The App Router in Next.js 13+ uses React Server Components by default with new patterns for routing, data fetching, and rendering.\n\nKey Concepts:\n• Server First: Components are server by default\n• File-Based Routing: App directory structure defines routes\n• Layouts: Shared UI that doesn't re-render\n• Loading UI: Automatic loading states\n• Error Boundaries: File-based error handling\n• Metadata API: SEO and document head\n\nBest Practices:\n• Use Server Components: Default for most components\n• Client Components Sparingly: Only for interactivity\n• Fetch in Server Components: Avoid API routes\n• Parallel Data Fetching: Use Promise.all\n• Proper use client Placement: As deep as possible\n• Streaming with Suspense: Progressive loading\n• Metadata: Use generateMetadata for SEO\n• Error Handling: error.js for error boundaries",
      "explanation": "Next.js App Router best practices include using Server Components by default, strategic use client placement, fetching data directly in components, and leveraging streaming with Suspense for optimal performance.",
      "difficulty": "Hard",
      "code": "// app/layout.js - Root Layout\nexport const metadata = {\n  title: 'My App',\n  description: 'App description'\n};\n\nexport default function RootLayout({ children }) {\n  return (\n    <html>\n      <body>\n        <Header />\n        <main>{children}</main>\n        <Footer />\n      </body>\n    </html>\n  );\n}\n\n// app/page.js - Server Component (default)\nasync function HomePage() {\n  // Fetch directly, no API route needed\n  const posts = await fetch('https://api.example.com/posts', {\n    next: { revalidate: 60 } // ISR\n  }).then(r => r.json());\n  \n  return (\n    <div>\n      <h1>Posts</h1>\n      {posts.map(post => <PostCard key={post.id} post={post} />)}\n    </div>\n  );\n}\n\n// app/posts/[id]/page.js - Dynamic Route\nexport async function generateMetadata({ params }) {\n  const post = await fetchPost(params.id);\n  return {\n    title: post.title,\n    description: post.excerpt\n  };\n}\n\nexport default async function PostPage({ params }) {\n  const post = await fetchPost(params.id);\n  \n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <PostContent content={post.content} />\n      {/* Client component for likes */}\n      <LikeButton postId={post.id} />\n    </article>\n  );\n}\n\n// components/LikeButton.js - Client Component\n'use client'; // Mark as client component\n\nimport { useState } from 'react';\n\nexport function LikeButton({ postId }) {\n  const [likes, setLikes] = useState(0);\n  \n  return <button onClick={() => setLikes(l => l + 1)}>Likes: {likes}</button>;\n}\n\n// app/dashboard/layout.js - Nested Layout\nexport default function DashboardLayout({ children }) {\n  return (\n    <div className=\"dashboard\">\n      <Sidebar /> {/* Doesn't re-render */}\n      <div className=\"content\">{children}</div>\n    </div>\n  );\n}\n\n// app/dashboard/loading.js - Loading UI\nexport default function Loading() {\n  return <DashboardSkeleton />;\n}\n\n// app/dashboard/error.js - Error Boundary\n'use client';\n\nexport default function Error({ error, reset }) {\n  return (\n    <div>\n      <h2>Something went wrong!</h2>\n      <p>{error.message}</p>\n      <button onClick={reset}>Try again</button>\n    </div>\n  );\n}\n\n// Parallel data fetching\nasync function Page() {\n  // Fetch in parallel\n  const [user, posts, comments] = await Promise.all([\n    fetchUser(),\n    fetchPosts(),\n    fetchComments()\n  ]);\n  \n  return (\n    <div>\n      <UserProfile user={user} />\n      <PostsList posts={posts} />\n      <CommentsList comments={comments} />\n    </div>\n  );\n}\n\n// Streaming pattern\nimport { Suspense } from 'react';\n\nfunction Page() {\n  return (\n    <div>\n      <Suspense fallback={<Skeleton />}>\n        <SlowComponent /> {/* Server Component */}\n      </Suspense>\n    </div>\n  );\n}"
    },
    {
      "id": 85,
      "question": "What is the difference between getServerSideProps, getStaticProps, and Server Components?",
      "answer": "These are different data fetching strategies in Next.js with different rendering and caching behaviors.\n\ngetServerSideProps (Pages Router):\n• Runs on Every Request: Fresh data each time\n• Blocks Rendering: Wait for data before render\n• Server Only: Never runs on client\n• Props to Component: Passes data as props\n• Use Case: Dynamic, personalized content\n\ngetStaticProps (Pages Router):\n• Build Time: Runs at build or revalidation\n• Static Generation: HTML generated ahead of time\n• ISR: Optionally revalidate periodically\n• Fast: Served from CDN\n• Use Case: Content that doesn't change often\n\nServer Components (App Router):\n• Component-Level: Fetch in the component\n• Streaming: Progressive rendering\n• No API Routes: Direct database access\n• Flexible: Mix static and dynamic\n• Modern: Recommended for new apps\n\nMigration:\n• Pages Router: Legacy, still supported\n• App Router: New, uses Server Components\n• Incremental: Can adopt gradually",
      "explanation": "getServerSideProps renders on every request, getStaticProps generates at build time with optional revalidation, while Server Components enable component-level fetching with streaming in the modern App Router.",
      "difficulty": "Medium",
      "code": "// Pages Router: getServerSideProps\n// pages/user/[id].js\nexport async function getServerSideProps(context) {\n  const { id } = context.params;\n  const user = await fetchUser(id);\n  \n  return {\n    props: { user }\n  };\n}\n\nfunction UserPage({ user }) {\n  return <div>{user.name}</div>;\n}\n\n// Pages Router: getStaticProps with ISR\n// pages/posts/[slug].js\nexport async function getStaticProps(context) {\n  const post = await fetchPost(context.params.slug);\n  \n  return {\n    props: { post },\n    revalidate: 60 // Revalidate every 60 seconds\n  };\n}\n\nexport async function getStaticPaths() {\n  const posts = await fetchAllPosts();\n  \n  return {\n    paths: posts.map(p => ({ params: { slug: p.slug } })),\n    fallback: 'blocking'\n  };\n}\n\nfunction PostPage({ post }) {\n  return <article>{post.content}</article>;\n}\n\n// App Router: Server Component\n// app/user/[id]/page.js\nasync function UserPage({ params }) {\n  // Fetch directly in component\n  const user = await fetchUser(params.id);\n  \n  return <div>{user.name}</div>;\n}\n\n// App Router: Static with revalidation\n// app/posts/[slug]/page.js\nasync function PostPage({ params }) {\n  const post = await fetch(`/api/posts/${params.slug}`, {\n    next: { revalidate: 60 } // ISR\n  }).then(r => r.json());\n  \n  return <article>{post.content}</article>;\n}\n\nexport async function generateStaticParams() {\n  const posts = await fetchAllPosts();\n  return posts.map(p => ({ slug: p.slug }));\n}\n\n// Comparison table:\n// Feature               | getServerSideProps | getStaticProps | Server Components\n// ----------------------|-------------------|----------------|------------------\n// When runs             | Every request     | Build time     | Request time\n// Caching               | No                | Yes            | Configurable\n// Streaming             | No                | No             | Yes\n// Component-level fetch | No                | No             | Yes\n// Direct DB access      | No                | No             | Yes\n// Props                 | Yes               | Yes            | No props needed\n\n// Migration example\n// Before (Pages Router)\nexport async function getServerSideProps() {\n  const data = await fetch('/api/data').then(r => r.json());\n  return { props: { data } };\n}\n\nfunction Page({ data }) {\n  return <div>{data.title}</div>;\n}\n\n// After (App Router)\nasync function Page() {\n  const data = await fetch('/api/data').then(r => r.json());\n  return <div>{data.title}</div>;\n}"
    },
    {
      "id": 86,
      "question": "What are the best practices for optimizing React application performance?",
      "answer": "React performance optimization involves reducing unnecessary renders, optimizing bundle size, and improving load times through various techniques.\n\nRender Optimization:\n• React.memo: Prevent unnecessary re-renders\n• useCallback: Memoize callback functions\n• useMemo: Memoize expensive calculations\n• Key Prop: Proper keys for list items\n• Code Splitting: Lazy load components\n• Virtualization: Render only visible items\n\nBundle Optimization:\n• Tree Shaking: Remove unused code\n• Dynamic Imports: Load code on demand\n• Bundle Analysis: Identify large dependencies\n• CDN: Use CDN for libraries\n• Compression: Enable gzip or brotli\n\nData Fetching:\n• Caching: Cache API responses\n• Pagination: Load data in chunks\n• Debouncing: Delay expensive operations\n• Prefetching: Load data before needed\n• Parallel Requests: Fetch concurrently\n\nImage Optimization:\n• Lazy Loading: Load images on scroll\n• Responsive Images: Serve appropriate sizes\n• Modern Formats: Use WebP or AVIF\n• Image CDN: Use image optimization services",
      "explanation": "React performance optimization includes preventing unnecessary renders with memoization, reducing bundle size through code splitting, optimizing data fetching with caching, and lazy loading assets.",
      "difficulty": "Hard"
    },
    {
      "id": 87,
      "question": "What is React virtualization and when should you use it?",
      "answer": "Virtualization renders only the visible items in a large list, dramatically improving performance by reducing DOM nodes and render time.\n\nHow It Works:\n• Visible Area: Calculate visible viewport\n• Render Window: Render only visible + buffer items\n• Scroll Position: Track scroll to update visible items\n• DOM Recycling: Reuse DOM nodes\n• Dynamic Heights: Handle variable item heights\n\nPopular Libraries:\n• react-window: Lightweight virtualization\n• react-virtualized: Feature-rich, larger bundle\n• TanStack Virtual: Modern, framework-agnostic\n\nWhen to Use:\n• Large Lists: 100+ items\n• Performance Issues: Slow scrolling or rendering\n• Long Feeds: Infinite scroll feeds\n• Tables: Large data tables\n\nBenefits:\n• Performance: Dramatically faster\n• Memory: Lower memory usage\n• Smooth Scrolling: No jank\n• Scalability: Handle thousands of items",
      "explanation": "Virtualization renders only visible list items instead of the entire list, drastically improving performance for large datasets by reducing DOM nodes and render work.",
      "difficulty": "Medium",
      "code": "// Without virtualization (slow for large lists)\nfunction SlowList({ items }) {\n  return (\n    <div style={{ height: 600, overflow: 'auto' }}>\n      {items.map(item => (\n        <div key={item.id} style={{ height: 50 }}>\n          {item.name}\n        </div>\n      ))}\n    </div>\n  );\n}\n\n// With react-window (fast)\nimport { FixedSizeList } from 'react-window';\n\nfunction VirtualList({ items }) {\n  const Row = ({ index, style }) => (\n    <div style={style}>\n      {items[index].name}\n    </div>\n  );\n  \n  return (\n    <FixedSizeList\n      height={600}\n      itemCount={items.length}\n      itemSize={50}\n      width='100%'\n    >\n      {Row}\n    </FixedSizeList>\n  );\n}\n\n// Variable height items\nimport { VariableSizeList } from 'react-window';\n\nfunction VariableList({ items }) {\n  const getItemSize = (index) => items[index].height;\n  \n  const Row = ({ index, style }) => (\n    <div style={style}>\n      {items[index].content}\n    </div>\n  );\n  \n  return (\n    <VariableSizeList\n      height={600}\n      itemCount={items.length}\n      itemSize={getItemSize}\n      width='100%'\n    >\n      {Row}\n    </VariableSizeList>\n  );\n}\n\n// Grid virtualization\nimport { FixedSizeGrid } from 'react-window';\n\nfunction VirtualGrid({ items }) {\n  const Cell = ({ columnIndex, rowIndex, style }) => (\n    <div style={style}>\n      Item {rowIndex}, {columnIndex}\n    </div>\n  );\n  \n  return (\n    <FixedSizeGrid\n      columnCount={10}\n      columnWidth={100}\n      height={600}\n      rowCount={Math.ceil(items.length / 10)}\n      rowHeight={50}\n      width={1000}\n    >\n      {Cell}\n    </FixedSizeGrid>\n  );\n}"
    },
    {
      "id": 88,
      "question": "How do you analyze and optimize React bundle size?",
      "answer": "Bundle size analysis identifies large dependencies and opportunities for optimization to reduce download time and improve performance.\n\nAnalysis Tools:\n• webpack-bundle-analyzer: Visualize bundle contents\n• source-map-explorer: Analyze source maps\n• Bundle Buddy: Find duplicate dependencies\n• Chrome DevTools: Coverage tool\n\nOptimization Techniques:\n• Code Splitting: Dynamic imports for routes/features\n• Tree Shaking: Remove unused code\n• Dependencies: Replace large libraries\n• Lodash: Import specific functions\n• moment.js: Replace with date-fns or dayjs\n• External CDN: Move libraries to CDN\n• Compression: Enable gzip/brotli\n\nBest Practices:\n• Analyze Regularly: Check bundle on each build\n• Lazy Load: Load code when needed\n• Import Wisely: Named imports for tree shaking\n• Audit Dependencies: Review package sizes\n• Remove Unused: Delete dead code",
      "explanation": "Bundle size optimization involves analyzing dependencies with tools like webpack-bundle-analyzer, implementing code splitting, replacing large libraries, and enabling tree shaking to reduce download sizes.",
      "difficulty": "Medium",
      "code": "// Install bundle analyzer\n// npm install --save-dev webpack-bundle-analyzer\n\n// webpack.config.js\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\nmodule.exports = {\n  plugins: [\n    new BundleAnalyzerPlugin()\n  ]\n};\n\n// package.json\n{\n  \"scripts\": {\n    \"analyze\": \"webpack-bundle-analyzer build/bundle-stats.json\"\n  }\n}\n\n// Bad: Import entire library\nimport _ from 'lodash';\nconst result = _.debounce(fn, 300);\n\n// Good: Import specific function\nimport debounce from 'lodash/debounce';\nconst result = debounce(fn, 300);\n\n// Bad: Large date library\nimport moment from 'moment';\nconst date = moment().format('YYYY-MM-DD');\n\n// Good: Smaller alternative\nimport { format } from 'date-fns';\nconst date = format(new Date(), 'yyyy-MM-dd');\n\n// Code splitting for routes\nimport { lazy, Suspense } from 'react';\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\n\nconst Home = lazy(() => import('./pages/Home'));\nconst Dashboard = lazy(() => import('./pages/Dashboard'));\nconst Settings = lazy(() => import('./pages/Settings'));\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Suspense fallback={<Loading />}>\n        <Routes>\n          <Route path='/' element={<Home />} />\n          <Route path='/dashboard' element={<Dashboard />} />\n          <Route path='/settings' element={<Settings />} />\n        </Routes>\n      </Suspense>\n    </BrowserRouter>\n  );\n}\n\n// Feature-based code splitting\nfunction App() {\n  const [showChart, setShowChart] = useState(false);\n  \n  const Chart = lazy(() => import('./Chart'));\n  \n  return (\n    <div>\n      <button onClick={() => setShowChart(true)}>Show Chart</button>\n      {showChart && (\n        <Suspense fallback={<div>Loading chart...</div>}>\n          <Chart />\n        </Suspense>\n      )}\n    </div>\n  );\n}\n\n// Next.js bundle analysis\n// npm install @next/bundle-analyzer\n// next.config.js\nconst withBundleAnalyzer = require('@next/bundle-analyzer')({\n  enabled: process.env.ANALYZE === 'true'\n});\n\nmodule.exports = withBundleAnalyzer({\n  // config\n});\n\n// Run analysis\n// ANALYZE=true npm run build"
    },
    {
      "id": 89,
      "question": "What are React profiling tools and how do you use them?",
      "answer": "React provides profiling tools to measure component performance, identify slow renders, and optimize application speed.\n\nProfiler Component:\n• Wrap Components: Measure specific parts\n• onRender Callback: Get performance metrics\n• Render Time: Actual time to render\n• Base Time: Time without memoization\n• Start/Commit Time: When render started/finished\n\nReact DevTools Profiler:\n• Flame Graph: Visualize component render times\n• Ranked Chart: See slowest components\n• Component Chart: Individual component performance\n• Interactions: Track user interactions\n• Why Did You Render: Debug unnecessary renders\n\nMetrics to Monitor:\n• Render Count: How often component renders\n• Render Duration: Time taken to render\n• Wasted Renders: Unnecessary re-renders\n• Props Changes: What triggered re-render\n\nOptimization Strategy:\n• Profile First: Measure before optimizing\n• Find Bottlenecks: Identify slow components\n• Apply Fixes: Use memo, useMemo, useCallback\n• Re-Profile: Verify improvements",
      "explanation": "React profiling uses the Profiler component and DevTools to measure render performance, identify slow components and unnecessary renders, guiding optimization efforts with concrete metrics.",
      "difficulty": "Medium",
      "code": "import { Profiler } from 'react';\n\n// Profiler component\nfunction App() {\n  const onRenderCallback = (\n    id, // Profiler id\n    phase, // 'mount' or 'update'\n    actualDuration, // Time spent rendering\n    baseDuration, // Estimated time without memoization\n    startTime, // When React began rendering\n    commitTime, // When React committed update\n    interactions // Set of interactions\n  ) => {\n    console.log({\n      id,\n      phase,\n      actualDuration,\n      baseDuration\n    });\n    \n    // Send to analytics\n    // analytics.track('render', { id, actualDuration });\n  };\n  \n  return (\n    <Profiler id='App' onRender={onRenderCallback}>\n      <Header />\n      <Profiler id='MainContent' onRender={onRenderCallback}>\n        <MainContent />\n      </Profiler>\n      <Footer />\n    </Profiler>\n  );\n}\n\n// Detecting unnecessary renders\nimport { useEffect, useRef } from 'react';\n\nfunction useWhyDidYouUpdate(name, props) {\n  const previousProps = useRef();\n  \n  useEffect(() => {\n    if (previousProps.current) {\n      const allKeys = Object.keys({ ...previousProps.current, ...props });\n      const changedProps = {};\n      \n      allKeys.forEach(key => {\n        if (previousProps.current[key] !== props[key]) {\n          changedProps[key] = {\n            from: previousProps.current[key],\n            to: props[key]\n          };\n        }\n      });\n      \n      if (Object.keys(changedProps).length > 0) {\n        console.log('[why-did-you-update]', name, changedProps);\n      }\n    }\n    \n    previousProps.current = props;\n  });\n}\n\n// Usage\nfunction MyComponent(props) {\n  useWhyDidYouUpdate('MyComponent', props);\n  return <div>{props.value}</div>;\n}\n\n// Performance monitoring\nfunction useRenderCount() {\n  const renders = useRef(0);\n  \n  useEffect(() => {\n    renders.current++;\n  });\n  \n  return renders.current;\n}\n\nfunction Component() {\n  const renderCount = useRenderCount();\n  console.log('Rendered', renderCount, 'times');\n  \n  return <div>Component</div>;\n}\n\n// React DevTools Profiler usage:\n// 1. Open React DevTools\n// 2. Click 'Profiler' tab\n// 3. Click record button\n// 4. Interact with app\n// 5. Stop recording\n// 6. View flame graph or ranked chart\n// 7. Click components to see details\n// 8. Check 'Why did this render?'\n\n// Custom performance monitor\nfunction PerformanceMonitor({ children }) {\n  const renderTime = useRef();\n  \n  useEffect(() => {\n    renderTime.current = performance.now();\n  });\n  \n  useEffect(() => {\n    const duration = performance.now() - renderTime.current;\n    if (duration > 16) { // 60fps threshold\n      console.warn('Slow render:', duration, 'ms');\n    }\n  });\n  \n  return children;\n}"
    },
    {
      "id": 90,
      "question": "What are the best practices for lazy loading images in React?",
      "answer": "Lazy loading images defers loading off-screen images until needed, reducing initial page load time and improving performance.\n\nNative Lazy Loading:\n• loading Attribute: Use loading='lazy' on img tags\n• Browser Support: Modern browsers support natively\n• No JavaScript: Works without extra code\n• Simple: Easy to implement\n\nIntersection Observer:\n• Custom Control: More control over loading\n• Placeholder: Show placeholder until loaded\n• Threshold: Control when to load\n• Polyfill: Support older browsers\n\nLibraries:\n• react-lazy-load-image-component: Easy to use\n• react-intersection-observer: Flexible observer hook\n• Next.js Image: Automatic optimization\n\nBest Practices:\n• Above Fold: Don't lazy load above-the-fold images\n• Placeholders: Show placeholder during load\n• Blur Effect: Progressive image loading\n• Error Handling: Handle failed loads\n• Responsive: Serve appropriate sizes\n• Modern Formats: Use WebP with fallback",
      "explanation": "Lazy loading images uses native loading attribute or Intersection Observer to defer loading off-screen images, improving initial load time with proper placeholders and error handling.",
      "difficulty": "Medium",
      "code": "// 1. Native lazy loading (simplest)\nfunction NativeLazy() {\n  return (\n    <img\n      src=\"large-image.jpg\"\n      loading=\"lazy\"\n      alt=\"Lazy loaded\"\n      width=\"800\"\n      height=\"600\"\n    />\n  );\n}\n\n// 2. Intersection Observer approach\nimport { useState, useEffect, useRef } from 'react';\n\nfunction LazyImage({ src, placeholder, alt, ...props }) {\n  const [imageSrc, setImageSrc] = useState(placeholder);\n  const [isLoaded, setIsLoaded] = useState(false);\n  const imageRef = useRef();\n  \n  useEffect(() => {\n    const observer = new IntersectionObserver(\n      (entries) => {\n        entries.forEach(entry => {\n          if (entry.isIntersecting) {\n            setImageSrc(src);\n            observer.unobserve(entry.target);\n          }\n        });\n      },\n      { rootMargin: '50px' } // Start loading 50px before visible\n    );\n    \n    if (imageRef.current) {\n      observer.observe(imageRef.current);\n    }\n    \n    return () => observer.disconnect();\n  }, [src]);\n  \n  return (\n    <img\n      ref={imageRef}\n      src={imageSrc}\n      alt={alt}\n      className={isLoaded ? 'loaded' : 'loading'}\n      onLoad={() => setIsLoaded(true)}\n      {...props}\n    />\n  );\n}\n\n// 3. Progressive image loading (blur-up)\nfunction ProgressiveImage({ placeholder, src, alt }) {\n  const [currentSrc, setCurrentSrc] = useState(placeholder);\n  const [isLoading, setIsLoading] = useState(true);\n  \n  useEffect(() => {\n    const img = new Image();\n    img.src = src;\n    \n    img.onload = () => {\n      setCurrentSrc(src);\n      setIsLoading(false);\n    };\n  }, [src]);\n  \n  return (\n    <div style={{ position: 'relative' }}>\n      <img\n        src={currentSrc}\n        alt={alt}\n        style={{\n          filter: isLoading ? 'blur(10px)' : 'none',\n          transition: 'filter 0.3s'\n        }}\n      />\n      {isLoading && <div className=\"spinner\" />}\n    </div>\n  );\n}\n\n// 4. Using react-lazy-load-image-component\nimport { LazyLoadImage } from 'react-lazy-load-image-component';\nimport 'react-lazy-load-image-component/src/effects/blur.css';\n\nfunction WithLibrary() {\n  return (\n    <LazyLoadImage\n      src=\"image.jpg\"\n      placeholderSrc=\"tiny-placeholder.jpg\"\n      effect=\"blur\"\n      alt=\"Product\"\n      threshold={100}\n    />\n  );\n}\n\n// 5. Custom hook for lazy loading\nfunction useLazyLoad(ref, options = {}) {\n  const [isVisible, setIsVisible] = useState(false);\n  \n  useEffect(() => {\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        if (entry.isIntersecting) {\n          setIsVisible(true);\n          observer.disconnect();\n        }\n      },\n      options\n    );\n    \n    if (ref.current) {\n      observer.observe(ref.current);\n    }\n    \n    return () => observer.disconnect();\n  }, [ref, options]);\n  \n  return isVisible;\n}\n\nfunction ImageWithHook({ src, placeholder, alt }) {\n  const ref = useRef();\n  const isVisible = useLazyLoad(ref, { rootMargin: '100px' });\n  \n  return (\n    <img\n      ref={ref}\n      src={isVisible ? src : placeholder}\n      alt={alt}\n    />\n  );\n}\n\n// 6. Error handling and retry\nfunction RobustLazyImage({ src, fallback, alt }) {\n  const [imgSrc, setImgSrc] = useState(null);\n  const [error, setError] = useState(false);\n  const [retries, setRetries] = useState(0);\n  const ref = useRef();\n  \n  const isVisible = useLazyLoad(ref);\n  \n  useEffect(() => {\n    if (!isVisible || error) return;\n    \n    const img = new Image();\n    img.src = src;\n    \n    img.onload = () => setImgSrc(src);\n    img.onerror = () => {\n      if (retries < 3) {\n        setTimeout(() => setRetries(r => r + 1), 1000);\n      } else {\n        setError(true);\n        setImgSrc(fallback);\n      }\n    };\n  }, [src, isVisible, retries, error, fallback]);\n  \n  return (\n    <img\n      ref={ref}\n      src={imgSrc || 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='}\n      alt={alt}\n    />\n  );\n}"
    },
    {
      "id": 91,
      "question": "How do you prevent XSS (Cross-Site Scripting) attacks in React?",
      "answer": "React provides built-in protection against XSS attacks through automatic escaping, but developers must still follow security best practices.\n\nBuilt-in Protection:\n• Auto-Escaping: JSX escapes values by default\n• Safe Rendering: Text content is escaped automatically\n• Props Escaping: All props are escaped\n\nDangerous Patterns to Avoid:\n• dangerouslySetInnerHTML: Bypasses escaping\n• href='javascript:': Dangerous JavaScript URLs\n• User-Generated HTML: Rendering untrusted HTML\n• eval(): Never use eval with user input\n• innerHTML: Direct DOM manipulation\n\nSafe Practices:\n• Sanitize Input: Use DOMPurify for HTML\n• Validate URLs: Check href and src values\n• Content Security Policy: Implement CSP headers\n• Escape User Data: Never trust user input\n• Use Libraries: Leverage trusted sanitization libraries\n\nCSP Headers:\n• script-src: Control script sources\n• style-src: Control style sources\n• Nonce: Use nonces for inline scripts",
      "explanation": "React auto-escapes JSX values preventing XSS, but developers must sanitize HTML with libraries like DOMPurify, validate URLs, implement CSP, and avoid dangerouslySetInnerHTML with untrusted content.",
      "difficulty": "Medium",
      "code": "// Safe: React auto-escapes\nfunction SafeComponent({ userInput }) {\n  return <div>{userInput}</div>;\n  // Even if userInput is <script>alert('XSS')</script>\n  // React renders it as text, not script\n}\n\n// Dangerous: dangerouslySetInnerHTML\nfunction DangerousComponent({ html }) {\n  return <div dangerouslySetInnerHTML={{ __html: html }} />;\n  // If html contains <script>, it will execute! ❌\n}\n\n// Safe: Sanitize with DOMPurify\nimport DOMPurify from 'dompurify';\n\nfunction SafeHTML({ html }) {\n  const clean = DOMPurify.sanitize(html);\n  return <div dangerouslySetInnerHTML={{ __html: clean }} />;\n  // DOMPurify removes malicious code ✅\n}\n\n// Dangerous: JavaScript URLs\nfunction DangerousLink({ url }) {\n  return <a href={url}>Click</a>;\n  // url could be 'javascript:alert(1)' ❌\n}\n\n// Safe: Validate URLs\nfunction SafeLink({ url }) {\n  const isValidUrl = (str) => {\n    try {\n      const parsed = new URL(str);\n      return ['http:', 'https:'].includes(parsed.protocol);\n    } catch {\n      return false;\n    }\n  };\n  \n  if (!isValidUrl(url)) {\n    return <span>Invalid link</span>;\n  }\n  \n  return <a href={url}>Click</a>; // ✅\n}\n\n// CSP implementation (Next.js)\n// next.config.js\nconst securityHeaders = [\n  {\n    key: 'Content-Security-Policy',\n    value: \"default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline';\"\n  }\n];\n\nmodule.exports = {\n  async headers() {\n    return [\n      {\n        source: '/(.*)',\n        headers: securityHeaders\n      }\n    ];\n  }\n};\n\n// Safe markdown rendering\nimport ReactMarkdown from 'react-markdown';\n\nfunction SafeMarkdown({ content }) {\n  return (\n    <ReactMarkdown\n      components={{\n        // Remove potentially dangerous elements\n        script: () => null,\n        iframe: () => null\n      }}\n    >\n      {content}\n    </ReactMarkdown>\n  );\n}\n\n// Input validation\nfunction CommentForm() {\n  const [comment, setComment] = useState('');\n  \n  const sanitizeInput = (input) => {\n    // Remove script tags\n    return input.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '');\n  };\n  \n  const handleSubmit = (e) => {\n    e.preventDefault();\n    const clean = sanitizeInput(comment);\n    // Send clean to server\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <textarea\n        value={comment}\n        onChange={(e) => setComment(e.target.value)}\n      />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}"
    },
    {
      "id": 92,
      "question": "What are React accessibility best practices and ARIA attributes?",
      "answer": "Accessibility ensures React apps are usable by everyone, including people with disabilities. ARIA attributes provide semantic information to assistive technologies.\n\nSemantic HTML:\n• Use Proper Elements: button, nav, main, article\n• Headings: Proper heading hierarchy (h1-h6)\n• Labels: Associate labels with form inputs\n• Alt Text: Descriptive image alternatives\n• Focus Management: Logical tab order\n\nARIA Attributes:\n• aria-label: Accessible name for element\n• aria-labelledby: Reference to label element\n• aria-describedby: Additional description\n• aria-hidden: Hide from screen readers\n• aria-live: Announce dynamic content\n• role: Define element role\n\nKeyboard Navigation:\n• Tab Order: All interactive elements focusable\n• Focus Indicators: Visible focus states\n• Keyboard Shortcuts: Escape, Enter, Arrow keys\n• Focus Trapping: Modal focus management\n\nTools:\n• react-aria: Accessible component hooks\n• eslint-plugin-jsx-a11y: Lint accessibility\n• axe DevTools: Accessibility testing",
      "explanation": "React accessibility uses semantic HTML, ARIA attributes for assistive technologies, proper keyboard navigation, focus management, and testing tools to ensure apps are usable by everyone.",
      "difficulty": "Medium",
      "code": "// Semantic HTML and ARIA\nfunction AccessibleButton() {\n  return (\n    <button\n      onClick={handleClick}\n      aria-label=\"Close dialog\"\n      aria-describedby=\"close-description\"\n    >\n      ✕\n    </button>\n    <span id=\"close-description\" hidden>\n      Closes the dialog and returns to main page\n    </span>\n  );\n}\n\n// Form accessibility\nfunction AccessibleForm() {\n  return (\n    <form>\n      <label htmlFor=\"email\">Email Address:</label>\n      <input\n        id=\"email\"\n        type=\"email\"\n        required\n        aria-required=\"true\"\n        aria-describedby=\"email-error\"\n      />\n      <span id=\"email-error\" role=\"alert\">\n        Please enter a valid email\n      </span>\n    </form>\n  );\n}\n\n// Modal with focus trap\nimport { useEffect, useRef } from 'react';\nimport FocusTrap from 'focus-trap-react';\n\nfunction Modal({ isOpen, onClose, children }) {\n  const closeButtonRef = useRef();\n  \n  useEffect(() => {\n    if (isOpen) {\n      closeButtonRef.current?.focus();\n    }\n  }, [isOpen]);\n  \n  if (!isOpen) return null;\n  \n  return (\n    <FocusTrap>\n      <div\n        role=\"dialog\"\n        aria-modal=\"true\"\n        aria-labelledby=\"modal-title\"\n      >\n        <h2 id=\"modal-title\">Dialog Title</h2>\n        {children}\n        <button\n          ref={closeButtonRef}\n          onClick={onClose}\n          aria-label=\"Close dialog\"\n        >\n          Close\n        </button>\n      </div>\n    </FocusTrap>\n  );\n}\n\n// Live regions for dynamic content\nfunction Notifications() {\n  const [messages, setMessages] = useState([]);\n  \n  return (\n    <div\n      role=\"status\"\n      aria-live=\"polite\"\n      aria-atomic=\"true\"\n    >\n      {messages.map(msg => (\n        <div key={msg.id}>{msg.text}</div>\n      ))}\n    </div>\n  );\n}\n\n// Skip navigation\nfunction App() {\n  return (\n    <>\n      <a href=\"#main-content\" className=\"skip-link\">\n        Skip to main content\n      </a>\n      <nav>Navigation</nav>\n      <main id=\"main-content\" tabIndex={-1}>\n        <h1>Page Title</h1>\n        Content\n      </main>\n    </>\n  );\n}\n\n// Accessible custom checkbox\nfunction Checkbox({ label, checked, onChange }) {\n  return (\n    <div\n      role=\"checkbox\"\n      aria-checked={checked}\n      tabIndex={0}\n      onClick={onChange}\n      onKeyPress={(e) => {\n        if (e.key === ' ' || e.key === 'Enter') {\n          onChange();\n        }\n      }}\n    >\n      {checked ? '☑' : '☐'} {label}\n    </div>\n  );\n}\n\n// Image accessibility\nfunction AccessibleImage({ src, alt, isDecorative }) {\n  if (isDecorative) {\n    return <img src={src} alt=\"\" aria-hidden=\"true\" />;\n  }\n  \n  return <img src={src} alt={alt} />;\n}\n\n// Keyboard navigation\nfunction Menu({ items }) {\n  const [activeIndex, setActiveIndex] = useState(0);\n  \n  const handleKeyDown = (e) => {\n    switch (e.key) {\n      case 'ArrowDown':\n        setActiveIndex((i) => (i + 1) % items.length);\n        break;\n      case 'ArrowUp':\n        setActiveIndex((i) => (i - 1 + items.length) % items.length);\n        break;\n      case 'Enter':\n        items[activeIndex].action();\n        break;\n    }\n  };\n  \n  return (\n    <ul role=\"menu\" onKeyDown={handleKeyDown}>\n      {items.map((item, i) => (\n        <li\n          key={item.id}\n          role=\"menuitem\"\n          tabIndex={i === activeIndex ? 0 : -1}\n        >\n          {item.label}\n        </li>\n      ))}\n    </ul>\n  );\n}"
    },
    {
      "id": 93,
      "question": "What are compound components and when should you use them?",
      "answer": "Compound components is a pattern where components work together sharing implicit state, providing a flexible and intuitive API for complex UI components.\n\nKey Concepts:\n• Parent-Child Relationship: Components designed to work together\n• Implicit State: Share state without explicit props\n• Flexible Composition: Users compose how they want\n• Context API: Share state via context\n• Dot Notation: Component.SubComponent naming\n\nBenefits:\n• Flexibility: Users control component structure\n• Clean API: Intuitive component usage\n• Separation of Concerns: Each component has single responsibility\n• Reusability: Components independently reusable\n• Customization: Easy to customize appearance\n\nWhen to Use:\n• Complex Components: Tabs, accordions, selects\n• Flexible Layout: Multiple ways to arrange\n• Shared State: Components need common state\n• Component Libraries: Building reusable components\n\nExamples:\n• Tabs: Tab.List, Tab.Panel\n• Select: Select.Trigger, Select.Options\n• Accordion: Accordion.Item, Accordion.Header",
      "explanation": "Compound components share implicit state through context, enabling flexible composition where users control structure while components coordinate behavior, ideal for complex UI like tabs and selects.",
      "difficulty": "Hard",
      "code": "// Compound component pattern\nimport { createContext, useContext, useState } from 'react';\n\n// Tabs implementation\nconst TabsContext = createContext();\n\nfunction Tabs({ children, defaultValue }) {\n  const [activeTab, setActiveTab] = useState(defaultValue);\n  \n  return (\n    <TabsContext.Provider value={{ activeTab, setActiveTab }}>\n      <div className=\"tabs\">{children}</div>\n    </TabsContext.Provider>\n  );\n}\n\nfunction TabList({ children }) {\n  return <div className=\"tab-list\" role=\"tablist\">{children}</div>;\n}\n\nfunction Tab({ value, children }) {\n  const { activeTab, setActiveTab } = useContext(TabsContext);\n  \n  return (\n    <button\n      role=\"tab\"\n      aria-selected={activeTab === value}\n      onClick={() => setActiveTab(value)}\n      className={activeTab === value ? 'active' : ''}\n    >\n      {children}\n    </button>\n  );\n}\n\nfunction TabPanel({ value, children }) {\n  const { activeTab } = useContext(TabsContext);\n  \n  if (activeTab !== value) return null;\n  \n  return (\n    <div role=\"tabpanel\" className=\"tab-panel\">\n      {children}\n    </div>\n  );\n}\n\n// Attach as properties\nTabs.List = TabList;\nTabs.Tab = Tab;\nTabs.Panel = TabPanel;\n\n// Usage\nfunction App() {\n  return (\n    <Tabs defaultValue=\"home\">\n      <Tabs.List>\n        <Tabs.Tab value=\"home\">Home</Tabs.Tab>\n        <Tabs.Tab value=\"profile\">Profile</Tabs.Tab>\n        <Tabs.Tab value=\"settings\">Settings</Tabs.Tab>\n      </Tabs.List>\n      \n      <Tabs.Panel value=\"home\">\n        <h2>Home Content</h2>\n      </Tabs.Panel>\n      <Tabs.Panel value=\"profile\">\n        <h2>Profile Content</h2>\n      </Tabs.Panel>\n      <Tabs.Panel value=\"settings\">\n        <h2>Settings Content</h2>\n      </Tabs.Panel>\n    </Tabs>\n  );\n}\n\n// Accordion compound component\nconst AccordionContext = createContext();\n\nfunction Accordion({ children }) {\n  const [openItems, setOpenItems] = useState([]);\n  \n  const toggle = (id) => {\n    setOpenItems(prev =>\n      prev.includes(id)\n        ? prev.filter(item => item !== id)\n        : [...prev, id]\n    );\n  };\n  \n  return (\n    <AccordionContext.Provider value={{ openItems, toggle }}>\n      <div className=\"accordion\">{children}</div>\n    </AccordionContext.Provider>\n  );\n}\n\nfunction AccordionItem({ id, children }) {\n  return <div className=\"accordion-item\">{children}</div>;\n}\n\nfunction AccordionHeader({ id, children }) {\n  const { openItems, toggle } = useContext(AccordionContext);\n  const isOpen = openItems.includes(id);\n  \n  return (\n    <button\n      onClick={() => toggle(id)}\n      aria-expanded={isOpen}\n    >\n      {children}\n      <span>{isOpen ? '−' : '+'}</span>\n    </button>\n  );\n}\n\nfunction AccordionContent({ id, children }) {\n  const { openItems } = useContext(AccordionContext);\n  const isOpen = openItems.includes(id);\n  \n  if (!isOpen) return null;\n  \n  return <div className=\"accordion-content\">{children}</div>;\n}\n\nAccordion.Item = AccordionItem;\nAccordion.Header = AccordionHeader;\nAccordion.Content = AccordionContent;\n\n// Usage\nfunction FAQ() {\n  return (\n    <Accordion>\n      <Accordion.Item id=\"1\">\n        <Accordion.Header id=\"1\">Question 1?</Accordion.Header>\n        <Accordion.Content id=\"1\">Answer 1</Accordion.Content>\n      </Accordion.Item>\n      <Accordion.Item id=\"2\">\n        <Accordion.Header id=\"2\">Question 2?</Accordion.Header>\n        <Accordion.Content id=\"2\">Answer 2</Accordion.Content>\n      </Accordion.Item>\n    </Accordion>\n  );\n}"
    },
    {
      "id": 94,
      "question": "What are state machines and how can you implement them in React?",
      "answer": "State machines model application state as a finite set of states and transitions, making complex state logic predictable and maintainable.\n\nKey Concepts:\n• States: Finite set of possible states\n• Transitions: Rules for moving between states\n• Events: Triggers that cause transitions\n• Guards: Conditions for transitions\n• Actions: Side effects during transitions\n\nBenefits:\n• Predictability: Explicit state transitions\n• Visualization: Can diagram state flow\n• Debugging: Easier to trace state changes\n• Testability: Test each transition\n• Impossible States: Prevent invalid states\n\nImplementation Options:\n• useReducer: Manual state machine\n• XState: Full-featured state machine library\n• Custom Hook: Encapsulate logic\n\nUse Cases:\n• Forms: Multi-step forms, validation states\n• Auth: Login flows, session management\n• Async Operations: Loading, success, error states\n• UI Components: Modal, dropdown, tooltip states",
      "explanation": "State machines model state as explicit states with defined transitions triggered by events, making complex logic predictable and preventing impossible states, implementable with useReducer or libraries like XState.",
      "difficulty": "Hard",
      "code": "// Simple state machine with useReducer\nfunction trafficLightReducer(state, event) {\n  const transitions = {\n    red: { NEXT: 'green' },\n    green: { NEXT: 'yellow' },\n    yellow: { NEXT: 'red' }\n  };\n  \n  const nextState = transitions[state]?.[event.type];\n  return nextState || state;\n}\n\nfunction TrafficLight() {\n  const [state, dispatch] = useReducer(trafficLightReducer, 'red');\n  \n  return (\n    <div>\n      <div className={`light ${state}`}></div>\n      <button onClick={() => dispatch({ type: 'NEXT' })}>\n        Next\n      </button>\n    </div>\n  );\n}\n\n// Async data fetching state machine\nconst STATES = {\n  IDLE: 'idle',\n  LOADING: 'loading',\n  SUCCESS: 'success',\n  ERROR: 'error'\n};\n\nfunction fetchReducer(state, action) {\n  switch (action.type) {\n    case 'FETCH':\n      return { status: STATES.LOADING, data: null, error: null };\n    case 'SUCCESS':\n      return { status: STATES.SUCCESS, data: action.data, error: null };\n    case 'ERROR':\n      return { status: STATES.ERROR, data: null, error: action.error };\n    case 'RESET':\n      return { status: STATES.IDLE, data: null, error: null };\n    default:\n      return state;\n  }\n}\n\nfunction DataFetcher() {\n  const [state, dispatch] = useReducer(fetchReducer, {\n    status: STATES.IDLE,\n    data: null,\n    error: null\n  });\n  \n  const fetchData = async () => {\n    dispatch({ type: 'FETCH' });\n    try {\n      const res = await fetch('/api/data');\n      const data = await res.json();\n      dispatch({ type: 'SUCCESS', data });\n    } catch (error) {\n      dispatch({ type: 'ERROR', error });\n    }\n  };\n  \n  return (\n    <div>\n      {state.status === STATES.IDLE && (\n        <button onClick={fetchData}>Fetch Data</button>\n      )}\n      {state.status === STATES.LOADING && <div>Loading...</div>}\n      {state.status === STATES.SUCCESS && (\n        <div>Data: {JSON.stringify(state.data)}</div>\n      )}\n      {state.status === STATES.ERROR && (\n        <div>Error: {state.error.message}</div>\n      )}\n    </div>\n  );\n}\n\n// Using XState library\nimport { createMachine, interpret } from 'xstate';\nimport { useMachine } from '@xstate/react';\n\nconst toggleMachine = createMachine({\n  id: 'toggle',\n  initial: 'inactive',\n  states: {\n    inactive: {\n      on: { TOGGLE: 'active' }\n    },\n    active: {\n      on: { TOGGLE: 'inactive' }\n    }\n  }\n});\n\nfunction Toggle() {\n  const [state, send] = useMachine(toggleMachine);\n  \n  return (\n    <button onClick={() => send('TOGGLE')}>\n      {state.value === 'active' ? 'ON' : 'OFF'}\n    </button>\n  );\n}\n\n// Multi-step form state machine\nconst formMachine = createMachine({\n  id: 'form',\n  initial: 'personalInfo',\n  context: { data: {} },\n  states: {\n    personalInfo: {\n      on: {\n        NEXT: { target: 'address', actions: 'savePersonalInfo' }\n      }\n    },\n    address: {\n      on: {\n        BACK: 'personalInfo',\n        NEXT: { target: 'confirmation', actions: 'saveAddress' }\n      }\n    },\n    confirmation: {\n      on: {\n        BACK: 'address',\n        SUBMIT: { target: 'submitted', actions: 'submitForm' }\n      }\n    },\n    submitted: {\n      type: 'final'\n    }\n  }\n});\n\nfunction MultiStepForm() {\n  const [state, send] = useMachine(formMachine);\n  \n  return (\n    <div>\n      {state.matches('personalInfo') && <PersonalInfoStep />}\n      {state.matches('address') && <AddressStep />}\n      {state.matches('confirmation') && <ConfirmationStep />}\n      {state.matches('submitted') && <SuccessMessage />}\n    </div>\n  );\n}"
    },
    {
      "id": 95,
      "question": "What are micro-frontends and how can you implement them with React?",
      "answer": "Micro-frontends extend microservices to the frontend, allowing teams to build and deploy independent frontend applications that work together as a single application.\n\nKey Concepts:\n• Independent Deployment: Each micro-frontend deploys separately\n• Technology Agnostic: Can use different frameworks\n• Team Autonomy: Teams own entire features\n• Isolated Development: Independent development and testing\n• Shared Components: Optional shared component library\n\nImplementation Approaches:\n• Module Federation: Webpack 5 feature for sharing code\n• iframes: Simple but limited communication\n• Web Components: Framework-agnostic components\n• Single-SPA: Framework for orchestrating micro-frontends\n• Server-Side Composition: Compose at server level\n\nBenefits:\n• Scalability: Scale teams independently\n• Technology Flexibility: Use best tool for each feature\n• Incremental Migration: Gradually modernize apps\n• Isolated Failures: One app failure doesn't break all\n\nChallenges:\n• Complexity: More moving parts\n• Performance: Multiple frameworks overhead\n• Shared State: Cross-app communication\n• Styling: CSS conflicts between apps",
      "explanation": "Micro-frontends split frontend into independent applications owned by different teams, using Module Federation, Web Components, or Single-SPA for composition while enabling autonomous development and deployment.",
      "difficulty": "Hard",
      "code": "// 1. Module Federation (Webpack 5)\n// Host app webpack.config.js\nconst ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');\n\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'host',\n      remotes: {\n        app1: 'app1@http://localhost:3001/remoteEntry.js',\n        app2: 'app2@http://localhost:3002/remoteEntry.js'\n      },\n      shared: {\n        react: { singleton: true },\n        'react-dom': { singleton: true }\n      }\n    })\n  ]\n};\n\n// Remote app webpack.config.js\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'app1',\n      filename: 'remoteEntry.js',\n      exposes: {\n        './Header': './src/Header',\n        './Button': './src/Button'\n      },\n      shared: {\n        react: { singleton: true },\n        'react-dom': { singleton: true }\n      }\n    })\n  ]\n};\n\n// Using remote component in host\nimport { lazy, Suspense } from 'react';\n\nconst RemoteHeader = lazy(() => import('app1/Header'));\nconst RemoteButton = lazy(() => import('app2/Button'));\n\nfunction Host() {\n  return (\n    <Suspense fallback=\"Loading...\">\n      <RemoteHeader />\n      <RemoteButton />\n    </Suspense>\n  );\n}\n\n// 2. Single-SPA implementation\n// Root config\nimport { registerApplication, start } from 'single-spa';\n\nregisterApplication({\n  name: '@org/navbar',\n  app: () => System.import('@org/navbar'),\n  activeWhen: ['/'],\n});\n\nregisterApplication({\n  name: '@org/dashboard',\n  app: () => System.import('@org/dashboard'),\n  activeWhen: ['/dashboard'],\n});\n\nstart();\n\n// Micro-frontend app\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport singleSpaReact from 'single-spa-react';\nimport App from './App';\n\nconst lifecycles = singleSpaReact({\n  React,\n  ReactDOM,\n  rootComponent: App,\n  errorBoundary(err, info, props) {\n    return <div>Error in app</div>;\n  },\n});\n\nexport const { bootstrap, mount, unmount } = lifecycles;\n\n// 3. Web Components approach\n// Define custom element\nclass MicroApp extends HTMLElement {\n  connectedCallback() {\n    const root = ReactDOM.createRoot(this);\n    root.render(<App {...this.getProps()} />);\n  }\n  \n  getProps() {\n    return {\n      title: this.getAttribute('title'),\n      data: JSON.parse(this.getAttribute('data') || '{}')\n    };\n  }\n  \n  disconnectedCallback() {\n    ReactDOM.unmountComponentAtNode(this);\n  }\n}\n\ncustomElements.define('micro-app-1', MicroApp);\n\n// Usage in HTML\n// <micro-app-1 title=\"My App\" data='{\"id\": 1}'></micro-app-1>\n\n// 4. Communication between micro-frontends\n// Event bus for cross-app communication\nclass EventBus {\n  constructor() {\n    this.events = {};\n  }\n  \n  on(event, callback) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    this.events[event].push(callback);\n  }\n  \n  emit(event, data) {\n    if (this.events[event]) {\n      this.events[event].forEach(cb => cb(data));\n    }\n  }\n  \n  off(event, callback) {\n    if (this.events[event]) {\n      this.events[event] = this.events[event].filter(cb => cb !== callback);\n    }\n  }\n}\n\nconst eventBus = new EventBus();\n\n// App 1 - Publish event\nfunction App1() {\n  const handleAction = () => {\n    eventBus.emit('user:login', { userId: 123 });\n  };\n  \n  return <button onClick={handleAction}>Login</button>;\n}\n\n// App 2 - Subscribe to event\nfunction App2() {\n  useEffect(() => {\n    const handleLogin = (data) => {\n      console.log('User logged in:', data.userId);\n    };\n    \n    eventBus.on('user:login', handleLogin);\n    \n    return () => eventBus.off('user:login', handleLogin);\n  }, []);\n  \n  return <div>Dashboard</div>;\n}\n\n// 5. Shared state management\n// Using Redux or Context across micro-frontends\nimport { createStore } from 'redux';\n\nconst store = createStore(reducer);\nwindow.sharedStore = store;\n\n// App 1\nfunction App1() {\n  const store = window.sharedStore;\n  // Use shared store\n}\n\n// App 2\nfunction App2() {\n  const store = window.sharedStore;\n  // Use same store\n}"
    },
    {
      "id": 96,
      "question": "What are the best practices for structuring a large React application?",
      "answer": "Proper application structure improves maintainability, scalability, and developer experience in large React projects.\n\nFolder Structure Patterns:\n• Feature-Based: Organize by features/domains\n• Layer-Based: Separate by technical concerns\n• Hybrid: Combine features with shared layers\n• Atomic Design: Components by complexity level\n\nRecommended Structure:\n• src/features: Feature modules\n• src/components: Shared components\n• src/hooks: Custom hooks\n• src/utils: Utility functions\n• src/services: API and external services\n• src/store: State management\n• src/types: TypeScript types\n• src/constants: Constants and config\n\nBest Practices:\n• Colocation: Keep related files together\n• Index Files: Barrel exports for clean imports\n• Absolute Imports: Use path aliases\n• Naming Conventions: Consistent naming\n• Component Guidelines: Single responsibility\n• Code Splitting: Lazy load features\n• Testing: Co-locate tests with code",
      "explanation": "Large React apps benefit from feature-based structure with shared components, consistent naming, absolute imports, colocated tests, and clear separation of concerns between features, components, and services.",
      "difficulty": "Medium",
      "code": "// Recommended folder structure\n/*\nsrc/\n├── features/\n│   ├── auth/\n│   │   ├── components/\n│   │   │   ├── LoginForm.jsx\n│   │   │   ├── LoginForm.test.jsx\n│   │   │   └── index.js\n│   │   ├── hooks/\n│   │   │   └── useAuth.js\n│   │   ├── services/\n│   │   │   └── authService.js\n│   │   ├── store/\n│   │   │   └── authSlice.js\n│   │   ├── types/\n│   │   │   └── auth.types.ts\n│   │   └── index.js\n│   ├── dashboard/\n│   └── settings/\n├── components/\n│   ├── Button/\n│   │   ├── Button.jsx\n│   │   ├── Button.test.jsx\n│   │   ├── Button.module.css\n│   │   └── index.js\n│   ├── Card/\n│   └── Modal/\n├── hooks/\n│   ├── useLocalStorage.js\n│   ├── useDebounce.js\n│   └── index.js\n├── services/\n│   ├── api.js\n│   └── analytics.js\n├── store/\n│   ├── index.js\n│   └── rootReducer.js\n├── utils/\n│   ├── formatters.js\n│   └── validators.js\n├── constants/\n│   └── config.js\n├── types/\n│   └── common.types.ts\n└── App.jsx\n*/\n\n// Barrel exports (index.js)\n// components/index.js\nexport { Button } from './Button';\nexport { Card } from './Card';\nexport { Modal } from './Modal';\n\n// Clean imports\nimport { Button, Card, Modal } from '@/components';\n\n// Path aliases (tsconfig.json or jsconfig.json)\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \"src\",\n    \"paths\": {\n      \"@/components/*\": [\"components/*\"],\n      \"@/features/*\": [\"features/*\"],\n      \"@/hooks/*\": [\"hooks/*\"],\n      \"@/utils/*\": [\"utils/*\"],\n      \"@/services/*\": [\"services/*\"]\n    }\n  }\n}\n\n// Feature module structure\n// features/auth/index.js\nexport { LoginForm } from './components/LoginForm';\nexport { useAuth } from './hooks/useAuth';\nexport { authService } from './services/authService';\n\n// Usage in other features\nimport { useAuth } from '@/features/auth';\n\nfunction Dashboard() {\n  const { user, logout } = useAuth();\n  return <div>Welcome, {user.name}</div>;\n}\n\n// Component organization\n// components/Button/Button.jsx\nimport styles from './Button.module.css';\n\nexport function Button({ variant = 'primary', children, ...props }) {\n  return (\n    <button className={styles[variant]} {...props}>\n      {children}\n    </button>\n  );\n}\n\nButton.propTypes = {\n  variant: PropTypes.oneOf(['primary', 'secondary', 'danger']),\n  children: PropTypes.node.isRequired\n};\n\n// Feature component\n// features/dashboard/components/DashboardCard.jsx\nimport { Card } from '@/components';\nimport { useDashboardData } from '../hooks/useDashboardData';\nimport styles from './DashboardCard.module.css';\n\nexport function DashboardCard() {\n  const { data, loading } = useDashboardData();\n  \n  if (loading) return <Card.Skeleton />;\n  \n  return (\n    <Card className={styles.card}>\n      <Card.Title>{data.title}</Card.Title>\n      <Card.Content>{data.content}</Card.Content>\n    </Card>\n  );\n}"
    },
    {
      "id": 97,
      "question": "What are the best practices for error handling in React applications?",
      "answer": "Comprehensive error handling catches errors at different levels, provides meaningful feedback, and helps with debugging and monitoring.\n\nError Handling Strategies:\n• Error Boundaries: Catch render errors\n• Try-Catch: Handle errors in event handlers\n• Promise Catch: Handle async errors\n• Global Handler: Catch unhandled errors\n• Validation: Prevent errors proactively\n\nLogging and Monitoring:\n• Error Tracking: Sentry, Bugsnag, LogRocket\n• Contextual Info: User, component, stack trace\n• Error Aggregation: Group similar errors\n• Alerts: Notify team of critical errors\n\nUser Experience:\n• Friendly Messages: Clear, non-technical errors\n• Recovery Options: Retry, go back, contact support\n• Fallback UI: Graceful degradation\n• Loading States: Prevent timeout frustration\n\nBest Practices:\n• Multiple Boundaries: Granular error catching\n• Error Recovery: Allow users to retry\n• Development Errors: Detailed in dev, simple in prod\n• Log Everything: Comprehensive error logging",
      "explanation": "React error handling uses Error Boundaries for render errors, try-catch for handlers, promise catch for async, error tracking services, and friendly fallback UIs with recovery options.",
      "difficulty": "Medium",
      "code": "// Error Boundary\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n  \n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n  \n  componentDidCatch(error, errorInfo) {\n    // Log to error tracking service\n    console.error('Error:', error);\n    console.error('Error Info:', errorInfo);\n    \n    // Send to Sentry, Bugsnag, etc.\n    // Sentry.captureException(error, { extra: errorInfo });\n    \n    this.setState({ error, errorInfo });\n  }\n  \n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className=\"error-fallback\">\n          <h1>Something went wrong</h1>\n          <p>We're sorry for the inconvenience.</p>\n          <button onClick={() => window.location.reload()}>\n            Reload Page\n          </button>\n          {process.env.NODE_ENV === 'development' && (\n            <details>\n              <summary>Error Details</summary>\n              <pre>{this.state.error?.toString()}</pre>\n              <pre>{this.state.errorInfo?.componentStack}</pre>\n            </details>\n          )}\n        </div>\n      );\n    }\n    \n    return this.props.children;\n  }\n}\n\n// Usage with multiple boundaries\nfunction App() {\n  return (\n    <ErrorBoundary>\n      <Header />\n      <ErrorBoundary>\n        <Sidebar />\n      </ErrorBoundary>\n      <ErrorBoundary>\n        <MainContent />\n      </ErrorBoundary>\n    </ErrorBoundary>\n  );\n}\n\n// Async error handling\nfunction DataFetcher() {\n  const [data, setData] = useState(null);\n  const [error, setError] = useState(null);\n  const [loading, setLoading] = useState(false);\n  \n  const fetchData = async () => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const response = await fetch('/api/data');\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      \n      const json = await response.json();\n      setData(json);\n    } catch (err) {\n      setError(err);\n      console.error('Fetch error:', err);\n      // Send to error tracking\n    } finally {\n      setLoading(false);\n    }\n  };\n  \n  if (error) {\n    return (\n      <div className=\"error\">\n        <p>Failed to load data: {error.message}</p>\n        <button onClick={fetchData}>Retry</button>\n      </div>\n    );\n  }\n  \n  return loading ? <Loading /> : <Data data={data} />;\n}\n\n// Global error handler\nwindow.addEventListener('error', (event) => {\n  console.error('Global error:', event.error);\n  // Send to error tracking\n});\n\nwindow.addEventListener('unhandledrejection', (event) => {\n  console.error('Unhandled promise rejection:', event.reason);\n  // Send to error tracking\n});\n\n// Custom error hook\nfunction useErrorHandler() {\n  const [error, setError] = useState(null);\n  \n  const handleError = useCallback((err) => {\n    setError(err);\n    console.error('Error:', err);\n    // Send to error tracking\n  }, []);\n  \n  const resetError = useCallback(() => {\n    setError(null);\n  }, []);\n  \n  return { error, handleError, resetError };\n}\n\n// Usage\nfunction Component() {\n  const { error, handleError, resetError } = useErrorHandler();\n  \n  const handleClick = async () => {\n    try {\n      await riskyOperation();\n    } catch (err) {\n      handleError(err);\n    }\n  };\n  \n  if (error) {\n    return (\n      <div>\n        <p>Error: {error.message}</p>\n        <button onClick={resetError}>Dismiss</button>\n      </div>\n    );\n  }\n  \n  return <button onClick={handleClick}>Do Something</button>;\n}"
    },
    {
      "id": 98,
      "question": "What are the best practices for testing React components?",
      "answer": "Effective testing ensures components work correctly, catches regressions, and enables confident refactoring.\n\nTesting Types:\n• Unit Tests: Individual component logic\n• Integration Tests: Component interactions\n• E2E Tests: Full user flows\n• Accessibility Tests: A11y compliance\n• Visual Regression: UI appearance\n\nTesting Tools:\n• Jest: Test runner and assertions\n• React Testing Library: Component testing\n• Cypress: End-to-end testing\n• MSW: API mocking\n• jest-axe: Accessibility testing\n\nTesting Principles:\n• Test Behavior: Not implementation details\n• User Perspective: Test as users interact\n• Accessibility: Query by accessible attributes\n• Avoid Implementation: Don't test internal state\n• Confidence: Write tests that catch real bugs\n\nBest Practices:\n• Arrange-Act-Assert: Structure tests clearly\n• Test User Flows: Not isolated functions\n• Mock Sparingly: Only external dependencies\n• Async Handling: Use waitFor, findBy queries\n• Coverage: Focus on critical paths",
      "explanation": "React testing uses Jest and React Testing Library to test component behavior from user perspective, focusing on interactions rather than implementation, with proper async handling and accessibility queries.",
      "difficulty": "Medium",
      "code": "// Basic component test\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { Counter } from './Counter';\n\ndescribe('Counter', () => {\n  it('increments count when button clicked', () => {\n    // Arrange\n    render(<Counter />);\n    \n    // Act\n    const button = screen.getByRole('button', { name: /increment/i });\n    fireEvent.click(button);\n    \n    // Assert\n    expect(screen.getByText('Count: 1')).toBeInTheDocument();\n  });\n});\n\n// Testing async operations\nimport { waitFor } from '@testing-library/react';\n\nit('loads and displays data', async () => {\n  render(<UserProfile userId={1} />);\n  \n  // Wait for loading to finish\n  await waitFor(() => {\n    expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();\n  });\n  \n  // Assert data displayed\n  expect(screen.getByText('John Doe')).toBeInTheDocument();\n});\n\n// Mocking API calls with MSW\nimport { rest } from 'msw';\nimport { setupServer } from 'msw/node';\n\nconst server = setupServer(\n  rest.get('/api/users/:id', (req, res, ctx) => {\n    return res(\n      ctx.json({\n        id: 1,\n        name: 'John Doe',\n        email: 'john@example.com'\n      })\n    );\n  })\n);\n\nbeforeAll(() => server.listen());\nafterEach(() => server.resetHandlers());\nafterAll(() => server.close());\n\nit('displays user data from API', async () => {\n  render(<UserProfile userId={1} />);\n  \n  expect(await screen.findByText('John Doe')).toBeInTheDocument();\n});\n\n// Testing form submission\nimport userEvent from '@testing-library/user-event';\n\nit('submits form with correct data', async () => {\n  const onSubmit = jest.fn();\n  const user = userEvent.setup();\n  \n  render(<LoginForm onSubmit={onSubmit} />);\n  \n  // Fill form\n  await user.type(screen.getByLabelText(/username/i), 'testuser');\n  await user.type(screen.getByLabelText(/password/i), 'password123');\n  \n  // Submit\n  await user.click(screen.getByRole('button', { name: /login/i }));\n  \n  // Assert\n  expect(onSubmit).toHaveBeenCalledWith({\n    username: 'testuser',\n    password: 'password123'\n  });\n});\n\n// Testing hooks\nimport { renderHook, act } from '@testing-library/react';\nimport { useCounter } from './useCounter';\n\nit('increments counter', () => {\n  const { result } = renderHook(() => useCounter());\n  \n  act(() => {\n    result.current.increment();\n  });\n  \n  expect(result.current.count).toBe(1);\n});\n\n// Accessibility testing\nimport { axe, toHaveNoViolations } from 'jest-axe';\nexpect.extend(toHaveNoViolations);\n\nit('has no accessibility violations', async () => {\n  const { container } = render(<Form />);\n  const results = await axe(container);\n  \n  expect(results).toHaveNoViolations();\n});\n\n// Snapshot testing\nit('matches snapshot', () => {\n  const { container } = render(<Button>Click me</Button>);\n  expect(container).toMatchSnapshot();\n});\n\n// Testing with providers\nimport { BrowserRouter } from 'react-router-dom';\nimport { QueryClient, QueryClientProvider } from 'react-query';\n\nfunction renderWithProviders(ui) {\n  const queryClient = new QueryClient();\n  \n  return render(\n    <QueryClientProvider client={queryClient}>\n      <BrowserRouter>\n        {ui}\n      </BrowserRouter>\n    </QueryClientProvider>\n  );\n}\n\nit('renders with all providers', () => {\n  renderWithProviders(<App />);\n  expect(screen.getByText(/home/i)).toBeInTheDocument();\n});"
    },
    {
      "id": 99,
      "question": "What are the best practices for React performance monitoring and optimization?",
      "answer": "Performance monitoring identifies bottlenecks and guides optimization efforts for faster, more responsive applications.\n\nMonitoring Tools:\n• React DevTools Profiler: Component render times\n• Chrome DevTools: Performance profiling\n• Lighthouse: Overall performance metrics\n• Web Vitals: Core web vitals tracking\n• Custom Metrics: Application-specific tracking\n\nKey Metrics:\n• First Contentful Paint (FCP): First content rendered\n• Largest Contentful Paint (LCP): Main content rendered\n• Time to Interactive (TTI): Page fully interactive\n• Cumulative Layout Shift (CLS): Visual stability\n• First Input Delay (FID): Input responsiveness\n\nOptimization Techniques:\n• Code Splitting: Reduce initial bundle\n• Lazy Loading: Load on demand\n• Memoization: Prevent unnecessary renders\n• Virtual Lists: Render visible items only\n• Image Optimization: Compress and lazy load\n• Bundle Analysis: Identify large dependencies\n\nMonitoring Strategy:\n• Set Baselines: Know current performance\n• Continuous Monitoring: Track over time\n• User Monitoring: Real user metrics\n• Alert Thresholds: Get notified of regressions",
      "explanation": "React performance monitoring uses DevTools Profiler, Chrome DevTools, and Web Vitals to track metrics like LCP and FID, guiding optimizations like code splitting, memoization, and lazy loading.",
      "difficulty": "Hard",
      "code": "// Web Vitals monitoring\nimport { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';\n\nfunction sendToAnalytics(metric) {\n  // Send to analytics service\n  console.log(metric);\n  // analytics.track('web-vital', metric);\n}\n\ngetCLS(sendToAnalytics);\ngetFID(sendToAnalytics);\ngetFCP(sendToAnalytics);\ngetLCP(sendToAnalytics);\ngetTTFB(sendToAnalytics);\n\n// Custom performance monitoring\nimport { useEffect } from 'react';\n\nfunction usePerformanceMonitor(componentName) {\n  useEffect(() => {\n    const startTime = performance.now();\n    \n    return () => {\n      const endTime = performance.now();\n      const renderTime = endTime - startTime;\n      \n      if (renderTime > 16) { // > 1 frame at 60fps\n        console.warn(`${componentName} slow render:`, renderTime, 'ms');\n        // Send to monitoring service\n      }\n    };\n  });\n}\n\nfunction Component() {\n  usePerformanceMonitor('Component');\n  return <div>Component</div>;\n}\n\n// React Profiler API\nimport { Profiler } from 'react';\n\nfunction onRenderCallback(\n  id,\n  phase,\n  actualDuration,\n  baseDuration,\n  startTime,\n  commitTime\n) {\n  // Send metrics to analytics\n  if (actualDuration > 16) {\n    console.warn(`Slow render in ${id}:`, actualDuration, 'ms');\n  }\n  \n  // Track with analytics\n  // analytics.track('component-render', {\n  //   component: id,\n  //   duration: actualDuration,\n  //   phase\n  // });\n}\n\nfunction App() {\n  return (\n    <Profiler id=\"App\" onRender={onRenderCallback}>\n      <MainContent />\n    </Profiler>\n  );\n}\n\n// Performance marks and measures\nfunction ComponentWithMarks() {\n  useEffect(() => {\n    performance.mark('component-render-start');\n    \n    return () => {\n      performance.mark('component-render-end');\n      performance.measure(\n        'component-render',\n        'component-render-start',\n        'component-render-end'\n      );\n      \n      const measures = performance.getEntriesByName('component-render');\n      console.log('Render time:', measures[0].duration);\n    };\n  });\n  \n  return <div>Component</div>;\n}\n\n// Bundle size monitoring\n// webpack.config.js\nconst { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');\n\nmodule.exports = {\n  plugins: [\n    new BundleAnalyzerPlugin({\n      analyzerMode: 'static',\n      reportFilename: 'bundle-report.html'\n    })\n  ]\n};\n\n// Runtime performance monitoring\nclass PerformanceMonitor {\n  constructor() {\n    this.metrics = [];\n  }\n  \n  recordMetric(name, value) {\n    this.metrics.push({\n      name,\n      value,\n      timestamp: Date.now()\n    });\n  }\n  \n  getMetrics() {\n    return this.metrics;\n  }\n  \n  sendToServer() {\n    // Batch send metrics to server\n    fetch('/api/metrics', {\n      method: 'POST',\n      body: JSON.stringify(this.metrics)\n    });\n  }\n}\n\nconst monitor = new PerformanceMonitor();\n\n// Track component renders\nfunction TrackedComponent() {\n  useEffect(() => {\n    monitor.recordMetric('component-mount', performance.now());\n    \n    return () => {\n      monitor.recordMetric('component-unmount', performance.now());\n    };\n  }, []);\n  \n  return <div>Component</div>;\n}\n\n// Automated performance testing\n// jest.config.js\nmodule.exports = {\n  setupFilesAfterEnv: ['<rootDir>/setupTests.js']\n};\n\n// setupTests.js\nconst RENDER_TIME_THRESHOLD = 100; // ms\n\nafterEach(() => {\n  const entries = performance.getEntriesByType('measure');\n  entries.forEach(entry => {\n    if (entry.duration > RENDER_TIME_THRESHOLD) {\n      console.warn(`Performance issue: ${entry.name} took ${entry.duration}ms`);\n    }\n  });\n});"
    },
    {
      "id": 100,
      "question": "What are the essential React patterns and anti-patterns to know?",
      "answer": "Understanding React patterns and anti-patterns helps write maintainable, performant, and idiomatic React code.\n\nGood Patterns:\n• Composition: Compose components instead of inheritance\n• Render Props: Share logic through render prop\n• Custom Hooks: Extract and reuse stateful logic\n• Compound Components: Components that work together\n• Provider Pattern: Share data with Context\n• HOCs: Enhance components with additional functionality\n• Container/Presentational: Separate logic from UI\n\nAnti-Patterns to Avoid:\n• Props Drilling: Passing props through many levels\n• Prop Spreading Blindly: Spreading all props without care\n• Index as Key: Using array index as key\n• Side Effects in Render: State updates during render\n• Mutating State: Directly modifying state object\n• Missing Dependencies: Omitting useEffect dependencies\n• Inline Function Props: Creating new functions each render\n• Premature Optimization: Memoizing everything\n\nBest Practices:\n• Keep Components Small: Single responsibility\n• Use TypeScript: Type safety\n• Write Tests: Test critical functionality\n• Accessibility: Build inclusive UIs\n• Performance: Optimize when needed",
      "explanation": "Essential React patterns include composition, custom hooks, and compound components for reusable logic, while anti-patterns like prop drilling, index keys, and missing dependencies should be avoided for maintainable code.",
      "difficulty": "Hard",
      "code": "// GOOD PATTERNS\n\n// 1. Composition over Inheritance\n// Good: Composition\nfunction Button({ variant, icon, children }) {\n  return (\n    <button className={variant}>\n      {icon && <Icon name={icon} />}\n      {children}\n    </button>\n  );\n}\n\n// Bad: Inheritance (don't do this)\nclass IconButton extends Button {\n  render() {\n    return <Button icon={this.props.icon}>{this.props.children}</Button>;\n  }\n}\n\n// 2. Custom Hooks\n// Good: Extract logic into custom hook\nfunction useForm(initialValues) {\n  const [values, setValues] = useState(initialValues);\n  \n  const handleChange = (e) => {\n    setValues({ ...values, [e.target.name]: e.target.value });\n  };\n  \n  return { values, handleChange };\n}\n\n// 3. Compound Components\nconst Tabs = ({ children }) => {\n  const [activeTab, setActiveTab] = useState(0);\n  return (\n    <TabsContext.Provider value={{ activeTab, setActiveTab }}>\n      {children}\n    </TabsContext.Provider>\n  );\n};\n\nTabs.List = TabList;\nTabs.Tab = Tab;\nTabs.Panel = TabPanel;\n\n// Usage\n<Tabs>\n  <Tabs.List>\n    <Tabs.Tab>Tab 1</Tabs.Tab>\n  </Tabs.List>\n  <Tabs.Panel>Panel 1</Tabs.Panel>\n</Tabs>\n\n// ANTI-PATTERNS\n\n// 1. Props Drilling (Bad)\nfunction App() {\n  const user = { name: 'John' };\n  return <Level1 user={user} />;\n}\n\nfunction Level1({ user }) {\n  return <Level2 user={user} />;\n}\n\nfunction Level2({ user }) {\n  return <Level3 user={user} />;\n}\n\n// Better: Use Context\nconst UserContext = createContext();\n\nfunction App() {\n  const user = { name: 'John' };\n  return (\n    <UserContext.Provider value={user}>\n      <Level1 />\n    </UserContext.Provider>\n  );\n}\n\nfunction Level3() {\n  const user = useContext(UserContext);\n  return <div>{user.name}</div>;\n}\n\n// 2. Index as Key (Bad)\nfunction List({ items }) {\n  return items.map((item, index) => (\n    <div key={index}>{item.text}</div> // ❌ Bad\n  ));\n}\n\n// Good: Use unique ID\nfunction List({ items }) {\n  return items.map(item => (\n    <div key={item.id}>{item.text}</div> // ✅ Good\n  ));\n}\n\n// 3. Side Effects in Render (Bad)\nfunction BadComponent() {\n  const [count, setCount] = useState(0);\n  \n  // ❌ Don't do this\n  setCount(count + 1);\n  \n  return <div>{count}</div>;\n}\n\n// Good: Use useEffect\nfunction GoodComponent() {\n  const [count, setCount] = useState(0);\n  \n  useEffect(() => {\n    // ✅ Side effects in useEffect\n    setCount(count + 1);\n  }, []);\n  \n  return <div>{count}</div>;\n}\n\n// 4. Mutating State (Bad)\nfunction BadUpdate() {\n  const [user, setUser] = useState({ name: 'John' });\n  \n  const updateName = () => {\n    user.name = 'Jane'; // ❌ Mutation\n    setUser(user);\n  };\n}\n\n// Good: Create new object\nfunction GoodUpdate() {\n  const [user, setUser] = useState({ name: 'John' });\n  \n  const updateName = () => {\n    setUser({ ...user, name: 'Jane' }); // ✅ New object\n  };\n}\n\n// 5. Missing Dependencies (Bad)\nfunction BadEffect() {\n  const [count, setCount] = useState(0);\n  \n  useEffect(() => {\n    console.log(count);\n  }, []); // ❌ Missing count dependency\n}\n\n// Good: Include all dependencies\nfunction GoodEffect() {\n  const [count, setCount] = useState(0);\n  \n  useEffect(() => {\n    console.log(count);\n  }, [count]); // ✅ All dependencies\n}\n\n// 6. Premature Optimization (Bad)\nfunction OverOptimized() {\n  // ❌ Unnecessary memoization\n  const value = useMemo(() => 5 + 5, []);\n  const handleClick = useCallback(() => {}, []);\n  \n  // Just do this:\n  // const value = 10;\n  // const handleClick = () => {};\n}\n\n// Summary: Write clean, maintainable code first,\n// optimize only when you have performance issues!"
    }
  ]
}
