{
  "topic": "REST API",
  "questions": [
    {
      "id": 1,
      "question": "What is REST and what are its principles?",
      "answer": "REST (Representational State Transfer) is an architectural style for web services.\n\nPrinciples:\n1. Client-Server: Separation of concerns\n2. Stateless: No client context stored on server\n3. Cacheable: Responses can be cached\n4. Uniform Interface: Standardized API\n5. Layered System: Multiple layers possible\n6. Code on Demand (optional): Server can send executable code",
      "explanation": "REST is not a protocol - it's architectural constraints. APIs following these principles are called RESTful.",
      "difficulty": "Easy"
    },
    {
      "id": 2,
      "question": "What are the main HTTP methods and their purposes?",
      "answer": "GET:\n• Retrieve resource(s)\n• Safe, idempotent, cacheable\n• No request body\n\nPOST:\n• Create new resource\n• Not idempotent\n• Has request body\n\nPUT:\n• Replace entire resource\n• Idempotent\n• Has request body\n\nPATCH:\n• Partial update\n• Not idempotent\n• Has request body\n\nDELETE:\n• Remove resource\n• Idempotent\n• Usually no body",
      "explanation": "Safe = no side effects. Idempotent = same result for repeated calls. GET is both safe and idempotent.",
      "difficulty": "Easy",
      "code": "// GET - Retrieve resources\nGET /api/users           // List all users\nGET /api/users/123       // Get specific user\nGET /api/users?status=active  // Query parameters\n\n// POST - Create resource\nPOST /api/users\nContent-Type: application/json\n{\n  \"name\": \"John\",\n  \"email\": \"john@test.com\"\n}\n// Returns: 201 Created with Location header\n\n// PUT - Replace entire resource\nPUT /api/users/123\nContent-Type: application/json\n{\n  \"name\": \"John Updated\",\n  \"email\": \"john@test.com\",\n  \"status\": \"active\"\n}\n// Must include all fields\n\n// PATCH - Partial update\nPATCH /api/users/123\nContent-Type: application/json\n{\n  \"status\": \"inactive\"\n}\n// Only update specified fields\n\n// DELETE - Remove resource\nDELETE /api/users/123\n// Returns: 204 No Content\n\n// HEAD - Like GET but no body (check existence)\nHEAD /api/users/123\n\n// OPTIONS - Get allowed methods\nOPTIONS /api/users"
    },
    {
      "id": 3,
      "question": "What are the common HTTP status codes?",
      "answer": "2xx Success:\n• 200 OK - Request succeeded\n• 201 Created - Resource created\n• 204 No Content - Success, no body\n\n3xx Redirection:\n• 301 Moved Permanently\n• 304 Not Modified (cache)\n\n4xx Client Errors:\n• 400 Bad Request - Invalid syntax\n• 401 Unauthorized - Authentication required\n• 403 Forbidden - No permission\n• 404 Not Found\n• 422 Unprocessable Entity - Validation failed\n\n5xx Server Errors:\n• 500 Internal Server Error\n• 502 Bad Gateway\n• 503 Service Unavailable",
      "explanation": "Use appropriate status codes - they're part of the API contract. 4xx means client's fault, 5xx means server's fault.",
      "difficulty": "Easy",
      "code": "// 200 OK - Successful GET/PUT/PATCH\nGET /api/users/123\nResponse: 200 OK\n{ \"id\": 123, \"name\": \"John\" }\n\n// 201 Created - Successful POST\nPOST /api/users\nResponse: 201 Created\nLocation: /api/users/124\n{ \"id\": 124, \"name\": \"Jane\" }\n\n// 204 No Content - Successful DELETE\nDELETE /api/users/123\nResponse: 204 No Content\n(no body)\n\n// 400 Bad Request - Malformed request\n{ \"error\": \"Invalid JSON syntax\" }\n\n// 401 Unauthorized - Need to authenticate\n{ \"error\": \"Authentication required\" }\n\n// 403 Forbidden - Authenticated but not allowed\n{ \"error\": \"You don't have permission to access this resource\" }\n\n// 404 Not Found\n{ \"error\": \"User not found\" }\n\n// 422 Unprocessable Entity - Validation errors\n{\n  \"error\": \"Validation failed\",\n  \"details\": [\n    { \"field\": \"email\", \"message\": \"Invalid email format\" },\n    { \"field\": \"age\", \"message\": \"Must be at least 18\" }\n  ]\n}\n\n// 500 Internal Server Error\n{ \"error\": \"Something went wrong\" }"
    },
    {
      "id": 4,
      "question": "What is the difference between PUT and PATCH?",
      "answer": "PUT:\n• Replace entire resource\n• Idempotent\n• Send complete representation\n• Missing fields = deleted/null\n• Creates if doesn't exist (sometimes)\n\nPATCH:\n• Partial update\n• Not guaranteed idempotent\n• Send only changed fields\n• Missing fields = unchanged\n• Smaller payload",
      "explanation": "PUT is 'replace', PATCH is 'update'. Use PATCH for partial updates to avoid sending entire resource.",
      "difficulty": "Medium",
      "code": "// Original resource\n{\n  \"id\": 1,\n  \"name\": \"John\",\n  \"email\": \"john@test.com\",\n  \"status\": \"active\",\n  \"role\": \"user\"\n}\n\n// PUT - Must send complete resource\nPUT /api/users/1\n{\n  \"name\": \"John Updated\",\n  \"email\": \"john@test.com\",\n  \"status\": \"active\",\n  \"role\": \"admin\"  // Changed this\n}\n// If you omit 'role', it might become null!\n\n// PATCH - Send only what changed\nPATCH /api/users/1\n{\n  \"role\": \"admin\"\n}\n// Other fields remain unchanged\n\n// JSON Patch format (RFC 6902)\nPATCH /api/users/1\nContent-Type: application/json-patch+json\n[\n  { \"op\": \"replace\", \"path\": \"/role\", \"value\": \"admin\" },\n  { \"op\": \"add\", \"path\": \"/department\", \"value\": \"IT\" },\n  { \"op\": \"remove\", \"path\": \"/tempField\" }\n]\n\n// When to use which:\n// PUT: Replacing configuration, form submissions\n// PATCH: Updating status, changing single field"
    },
    {
      "id": 5,
      "question": "How do you design RESTful URL structures?",
      "answer": "Best practices:\n\n1. Use nouns, not verbs\n2. Use plural names for collections\n3. Use hierarchical structure for relationships\n4. Use lowercase with hyphens\n5. Don't include file extensions\n6. Use query params for filtering/sorting\n7. Version your API\n\nAnti-patterns:\n• /getUsers, /createUser (verbs)\n• /user/1 (singular for collection)\n• /users/1/getOrders (verb in path)",
      "explanation": "Good URL design makes API intuitive. Resources are nouns, HTTP methods are verbs. URLs should be predictable.",
      "difficulty": "Medium",
      "code": "// Good URL design\n\n// Collections\nGET    /api/v1/users                    // List users\nPOST   /api/v1/users                    // Create user\nGET    /api/v1/users/123                // Get user\nPUT    /api/v1/users/123                // Update user\nDELETE /api/v1/users/123                // Delete user\n\n// Nested resources\nGET    /api/v1/users/123/orders         // User's orders\nPOST   /api/v1/users/123/orders         // Create order for user\nGET    /api/v1/users/123/orders/456     // Specific order\n\n// Query parameters for filtering/sorting/pagination\nGET /api/v1/products?category=electronics\nGET /api/v1/products?sort=price&order=desc\nGET /api/v1/products?page=2&limit=20\nGET /api/v1/products?minPrice=100&maxPrice=500\n\n// Search\nGET /api/v1/products?search=laptop\nGET /api/v1/users?q=john@\n\n// Versioning options\n/api/v1/users              // URL versioning (common)\n/api/users (Header: API-Version: 1)  // Header versioning\n/api/users (Accept: application/vnd.myapi.v1+json)  // Media type\n\n// Bad examples (avoid)\n// GET /api/getUsers         // Verb in URL\n// POST /api/users/create    // Redundant verb\n// GET /api/user             // Singular for collection\n// GET /api/Users            // Uppercase\n// GET /api/users/123.json   // Extension"
    },
    {
      "id": 6,
      "question": "What is HATEOAS in REST?",
      "answer": "HATEOAS (Hypermedia as the Engine of Application State):\n\nResponses include links to related resources and possible actions.\n\nBenefits:\n• Self-documenting API\n• Client discovers actions dynamically\n• Decouples client from URL structure\n• API can evolve without breaking clients\n\nLevel 3 of Richardson Maturity Model.",
      "explanation": "HATEOAS is the highest REST maturity level. Links guide clients to next possible actions. Not always necessary but powerful.",
      "difficulty": "Medium",
      "code": "// Without HATEOAS\n{\n  \"id\": 123,\n  \"name\": \"John\",\n  \"email\": \"john@test.com\",\n  \"status\": \"active\"\n}\n// Client must know URL structure\n\n// With HATEOAS\n{\n  \"id\": 123,\n  \"name\": \"John\",\n  \"email\": \"john@test.com\",\n  \"status\": \"active\",\n  \"_links\": {\n    \"self\": { \"href\": \"/api/users/123\" },\n    \"orders\": { \"href\": \"/api/users/123/orders\" },\n    \"update\": { \"href\": \"/api/users/123\", \"method\": \"PUT\" },\n    \"delete\": { \"href\": \"/api/users/123\", \"method\": \"DELETE\" },\n    \"deactivate\": { \"href\": \"/api/users/123/deactivate\", \"method\": \"POST\" }\n  }\n}\n\n// Collection with pagination links\n{\n  \"data\": [...],\n  \"_links\": {\n    \"self\": { \"href\": \"/api/users?page=2\" },\n    \"first\": { \"href\": \"/api/users?page=1\" },\n    \"prev\": { \"href\": \"/api/users?page=1\" },\n    \"next\": { \"href\": \"/api/users?page=3\" },\n    \"last\": { \"href\": \"/api/users?page=10\" }\n  },\n  \"meta\": {\n    \"total\": 195,\n    \"page\": 2,\n    \"perPage\": 20\n  }\n}\n\n// Conditional links based on state\n{\n  \"id\": 456,\n  \"status\": \"draft\",\n  \"_links\": {\n    \"self\": { \"href\": \"/api/articles/456\" },\n    \"edit\": { \"href\": \"/api/articles/456\" },\n    \"publish\": { \"href\": \"/api/articles/456/publish\" }  // Only for drafts\n  }\n}"
    },
    {
      "id": 7,
      "question": "What is API versioning and what are the strategies?",
      "answer": "API versioning manages breaking changes over time.\n\nStrategies:\n\n1. URL Path Versioning:\n   /api/v1/users\n   Most common, clear, cacheable\n\n2. Query Parameter:\n   /api/users?version=1\n   Optional versioning\n\n3. Header Versioning:\n   X-API-Version: 1\n   Clean URLs, harder to test\n\n4. Media Type (Content Negotiation):\n   Accept: application/vnd.api.v1+json\n   RESTful, complex",
      "explanation": "URL versioning is most practical. Always version from the start. Support old versions for transition period.",
      "difficulty": "Medium",
      "code": "// 1. URL Path Versioning (most common)\nGET /api/v1/users\nGET /api/v2/users\n\n// In Spring Boot\n@RestController\n@RequestMapping(\"/api/v1/users\")\npublic class UserControllerV1 { }\n\n@RestController\n@RequestMapping(\"/api/v2/users\")\npublic class UserControllerV2 { }\n\n// 2. Query Parameter\nGET /api/users?version=1\nGET /api/users?v=2\n\n// 3. Header Versioning\nGET /api/users\nX-API-Version: 1\nAccept-Version: v2\n\n// In Spring Boot with header\n@GetMapping(value = \"/users\", headers = \"X-API-Version=1\")\npublic List<UserV1> getUsersV1() { }\n\n@GetMapping(value = \"/users\", headers = \"X-API-Version=2\")\npublic List<UserV2> getUsersV2() { }\n\n// 4. Media Type / Content Negotiation\nGET /api/users\nAccept: application/vnd.myapi.v1+json\nAccept: application/vnd.myapi.v2+json\n\n// In Spring Boot\n@GetMapping(value = \"/users\", produces = \"application/vnd.myapi.v1+json\")\npublic List<UserV1> getUsersV1() { }\n\n// Deprecation headers\nHTTP/1.1 200 OK\nDeprecation: true\nSunset: Sat, 31 Dec 2024 23:59:59 GMT\nLink: </api/v2/users>; rel=\"successor-version\""
    },
    {
      "id": 8,
      "question": "What is the difference between Authentication and Authorization?",
      "answer": "Authentication (AuthN):\n• WHO are you?\n• Verifies identity\n• Examples: Login, JWT, OAuth\n• Answers: \"Is this user who they claim to be?\"\n\nAuthorization (AuthZ):\n• WHAT can you do?\n• Verifies permissions\n• Examples: Roles, permissions, ACL\n• Answers: \"Is this user allowed to do this?\"\n\n401 Unauthorized = Authentication failed\n403 Forbidden = Authorization failed",
      "explanation": "Authentication comes first (verify identity), then authorization (check permissions). Both are needed for secure APIs.",
      "difficulty": "Easy",
      "code": "// Authentication flow\n// 1. User provides credentials\nPOST /api/auth/login\n{\n  \"email\": \"john@test.com\",\n  \"password\": \"secret123\"\n}\n\n// 2. Server verifies and returns token\n{\n  \"access_token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\",\n  \"token_type\": \"Bearer\",\n  \"expires_in\": 3600\n}\n\n// 3. Client sends token with requests\nGET /api/users\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\n\n// Authorization flow\n// After authentication, check permissions\n\n// Role-based (RBAC)\n@PreAuthorize(\"hasRole('ADMIN')\")\n@DeleteMapping(\"/users/{id}\")\npublic void deleteUser(@PathVariable Long id) { }\n\n// Permission-based\n@PreAuthorize(\"hasPermission(#id, 'User', 'delete')\")\n@DeleteMapping(\"/users/{id}\")\npublic void deleteUser(@PathVariable Long id) { }\n\n// Response examples\n// 401 - Not authenticated\n{\n  \"error\": \"Unauthorized\",\n  \"message\": \"Invalid or expired token\"\n}\n\n// 403 - Authenticated but not allowed\n{\n  \"error\": \"Forbidden\",\n  \"message\": \"You don't have permission to delete users\"\n}"
    },
    {
      "id": 9,
      "question": "What is JWT and how does it work?",
      "answer": "JWT (JSON Web Token) is a compact, self-contained token for authentication.\n\nStructure (3 parts, dot-separated):\n1. Header: Algorithm, type\n2. Payload: Claims (data)\n3. Signature: Verification\n\nBenefits:\n• Stateless (no server session)\n• Self-contained (carries user info)\n• Cross-domain compatible\n• Scalable (works with microservices)\n\nClaims: iss, sub, exp, iat, custom data",
      "explanation": "JWT allows stateless authentication. Server doesn't store sessions - token contains all needed info. Verify signature to trust content.",
      "difficulty": "Medium",
      "code": "// JWT Structure\n// Header.Payload.Signature\n// eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\n// eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.\n// SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n\n// Header (Base64 decoded)\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n\n// Payload (Base64 decoded)\n{\n  \"sub\": \"1234567890\",      // Subject (user ID)\n  \"name\": \"John Doe\",        // Custom claim\n  \"email\": \"john@test.com\",  // Custom claim\n  \"role\": \"admin\",           // Custom claim\n  \"iat\": 1516239022,         // Issued at\n  \"exp\": 1516242622          // Expiration\n}\n\n// Java - Creating JWT\n@Service\npublic class JwtService {\n    private final String SECRET = \"your-secret-key\";\n    \n    public String generateToken(User user) {\n        return Jwts.builder()\n            .setSubject(user.getId().toString())\n            .claim(\"email\", user.getEmail())\n            .claim(\"role\", user.getRole())\n            .setIssuedAt(new Date())\n            .setExpiration(new Date(System.currentTimeMillis() + 3600000))\n            .signWith(SignatureAlgorithm.HS256, SECRET)\n            .compact();\n    }\n    \n    public Claims validateToken(String token) {\n        return Jwts.parser()\n            .setSigningKey(SECRET)\n            .parseClaimsJws(token)\n            .getBody();\n    }\n}\n\n// Usage in request\nGET /api/protected\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIs..."
    },
    {
      "id": 10,
      "question": "What is OAuth 2.0 and what are its grant types?",
      "answer": "OAuth 2.0 is an authorization framework for third-party access.\n\nRoles:\n• Resource Owner: User\n• Client: Application\n• Authorization Server: Issues tokens\n• Resource Server: API with protected resources\n\nGrant Types:\n1. Authorization Code: Web apps (most secure)\n2. PKCE: Mobile/SPA (enhanced auth code)\n3. Client Credentials: Machine-to-machine\n4. Password (deprecated): Direct credentials\n5. Refresh Token: Get new access token",
      "explanation": "OAuth lets users grant limited access without sharing credentials. 'Login with Google' uses OAuth. Choose grant type based on app type.",
      "difficulty": "Hard",
      "code": "// Authorization Code Flow (Web Apps)\n\n// 1. Redirect user to authorization server\nGET https://auth.example.com/authorize?\n  response_type=code&\n  client_id=YOUR_CLIENT_ID&\n  redirect_uri=https://yourapp.com/callback&\n  scope=read write&\n  state=random_state_string\n\n// 2. User logs in, approves, redirected back\nGET https://yourapp.com/callback?\n  code=AUTHORIZATION_CODE&\n  state=random_state_string\n\n// 3. Exchange code for token (server-side)\nPOST https://auth.example.com/token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=authorization_code&\ncode=AUTHORIZATION_CODE&\nredirect_uri=https://yourapp.com/callback&\nclient_id=YOUR_CLIENT_ID&\nclient_secret=YOUR_CLIENT_SECRET\n\n// 4. Response with tokens\n{\n  \"access_token\": \"eyJhbGc...\",\n  \"token_type\": \"Bearer\",\n  \"expires_in\": 3600,\n  \"refresh_token\": \"dGhpcyBpcyBhIHJlZnJlc2ggdG9rZW4\",\n  \"scope\": \"read write\"\n}\n\n// Client Credentials (Machine-to-Machine)\nPOST https://auth.example.com/token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=client_credentials&\nclient_id=YOUR_CLIENT_ID&\nclient_secret=YOUR_CLIENT_SECRET&\nscope=api.read\n\n// Refresh Token\nPOST https://auth.example.com/token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=refresh_token&\nrefresh_token=dGhpcyBpcyBhIHJlZnJlc2ggdG9rZW4&\nclient_id=YOUR_CLIENT_ID"
    },
    {
      "id": 11,
      "question": "What is CORS and how do you handle it?",
      "answer": "CORS (Cross-Origin Resource Sharing) controls cross-domain requests.\n\nSame-origin policy blocks requests to different domains by default.\n\nCORS headers:\n• Access-Control-Allow-Origin: Allowed origins\n• Access-Control-Allow-Methods: Allowed HTTP methods\n• Access-Control-Allow-Headers: Allowed request headers\n• Access-Control-Allow-Credentials: Allow cookies\n• Access-Control-Max-Age: Preflight cache time\n\nPreflight: OPTIONS request before actual request.",
      "explanation": "CORS is browser security. Configure on server to allow specific origins. Never use * with credentials.",
      "difficulty": "Medium",
      "code": "// Simple request (no preflight)\nGET /api/data\nOrigin: https://frontend.com\n\n// Response headers\nAccess-Control-Allow-Origin: https://frontend.com\n\n// Preflight request (for PUT, DELETE, custom headers)\nOPTIONS /api/users\nOrigin: https://frontend.com\nAccess-Control-Request-Method: PUT\nAccess-Control-Request-Headers: Content-Type, Authorization\n\n// Preflight response\nHTTP/1.1 204 No Content\nAccess-Control-Allow-Origin: https://frontend.com\nAccess-Control-Allow-Methods: GET, POST, PUT, DELETE\nAccess-Control-Allow-Headers: Content-Type, Authorization\nAccess-Control-Max-Age: 86400\n\n// Spring Boot configuration\n@Configuration\npublic class CorsConfig implements WebMvcConfigurer {\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(\"/api/**\")\n            .allowedOrigins(\"https://frontend.com\")\n            .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\")\n            .allowedHeaders(\"*\")\n            .allowCredentials(true)\n            .maxAge(3600);\n    }\n}\n\n// Per-controller\n@CrossOrigin(origins = \"https://frontend.com\")\n@RestController\npublic class UserController { }\n\n// Per-method\n@CrossOrigin(origins = \"*\")\n@GetMapping(\"/public\")\npublic String publicEndpoint() { }"
    },
    {
      "id": 12,
      "question": "What is Rate Limiting and how do you implement it?",
      "answer": "Rate limiting controls request frequency to prevent abuse.\n\nStrategies:\n• Fixed Window: X requests per time window\n• Sliding Window: More accurate, smoother\n• Token Bucket: Allows bursts, refills over time\n• Leaky Bucket: Constant output rate\n\nImplementation:\n• Track requests per client (IP, API key, user)\n• Return 429 Too Many Requests when exceeded\n• Include rate limit headers",
      "explanation": "Rate limiting protects APIs from abuse, DDoS, and ensures fair usage. Apply different limits per tier/plan.",
      "difficulty": "Medium",
      "code": "// Rate limit headers\nHTTP/1.1 200 OK\nX-RateLimit-Limit: 100        // Max requests\nX-RateLimit-Remaining: 95      // Remaining\nX-RateLimit-Reset: 1609459200  // Window reset (epoch)\n\n// When exceeded\nHTTP/1.1 429 Too Many Requests\nRetry-After: 60\n{\n  \"error\": \"Rate limit exceeded\",\n  \"message\": \"Too many requests. Please try again in 60 seconds.\"\n}\n\n// Spring Boot with Bucket4j\n@Configuration\npublic class RateLimitConfig {\n    @Bean\n    public Bucket createBucket() {\n        Bandwidth limit = Bandwidth.classic(100, Refill.intervally(100, Duration.ofMinutes(1)));\n        return Bucket.builder().addLimit(limit).build();\n    }\n}\n\n@RestController\npublic class ApiController {\n    @Autowired\n    private Bucket bucket;\n    \n    @GetMapping(\"/api/data\")\n    public ResponseEntity<?> getData() {\n        if (bucket.tryConsume(1)) {\n            return ResponseEntity.ok(data);\n        }\n        return ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS)\n            .header(\"Retry-After\", \"60\")\n            .body(\"Rate limit exceeded\");\n    }\n}\n\n// Redis-based rate limiting\n@Component\npublic class RateLimiter {\n    @Autowired\n    private StringRedisTemplate redis;\n    \n    public boolean isAllowed(String key, int limit, int windowSeconds) {\n        String redisKey = \"rate:\" + key;\n        Long current = redis.opsForValue().increment(redisKey);\n        \n        if (current == 1) {\n            redis.expire(redisKey, windowSeconds, TimeUnit.SECONDS);\n        }\n        \n        return current <= limit;\n    }\n}"
    },
    {
      "id": 13,
      "question": "How do you handle errors in REST APIs?",
      "answer": "Best practices:\n\n1. Use appropriate HTTP status codes\n2. Consistent error response format\n3. Include error code for programmatic handling\n4. Human-readable message\n5. Field-level validation errors\n6. Don't expose sensitive info in production\n7. Include request ID for debugging\n8. Log errors server-side",
      "explanation": "Good error handling improves developer experience. Consistent format helps clients handle errors predictably.",
      "difficulty": "Medium",
      "code": "// Error response format\n{\n  \"status\": 400,\n  \"error\": \"Bad Request\",\n  \"code\": \"VALIDATION_ERROR\",\n  \"message\": \"Validation failed for request\",\n  \"timestamp\": \"2024-01-15T10:30:00Z\",\n  \"path\": \"/api/users\",\n  \"requestId\": \"abc123\",\n  \"details\": [\n    {\n      \"field\": \"email\",\n      \"message\": \"Invalid email format\",\n      \"rejectedValue\": \"invalid-email\"\n    },\n    {\n      \"field\": \"age\",\n      \"message\": \"Must be at least 18\",\n      \"rejectedValue\": 16\n    }\n  ]\n}\n\n// Spring Boot Global Exception Handler\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n\n    @ExceptionHandler(ResourceNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleNotFound(ResourceNotFoundException ex) {\n        ErrorResponse error = ErrorResponse.builder()\n            .status(404)\n            .error(\"Not Found\")\n            .code(\"RESOURCE_NOT_FOUND\")\n            .message(ex.getMessage())\n            .build();\n        return ResponseEntity.status(404).body(error);\n    }\n\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity<ErrorResponse> handleValidation(MethodArgumentNotValidException ex) {\n        List<FieldError> details = ex.getBindingResult().getFieldErrors().stream()\n            .map(e -> new FieldError(e.getField(), e.getDefaultMessage(), e.getRejectedValue()))\n            .collect(Collectors.toList());\n        \n        ErrorResponse error = ErrorResponse.builder()\n            .status(400)\n            .error(\"Bad Request\")\n            .code(\"VALIDATION_ERROR\")\n            .message(\"Validation failed\")\n            .details(details)\n            .build();\n        return ResponseEntity.badRequest().body(error);\n    }\n\n    @ExceptionHandler(Exception.class)\n    public ResponseEntity<ErrorResponse> handleGeneral(Exception ex) {\n        log.error(\"Unexpected error\", ex);\n        ErrorResponse error = ErrorResponse.builder()\n            .status(500)\n            .error(\"Internal Server Error\")\n            .message(\"An unexpected error occurred\")\n            .build();\n        return ResponseEntity.status(500).body(error);\n    }\n}"
    },
    {
      "id": 14,
      "question": "What is API pagination and what are the strategies?",
      "answer": "Pagination splits large result sets into pages.\n\nStrategies:\n\n1. Offset-based:\n   ?page=2&limit=20\n   Simple but slow for large offsets\n\n2. Cursor-based:\n   ?cursor=abc123&limit=20\n   Better performance, handles real-time data\n\n3. Keyset (seek):\n   ?after_id=100&limit=20\n   Efficient, requires sortable unique field\n\nInclude metadata: total, page, hasNext, links",
      "explanation": "Offset pagination is simple but doesn't scale. Cursor pagination is better for large datasets and real-time data.",
      "difficulty": "Medium",
      "code": "// Offset-based pagination\nGET /api/users?page=2&size=20\n\n{\n  \"data\": [...],\n  \"pagination\": {\n    \"page\": 2,\n    \"size\": 20,\n    \"total\": 195,\n    \"totalPages\": 10,\n    \"hasNext\": true,\n    \"hasPrev\": true\n  },\n  \"_links\": {\n    \"first\": \"/api/users?page=1&size=20\",\n    \"prev\": \"/api/users?page=1&size=20\",\n    \"next\": \"/api/users?page=3&size=20\",\n    \"last\": \"/api/users?page=10&size=20\"\n  }\n}\n\n// Cursor-based pagination (better for large datasets)\nGET /api/users?cursor=eyJpZCI6MTAwfQ&limit=20\n\n{\n  \"data\": [...],\n  \"pagination\": {\n    \"limit\": 20,\n    \"hasMore\": true,\n    \"nextCursor\": \"eyJpZCI6MTIwfQ\"\n  }\n}\n\n// Keyset pagination\nGET /api/users?after_id=100&limit=20\n\n// Spring Boot implementation\n@GetMapping(\"/users\")\npublic Page<User> getUsers(\n    @RequestParam(defaultValue = \"0\") int page,\n    @RequestParam(defaultValue = \"20\") int size,\n    @RequestParam(defaultValue = \"id\") String sortBy) {\n    \n    Pageable pageable = PageRequest.of(page, size, Sort.by(sortBy));\n    return userRepository.findAll(pageable);\n}\n\n// Cursor implementation\n@GetMapping(\"/users\")\npublic CursorPage<User> getUsers(\n    @RequestParam(required = false) String cursor,\n    @RequestParam(defaultValue = \"20\") int limit) {\n    \n    Long afterId = decodeCursor(cursor);\n    List<User> users = userRepository.findByIdGreaterThan(afterId, limit + 1);\n    \n    boolean hasMore = users.size() > limit;\n    if (hasMore) users = users.subList(0, limit);\n    \n    String nextCursor = hasMore ? encodeCursor(users.get(users.size()-1).getId()) : null;\n    return new CursorPage<>(users, hasMore, nextCursor);\n}"
    },
    {
      "id": 15,
      "question": "What is idempotency and why is it important?",
      "answer": "Idempotency: Same request produces same result, no matter how many times called.\n\nIdempotent methods:\n• GET, HEAD, OPTIONS, TRACE\n• PUT, DELETE\n\nNot idempotent:\n• POST (creates new resource each time)\n• PATCH (can increment values)\n\nWhy important:\n• Safe retries on network failures\n• Prevents duplicate processing\n• Essential for payment/financial APIs",
      "explanation": "Idempotency enables safe retries. Use idempotency keys for non-idempotent operations like payments.",
      "difficulty": "Medium",
      "code": "// Idempotent: Same result for repeated calls\n// DELETE /api/users/123 - First call deletes, subsequent calls still \"succeed\" (already deleted)\n// PUT /api/users/123 - Always results in same state\n\n// Not idempotent\n// POST /api/orders - Creates new order each time\n// PATCH /api/accounts/123 { \"balance\": \"+100\" } - Adds 100 each time\n\n// Idempotency key for POST/PATCH\nPOST /api/payments\nIdempotency-Key: unique-request-id-12345\n{\n  \"amount\": 100.00,\n  \"recipient\": \"user123\"\n}\n\n// Server implementation\n@Service\npublic class PaymentService {\n    @Autowired\n    private IdempotencyStore store;\n    \n    public Payment processPayment(String idempotencyKey, PaymentRequest request) {\n        // Check if already processed\n        Payment existing = store.get(idempotencyKey);\n        if (existing != null) {\n            return existing; // Return cached result\n        }\n        \n        // Process payment\n        Payment payment = createPayment(request);\n        \n        // Store result for future duplicate requests\n        store.put(idempotencyKey, payment, Duration.ofHours(24));\n        \n        return payment;\n    }\n}\n\n// Redis-based idempotency store\n@Component\npublic class RedisIdempotencyStore {\n    @Autowired\n    private StringRedisTemplate redis;\n    \n    public void put(String key, Object result) {\n        redis.opsForValue().set(\n            \"idempotency:\" + key,\n            serialize(result),\n            24, TimeUnit.HOURS\n        );\n    }\n    \n    public <T> T get(String key, Class<T> type) {\n        String value = redis.opsForValue().get(\"idempotency:\" + key);\n        return value != null ? deserialize(value, type) : null;\n    }\n}"
    },
    {
      "id": 16,
      "question": "What is Content Negotiation in REST?",
      "answer": "Content negotiation selects appropriate response format based on client preferences.\n\nMechanisms:\n• Accept header: Client requests format\n• Content-Type header: Request body format\n• URL extension: /api/users.json (less RESTful)\n\nCommon formats:\n• application/json\n• application/xml\n• text/html\n• text/csv",
      "explanation": "Content negotiation makes APIs flexible. Same endpoint can return JSON, XML, etc. based on Accept header.",
      "difficulty": "Easy",
      "code": "// Client requests JSON\nGET /api/users\nAccept: application/json\n\n// Response\nHTTP/1.1 200 OK\nContent-Type: application/json\n[\n  { \"id\": 1, \"name\": \"John\" }\n]\n\n// Client requests XML\nGET /api/users\nAccept: application/xml\n\n// Response\nHTTP/1.1 200 OK\nContent-Type: application/xml\n<users>\n  <user><id>1</id><name>John</name></user>\n</users>\n\n// Priority (q value)\nAccept: application/json, application/xml;q=0.9, */*;q=0.8\n// Prefers JSON, then XML, then anything\n\n// Spring Boot configuration\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    @Override\n    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {\n        configurer\n            .defaultContentType(MediaType.APPLICATION_JSON)\n            .mediaType(\"json\", MediaType.APPLICATION_JSON)\n            .mediaType(\"xml\", MediaType.APPLICATION_XML);\n    }\n}\n\n// Controller\n@GetMapping(value = \"/users\", produces = { \"application/json\", \"application/xml\" })\npublic List<User> getUsers() {\n    return userService.findAll();\n}\n\n// Request body content type\nPOST /api/users\nContent-Type: application/json\n{ \"name\": \"John\" }\n\n// 406 Not Acceptable if format not supported\nGET /api/users\nAccept: application/pdf\n\nHTTP/1.1 406 Not Acceptable"
    },
    {
      "id": 17,
      "question": "What is API documentation and what tools are available?",
      "answer": "API documentation describes how to use an API.\n\nElements:\n• Endpoints and methods\n• Request/response formats\n• Authentication requirements\n• Examples\n• Error codes\n\nTools:\n• OpenAPI/Swagger: Specification + UI\n• Postman: Collections + documentation\n• API Blueprint: Markdown-based\n• RAML: YAML-based\n\nSpring Boot: springdoc-openapi, Swagger UI",
      "explanation": "Good documentation is essential for API adoption. Auto-generate from code annotations when possible. Keep examples up-to-date.",
      "difficulty": "Easy",
      "code": "// OpenAPI/Swagger in Spring Boot\n// Add dependency: springdoc-openapi-starter-webmvc-ui\n\n@RestController\n@Tag(name = \"Users\", description = \"User management APIs\")\n@RequestMapping(\"/api/users\")\npublic class UserController {\n\n    @Operation(\n        summary = \"Get user by ID\",\n        description = \"Returns a single user by their unique identifier\"\n    )\n    @ApiResponses({\n        @ApiResponse(\n            responseCode = \"200\",\n            description = \"User found\",\n            content = @Content(schema = @Schema(implementation = User.class))\n        ),\n        @ApiResponse(\n            responseCode = \"404\",\n            description = \"User not found\"\n        )\n    })\n    @GetMapping(\"/{id}\")\n    public User getUser(\n        @Parameter(description = \"User ID\", required = true)\n        @PathVariable Long id) {\n        return userService.findById(id);\n    }\n\n    @Operation(summary = \"Create new user\")\n    @PostMapping\n    public ResponseEntity<User> createUser(\n        @RequestBody @Valid CreateUserRequest request) {\n        User user = userService.create(request);\n        return ResponseEntity.created(URI.create(\"/api/users/\" + user.getId()))\n            .body(user);\n    }\n}\n\n// Schema documentation\n@Schema(description = \"User entity\")\npublic class User {\n    @Schema(description = \"Unique identifier\", example = \"123\")\n    private Long id;\n    \n    @Schema(description = \"User's full name\", example = \"John Doe\")\n    private String name;\n    \n    @Schema(description = \"Email address\", example = \"john@example.com\")\n    private String email;\n}\n\n// Access Swagger UI at: http://localhost:8080/swagger-ui.html\n// OpenAPI spec at: http://localhost:8080/v3/api-docs"
    },
    {
      "id": 18,
      "question": "What is the difference between REST and GraphQL?",
      "answer": "REST:\n• Multiple endpoints per resource\n• Fixed response structure\n• Over-fetching/under-fetching common\n• HTTP caching works well\n• Simple to understand\n\nGraphQL:\n• Single endpoint\n• Client specifies needed fields\n• No over/under-fetching\n• Complex caching\n• Learning curve\n\nUse GraphQL for: Complex relationships, mobile apps, varied client needs",
      "explanation": "REST is simpler and widely adopted. GraphQL solves specific problems like over-fetching and multiple round trips.",
      "difficulty": "Medium",
      "code": "// REST: Multiple endpoints, fixed response\nGET /api/users/123\n{\n  \"id\": 123,\n  \"name\": \"John\",\n  \"email\": \"john@test.com\",\n  \"address\": { ... },  // Always included\n  \"orders\": [ ... ]    // Or separate call\n}\n\nGET /api/users/123/orders  // Additional request\n\n// Over-fetching: Getting address when only need name\n// Under-fetching: Need orders, must make second request\n\n// GraphQL: Single endpoint, flexible query\nPOST /graphql\n{\n  \"query\": \"\"\"\n    query {\n      user(id: 123) {\n        name\n        email\n        orders {\n          id\n          total\n        }\n      }\n    }\n  \"\"\"\n}\n\n// Response: Only requested fields\n{\n  \"data\": {\n    \"user\": {\n      \"name\": \"John\",\n      \"email\": \"john@test.com\",\n      \"orders\": [\n        { \"id\": 1, \"total\": 99.99 }\n      ]\n    }\n  }\n}\n\n// GraphQL mutation\nPOST /graphql\n{\n  \"query\": \"\"\"\n    mutation {\n      createUser(input: { name: \"Jane\", email: \"jane@test.com\" }) {\n        id\n        name\n      }\n    }\n  \"\"\"\n}\n\n// Comparison:\n// REST pros: Simple, cacheable, widely understood\n// GraphQL pros: Flexible queries, single request for complex data\n// REST cons: Over/under-fetching, multiple round trips\n// GraphQL cons: Complex caching, learning curve, harder to secure"
    },
    {
      "id": 19,
      "question": "How do you secure REST APIs?",
      "answer": "Security best practices:\n\n1. Authentication: JWT, OAuth 2.0\n2. HTTPS: Always use TLS\n3. Input validation: Sanitize all inputs\n4. Rate limiting: Prevent abuse\n5. CORS: Restrict origins\n6. Authorization: Check permissions per request\n7. Audit logging: Track access\n8. Security headers: CSP, X-Frame-Options\n9. Keep dependencies updated\n10. Don't expose sensitive data in errors",
      "explanation": "Security is multi-layered. No single measure is enough. Validate inputs, authenticate, authorize, and monitor.",
      "difficulty": "Hard",
      "code": "// 1. HTTPS only\nserver.ssl.enabled=true\nserver.ssl.key-store=keystore.p12\n\n// 2. Security headers\n@Configuration\npublic class SecurityConfig {\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .headers(headers -> headers\n                .contentSecurityPolicy(csp -> csp.policyDirectives(\"default-src 'self'\"))\n                .frameOptions(frame -> frame.deny())\n                .xssProtection(xss -> xss.enable())\n            )\n            .csrf(csrf -> csrf.disable())  // For stateless API\n            .sessionManagement(session -> \n                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/api/auth/**\").permitAll()\n                .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\n                .anyRequest().authenticated()\n            )\n            .oauth2ResourceServer(oauth2 -> oauth2.jwt());\n        \n        return http.build();\n    }\n}\n\n// 3. Input validation\n@PostMapping(\"/users\")\npublic User createUser(@Valid @RequestBody CreateUserRequest request) { }\n\npublic class CreateUserRequest {\n    @NotBlank\n    @Size(max = 100)\n    private String name;\n    \n    @NotBlank\n    @Email\n    private String email;\n    \n    @NotBlank\n    @Size(min = 8)\n    @Pattern(regexp = \"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\\\d).*$\")\n    private String password;\n}\n\n// 4. SQL injection prevention (use parameterized queries)\n@Query(\"SELECT u FROM User u WHERE u.email = :email\")\nUser findByEmail(@Param(\"email\") String email);\n\n// 5. Audit logging\n@Aspect\n@Component\npublic class AuditAspect {\n    @AfterReturning(\"@annotation(Audited)\")\n    public void audit(JoinPoint jp) {\n        log.info(\"User {} accessed {}\", currentUser(), jp.getSignature());\n    }\n}"
    },
    {
      "id": 20,
      "question": "What is caching in REST APIs and how do you implement it?",
      "answer": "Caching stores responses to avoid repeated processing.\n\nLevels:\n• Client cache: Browser\n• CDN/Proxy cache: Edge servers\n• Application cache: Redis, in-memory\n• Database cache: Query results\n\nHTTP Cache Headers:\n• Cache-Control: max-age, no-cache, no-store\n• ETag: Content hash\n• Last-Modified: Timestamp\n• Expires: Expiration date (legacy)",
      "explanation": "Caching improves performance and reduces load. Use appropriate cache headers. Invalidate cache when data changes.",
      "difficulty": "Medium",
      "code": "// HTTP Cache Headers\n\n// Public cache (can be cached by CDN)\nGET /api/products/123\n\nHTTP/1.1 200 OK\nCache-Control: public, max-age=3600\nETag: \"abc123\"\n{\n  \"id\": 123,\n  \"name\": \"Product\"\n}\n\n// Private cache (only browser)\nCache-Control: private, max-age=600\n\n// No caching\nCache-Control: no-store, no-cache, must-revalidate\n\n// Conditional request with ETag\nGET /api/products/123\nIf-None-Match: \"abc123\"\n\nHTTP/1.1 304 Not Modified\n// No body, use cached version\n\n// Spring Boot caching\n@Configuration\n@EnableCaching\npublic class CacheConfig {\n    @Bean\n    public CacheManager cacheManager() {\n        return new ConcurrentMapCacheManager(\"users\", \"products\");\n    }\n}\n\n// Redis cache\n@Bean\npublic CacheManager cacheManager(RedisConnectionFactory cf) {\n    RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()\n        .entryTtl(Duration.ofMinutes(10));\n    return RedisCacheManager.builder(cf).cacheDefaults(config).build();\n}\n\n// Cache annotations\n@Service\npublic class UserService {\n    @Cacheable(value = \"users\", key = \"#id\")\n    public User findById(Long id) {\n        return userRepository.findById(id).orElseThrow();\n    }\n    \n    @CacheEvict(value = \"users\", key = \"#user.id\")\n    public User update(User user) {\n        return userRepository.save(user);\n    }\n    \n    @CacheEvict(value = \"users\", allEntries = true)\n    public void clearCache() { }\n}\n\n// Controller with cache headers\n@GetMapping(\"/products/{id}\")\npublic ResponseEntity<Product> getProduct(@PathVariable Long id) {\n    Product product = productService.findById(id);\n    String etag = generateETag(product);\n    \n    return ResponseEntity.ok()\n        .cacheControl(CacheControl.maxAge(1, TimeUnit.HOURS).cachePublic())\n        .eTag(etag)\n        .body(product);\n}"
    }
  ]
}
