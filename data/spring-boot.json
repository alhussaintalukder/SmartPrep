{
  "topic": "Spring Boot",
  "questions": [
    {
      "id": 1,
      "question": "What is Spring Boot and how is it different from Spring Framework?",
      "answer": "Spring Boot is an extension of Spring Framework that simplifies application development by providing:\n\n• Auto-configuration: Automatically configures components based on classpath\n• Starter dependencies: Pre-configured dependency bundles\n• Embedded servers: Tomcat, Jetty, or Undertow built-in\n• Production-ready features: Health checks, metrics, externalized config\n• No XML configuration required\n\nSpring Framework requires manual configuration while Spring Boot provides opinionated defaults.",
      "explanation": "Spring Boot follows 'convention over configuration' philosophy. It eliminates boilerplate setup so you can focus on business logic. Spring Framework is powerful but requires extensive configuration.",
      "difficulty": "Easy"
    },
    {
      "id": 2,
      "question": "What are Spring Boot Starters?",
      "answer": "Starters are convenient dependency descriptors that bundle commonly used dependencies together.\n\nCommon starters:\n• spring-boot-starter-web: Web apps (Tomcat, Spring MVC)\n• spring-boot-starter-data-jpa: JPA with Hibernate\n• spring-boot-starter-security: Spring Security\n• spring-boot-starter-test: Testing libraries\n• spring-boot-starter-actuator: Production features\n• spring-boot-starter-validation: Bean validation",
      "explanation": "Instead of adding 10 individual dependencies for a web app, you add one starter. Spring Boot manages compatible versions automatically, reducing dependency conflicts.",
      "difficulty": "Easy",
      "code": "<!-- pom.xml -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n\n<!-- This single starter includes: -->\n<!-- - Spring MVC -->\n<!-- - Embedded Tomcat -->\n<!-- - Jackson for JSON -->\n<!-- - Validation -->\n<!-- - Logging -->"
    },
    {
      "id": 3,
      "question": "Explain the @SpringBootApplication annotation.",
      "answer": "@SpringBootApplication is a convenience annotation that combines three annotations:\n\n1. @Configuration: Marks class as source of bean definitions\n\n2. @EnableAutoConfiguration: Enables Spring Boot's auto-configuration mechanism\n\n3. @ComponentScan: Enables scanning for components in current package and sub-packages",
      "explanation": "This single annotation bootstraps your entire Spring Boot application. It's typically placed on the main class with the main() method.",
      "difficulty": "Easy",
      "code": "@SpringBootApplication\npublic class MyApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApplication.class, args);\n    }\n}\n\n// Equivalent to:\n@Configuration\n@EnableAutoConfiguration\n@ComponentScan\npublic class MyApplication { }"
    },
    {
      "id": 4,
      "question": "What is Dependency Injection and how does Spring implement it?",
      "answer": "Dependency Injection (DI) is a design pattern where objects receive their dependencies from external sources rather than creating them internally.\n\nSpring DI methods:\n1. Constructor Injection (recommended): Dependencies via constructor\n2. Setter Injection: Dependencies via setter methods\n3. Field Injection: Dependencies via @Autowired on fields\n\nSpring container (IoC container) manages object creation and dependency wiring.",
      "explanation": "DI promotes loose coupling, easier testing, and better maintainability. Constructor injection is preferred because it ensures required dependencies are provided and enables immutability.",
      "difficulty": "Medium",
      "code": "// Constructor Injection (Recommended)\n@Service\npublic class UserService {\n    private final UserRepository userRepository;\n    \n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n\n// Setter Injection\n@Service\npublic class UserService {\n    private UserRepository userRepository;\n    \n    @Autowired\n    public void setUserRepository(UserRepository repo) {\n        this.userRepository = repo;\n    }\n}\n\n// Field Injection (Not recommended)\n@Service\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n}"
    },
    {
      "id": 5,
      "question": "What are the different bean scopes in Spring?",
      "answer": "Bean scopes define the lifecycle and visibility of beans:\n\n1. Singleton (default): One instance per Spring container\n2. Prototype: New instance each time bean is requested\n3. Request: One instance per HTTP request (web only)\n4. Session: One instance per HTTP session (web only)\n5. Application: One instance per ServletContext\n6. WebSocket: One instance per WebSocket session",
      "explanation": "Singleton is most common for stateless services. Prototype for stateful beans. Request/Session for web-specific scenarios like user data.",
      "difficulty": "Medium",
      "code": "@Component\n@Scope(\"singleton\") // default\npublic class SingletonBean { }\n\n@Component\n@Scope(\"prototype\")\npublic class PrototypeBean { }\n\n@Component\n@Scope(value = WebApplicationContext.SCOPE_REQUEST, \n       proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class RequestBean { }\n\n@Component\n@Scope(value = WebApplicationContext.SCOPE_SESSION,\n       proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class SessionBean { }"
    },
    {
      "id": 6,
      "question": "What is Spring Boot Auto-Configuration?",
      "answer": "Auto-configuration automatically configures Spring beans based on:\n• Dependencies on classpath\n• Existing beans already defined\n• Property settings\n\nHow it works:\n1. @EnableAutoConfiguration triggers the process\n2. Spring Boot checks META-INF/spring.factories for config classes\n3. @Conditional annotations determine if config should apply\n4. Beans are created if conditions are met\n\nYou can exclude specific auto-configurations if needed.",
      "explanation": "Auto-config reduces boilerplate. If you add spring-boot-starter-data-jpa, Spring automatically configures DataSource, EntityManager, TransactionManager, etc.",
      "difficulty": "Medium",
      "code": "// Exclude specific auto-configuration\n@SpringBootApplication(\n    exclude = {DataSourceAutoConfiguration.class}\n)\npublic class MyApp { }\n\n// Or in application.properties\nspring.autoconfigure.exclude=\\\n  org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration\n\n// View auto-configuration report\n// Add --debug to startup or\n// Set debug=true in application.properties"
    },
    {
      "id": 7,
      "question": "Explain @RestController vs @Controller.",
      "answer": "@Controller:\n• Traditional MVC controller\n• Returns view names (HTML pages)\n• Used with view resolvers (Thymeleaf, JSP)\n• Need @ResponseBody for JSON responses\n\n@RestController:\n• Combination of @Controller + @ResponseBody\n• Returns data directly (JSON/XML)\n• Every method's return value is serialized to response body\n• Used for REST APIs",
      "explanation": "@RestController is for APIs returning data, @Controller is for web apps returning HTML. Most modern apps use @RestController for backend APIs.",
      "difficulty": "Easy",
      "code": "// @Controller - returns view\n@Controller\npublic class WebController {\n    @GetMapping(\"/home\")\n    public String home(Model model) {\n        model.addAttribute(\"message\", \"Hello\");\n        return \"home\"; // returns home.html view\n    }\n    \n    @GetMapping(\"/api/data\")\n    @ResponseBody // needed for JSON\n    public Data getData() {\n        return new Data();\n    }\n}\n\n// @RestController - returns data\n@RestController\n@RequestMapping(\"/api\")\npublic class ApiController {\n    @GetMapping(\"/users\")\n    public List<User> getUsers() {\n        return userService.findAll(); // automatically JSON\n    }\n}"
    },
    {
      "id": 8,
      "question": "What is Spring Data JPA and how does it work?",
      "answer": "Spring Data JPA simplifies database access by:\n\n• Providing repository interfaces with CRUD operations\n• Generating queries from method names\n• Supporting custom queries with @Query\n• Integrating with Hibernate/JPA seamlessly\n\nRepository hierarchy:\n• Repository<T, ID> - marker interface\n• CrudRepository - basic CRUD\n• PagingAndSortingRepository - pagination + sorting\n• JpaRepository - JPA specific features",
      "explanation": "You just define an interface extending JpaRepository, and Spring generates the implementation at runtime. No boilerplate DAO code needed.",
      "difficulty": "Medium",
      "code": "@Entity\npublic class User {\n    @Id @GeneratedValue\n    private Long id;\n    private String name;\n    private String email;\n}\n\n// Just define interface - Spring implements it!\npublic interface UserRepository extends JpaRepository<User, Long> {\n    // Query from method name\n    List<User> findByName(String name);\n    List<User> findByEmailContaining(String email);\n    Optional<User> findByNameAndEmail(String name, String email);\n    \n    // Custom query\n    @Query(\"SELECT u FROM User u WHERE u.email LIKE %:domain\")\n    List<User> findByEmailDomain(@Param(\"domain\") String domain);\n}"
    },
    {
      "id": 9,
      "question": "How do you handle exceptions in Spring Boot REST APIs?",
      "answer": "Exception handling approaches:\n\n1. @ExceptionHandler: Handle exceptions in specific controller\n\n2. @ControllerAdvice: Global exception handling across all controllers\n\n3. ResponseEntityExceptionHandler: Extend for standard Spring exceptions\n\n4. @ResponseStatus: Map exceptions to HTTP status codes\n\nBest practice: Use @ControllerAdvice with custom exception classes for consistent API error responses.",
      "explanation": "@ControllerAdvice provides centralized exception handling. Create custom exceptions for business logic and map them to appropriate HTTP responses.",
      "difficulty": "Medium",
      "code": "// Custom exception\npublic class ResourceNotFoundException extends RuntimeException {\n    public ResourceNotFoundException(String message) {\n        super(message);\n    }\n}\n\n// Error response DTO\npublic class ErrorResponse {\n    private int status;\n    private String message;\n    private LocalDateTime timestamp;\n}\n\n// Global exception handler\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    @ExceptionHandler(ResourceNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleNotFound(ResourceNotFoundException ex) {\n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.NOT_FOUND.value(),\n            ex.getMessage(),\n            LocalDateTime.now()\n        );\n        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);\n    }\n    \n    @ExceptionHandler(Exception.class)\n    public ResponseEntity<ErrorResponse> handleGeneral(Exception ex) {\n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.INTERNAL_SERVER_ERROR.value(),\n            \"Internal server error\",\n            LocalDateTime.now()\n        );\n        return ResponseEntity.status(500).body(error);\n    }\n}"
    },
    {
      "id": 10,
      "question": "What is Spring Boot Actuator?",
      "answer": "Spring Boot Actuator provides production-ready features for monitoring and managing applications:\n\n• /actuator/health - Application health status\n• /actuator/info - Application information\n• /actuator/metrics - Application metrics\n• /actuator/env - Environment properties\n• /actuator/loggers - View/modify log levels\n• /actuator/httptrace - HTTP request traces\n\nEndpoints can be exposed via HTTP or JMX.",
      "explanation": "Actuator is essential for production monitoring. Integrate with Prometheus/Grafana for metrics visualization. Always secure sensitive endpoints in production.",
      "difficulty": "Medium",
      "code": "<!-- Add dependency -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n\n# application.properties\n# Expose specific endpoints\nmanagement.endpoints.web.exposure.include=health,info,metrics\n\n# Expose all endpoints (dev only)\nmanagement.endpoints.web.exposure.include=*\n\n# Show full health details\nmanagement.endpoint.health.show-details=always\n\n# Custom health indicator\n@Component\npublic class CustomHealthIndicator implements HealthIndicator {\n    @Override\n    public Health health() {\n        boolean isHealthy = checkService();\n        if (isHealthy) {\n            return Health.up().withDetail(\"service\", \"Available\").build();\n        }\n        return Health.down().withDetail(\"service\", \"Unavailable\").build();\n    }\n}"
    },
    {
      "id": 11,
      "question": "Explain Spring Boot profiles and how to use them.",
      "answer": "Profiles allow different configurations for different environments:\n\n• application.properties - default config\n• application-dev.properties - development\n• application-prod.properties - production\n• application-test.properties - testing\n\nActivation:\n• spring.profiles.active=dev in properties\n• --spring.profiles.active=dev command line\n• SPRING_PROFILES_ACTIVE=dev environment variable",
      "explanation": "Profiles separate environment-specific configs like database URLs, log levels, and feature flags. You can have multiple active profiles.",
      "difficulty": "Easy",
      "code": "# application.properties\nspring.profiles.active=dev\napp.name=MyApp\n\n# application-dev.properties\nspring.datasource.url=jdbc:mysql://localhost:3306/devdb\nlogging.level.root=DEBUG\n\n# application-prod.properties\nspring.datasource.url=jdbc:mysql://prod-server:3306/proddb\nlogging.level.root=WARN\n\n// Profile-specific beans\n@Configuration\n@Profile(\"dev\")\npublic class DevConfig {\n    @Bean\n    public DataSource dataSource() {\n        // H2 in-memory for dev\n    }\n}\n\n@Configuration\n@Profile(\"prod\")\npublic class ProdConfig {\n    @Bean\n    public DataSource dataSource() {\n        // MySQL for prod\n    }\n}"
    },
    {
      "id": 12,
      "question": "What is the difference between @Component, @Service, @Repository, and @Controller?",
      "answer": "All are stereotype annotations that mark classes as Spring-managed beans:\n\n@Component: Generic stereotype for any Spring component\n\n@Service: Business logic layer. No additional behavior, just semantic meaning.\n\n@Repository: Data access layer. Enables exception translation (DB exceptions → Spring DataAccessException)\n\n@Controller: Web layer. Handles HTTP requests, returns views or data.\n\nAll are specializations of @Component with different semantic purposes.",
      "explanation": "Using correct annotations improves code readability and enables layer-specific features. @Repository's exception translation is the only one with actual technical benefit.",
      "difficulty": "Easy",
      "code": "@Component\npublic class GenericComponent { }\n\n@Service\npublic class UserService {\n    // Business logic\n    public User createUser(UserDTO dto) { }\n}\n\n@Repository\npublic class UserRepositoryImpl implements UserRepository {\n    // Data access - DB exceptions auto-translated\n    @PersistenceContext\n    private EntityManager em;\n}\n\n@Controller // or @RestController\npublic class UserController {\n    // Handle HTTP requests\n    @GetMapping(\"/users\")\n    public List<User> getUsers() { }\n}"
    },
    {
      "id": 13,
      "question": "How does Spring Boot handle externalized configuration?",
      "answer": "Spring Boot loads configuration from multiple sources (in order of precedence):\n\n1. Command line arguments\n2. Java System properties\n3. OS environment variables\n4. Profile-specific properties (application-{profile}.properties)\n5. application.properties/yml\n6. @PropertySource annotations\n7. Default properties\n\nAccess properties using @Value, @ConfigurationProperties, or Environment.",
      "explanation": "Higher precedence overrides lower. This allows same code to run in different environments with different configs without code changes.",
      "difficulty": "Medium",
      "code": "# application.yml\napp:\n  name: SmartList\n  api:\n    url: https://api.example.com\n    timeout: 30\n\n// Access with @Value\n@Component\npublic class MyComponent {\n    @Value(\"${app.name}\")\n    private String appName;\n    \n    @Value(\"${app.api.timeout:60}\") // with default\n    private int timeout;\n}\n\n// Access with @ConfigurationProperties (recommended)\n@Component\n@ConfigurationProperties(prefix = \"app.api\")\npublic class ApiProperties {\n    private String url;\n    private int timeout;\n    // getters and setters\n}\n\n// Enable configuration properties\n@SpringBootApplication\n@EnableConfigurationProperties(ApiProperties.class)\npublic class MyApp { }"
    },
    {
      "id": 14,
      "question": "What is @Transactional and how does it work?",
      "answer": "@Transactional manages database transactions declaratively:\n\n• Starts transaction before method execution\n• Commits on successful completion\n• Rolls back on RuntimeException (by default)\n\nKey attributes:\n• propagation: How transactions relate to each other\n• isolation: Transaction isolation level\n• readOnly: Optimization hint for read operations\n• rollbackFor: Exceptions that trigger rollback\n• timeout: Transaction timeout",
      "explanation": "Spring uses AOP proxies to wrap @Transactional methods. Important: self-invocation (calling @Transactional method from same class) bypasses the proxy.",
      "difficulty": "Medium",
      "code": "@Service\npublic class UserService {\n    \n    @Transactional\n    public void createUser(User user) {\n        userRepository.save(user);\n        auditRepository.log(\"User created\");\n        // If exception here, both operations rollback\n    }\n    \n    @Transactional(readOnly = true)\n    public List<User> getAllUsers() {\n        return userRepository.findAll();\n    }\n    \n    @Transactional(\n        propagation = Propagation.REQUIRES_NEW,\n        isolation = Isolation.READ_COMMITTED,\n        rollbackFor = Exception.class,\n        timeout = 30\n    )\n    public void complexOperation() { }\n}\n\n// Propagation types:\n// REQUIRED (default) - use existing or create new\n// REQUIRES_NEW - always create new\n// NESTED - nested transaction\n// SUPPORTS - use if exists, else non-transactional"
    },
    {
      "id": 15,
      "question": "How do you implement pagination in Spring Data JPA?",
      "answer": "Spring Data JPA provides built-in pagination support:\n\n1. Extend JpaRepository (includes PagingAndSortingRepository)\n2. Use Pageable parameter in methods\n3. Return Page<T> or Slice<T>\n\nPage: Contains data + total count (extra query)\nSlice: Contains data + hasNext flag (no count query)\n\nPageRequest.of(page, size, sort) creates Pageable objects.",
      "explanation": "Pagination is essential for large datasets. Page is best when you need total count (UI pagination). Slice is better for infinite scroll (no count overhead).",
      "difficulty": "Medium",
      "code": "// Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    Page<User> findByName(String name, Pageable pageable);\n    Slice<User> findByStatus(String status, Pageable pageable);\n}\n\n// Service\n@Service\npublic class UserService {\n    public Page<User> getUsers(int page, int size) {\n        Pageable pageable = PageRequest.of(page, size, Sort.by(\"name\"));\n        return userRepository.findAll(pageable);\n    }\n}\n\n// Controller\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    @GetMapping\n    public Page<User> getUsers(\n            @RequestParam(defaultValue = \"0\") int page,\n            @RequestParam(defaultValue = \"10\") int size,\n            @RequestParam(defaultValue = \"id\") String sortBy) {\n        \n        Pageable pageable = PageRequest.of(page, size, Sort.by(sortBy));\n        return userService.findAll(pageable);\n    }\n}"
    },
    {
      "id": 16,
      "question": "What is Spring Security and how do you implement authentication?",
      "answer": "Spring Security provides:\n• Authentication: Verify user identity\n• Authorization: Control access to resources\n• Protection against attacks (CSRF, session fixation, etc.)\n\nKey components:\n• SecurityFilterChain: Main security configuration\n• UserDetailsService: Load user data\n• PasswordEncoder: Encode passwords\n• AuthenticationManager: Process authentication",
      "explanation": "Spring Security uses a chain of filters. When a request comes in, filters check authentication/authorization before reaching your controller.",
      "difficulty": "Hard",
      "code": "@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .csrf(csrf -> csrf.disable()) // Disable for APIs\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/api/public/**\").permitAll()\n                .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\n                .anyRequest().authenticated()\n            )\n            .httpBasic(Customizer.withDefaults());\n        return http.build();\n    }\n    \n    @Bean\n    public UserDetailsService userDetailsService() {\n        UserDetails user = User.builder()\n            .username(\"user\")\n            .password(passwordEncoder().encode(\"password\"))\n            .roles(\"USER\")\n            .build();\n        return new InMemoryUserDetailsManager(user);\n    }\n    \n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n}"
    },
    {
      "id": 17,
      "question": "How do you implement JWT authentication in Spring Boot?",
      "answer": "JWT (JSON Web Token) authentication flow:\n\n1. User logs in with credentials\n2. Server validates and returns JWT token\n3. Client includes token in Authorization header\n4. Server validates token on each request\n\nComponents needed:\n• JWT utility class for token generation/validation\n• Authentication filter to intercept requests\n• Security configuration to use the filter",
      "explanation": "JWT is stateless - no server-side session storage. Token contains encoded user info and signature. Great for microservices and mobile apps.",
      "difficulty": "Hard",
      "code": "// JWT Utility\n@Component\npublic class JwtUtil {\n    @Value(\"${jwt.secret}\")\n    private String secret;\n    \n    public String generateToken(String username) {\n        return Jwts.builder()\n            .setSubject(username)\n            .setIssuedAt(new Date())\n            .setExpiration(new Date(System.currentTimeMillis() + 86400000))\n            .signWith(SignatureAlgorithm.HS256, secret)\n            .compact();\n    }\n    \n    public String extractUsername(String token) {\n        return Jwts.parser()\n            .setSigningKey(secret)\n            .parseClaimsJws(token)\n            .getBody()\n            .getSubject();\n    }\n    \n    public boolean validateToken(String token) {\n        try {\n            Jwts.parser().setSigningKey(secret).parseClaimsJws(token);\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}\n\n// Auth Controller\n@RestController\n@RequestMapping(\"/api/auth\")\npublic class AuthController {\n    @PostMapping(\"/login\")\n    public ResponseEntity<String> login(@RequestBody LoginRequest request) {\n        // Validate credentials\n        String token = jwtUtil.generateToken(request.getUsername());\n        return ResponseEntity.ok(token);\n    }\n}"
    },
    {
      "id": 18,
      "question": "What is WebSocket support in Spring Boot?",
      "answer": "Spring Boot supports WebSocket for real-time bidirectional communication:\n\n• STOMP (Simple Text Oriented Messaging Protocol): Higher-level messaging protocol over WebSocket\n• SockJS: Fallback for browsers without WebSocket support\n• Message Broker: Route messages between clients\n\nUse cases: Chat apps, live notifications, real-time dashboards, collaborative editing.",
      "explanation": "WebSocket maintains persistent connection unlike HTTP request-response. STOMP provides pub-sub messaging pattern. SockJS ensures compatibility with older browsers.",
      "difficulty": "Hard",
      "code": "// WebSocket Configuration\n@Configuration\n@EnableWebSocketMessageBroker\npublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer {\n    \n    @Override\n    public void configureMessageBroker(MessageBrokerRegistry config) {\n        config.enableSimpleBroker(\"/topic\"); // Subscribe destinations\n        config.setApplicationDestinationPrefixes(\"/app\"); // Send destinations\n    }\n    \n    @Override\n    public void registerStompEndpoints(StompEndpointRegistry registry) {\n        registry.addEndpoint(\"/ws\")\n            .setAllowedOrigins(\"*\")\n            .withSockJS();\n    }\n}\n\n// Controller\n@Controller\npublic class MessageController {\n    \n    @MessageMapping(\"/send\") // Receives from /app/send\n    @SendTo(\"/topic/messages\") // Broadcasts to subscribers\n    public Message sendMessage(Message message) {\n        return message;\n    }\n}\n\n// Send message programmatically\n@Autowired\nprivate SimpMessagingTemplate messagingTemplate;\n\npublic void notifyUsers(String message) {\n    messagingTemplate.convertAndSend(\"/topic/notifications\", message);\n}"
    },
    {
      "id": 19,
      "question": "How do you test Spring Boot applications?",
      "answer": "Spring Boot testing layers:\n\n1. Unit Tests: Test individual components in isolation\n   • @Mock, @InjectMocks with Mockito\n\n2. Integration Tests: Test multiple components together\n   • @SpringBootTest loads full context\n   • @DataJpaTest for repository layer\n   • @WebMvcTest for controller layer\n\n3. End-to-End Tests: Test complete application\n   • TestRestTemplate or WebTestClient",
      "explanation": "Use @WebMvcTest for fast controller tests (no full context). Use @SpringBootTest for integration tests. Mock external dependencies.",
      "difficulty": "Medium",
      "code": "// Unit Test - Service\n@ExtendWith(MockitoExtension.class)\nclass UserServiceTest {\n    @Mock\n    private UserRepository userRepository;\n    \n    @InjectMocks\n    private UserService userService;\n    \n    @Test\n    void shouldFindUser() {\n        when(userRepository.findById(1L)).thenReturn(Optional.of(new User()));\n        assertNotNull(userService.findById(1L));\n    }\n}\n\n// Controller Test\n@WebMvcTest(UserController.class)\nclass UserControllerTest {\n    @Autowired\n    private MockMvc mockMvc;\n    \n    @MockBean\n    private UserService userService;\n    \n    @Test\n    void shouldReturnUsers() throws Exception {\n        mockMvc.perform(get(\"/api/users\"))\n            .andExpect(status().isOk())\n            .andExpect(jsonPath(\"$\").isArray());\n    }\n}\n\n// Integration Test\n@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)\nclass IntegrationTest {\n    @Autowired\n    private TestRestTemplate restTemplate;\n    \n    @Test\n    void shouldCreateUser() {\n        ResponseEntity<User> response = restTemplate\n            .postForEntity(\"/api/users\", new User(), User.class);\n        assertEquals(HttpStatus.CREATED, response.getStatusCode());\n    }\n}"
    },
    {
      "id": 20,
      "question": "What is Spring Boot DevTools?",
      "answer": "Spring Boot DevTools provides development-time features:\n\n• Automatic Restart: Restarts app when classpath changes\n• LiveReload: Refreshes browser automatically\n• Property Defaults: Development-friendly defaults\n• Remote Debugging: Debug remote applications\n• H2 Console: Access H2 database UI\n\nAutomatically disabled in production (when running from JAR).",
      "explanation": "DevTools significantly improves development experience with fast restarts (uses two classloaders) instead of full application restart. Never include in production.",
      "difficulty": "Easy",
      "code": "<!-- Add dependency -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-devtools</artifactId>\n    <scope>runtime</scope>\n    <optional>true</optional>\n</dependency>\n\n# application.properties\n# Customize restart behavior\nspring.devtools.restart.enabled=true\nspring.devtools.restart.exclude=static/**,public/**\n\n# LiveReload\nspring.devtools.livereload.enabled=true\n\n# H2 Console (if using H2)\nspring.h2.console.enabled=true"
    },
    {
      "id": 21,
      "question": "What is @Qualifier and when to use it?",
      "answer": "@Qualifier specifies which bean to inject when multiple beans of same type exist.\n\nUsage scenarios:\n• Multiple implementations of an interface\n• Resolving autowiring ambiguity\n• Fine-grained control over dependency injection\n\nCombine with @Autowired or use in constructor parameters.\n\nAlternatives: @Primary (marks default bean), @Profile (environment-specific beans).",
      "explanation": "Without @Qualifier, Spring throws NoUniqueBeanDefinitionException when multiple beans match. @Primary is simpler but @Qualifier provides explicit control.",
      "difficulty": "Medium",
      "code": "// Multiple implementations\ninterface PaymentService { }\n\n@Service\n@Qualifier(\"paypal\")\nclass PayPalService implements PaymentService { }\n\n@Service\n@Qualifier(\"stripe\")\nclass StripeService implements PaymentService { }\n\n// Inject specific bean\n@RestController\npublic class PaymentController {\n    private final PaymentService paypalService;\n    private final PaymentService stripeService;\n    \n    public PaymentController(\n            @Qualifier(\"paypal\") PaymentService paypalService,\n            @Qualifier(\"stripe\") PaymentService stripeService) {\n        this.paypalService = paypalService;\n        this.stripeService = stripeService;\n    }\n}"
    },
    {
      "id": 22,
      "question": "What are Conditional Annotations in Spring Boot?",
      "answer": "Conditional annotations control bean registration based on conditions:\n\n• @ConditionalOnClass: Bean created if class is on classpath\n• @ConditionalOnMissingClass: Opposite of OnClass\n• @ConditionalOnBean: If specific bean exists\n• @ConditionalOnMissingBean: If bean doesn't exist\n• @ConditionalOnProperty: Based on property value\n• @ConditionalOnExpression: Based on SpEL expression\n\nUsed extensively in Spring Boot auto-configuration.",
      "explanation": "Conditionals enable auto-configuration magic - beans are created only when appropriate. Helps avoid conflicts and provides smart defaults.",
      "difficulty": "Hard",
      "code": "@Configuration\npublic class DatabaseConfig {\n    \n    @Bean\n    @ConditionalOnClass(name = \"org.h2.Driver\")\n    public DataSource h2DataSource() {\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.H2)\n            .build();\n    }\n    \n    @Bean\n    @ConditionalOnMissingBean(DataSource.class)\n    public DataSource defaultDataSource() {\n        return new SimpleDriverDataSource();\n    }\n    \n    @Bean\n    @ConditionalOnProperty(\n        name = \"app.cache.enabled\",\n        havingValue = \"true\"\n    )\n    public CacheManager cacheManager() {\n        return new ConcurrentMapCacheManager();\n    }\n}"
    },
    {
      "id": 23,
      "question": "How does Spring Boot Logging work?",
      "answer": "Spring Boot uses Commons Logging API with default implementations:\n\n• Logback (default)\n• Log4j2\n• Java Util Logging\n\nConfiguration levels:\n• TRACE, DEBUG, INFO, WARN, ERROR\n\nFeatures:\n• Auto-configured based on classpath\n• Configurable via application.properties\n• Custom logback.xml for advanced config\n• Color-coded console output",
      "explanation": "Default console output includes timestamp, level, PID, thread, logger name, and message. For production, use log files with rotation.",
      "difficulty": "Easy",
      "code": "# application.properties\nlogging.level.root=INFO\nlogging.level.com.example.myapp=DEBUG\nlogging.level.org.springframework=WARN\n\nlogging.file.name=app.log\nlogging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%n\n\n// Using logger\n@Slf4j\n@Service\npublic class UserService {\n    public void createUser(User user) {\n        log.debug(\"Creating user: {}\", user.getName());\n        log.info(\"User created: {}\", user.getId());\n    }\n}"
    },
    {
      "id": 24,
      "question": "What is @ConfigurationProperties?",
      "answer": "@ConfigurationProperties binds external properties to a Java object:\n\nBenefits:\n• Type-safe configuration\n• Validation support (@Valid, @NotNull)\n• Hierarchical property binding\n• Better than multiple @Value annotations\n• IDE auto-completion with metadata\n\nRequires @EnableConfigurationProperties or @ConfigurationPropertiesScan.",
      "explanation": "Preferred over @Value for grouped properties. Supports relaxed binding (kebab-case, camelCase, snake_case).",
      "difficulty": "Medium",
      "code": "# application.yml\napp:\n  name: SmartList\n  api:\n    url: https://api.example.com\n    timeout: 30\n\n@Component\n@ConfigurationProperties(prefix = \"app\")\n@Validated\npublic class AppProperties {\n    @NotBlank\n    private String name;\n    private Api api = new Api();\n    \n    public static class Api {\n        private String url;\n        private int timeout = 60;\n        // getters/setters\n    }\n    // getters/setters\n}\n\n@SpringBootApplication\n@EnableConfigurationProperties(AppProperties.class)\npublic class MyApp { }"
    },
    {
      "id": 25,
      "question": "What is Spring Boot Caching?",
      "answer": "Spring Boot provides caching abstraction:\n\nCache annotations:\n• @Cacheable: Caches method result\n• @CachePut: Updates cache\n• @CacheEvict: Removes from cache\n• @Caching: Combines multiple operations\n\nCache providers:\n• Simple (ConcurrentHashMap)\n• Caffeine\n• Redis\n• EhCache",
      "explanation": "Caching improves performance by storing expensive operation results. Use for read-heavy operations, repeated calculations, or external API calls.",
      "difficulty": "Medium",
      "code": "@SpringBootApplication\n@EnableCaching\npublic class MyApp { }\n\n@Service\npublic class UserService {\n    \n    @Cacheable(value = \"users\", key = \"#userId\")\n    public User findById(Long userId) {\n        return userRepository.findById(userId).orElse(null);\n    }\n    \n    @CachePut(value = \"users\", key = \"#user.id\")\n    public User updateUser(User user) {\n        return userRepository.save(user);\n    }\n    \n    @CacheEvict(value = \"users\", key = \"#userId\")\n    public void deleteUser(Long userId) {\n        userRepository.deleteById(userId);\n    }\n}"
    },
    {
      "id": 26,
      "question": "What is @Async in Spring Boot?",
      "answer": "@Async executes methods asynchronously in separate threads:\n\nFeatures:\n• Non-blocking execution\n• Returns void, Future, or CompletableFuture\n• Configurable thread pool\n• Exception handling strategies\n\nRequires @EnableAsync annotation.\n\nUse cases: Email sending, file processing, external API calls, background tasks.",
      "explanation": "By default, uses SimpleAsyncTaskExecutor. For production, configure ThreadPoolTaskExecutor. Self-invocation doesn't work.",
      "difficulty": "Medium",
      "code": "@SpringBootApplication\n@EnableAsync\npublic class MyApp { }\n\n@Service\npublic class EmailService {\n    \n    @Async\n    public void sendEmail(String to, String message) {\n        // Runs in separate thread\n    }\n    \n    @Async\n    public CompletableFuture<User> findUser(Long id) {\n        User user = userRepository.findById(id).orElse(null);\n        return CompletableFuture.completedFuture(user);\n    }\n}\n\n// Configure thread pool\n@Bean(name = \"taskExecutor\")\npublic Executor taskExecutor() {\n    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n    executor.setCorePoolSize(5);\n    executor.setMaxPoolSize(10);\n    executor.initialize();\n    return executor;\n}"
    },
    {
      "id": 27,
      "question": "What is Spring Boot Scheduling?",
      "answer": "Spring Boot scheduling executes tasks at fixed intervals or specific times:\n\nAnnotations:\n• @Scheduled: Marks method for scheduled execution\n• @EnableScheduling: Enables scheduling support\n\nScheduling options:\n• fixedRate: Fixed interval between starts\n• fixedDelay: Fixed delay between end and next start\n• cron: Cron expression for complex schedules\n• initialDelay: Delay before first execution",
      "explanation": "Scheduled methods must return void and have no parameters. Use cron for flexible scheduling (daily at 2 AM, every weekday).",
      "difficulty": "Medium",
      "code": "@SpringBootApplication\n@EnableScheduling\npublic class MyApp { }\n\n@Component\npublic class ScheduledTasks {\n    \n    @Scheduled(fixedRate = 5000)\n    public void reportCurrentTime() {\n        System.out.println(\"Current time: \" + new Date());\n    }\n    \n    @Scheduled(fixedDelay = 5000, initialDelay = 10000)\n    public void delayedTask() {\n        System.out.println(\"Task executed\");\n    }\n    \n    @Scheduled(cron = \"0 0 2 * * ?\") // 2 AM daily\n    public void dailyTask() {\n        System.out.println(\"Daily maintenance\");\n    }\n}"
    },
    {
      "id": 28,
      "question": "What is Validation in Spring Boot?",
      "answer": "Spring Boot validation validates request data using Bean Validation (JSR-380):\n\nCommon annotations:\n• @NotNull, @NotEmpty, @NotBlank\n• @Size(min, max)\n• @Min, @Max\n• @Email, @Pattern\n• @Past, @Future\n• @Valid (nested validation)\n\nUse @Valid on method parameters.\nErrors thrown as MethodArgumentNotValidException.",
      "explanation": "Validation happens before controller method execution. Use @Valid for DTOs. Create custom validators for complex business rules.",
      "difficulty": "Medium",
      "code": "public class UserDTO {\n    @NotBlank(message = \"Name is required\")\n    @Size(min = 2, max = 50)\n    private String name;\n    \n    @NotNull\n    @Email\n    private String email;\n    \n    @Min(18)\n    private int age;\n}\n\n@RestController\npublic class UserController {\n    \n    @PostMapping(\"/users\")\n    public ResponseEntity<User> createUser(@Valid @RequestBody UserDTO dto) {\n        return ResponseEntity.ok(userService.create(dto));\n    }\n}\n\n@RestControllerAdvice\npublic class ValidationExceptionHandler {\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity<Map<String, String>> handleValidation(\n            MethodArgumentNotValidException ex) {\n        Map<String, String> errors = new HashMap<>();\n        ex.getBindingResult().getFieldErrors().forEach(error -> \n            errors.put(error.getField(), error.getDefaultMessage())\n        );\n        return ResponseEntity.badRequest().body(errors);\n    }\n}"
    },
    {
      "id": 29,
      "question": "What is Spring Boot Application Events?",
      "answer": "Spring Boot provides event-driven programming model:\n\nBuilt-in events:\n• ApplicationStartedEvent\n• ApplicationReadyEvent\n• ApplicationFailedEvent\n• ContextRefreshedEvent\n\nCustom events:\n• Create event class extending ApplicationEvent\n• Publish with ApplicationEventPublisher\n• Listen with @EventListener\n\nEvents are synchronous by default.",
      "explanation": "Events decouple components - publisher doesn't know about listeners. Great for notifications, audit logging, and triggering side effects.",
      "difficulty": "Medium",
      "code": "// Custom event\npublic class UserRegisteredEvent extends ApplicationEvent {\n    private final User user;\n    \n    public UserRegisteredEvent(Object source, User user) {\n        super(source);\n        this.user = user;\n    }\n    \n    public User getUser() { return user; }\n}\n\n// Publisher\n@Service\npublic class UserService {\n    @Autowired\n    private ApplicationEventPublisher eventPublisher;\n    \n    public User register(UserDTO dto) {\n        User user = userRepository.save(new User(dto));\n        eventPublisher.publishEvent(new UserRegisteredEvent(this, user));\n        return user;\n    }\n}\n\n// Listener\n@Component\npublic class EmailListener {\n    @EventListener\n    public void handleUserRegistered(UserRegisteredEvent event) {\n        sendWelcomeEmail(event.getUser().getEmail());\n    }\n}"
    },
    {
      "id": 30,
      "question": "What is CORS in Spring Boot?",
      "answer": "CORS (Cross-Origin Resource Sharing) allows web apps from different origins to access your API:\n\nCORS concepts:\n• Origin: Protocol + domain + port\n• Preflight request: OPTIONS before actual request\n• Same-origin policy: Browser security feature\n\nConfiguration levels:\n• @CrossOrigin on controller/method\n• WebMvcConfigurer for global config\n• Security filter chain configuration",
      "explanation": "By default, browsers block cross-origin requests. Enable CORS to allow frontend from different domain to call your API.",
      "difficulty": "Medium",
      "code": "// Method level\n@RestController\npublic class UserController {\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @GetMapping(\"/users\")\n    public List<User> getUsers() {\n        return userService.findAll();\n    }\n}\n\n// Global configuration\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(\"/api/**\")\n            .allowedOrigins(\"http://localhost:3000\")\n            .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\")\n            .allowedHeaders(\"*\")\n            .allowCredentials(true);\n    }\n}"
    },
    {
      "id": 31,
      "question": "What is Spring Boot Embedded Server configuration?",
      "answer": "Spring Boot includes embedded servlet containers:\n\n• Tomcat (default)\n• Jetty\n• Undertow\n\nConfiguration options:\n• Port and context path\n• SSL/HTTPS\n• Thread pools\n• Connection limits\n• Compression\n• Timeouts\n\nBenefits: No external server needed, self-contained JAR, consistent across environments.",
      "explanation": "Embedded servers make Spring Boot apps truly standalone - just run the JAR. Great for microservices and containerization.",
      "difficulty": "Easy",
      "code": "# application.properties\nserver.port=8080\nserver.servlet.context-path=/api\nserver.servlet.session.timeout=30m\n\n# Tomcat thread pool\nserver.tomcat.threads.max=200\nserver.tomcat.threads.min-spare=10\nserver.tomcat.connection-timeout=20000\n\n# Compression\nserver.compression.enabled=true\nserver.compression.mime-types=application/json,text/html\n\n# SSL\nserver.ssl.enabled=true\nserver.ssl.key-store=classpath:keystore.p12\nserver.ssl.key-store-password=secret\n\n// Change to Jetty\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n    <exclusions>\n        <exclusion>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-tomcat</artifactId>\n        </exclusion>\n    </exclusions>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jetty</artifactId>\n</dependency>"
    },
    {
      "id": 32,
      "question": "What is CommandLineRunner vs ApplicationRunner?",
      "answer": "Both run code after Spring Boot application starts:\n\nCommandLineRunner:\n• run(String... args) method\n• Access raw command-line arguments\n\nApplicationRunner:\n• run(ApplicationArguments args) method\n• Parsed arguments (options vs non-options)\n\nMultiple runners:\n• Use @Order to control execution order\n• Lower value executes first\n\nUse for: Data initialization, startup checks.",
      "explanation": "Perfect for one-time startup tasks like loading cache or checking services. ApplicationRunner is better for complex argument parsing.",
      "difficulty": "Easy",
      "code": "@Component\n@Order(1)\npublic class DataLoader implements CommandLineRunner {\n    @Override\n    public void run(String... args) throws Exception {\n        System.out.println(\"Loading initial data...\");\n        if (args.length > 0) {\n            System.out.println(\"Args: \" + String.join(\", \", args));\n        }\n    }\n}\n\n@Component\n@Order(2)\npublic class StartupChecker implements ApplicationRunner {\n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        if (args.containsOption(\"debug\")) {\n            System.out.println(\"Debug mode enabled\");\n        }\n        List<String> nonOptionArgs = args.getNonOptionArgs();\n    }\n}"
    },
    {
      "id": 33,
      "question": "What is Spring Boot Content Negotiation?",
      "answer": "Content negotiation selects response format based on client request:\n\nDetermination by:\n• Accept header: application/json, application/xml\n• URL extension: /users.json, /users.xml\n• Query parameter: /users?format=json\n\nDefault: JSON (Jackson)\n\nSupported formats:\n• JSON (Jackson)\n• XML (JAXB)\n• Custom (CSV, PDF)",
      "explanation": "Spring Boot automatically handles content negotiation. Clients can request different formats from same endpoint.",
      "difficulty": "Medium",
      "code": "@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    @GetMapping(produces = {MediaType.APPLICATION_JSON_VALUE, \n                            MediaType.APPLICATION_XML_VALUE})\n    public List<User> getUsers() {\n        return userService.findAll();\n    }\n}\n\n// Add XML support\n<dependency>\n    <groupId>com.fasterxml.jackson.dataformat</groupId>\n    <artifactId>jackson-dataformat-xml</artifactId>\n</dependency>\n\n// Configure\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    @Override\n    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {\n        configurer\n            .favorParameter(true)\n            .parameterName(\"format\")\n            .defaultContentType(MediaType.APPLICATION_JSON)\n            .mediaType(\"json\", MediaType.APPLICATION_JSON)\n            .mediaType(\"xml\", MediaType.APPLICATION_XML);\n    }\n}"
    },
    {
      "id": 34,
      "question": "What is Spring Boot File Upload/Download?",
      "answer": "Spring Boot handles file operations through MultipartFile:\n\nFile Upload:\n• MultipartFile parameter\n• Configurable size limits\n• Validation support\n\nFile Download:\n• Return Resource or byte[]\n• Set Content-Disposition header\n• Streaming for large files\n\nConfiguration:\n• Max file size\n• Max request size",
      "explanation": "Use MultipartFile for uploads - more memory efficient. Use InputStreamResource for large file downloads.",
      "difficulty": "Medium",
      "code": "# application.properties\nspring.servlet.multipart.max-file-size=10MB\nspring.servlet.multipart.max-request-size=10MB\n\n@RestController\n@RequestMapping(\"/api/files\")\npublic class FileController {\n    \n    @PostMapping(\"/upload\")\n    public ResponseEntity<String> uploadFile(\n            @RequestParam(\"file\") MultipartFile file) {\n        \n        if (file.isEmpty()) {\n            return ResponseEntity.badRequest().body(\"File is empty\");\n        }\n        \n        Path path = Paths.get(uploadDir, file.getOriginalFilename());\n        Files.copy(file.getInputStream(), path);\n        return ResponseEntity.ok(\"File uploaded\");\n    }\n    \n    @GetMapping(\"/download/{filename}\")\n    public ResponseEntity<Resource> downloadFile(@PathVariable String filename) {\n        Path path = Paths.get(uploadDir, filename);\n        Resource resource = new UrlResource(path.toUri());\n        \n        return ResponseEntity.ok()\n            .contentType(MediaType.APPLICATION_OCTET_STREAM)\n            .header(HttpHeaders.CONTENT_DISPOSITION, \n                   \"attachment; filename=\\\"\" + filename + \"\\\"\")\n            .body(resource);\n    }\n}"
    },
    {
      "id": 35,
      "question": "What is Spring Boot Multi-Module Project?",
      "answer": "Multi-module projects organize related modules under parent:\n\nStructure:\n• parent: Root POM with common config\n• common: Shared utilities, DTOs\n• domain: Entities, repositories\n• service: Business logic\n• web: REST controllers\n\nBenefits:\n• Code organization\n• Dependency management\n• Independent deployment\n• Reusability",
      "explanation": "Multi-module is essential for large applications. Each module can have its own dependencies. Helps enforce layered architecture.",
      "difficulty": "Hard",
      "code": "// Parent pom.xml\n<project>\n    <groupId>com.example</groupId>\n    <artifactId>myapp-parent</artifactId>\n    <version>1.0.0</version>\n    <packaging>pom</packaging>\n    \n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>3.2.0</version>\n    </parent>\n    \n    <modules>\n        <module>myapp-common</module>\n        <module>myapp-domain</module>\n        <module>myapp-service</module>\n        <module>myapp-web</module>\n    </modules>\n</project>\n\n// myapp-domain/pom.xml\n<project>\n    <parent>\n        <groupId>com.example</groupId>\n        <artifactId>myapp-parent</artifactId>\n        <version>1.0.0</version>\n    </parent>\n    \n    <artifactId>myapp-domain</artifactId>\n    \n    <dependencies>\n        <dependency>\n            <groupId>com.example</groupId>\n            <artifactId>myapp-common</artifactId>\n            <version>${project.version}</version>\n        </dependency>\n    </dependencies>\n</project>"
    },
    {
      "id": 36,
      "question": "What is Spring Boot Docker deployment?",
      "answer": "Docker containerizes Spring Boot applications:\n\nApproaches:\n• Basic Dockerfile\n• Multi-stage build\n• Spring Boot Buildpacks\n• Jib plugin\n\nBest practices:\n• Use slim base images\n• Layer optimization\n• Non-root user\n• Health checks\n\nBenefits: Consistent environments, easy scaling, quick deployment.",
      "explanation": "Docker is standard for cloud deployments. Spring Boot Buildpacks and Jib don't require Dockerfile - they build optimized images automatically.",
      "difficulty": "Medium",
      "code": "# Basic Dockerfile\nFROM openjdk:17-slim\nWORKDIR /app\nCOPY target/*.jar app.jar\nEXPOSE 8080\nENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]\n\n# Multi-stage build\nFROM maven:3.8-openjdk-17 AS build\nWORKDIR /app\nCOPY pom.xml .\nCOPY src ./src\nRUN mvn clean package -DskipTests\n\nFROM openjdk:17-slim\nWORKDIR /app\nCOPY --from=build /app/target/*.jar app.jar\nEXPOSE 8080\nENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]\n\n# docker-compose.yml\nversion: '3.8'\nservices:\n  app:\n    build: .\n    ports:\n      - \"8080:8080\"\n    environment:\n      - SPRING_PROFILES_ACTIVE=prod\n    depends_on:\n      - db\n  db:\n    image: mysql:8\n    environment:\n      - MYSQL_ROOT_PASSWORD=root\n      - MYSQL_DATABASE=mydb\n\n# Using Spring Boot Buildpacks\n# mvn spring-boot:build-image"
    },
    {
      "id": 37,
      "question": "What is @ConditionalOnBean vs @ConditionalOnMissingBean?",
      "answer": "Conditional annotations control bean registration:\n\n@ConditionalOnBean:\n• Registers bean only if specified bean exists\n• Checks by type or name\n• Used for dependent beans\n\n@ConditionalOnMissingBean:\n• Registers bean only if specified bean doesn't exist\n• Provides default implementation\n• User can override\n\nOrder matters in bean creation.",
      "explanation": "@ConditionalOnMissingBean is key to Spring Boot auto-configuration - provides defaults that users can override.",
      "difficulty": "Medium",
      "code": "@Configuration\npublic class DatabaseConfig {\n    \n    @Bean\n    @ConditionalOnBean(DataSource.class)\n    public JdbcTemplate jdbcTemplate(DataSource dataSource) {\n        return new JdbcTemplate(dataSource);\n    }\n    \n    @Bean\n    @ConditionalOnMissingBean(DataSource.class)\n    public DataSource defaultDataSource() {\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.H2)\n            .build();\n    }\n}\n\n// User can override\n@Configuration\npublic class CustomConfig {\n    @Bean\n    public DataSource dataSource() {\n        // Custom DataSource\n        return new HikariDataSource();\n    }\n}"
    },
    {
      "id": 38,
      "question": "What is BeanPostProcessor in Spring Boot?",
      "answer": "BeanPostProcessor customizes bean instances after creation:\n\nMethods:\n• postProcessBeforeInitialization: Before @PostConstruct\n• postProcessAfterInitialization: After initialization, can return proxy\n\nUse cases:\n• Custom initialization logic\n• AOP proxy creation\n• Bean validation\n• Dependency injection customization\n\nExecuted for every bean in context.",
      "explanation": "BeanPostProcessor wraps/modifies beans after creation. Used internally for AOP, @Autowired, and other Spring features.",
      "difficulty": "Hard",
      "code": "@Component\npublic class CustomBeanPostProcessor implements BeanPostProcessor {\n    \n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) {\n        System.out.println(\"Before init: \" + beanName);\n        return bean;\n    }\n    \n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) {\n        System.out.println(\"After init: \" + beanName);\n        \n        // Can return proxy\n        if (bean instanceof MyService) {\n            return Proxy.newProxyInstance(\n                bean.getClass().getClassLoader(),\n                bean.getClass().getInterfaces(),\n                (proxy, method, args) -> {\n                    System.out.println(\"Before: \" + method.getName());\n                    Object result = method.invoke(bean, args);\n                    System.out.println(\"After: \" + method.getName());\n                    return result;\n                }\n            );\n        }\n        return bean;\n    }\n}"
    },
    {
      "id": 39,
      "question": "What is Spring Boot Batch Processing?",
      "answer": "Spring Batch provides framework for batch processing:\n\nKey concepts:\n• Job: Batch process\n• Step: Phase in job\n• ItemReader: Reads data\n• ItemProcessor: Transforms data\n• ItemWriter: Writes output\n• JobLauncher: Executes jobs\n\nFeatures: Transaction management, chunk processing, retry logic, parallel processing.",
      "explanation": "Spring Batch is for large-scale data processing - ETL, data migration, report generation. Chunk-based processing handles millions of records efficiently.",
      "difficulty": "Hard",
      "code": "@Configuration\n@EnableBatchProcessing\npublic class BatchConfig {\n    \n    @Bean\n    public Job importUserJob(JobRepository jobRepository, Step step1) {\n        return new JobBuilder(\"importUserJob\", jobRepository)\n            .start(step1)\n            .build();\n    }\n    \n    @Bean\n    public Step step1(JobRepository jobRepository,\n                      PlatformTransactionManager transactionManager) {\n        return new StepBuilder(\"step1\", jobRepository)\n            .<User, User>chunk(100, transactionManager)\n            .reader(reader())\n            .processor(processor())\n            .writer(writer())\n            .build();\n    }\n    \n    @Bean\n    public FlatFileItemReader<User> reader() {\n        return new FlatFileItemReaderBuilder<User>()\n            .name(\"userReader\")\n            .resource(new ClassPathResource(\"users.csv\"))\n            .delimited()\n            .names(\"id\", \"name\", \"email\")\n            .targetType(User.class)\n            .build();\n    }\n}"
    },
    {
      "id": 40,
      "question": "What is Spring Boot Retry mechanism?",
      "answer": "Spring Retry provides declarative retry support:\n\nKey features:\n• @Retryable: Method will retry on exception\n• @Recover: Fallback after retries exhausted\n• Configurable retry policies\n• Backoff strategies (fixed, exponential)\n\nUse cases:\n• Network calls\n• Database operations\n• External API calls\n• Transient failures",
      "explanation": "Retry pattern handles transient failures automatically. Use exponential backoff to avoid overwhelming failing services.",
      "difficulty": "Medium",
      "code": "@SpringBootApplication\n@EnableRetry\npublic class MyApp { }\n\n@Service\npublic class ExternalService {\n    \n    @Retryable(\n        retryFor = RestClientException.class,\n        maxAttempts = 3,\n        backoff = @Backoff(delay = 1000)\n    )\n    public String callExternalApi() {\n        return restTemplate.getForObject(apiUrl, String.class);\n    }\n    \n    @Retryable(\n        retryFor = RestClientException.class,\n        maxAttempts = 5,\n        backoff = @Backoff(\n            delay = 1000,\n            multiplier = 2.0,\n            maxDelay = 10000\n        )\n    )\n    public String callWithBackoff() {\n        return restTemplate.getForObject(apiUrl, String.class);\n    }\n    \n    @Recover\n    public String recover(RestClientException e) {\n        return \"Default data\";\n    }\n}"
    },
    {
      "id": 41,
      "question": "What is Spring Boot Testing (@SpringBootTest)?",
      "answer": "@SpringBootTest loads full application context for integration tests:\n\nFeatures:\n• Loads all beans\n• Auto-configuration\n• Random ports for web tests\n• @MockBean to mock dependencies\n\nWeb environment modes:\n• MOCK: Mock servlet environment\n• RANDOM_PORT: Real server on random port\n• DEFINED_PORT: server.port\n• NONE: No web environment",
      "explanation": "@SpringBootTest is heaviest test - loads entire context. Use @WebMvcTest or @DataJpaTest for faster unit tests of specific layers.",
      "difficulty": "Medium",
      "code": "@SpringBootTest\nclass UserServiceTest {\n    @Autowired\n    private UserService userService;\n    \n    @Test\n    void testFindUser() {\n        User user = userService.findById(1L);\n        assertNotNull(user);\n    }\n}\n\n// Web integration test\n@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)\nclass UserControllerIntegrationTest {\n    @Autowired\n    private TestRestTemplate restTemplate;\n    \n    @Test\n    void testGetUsers() {\n        ResponseEntity<User[]> response = \n            restTemplate.getForEntity(\"/api/users\", User[].class);\n        assertEquals(HttpStatus.OK, response.getStatusCode());\n    }\n}\n\n// Mock dependency\n@SpringBootTest\nclass OrderServiceTest {\n    @MockBean\n    private PaymentService paymentService;\n    \n    @Autowired\n    private OrderService orderService;\n    \n    @Test\n    void testPlaceOrder() {\n        when(paymentService.process(any())).thenReturn(true);\n        Order order = orderService.placeOrder(new Order());\n        assertNotNull(order.getId());\n    }\n}"
    },
    {
      "id": 42,
      "question": "What is @WebMvcTest vs @DataJpaTest?",
      "answer": "Slice tests focus on specific layers:\n\n@WebMvcTest:\n• Tests MVC layer only\n• Loads @Controller, @ControllerAdvice\n• Auto-configures MockMvc\n• No service or repository beans\n\n@DataJpaTest:\n• Tests JPA repositories\n• In-memory database\n• Transactional (rolls back after test)\n• No web components",
      "explanation": "Slice tests are faster than @SpringBootTest - they load only relevant beans. Use them for focused unit testing.",
      "difficulty": "Medium",
      "code": "@WebMvcTest(UserController.class)\nclass UserControllerTest {\n    @Autowired\n    private MockMvc mockMvc;\n    \n    @MockBean\n    private UserService userService;\n    \n    @Test\n    void testGetUser() throws Exception {\n        User user = new User(1L, \"John\");\n        when(userService.findById(1L)).thenReturn(user);\n        \n        mockMvc.perform(get(\"/api/users/1\"))\n            .andExpect(status().isOk())\n            .andExpect(jsonPath(\"$.name\").value(\"John\"));\n    }\n}\n\n@DataJpaTest\nclass UserRepositoryTest {\n    @Autowired\n    private UserRepository userRepository;\n    \n    @Autowired\n    private TestEntityManager entityManager;\n    \n    @Test\n    void testFindByEmail() {\n        User user = new User(\"john@example.com\", \"John\");\n        entityManager.persist(user);\n        \n        User found = userRepository.findByEmail(\"john@example.com\");\n        assertEquals(\"John\", found.getName());\n    }\n}"
    },
    {
      "id": 43,
      "question": "What is Spring Boot Actuator Security?",
      "answer": "Securing Actuator endpoints:\n\nDefault behavior:\n• /actuator/health and /info: Public\n• Other endpoints: Secured\n\nMethods:\n• Spring Security\n• management.endpoints.web.exposure.include/exclude\n• Custom security rules\n\nBest practices:\n• Enable only needed endpoints\n• Use different port\n• Restrict by IP\n• Require authentication",
      "explanation": "Actuator exposes sensitive data. Always secure in production - use authentication and limit exposed endpoints.",
      "difficulty": "Medium",
      "code": "# application.properties\n# Expose specific endpoints\nmanagement.endpoints.web.exposure.include=health,info,metrics\n\n# Use different port\nmanagement.server.port=9090\n\n# Security\n@Configuration\npublic class ActuatorSecurity {\n    @Bean\n    public SecurityFilterChain actuatorSecurity(HttpSecurity http) throws Exception {\n        http\n            .securityMatcher(\"/actuator/**\")\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/actuator/health\").permitAll()\n                .requestMatchers(\"/actuator/**\").hasRole(\"ADMIN\")\n            )\n            .httpBasic();\n        return http.build();\n    }\n}\n\n# Restrict by IP\n@Configuration\npublic class ActuatorConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new HandlerInterceptor() {\n            public boolean preHandle(HttpServletRequest request, \n                                   HttpServletResponse response, \n                                   Object handler) {\n                String remoteAddr = request.getRemoteAddr();\n                if (!remoteAddr.startsWith(\"10.0.\")) {\n                    response.sendError(403);\n                    return false;\n                }\n                return true;\n            }\n        }).addPathPatterns(\"/actuator/**\");\n    }\n}"
    },
    {
      "id": 44,
      "question": "What is Spring Boot Externalized Configuration hierarchy?",
      "answer": "Configuration sources in order of precedence:\n\n1. Command line arguments\n2. SPRING_APPLICATION_JSON\n3. ServletConfig/ServletContext\n4. JNDI\n5. Java System properties\n6. OS environment variables\n7. application-{profile}.properties outside jar\n8. application-{profile}.properties inside jar\n9. application.properties outside jar\n10. application.properties inside jar\n11. @PropertySource\n12. Default properties",
      "explanation": "Higher in list overrides lower. Command line args have highest priority. Environment-specific configs override defaults.",
      "difficulty": "Medium",
      "code": "# 1. Command line\njava -jar app.jar --server.port=8081\n\n# 2. JSON in env var\nexport SPRING_APPLICATION_JSON='{\"server\":{\"port\":8081}}'\n\n# 3. System properties\njava -Dserver.port=8081 -jar app.jar\n\n# 4. Environment variables\nexport SERVER_PORT=8081\n\n# 5. application-prod.properties (external)\n./config/application-prod.properties\n\n# 6. application-prod.properties (classpath)\nsrc/main/resources/application-prod.properties\n\n# 7. application.properties (external)\n./application.properties\n\n# 8. application.properties (classpath)\nsrc/main/resources/application.properties\n\n# Test effective config\n@Component\npublic class ConfigChecker implements CommandLineRunner {\n    @Value(\"${server.port}\")\n    private int port;\n    \n    @Override\n    public void run(String... args) {\n        System.out.println(\"Server port: \" + port);\n    }\n}"
    },
    {
      "id": 45,
      "question": "What is Spring Boot @ConfigurationProperties validation?",
      "answer": "@ConfigurationProperties can be validated using JSR-380:\n\nValidation:\n• Add @Validated to class\n• Use constraint annotations\n• @NotNull, @Min, @Max, @Pattern\n• Nested object validation\n\nNested classes:\n• Need @Valid annotation\n\nFailure:\n• Application won't start if invalid\n• BindValidationException thrown",
      "explanation": "@ConfigurationProperties validation ensures configuration is correct at startup - fail fast principle. Better than runtime errors.",
      "difficulty": "Medium",
      "code": "@Configuration\n@ConfigurationProperties(prefix = \"app\")\n@Validated\npublic class AppProperties {\n    \n    @NotBlank\n    private String name;\n    \n    @Min(1000)\n    @Max(65535)\n    private int port;\n    \n    @Email\n    private String adminEmail;\n    \n    @Pattern(regexp = \"^(dev|test|prod)$\")\n    private String environment;\n    \n    @Valid\n    private Database database;\n    \n    public static class Database {\n        @NotBlank\n        private String url;\n        \n        @Min(1)\n        @Max(100)\n        private int poolSize;\n        \n        // getters/setters\n    }\n    \n    // getters/setters\n}\n\n# application.properties\napp.name=MyApp\napp.port=8080\napp.admin-email=admin@example.com\napp.environment=prod\napp.database.url=jdbc:mysql://localhost/mydb\napp.database.pool-size=20"
    },
    {
      "id": 46,
      "question": "What is Spring Boot GraphQL support?",
      "answer": "Spring Boot provides GraphQL integration:\n\nKey components:\n• GraphQL schema definition\n• @QueryMapping for queries\n• @MutationMapping for mutations\n• @SchemaMapping for nested data\n• DataLoader for N+1 prevention\n\nGraphiQL:\n• Interactive GraphQL IDE\n• Enabled in dev mode\n\nBenefits: Client-specific data, single endpoint, type safety.",
      "explanation": "GraphQL lets clients request exactly what they need. Spring Boot auto-configures GraphQL with schema-first approach.",
      "difficulty": "Hard",
      "code": "<!-- pom.xml -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-graphql</artifactId>\n</dependency>\n\n// schema.graphqls\ntype Query {\n    user(id: ID!): User\n    users: [User]\n}\n\ntype Mutation {\n    createUser(name: String!, email: String!): User\n}\n\ntype User {\n    id: ID!\n    name: String!\n    email: String!\n    posts: [Post]\n}\n\n@Controller\npublic class UserController {\n    \n    @QueryMapping\n    public User user(@Argument Long id) {\n        return userService.findById(id);\n    }\n    \n    @QueryMapping\n    public List<User> users() {\n        return userService.findAll();\n    }\n    \n    @MutationMapping\n    public User createUser(@Argument String name, @Argument String email) {\n        return userService.create(name, email);\n    }\n    \n    @SchemaMapping(typeName = \"User\")\n    public List<Post> posts(User user) {\n        return postService.findByUserId(user.getId());\n    }\n}"
    },
    {
      "id": 47,
      "question": "What is Spring Boot WebSocket support?",
      "answer": "Spring Boot provides WebSocket capabilities for real-time communication:\n\nKey components:\n• @EnableWebSocketMessageBroker\n• Message broker (STOMP)\n• @MessageMapping for handling messages\n• @SendTo for broadcasting\n• SimpMessagingTemplate for sending\n\nUse cases:\n• Chat applications\n• Live updates\n• Notifications\n• Real-time dashboards",
      "explanation": "WebSocket provides full-duplex communication. STOMP protocol simplifies messaging patterns. Great for push notifications.",
      "difficulty": "Hard",
      "code": "@Configuration\n@EnableWebSocketMessageBroker\npublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer {\n    \n    @Override\n    public void configureMessageBroker(MessageBrokerRegistry registry) {\n        registry.enableSimpleBroker(\"/topic\");\n        registry.setApplicationDestinationPrefixes(\"/app\");\n    }\n    \n    @Override\n    public void registerStompEndpoints(StompEndpointRegistry registry) {\n        registry.addEndpoint(\"/ws\").withSockJS();\n    }\n}\n\n@Controller\npublic class ChatController {\n    \n    @MessageMapping(\"/chat.send\")\n    @SendTo(\"/topic/messages\")\n    public ChatMessage send(ChatMessage message) {\n        return message;\n    }\n    \n    @Autowired\n    private SimpMessagingTemplate messagingTemplate;\n    \n    public void sendToUser(String username, ChatMessage message) {\n        messagingTemplate.convertAndSendToUser(\n            username, \"/queue/messages\", \n            message\n        );\n    }\n}\n\n// Client (JavaScript)\nconst socket = new SockJS('/ws');\nconst stompClient = Stomp.over(socket);\n\nstompClient.connect({}, () => {\n    stompClient.subscribe('/topic/messages', (message) => {\n        console.log(JSON.parse(message.body));\n    });\n    \n    stompClient.send('/app/chat.send', {}, \n        JSON.stringify({text: 'Hello'}));\n});"
    },
    {
      "id": 48,
      "question": "What is Spring Boot DevTools Remote Update?",
      "answer": "DevTools can connect to remote applications:\n\nSetup:\n• Enable remote secret\n• Run remote client\n• Secure connection\n\nFeatures:\n• Remote restart\n• Live reload\n• Remote debugging\n\nUse cases:\n• Cloud deployments\n• Docker containers\n• Testing environments\n\nSecurity: Use only in dev/test, not production.",
      "explanation": "Remote DevTools lets you develop against apps running in containers or cloud. Great for microservices development.",
      "difficulty": "Hard",
      "code": "# Remote app application.properties\nspring.devtools.remote.secret=mysecret\n\n<!-- pom.xml - remote app -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-devtools</artifactId>\n    <optional>false</optional>\n</dependency>\n\n<!-- Build with devtools -->\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n            <configuration>\n                <excludeDevtools>false</excludeDevtools>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n\n// Run remote client\njava -jar spring-boot-devtools-run.jar \\\n    --spring.devtools.remote.secret=mysecret \\\n    https://myapp.example.com\n\n// Or in IDE: Run RemoteSpringApplication\npublic class RemoteSpringApplication {\n    public static void main(String[] args) {\n        System.setProperty(\"spring.devtools.remote.secret\", \"mysecret\");\n        SpringApplication.run(RemoteSpringApplication.class, \n            \"https://myapp.example.com\");\n    }\n}"
    },
    {
      "id": 49,
      "question": "What is Spring Boot Custom Health Indicator?",
      "answer": "Custom health indicators check application-specific health:\n\nImplement HealthIndicator:\n• health() method returns Health\n• Status: UP, DOWN, OUT_OF_SERVICE, UNKNOWN\n• Include details\n\nAuto-discovered:\n• Suffix bean name with HealthIndicator\n\nUse cases:\n• Database connectivity\n• External API availability\n• Disk space\n• Custom requirements",
      "explanation": "Custom health indicators extend Actuator health endpoint. Use for monitoring critical dependencies - database, cache, external services.",
      "difficulty": "Medium",
      "code": "@Component\npublic class CustomHealthIndicator implements HealthIndicator {\n    \n    @Override\n    public Health health() {\n        try {\n            // Check something\n            if (checkExternalService()) {\n                return Health.up()\n                    .withDetail(\"service\", \"available\")\n                    .withDetail(\"responseTime\", \"50ms\")\n                    .build();\n            } else {\n                return Health.down()\n                    .withDetail(\"service\", \"unavailable\")\n                    .withDetail(\"error\", \"Connection timeout\")\n                    .build();\n            }\n        } catch (Exception e) {\n            return Health.down(e).build();\n        }\n    }\n}\n\n@Component\npublic class DatabaseHealthIndicator implements HealthIndicator {\n    @Autowired\n    private DataSource dataSource;\n    \n    @Override\n    public Health health() {\n        try (Connection conn = dataSource.getConnection()) {\n            if (conn.isValid(1)) {\n                return Health.up()\n                    .withDetail(\"database\", \"PostgreSQL\")\n                    .withDetail(\"validationQuery\", \"SELECT 1\")\n                    .build();\n            }\n        } catch (SQLException e) {\n            return Health.down(e).build();\n        }\n        return Health.unknown().build();\n    }\n}"
    },
    {
      "id": 50,
      "question": "What is Spring Boot Custom Metrics?",
      "answer": "Custom metrics track application-specific data:\n\nMicrometer:\n• Counter: Incrementing values\n• Gauge: Current value\n• Timer: Time duration\n• Distribution Summary: Distribution data\n\nInject MeterRegistry:\n• Create metrics\n• Add tags for dimensions\n\nExported to:\n• Prometheus, Graphite, InfluxDB\n• Through Actuator /metrics",
      "explanation": "Custom metrics provide business insights - orders processed, login attempts, cache hits. Use tags for filtering and aggregation.",
      "difficulty": "Medium",
      "code": "@Service\npublic class OrderService {\n    private final Counter orderCounter;\n    private final Timer orderTimer;\n    private final AtomicInteger activeOrders;\n    \n    public OrderService(MeterRegistry registry) {\n        this.orderCounter = Counter.builder(\"orders.created\")\n            .description(\"Total orders created\")\n            .tag(\"type\", \"online\")\n            .register(registry);\n            \n        this.orderTimer = Timer.builder(\"orders.processing.time\")\n            .description(\"Order processing time\")\n            .register(registry);\n            \n        this.activeOrders = registry.gauge(\n            \"orders.active\", \n            new AtomicInteger(0)\n        );\n    }\n    \n    public Order createOrder(Order order) {\n        return orderTimer.record(() -> {\n            activeOrders.incrementAndGet();\n            Order created = orderRepository.save(order);\n            orderCounter.increment();\n            activeOrders.decrementAndGet();\n            return created;\n        });\n    }\n}\n\n// Access metrics\n// GET /actuator/metrics/orders.created\n// GET /actuator/metrics/orders.processing.time"
    },
    {
      "id": 51,
      "question": "What is Spring Boot @Transactional and propagation?",
      "answer": "@Transactional manages database transactions:\n\nPropagation types:\n• REQUIRED (default): Use existing or create new\n• REQUIRES_NEW: Always create new, suspend current\n• MANDATORY: Must have existing transaction\n• SUPPORTS: Use if exists, non-transactional otherwise\n• NOT_SUPPORTED: Execute non-transactionally\n• NEVER: Throw exception if transaction exists\n• NESTED: Nested transaction with savepoint\n\nIsolation levels also configurable.",
      "explanation": "@Transactional ensures ACID properties. REQUIRED is most common. REQUIRES_NEW useful for independent operations like logging.",
      "difficulty": "Hard",
      "code": "@Service\npublic class OrderService {\n    \n    @Transactional\n    public void placeOrder(Order order) {\n        orderRepository.save(order);\n        inventoryService.reduceStock(order.getItems());\n        // Both operations in same transaction\n    }\n    \n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    public void createAuditLog(String action) {\n        // Always new transaction\n        // Commits even if parent transaction rolls back\n        auditRepository.save(new AuditLog(action));\n    }\n    \n    @Transactional(\n        isolation = Isolation.SERIALIZABLE,\n        timeout = 30,\n        rollbackFor = Exception.class\n    )\n    public void complexOperation() {\n        // Highest isolation level\n        // Timeout after 30 seconds\n        // Rollback on any exception\n    }\n}\n\n@Service\npublic class PaymentService {\n    @Transactional(propagation = Propagation.MANDATORY)\n    public void processPayment(Payment payment) {\n        // Must be called within existing transaction\n        // Throws exception if no transaction\n    }\n}"
    },
    {
      "id": 52,
      "question": "What is Spring Boot @ControllerAdvice?",
      "answer": "@ControllerAdvice provides global exception handling:\n\nFeatures:\n• @ExceptionHandler: Handle exceptions\n• @ModelAttribute: Add model attributes\n• @InitBinder: Configure data binding\n\nScope:\n• Global by default\n• Can limit with annotations() or basePackages()\n\nBest practice:\n• Create custom error responses\n• Log exceptions\n• Return appropriate HTTP status",
      "explanation": "@ControllerAdvice centralizes exception handling across all controllers. Avoids repetitive try-catch blocks.",
      "difficulty": "Medium",
      "code": "@ControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    @ExceptionHandler(ResourceNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleNotFound(\n            ResourceNotFoundException ex) {\n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.NOT_FOUND.value(),\n            ex.getMessage(),\n            LocalDateTime.now()\n        );\n        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);\n    }\n    \n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity<Map<String, String>> handleValidation(\n            MethodArgumentNotValidException ex) {\n        Map<String, String> errors = new HashMap<>();\n        ex.getBindingResult().getFieldErrors().forEach(error ->\n            errors.put(error.getField(), error.getDefaultMessage())\n        );\n        return new ResponseEntity<>(errors, HttpStatus.BAD_REQUEST);\n    }\n    \n    @ExceptionHandler(Exception.class)\n    public ResponseEntity<ErrorResponse> handleGeneral(Exception ex) {\n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.INTERNAL_SERVER_ERROR.value(),\n            \"Internal server error\",\n            LocalDateTime.now()\n        );\n        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n}"
    },
    {
      "id": 53,
      "question": "What is Spring Boot @Conditional annotations?",
      "answer": "Conditional annotations control bean registration:\n\n@ConditionalOnClass:\n• Bean registered if class is on classpath\n\n@ConditionalOnProperty:\n• Based on configuration property\n\n@ConditionalOnMissingClass:\n• If class is NOT on classpath\n\n@ConditionalOnExpression:\n• SpEL expression evaluation\n\n@ConditionalOnWebApplication:\n• Only in web applications\n\nUsed extensively in auto-configuration.",
      "explanation": "Conditional annotations make configurations flexible. Core of Spring Boot's auto-configuration magic.",
      "difficulty": "Medium",
      "code": "@Configuration\npublic class DatabaseConfig {\n    \n    @Bean\n    @ConditionalOnClass(name = \"org.postgresql.Driver\")\n    public DataSource postgresDataSource() {\n        return new PostgresDataSource();\n    }\n    \n    @Bean\n    @ConditionalOnProperty(\n        name = \"cache.enabled\",\n        havingValue = \"true\"\n    )\n    public CacheManager cacheManager() {\n        return new ConcurrentMapCacheManager();\n    }\n    \n    @Bean\n    @ConditionalOnMissingBean(DataSource.class)\n    public DataSource defaultDataSource() {\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.H2)\n            .build();\n    }\n    \n    @Bean\n    @ConditionalOnExpression(\n        \"${feature.enabled:false} and ${environment} == 'prod'\"\n    )\n    public FeatureService featureService() {\n        return new FeatureService();\n    }\n    \n    @Bean\n    @ConditionalOnWebApplication(type = Type.SERVLET)\n    public WebFilter webFilter() {\n        return new CustomWebFilter();\n    }\n}"
    },
    {
      "id": 54,
      "question": "What is Spring Boot OAuth2 Resource Server?",
      "answer": "Resource Server validates JWT tokens from Authorization Server:\n\nSetup:\n• Add spring-boot-starter-oauth2-resource-server\n• Configure JWT issuer URI\n• Security configuration\n\nFeatures:\n• JWT validation\n• Scope-based authorization\n• Extract claims\n\nUse with:\n• Keycloak, Auth0, Okta\n• Custom OAuth2 server",
      "explanation": "Resource Server protects APIs with OAuth2 tokens. Clients get token from auth server, include in requests.",
      "difficulty": "Hard",
      "code": "<!-- pom.xml -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>\n</dependency>\n\n# application.properties\nspring.security.oauth2.resourceserver.jwt.issuer-uri=https://auth.example.com\n\n@Configuration\n@EnableMethodSecurity\npublic class SecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/public/**\").permitAll()\n                .anyRequest().authenticated()\n            )\n            .oauth2ResourceServer(oauth2 -> oauth2.jwt());\n        return http.build();\n    }\n}\n\n@RestController\npublic class UserController {\n    \n    @GetMapping(\"/user/profile\")\n    public Map<String, Object> getProfile(JwtAuthenticationToken auth) {\n        Map<String, Object> claims = auth.getToken().getClaims();\n        return Map.of(\n            \"username\", claims.get(\"preferred_username\"),\n            \"email\", claims.get(\"email\")\n        );\n    }\n    \n    @PreAuthorize(\"hasAuthority('SCOPE_read')\")\n    @GetMapping(\"/data\")\n    public String getData() {\n        return \"Protected data\";\n    }\n}"
    },
    {
      "id": 55,
      "question": "What is Spring Boot Circuit Breaker (Resilience4j)?",
      "answer": "Circuit Breaker prevents cascading failures:\n\nStates:\n• CLOSED: Normal operation\n• OPEN: Calls fail immediately\n• HALF_OPEN: Test if service recovered\n\nConfiguration:\n• Failure threshold\n• Wait duration\n• Sliding window\n\nFallback:\n• Return default value\n• Alternative service\n\nBetter than simple retry for external services.",
      "explanation": "Circuit breaker stops calling failing service - gives it time to recover. Essential for microservices resilience.",
      "difficulty": "Hard",
      "code": "<!-- pom.xml -->\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>\n</dependency>\n\n# application.yml\nresilience4j.circuitbreaker:\n  instances:\n    backendA:\n      sliding-window-size: 10\n      failure-rate-threshold: 50\n      wait-duration-in-open-state: 10000\n      permitted-number-of-calls-in-half-open-state: 3\n\n@Service\npublic class ExternalService {\n    @Autowired\n    private CircuitBreakerFactory circuitBreakerFactory;\n    \n    public String callExternalApi() {\n        CircuitBreaker cb = circuitBreakerFactory.create(\"backendA\");\n        return cb.run(\n            () -> restTemplate.getForObject(apiUrl, String.class),\n            throwable -> \"Fallback response\"\n        );\n    }\n}\n\n// Or with annotation\n@Service\npublic class PaymentService {\n    @CircuitBreaker(name = \"payment\", fallbackMethod = \"paymentFallback\")\n    public Payment processPayment(Payment payment) {\n        return paymentGateway.process(payment);\n    }\n    \n    public Payment paymentFallback(Payment payment, Exception e) {\n        return new Payment(\"PENDING\");\n    }\n}"
    },
    {
      "id": 56,
      "question": "What is Spring Boot Rate Limiting?",
      "answer": "Rate limiting controls request frequency:\n\nApproaches:\n• Bucket4j: Token bucket algorithm\n• Redis: Distributed rate limiting\n• Resilience4j RateLimiter\n• Custom Filter\n\nStrategies:\n• Per user\n• Per IP\n• Per API endpoint\n• Global\n\nResponse:\n• 429 Too Many Requests\n• Retry-After header",
      "explanation": "Rate limiting protects APIs from abuse and overload. Essential for public APIs. Use distributed (Redis) for clustered apps.",
      "difficulty": "Hard",
      "code": "<!-- Bucket4j -->\n<dependency>\n    <groupId>com.github.vladimir-bukhtoyarov</groupId>\n    <artifactId>bucket4j-core</artifactId>\n</dependency>\n\n@Component\npublic class RateLimitFilter extends OncePerRequestFilter {\n    \n    private final Map<String, Bucket> cache = new ConcurrentHashMap<>();\n    \n    private Bucket createBucket() {\n        Bandwidth limit = Bandwidth.classic(10, \n            Refill.intervally(10, Duration.ofMinutes(1)));\n        return Bucket.builder()\n            .addLimit(limit)\n            .build();\n    }\n    \n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                    HttpServletResponse response,\n                                    FilterChain filterChain) {\n        String key = request.getRemoteAddr();\n        Bucket bucket = cache.computeIfAbsent(key, k -> createBucket());\n        \n        if (bucket.tryConsume(1)) {\n            filterChain.doFilter(request, response);\n        } else {\n            response.setStatus(429);\n            response.setHeader(\"Retry-After\", \"60\");\n            response.getWriter().write(\"Too many requests\");\n        }\n    }\n}\n\n// With Resilience4j\n@Service\npublic class ApiService {\n    @RateLimiter(name = \"default\")\n    public String callApi() {\n        return externalApi.getData();\n    }\n}"
    },
    {
      "id": 57,
      "question": "What is Spring Boot @ConfigurationPropertiesScan?",
      "answer": "@ConfigurationPropertiesScan auto-detects configuration classes:\n\nInstead of:\n• @EnableConfigurationProperties on each class\n\nUse:\n• @ConfigurationPropertiesScan on main class\n• Scans for @ConfigurationProperties\n\nBenefits:\n• Less boilerplate\n• Auto-discovery\n• Cleaner code\n\nSimilar to @ComponentScan for @Component.",
      "explanation": "@ConfigurationPropertiesScan simplifies registration - no need to explicitly enable each properties class.",
      "difficulty": "Easy",
      "code": "@SpringBootApplication\n@ConfigurationPropertiesScan\npublic class MyApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApplication.class, args);\n    }\n}\n\n// Now these are auto-detected\n@ConfigurationProperties(prefix = \"app\")\npublic class AppProperties {\n    private String name;\n    private int timeout;\n    // getters/setters\n}\n\n@ConfigurationProperties(prefix = \"database\")\npublic class DatabaseProperties {\n    private String url;\n    private String username;\n    // getters/setters\n}\n\n// Before (without @ConfigurationPropertiesScan)\n@Configuration\n@EnableConfigurationProperties({\n    AppProperties.class,\n    DatabaseProperties.class\n})\npublic class PropertiesConfig { }"
    },
    {
      "id": 58,
      "question": "What is Spring Boot Lazy Initialization?",
      "answer": "Lazy initialization delays bean creation until first use:\n\nConfiguration:\n• spring.main.lazy-initialization=true\n• @Lazy annotation\n\nBenefits:\n• Faster startup time\n• Lower initial memory\n\nDrawbacks:\n• First request slower\n• Errors discovered late\n• Not suitable for all scenarios\n\nUse for: Development, large applications.",
      "explanation": "Lazy init speeds up startup but delays errors. Good for dev mode. Production apps should start fully initialized.",
      "difficulty": "Medium",
      "code": "# application.properties\nspring.main.lazy-initialization=true\n\n// Selective lazy initialization\n@Configuration\npublic class AppConfig {\n    \n    @Bean\n    @Lazy\n    public ExpensiveBean expensiveBean() {\n        return new ExpensiveBean();\n    }\n    \n    @Bean  // Eager by default\n    public CriticalBean criticalBean() {\n        return new CriticalBean();\n    }\n}\n\n@Service\n@Lazy(false)  // Override global lazy setting\npublic class EagerService {\n    public EagerService() {\n        System.out.println(\"Created at startup\");\n    }\n}\n\n// Lazy dependency injection\n@Service\npublic class UserService {\n    private final EmailService emailService;\n    \n    public UserService(@Lazy EmailService emailService) {\n        this.emailService = emailService;\n    }\n    // emailService created only when first used\n}"
    },
    {
      "id": 59,
      "question": "What is Spring Boot Custom Banner?",
      "answer": "Custom banner displayed at application startup:\n\nMethods:\n• banner.txt in resources\n• banner.gif, banner.jpg, banner.png\n• Programmatic Banner interface\n\nVariables:\n• ${application.version}\n• ${spring-boot.version}\n• ${AnsiColor.GREEN}\n\nDisable:\n• spring.main.banner-mode=off",
      "explanation": "Custom banners add branding. Use ASCII art generators. Can include version info dynamically.",
      "difficulty": "Easy",
      "code": "// src/main/resources/banner.txt\n${AnsiColor.GREEN}\n███████╗███╗   ███╗ █████╗ ██████╗ ████████╗██╗     ██╗███████╗████████╗\n██╔════╝████╗ ████║██╔══██╗██╔══██╗╚══██╔══╝██║     ██║██╔════╝╚══██╔══╝\n███████╗██╔████╔██║███████║██████╔╝   ██║   ██║     ██║███████╗   ██║   \n╚════██║██║╚██╔╝██║██╔══██║██╔══██╗   ██║   ██║     ██║╚════██║   ██║   \n███████║██║ ╚═╝ ██║██║  ██║██║  ██║   ██║   ███████╗██║███████║   ██║   \n╚══════╝╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═╝╚══════╝   ╚═╝   \n${AnsiColor.DEFAULT}\nApplication Version: ${application.version}\nSpring Boot Version: ${spring-boot.version}\n\n// Programmatic banner\n@SpringBootApplication\npublic class MyApp {\n    public static void main(String[] args) {\n        SpringApplication app = new SpringApplication(MyApp.class);\n        app.setBanner(new Banner() {\n            @Override\n            public void printBanner(Environment env, \n                                  Class<?> sourceClass, \n                                  PrintStream out) {\n                out.println(\"==========================\");\n                out.println(\"   My Application v1.0    \");\n                out.println(\"==========================\");\n            }\n        });\n        app.run(args);\n    }\n}"
    },
    {
      "id": 60,
      "question": "What is Spring Boot JAR vs WAR packaging?",
      "answer": "Spring Boot supports two packaging formats:\n\nJAR (default):\n• Embedded server (Tomcat)\n• Self-contained executable\n• java -jar app.jar\n• Ideal for microservices, cloud\n\nWAR:\n• Deploy to external server\n• Traditional deployment\n• Extends SpringBootServletInitializer\n• For legacy environments\n\nJAR is recommended for new projects.",
      "explanation": "JAR is modern approach - no external server needed. WAR for existing Tomcat/WebLogic infrastructure.",
      "difficulty": "Easy",
      "code": "<!-- JAR (default) -->\n<project>\n    <packaging>jar</packaging>\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n\n// Run: java -jar myapp.jar\n\n<!-- WAR packaging -->\n<project>\n    <packaging>war</packaging>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-tomcat</artifactId>\n            <scope>provided</scope>\n        </dependency>\n    </dependencies>\n</project>\n\n// Main class for WAR\n@SpringBootApplication\npublic class MyApp extends SpringBootServletInitializer {\n    \n    @Override\n    protected SpringApplicationBuilder configure(\n            SpringApplicationBuilder application) {\n        return application.sources(MyApp.class);\n    }\n    \n    public static void main(String[] args) {\n        SpringApplication.run(MyApp.class, args);\n    }\n}"
    },
    {
      "id": 61,
      "question": "What is Spring Boot Micrometer Tracing?",
      "answer": "Micrometer Tracing provides distributed tracing:\n\nKey concepts:\n• Trace: Complete request flow\n• Span: Single operation\n• Trace ID: Unique identifier\n• Span ID: Operation identifier\n\nIntegrations:\n• Zipkin\n• Jaeger\n• Wavefront\n\nAuto-instrumentation for:\n• HTTP requests\n• Database calls\n• Message queues",
      "explanation": "Distributed tracing tracks requests across microservices. Essential for debugging complex distributed systems.",
      "difficulty": "Hard",
      "code": "<!-- pom.xml -->\n<dependency>\n    <groupId>io.micrometer</groupId>\n    <artifactId>micrometer-tracing-bridge-brave</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.zipkin.reporter2</groupId>\n    <artifactId>zipkin-reporter-brave</artifactId>\n</dependency>\n\n# application.properties\nmanagement.tracing.sampling.probability=1.0\nmanagement.zipkin.tracing.endpoint=http://localhost:9411/api/v2/spans\n\n@RestController\npublic class OrderController {\n    @Autowired\n    private Tracer tracer;\n    \n    @GetMapping(\"/orders/{id}\")\n    public Order getOrder(@PathVariable Long id) {\n        Span span = tracer.nextSpan().name(\"get-order\");\n        try (Tracer.SpanInScope ws = tracer.withSpan(span.start())) {\n            span.tag(\"orderId\", id.toString());\n            return orderService.findById(id);\n        } finally {\n            span.end();\n        }\n    }\n}\n\n// Custom span\n@Service\npublic class PaymentService {\n    @NewSpan(\"process-payment\")\n    public Payment process(@SpanTag(\"amount\") BigDecimal amount) {\n        // Automatically traced\n        return gateway.charge(amount);\n    }\n}"
    },
    {
      "id": 62,
      "question": "What is Spring Boot @JsonView?",
      "answer": "@JsonView filters JSON fields based on context:\n\nDefine views:\n• Interface markers\n• Public, Internal, Admin\n\nUse on:\n• Entity fields\n• Controller methods\n\nBenefits:\n• Same entity, different representations\n• No DTOs needed\n• Security: Hide sensitive fields\n\nJackson feature integrated in Spring Boot.",
      "explanation": "@JsonView provides different JSON representations without multiple DTOs. Good for APIs with varying detail levels.",
      "difficulty": "Medium",
      "code": "public class Views {\n    public static class Public {}\n    public static class Internal extends Public {}\n    public static class Admin extends Internal {}\n}\n\n@Entity\npublic class User {\n    @JsonView(Views.Public.class)\n    private Long id;\n    \n    @JsonView(Views.Public.class)\n    private String name;\n    \n    @JsonView(Views.Internal.class)\n    private String email;\n    \n    @JsonView(Views.Admin.class)\n    private String password;\n    \n    @JsonView(Views.Admin.class)\n    private LocalDateTime lastLogin;\n}\n\n@RestController\npublic class UserController {\n    \n    @GetMapping(\"/public/users/{id}\")\n    @JsonView(Views.Public.class)\n    public User getPublicUser(@PathVariable Long id) {\n        return userService.findById(id);\n        // Returns: id, name only\n    }\n    \n    @GetMapping(\"/api/users/{id}\")\n    @JsonView(Views.Internal.class)\n    public User getUser(@PathVariable Long id) {\n        return userService.findById(id);\n        // Returns: id, name, email\n    }\n    \n    @GetMapping(\"/admin/users/{id}\")\n    @JsonView(Views.Admin.class)\n    public User getAdminUser(@PathVariable Long id) {\n        return userService.findById(id);\n        // Returns: all fields\n    }\n}"
    },
    {
      "id": 63,
      "question": "What is Spring Boot @JsonProperty and naming strategies?",
      "answer": "@JsonProperty customizes JSON field names:\n\nStrategies:\n• SNAKE_CASE: user_name\n• LOWER_CAMEL_CASE: userName (default)\n• UPPER_CAMEL_CASE: UserName\n• KEBAB_CASE: user-name\n\nConfiguration:\n• Global: application.properties\n• Class: @JsonNaming\n• Field: @JsonProperty\n\nHandles:\n• Serialization (to JSON)\n• Deserialization (from JSON)",
      "explanation": "Naming strategies ensure consistent JSON format. @JsonProperty useful for legacy APIs with specific field names.",
      "difficulty": "Easy",
      "code": "# application.properties\nspring.jackson.property-naming-strategy=SNAKE_CASE\n\n// Entity with custom names\npublic class User {\n    @JsonProperty(\"user_id\")\n    private Long id;\n    \n    @JsonProperty(\"full_name\")\n    private String name;\n    \n    @JsonProperty(access = Access.WRITE_ONLY)\n    private String password;  // Only in requests, not responses\n    \n    @JsonProperty(access = Access.READ_ONLY)\n    private LocalDateTime createdAt;  // Only in responses\n}\n\n// Class-level naming\n@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)\npublic class Product {\n    private Long productId;  // Becomes: product_id\n    private String productName;  // Becomes: product_name\n    private BigDecimal unitPrice;  // Becomes: unit_price\n}\n\n// Different names for input/output\npublic class Order {\n    @JsonProperty(\"order_id\")\n    @JsonAlias({\"id\", \"orderId\"})  // Accept multiple names\n    private Long id;\n}"
    },
    {
      "id": 64,
      "question": "What is Spring Boot Custom Jackson Module?",
      "answer": "Custom Jackson modules extend JSON processing:\n\nUse cases:\n• Custom serializers\n• Custom deserializers\n• Mix-in annotations\n• Type handling\n\nRegistration:\n• Auto-detected as @Bean\n• Or Module subclass\n\nExamples:\n• Format dates\n• Encrypt fields\n• Custom types",
      "explanation": "Custom Jackson modules handle special serialization needs. Auto-discovered by Spring Boot.",
      "difficulty": "Hard",
      "code": "@Configuration\npublic class JacksonConfig {\n    \n    @Bean\n    public Module customModule() {\n        SimpleModule module = new SimpleModule();\n        module.addSerializer(Money.class, new MoneySerializer());\n        module.addDeserializer(Money.class, new MoneyDeserializer());\n        return module;\n    }\n}\n\npublic class MoneySerializer extends JsonSerializer<Money> {\n    @Override\n    public void serialize(Money value, JsonGenerator gen, \n                         SerializerProvider serializers) throws IOException {\n        gen.writeStartObject();\n        gen.writeNumberField(\"amount\", value.getAmount());\n        gen.writeStringField(\"currency\", value.getCurrency());\n        gen.writeEndObject();\n    }\n}\n\npublic class MoneyDeserializer extends JsonDeserializer<Money> {\n    @Override\n    public Money deserialize(JsonParser p, DeserializationContext ctxt) \n            throws IOException {\n        JsonNode node = p.getCodec().readTree(p);\n        BigDecimal amount = new BigDecimal(node.get(\"amount\").asText());\n        String currency = node.get(\"currency\").asText();\n        return new Money(amount, currency);\n    }\n}\n\n// Using custom type\npublic class Product {\n    private String name;\n    private Money price;  // Custom serialization\n}"
    },
    {
      "id": 65,
      "question": "What is Spring Boot Data REST?",
      "answer": "Spring Data REST exposes repositories as REST APIs:\n\nFeatures:\n• Auto-generate CRUD endpoints\n• HATEOAS links\n• Pagination and sorting\n• Custom queries as endpoints\n• HAL format\n\nMinimal code:\n• Just repository interface\n• No controller needed\n\nCustomization:\n• @RepositoryRestResource\n• Projections\n• Excerpts",
      "explanation": "Data REST great for rapid API development. Auto-generates RESTful endpoints from repositories. Perfect for CRUD operations.",
      "difficulty": "Medium",
      "code": "<!-- pom.xml -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-rest</artifactId>\n</dependency>\n\n@RepositoryRestResource(path = \"users\")\npublic interface UserRepository extends JpaRepository<User, Long> {\n    List<User> findByLastName(@Param(\"name\") String name);\n}\n// Automatically creates:\n// GET /users - list all\n// POST /users - create\n// GET /users/{id} - get one\n// PUT /users/{id} - update\n// DELETE /users/{id} - delete\n// GET /users/search/findByLastName?name=Smith\n\n# Configuration\nspring.data.rest.base-path=/api\nspring.data.rest.default-page-size=20\nspring.data.rest.max-page-size=100\n\n// Projection for partial data\n@Projection(name = \"summary\", types = User.class)\ninterface UserSummary {\n    String getName();\n    String getEmail();\n}\n\n// Access: GET /api/users/1?projection=summary\n\n// Hide repository\n@RepositoryRestResource(exported = false)\npublic interface InternalRepository extends JpaRepository<Internal, Long> { }"
    },
    {
      "id": 66,
      "question": "What is Spring Boot @Scheduled and Task Scheduling?",
      "answer": "@Scheduled executes methods at intervals:\n\nOptions:\n• fixedRate: Fixed interval\n• fixedDelay: Delay after completion\n• cron: Cron expression\n• initialDelay: Start delay\n\nConfiguration:\n• @EnableScheduling\n• Thread pool size\n\nUse cases:\n• Cleanup tasks\n• Report generation\n• Data synchronization\n• Health checks",
      "explanation": "@Scheduled for periodic tasks. Cron for complex schedules. fixedDelay for sequential execution.",
      "difficulty": "Easy",
      "code": "@SpringBootApplication\n@EnableScheduling\npublic class MyApp { }\n\n@Component\npublic class ScheduledTasks {\n    \n    // Every 5 seconds\n    @Scheduled(fixedRate = 5000)\n    public void reportStatus() {\n        System.out.println(\"Status check: \" + LocalDateTime.now());\n    }\n    \n    // 5 seconds after previous completion\n    @Scheduled(fixedDelay = 5000)\n    public void processQueue() {\n        System.out.println(\"Processing queue\");\n    }\n    \n    // Cron: Every day at 2 AM\n    @Scheduled(cron = \"0 0 2 * * ?\", zone = \"America/New_York\")\n    public void dailyReport() {\n        System.out.println(\"Generating daily report\");\n    }\n    \n    // Wait 10 seconds, then every 30 seconds\n    @Scheduled(initialDelay = 10000, fixedRate = 30000)\n    public void syncData() {\n        System.out.println(\"Syncing data\");\n    }\n}\n\n// Configure thread pool\n@Configuration\npublic class SchedulingConfig implements SchedulingConfigurer {\n    @Override\n    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {\n        taskRegistrar.setScheduler(taskExecutor());\n    }\n    \n    @Bean\n    public Executor taskExecutor() {\n        return Executors.newScheduledThreadPool(5);\n    }\n}"
    },
    {
      "id": 67,
      "question": "What is Spring Boot Security Method-Level?",
      "answer": "Method-level security secures individual methods:\n\nAnnotations:\n• @PreAuthorize: Before execution\n• @PostAuthorize: After execution\n• @Secured: Role-based\n• @RolesAllowed: JSR-250\n\nSpEL expressions:\n• hasRole(), hasAuthority()\n• authentication, principal\n• returnObject, #parameters\n\nEnab @EnableMethodSecurity",
      "explanation": "Method security adds fine-grained access control. Use SpEL for complex permission logic.",
      "difficulty": "Medium",
      "code": "@Configuration\n@EnableMethodSecurity\npublic class SecurityConfig { }\n\n@Service\npublic class UserService {\n    \n    @PreAuthorize(\"hasRole('ADMIN')\")\n    public void deleteUser(Long id) {\n        userRepository.deleteById(id);\n    }\n    \n    @PreAuthorize(\"hasAuthority('WRITE_PRIVILEGE')\")\n    public User createUser(User user) {\n        return userRepository.save(user);\n    }\n    \n    // Access own data\n    @PreAuthorize(\"#username == authentication.principal.username\")\n    public User getUser(String username) {\n        return userRepository.findByUsername(username);\n    }\n    \n    // Check returned object\n    @PostAuthorize(\"returnObject.owner == authentication.name\")\n    public Order getOrder(Long id) {\n        return orderRepository.findById(id).orElseThrow();\n    }\n    \n    // Multiple roles\n    @PreAuthorize(\"hasAnyRole('ADMIN', 'MANAGER')\")\n    public List<User> getAllUsers() {\n        return userRepository.findAll();\n    }\n    \n    // Custom expression\n    @PreAuthorize(\"@securityService.canAccessOrder(#orderId)\")\n    public Order updateOrder(Long orderId, Order order) {\n        return orderRepository.save(order);\n    }\n}"
    },
    {
      "id": 68,
      "question": "What is Spring Boot remember-me authentication?",
      "answer": "Remember-me provides persistent login:\n\nMechanisms:\n• Token-based: Hashed cookie\n• Persistent: Database storage\n\nConfiguration:\n• rememberMe() in SecurityFilterChain\n• Token validity duration\n• Cookie name\n• UserDetailsService\n\nSecurity:\n• Use HTTPS\n• Secure cookies\n• Token rotation",
      "explanation": "Remember-me keeps users logged in across sessions. Persistent tokens more secure but need database.",
      "difficulty": "Medium",
      "code": "@Configuration\npublic class SecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http,\n                                          UserDetailsService userDetailsService) \n            throws Exception {\n        http\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/login\").permitAll()\n                .anyRequest().authenticated()\n            )\n            .formLogin(form -> form\n                .loginPage(\"/login\")\n            )\n            .rememberMe(remember -> remember\n                .key(\"uniqueAndSecret\")\n                .tokenValiditySeconds(86400) // 1 day\n                .userDetailsService(userDetailsService)\n            );\n        return http.build();\n    }\n}\n\n// Login form with remember-me\n<form method=\"post\" action=\"/login\">\n    <input type=\"text\" name=\"username\" required />\n    <input type=\"password\" name=\"password\" required />\n    <input type=\"checkbox\" name=\"remember-me\" /> Remember me\n    <button type=\"submit\">Login</button>\n</form>\n\n// Persistent tokens (database)\n@Configuration\npublic class PersistentTokenConfig {\n    @Bean\n    public PersistentTokenRepository tokenRepository(DataSource dataSource) {\n        JdbcTokenRepositoryImpl tokenRepository = new JdbcTokenRepositoryImpl();\n        tokenRepository.setDataSource(dataSource);\n        return tokenRepository;\n    }\n}"
    },
    {
      "id": 69,
      "question": "What is Spring Boot @DataSourceConfiguration?",
      "answer": "Custom DataSource configuration for multiple databases:\n\nScenarios:\n• Multiple data sources\n• Read/write splitting\n• Sharding\n• Different databases\n\nConfiguration:\n• @Primary for default\n• Separate EntityManager\n• Transaction managers\n• Repository packages\n\nComplexity: Each datasource needs full config.",
      "explanation": "Multiple datasources for microservices with separate DBs or read replicas. Requires careful transaction management.",
      "difficulty": "Hard",
      "code": "@Configuration\npublic class DataSourceConfig {\n    \n    @Bean\n    @Primary\n    @ConfigurationProperties(\"spring.datasource.primary\")\n    public DataSourceProperties primaryDataSourceProperties() {\n        return new DataSourceProperties();\n    }\n    \n    @Bean\n    @Primary\n    @ConfigurationProperties(\"spring.datasource.primary.configuration\")\n    public DataSource primaryDataSource() {\n        return primaryDataSourceProperties()\n            .initializeDataSourceBuilder()\n            .build();\n    }\n    \n    @Bean\n    @ConfigurationProperties(\"spring.datasource.secondary\")\n    public DataSourceProperties secondaryDataSourceProperties() {\n        return new DataSourceProperties();\n    }\n    \n    @Bean\n    @ConfigurationProperties(\"spring.datasource.secondary.configuration\")\n    public DataSource secondaryDataSource() {\n        return secondaryDataSourceProperties()\n            .initializeDataSourceBuilder()\n            .build();\n    }\n}\n\n# application.properties\nspring.datasource.primary.url=jdbc:mysql://localhost/primary\nspring.datasource.primary.username=root\nspring.datasource.primary.password=password\n\nspring.datasource.secondary.url=jdbc:postgresql://localhost/secondary\nspring.datasource.secondary.username=postgres\nspring.datasource.secondary.password=password\n\n@Configuration\n@EnableJpaRepositories(\n    basePackages = \"com.example.primary\",\n    entityManagerFactoryRef = \"primaryEntityManagerFactory\",\n    transactionManagerRef = \"primaryTransactionManager\"\n)\npublic class PrimaryJpaConfig {\n    // EntityManager and TransactionManager config\n}"
    },
    {
      "id": 70,
      "question": "What is Spring Boot @TestPropertySource?",
      "answer": "@TestPropertySource overrides properties in tests:\n\nUsage:\n• Inline properties\n• External files\n• Override application.properties\n\nScope:\n• Test class level\n• Test method (with @DynamicPropertySource)\n\nUse cases:\n• Test-specific config\n• Mock URLs\n• Override credentials\n• Feature flags",
      "explanation": "@TestPropertySource isolates test config from application config. Essential for integration tests.",
      "difficulty": "Easy",
      "code": "@SpringBootTest\n@TestPropertySource(properties = {\n    \"spring.datasource.url=jdbc:h2:mem:testdb\",\n    \"app.feature.enabled=true\",\n    \"external.api.url=http://mock-api:8080\"\n})\nclass UserServiceTest {\n    @Value(\"${app.feature.enabled}\")\n    private boolean featureEnabled;\n    \n    @Test\n    void testWithCustomProps() {\n        assertTrue(featureEnabled);\n    }\n}\n\n// Use external file\n@SpringBootTest\n@TestPropertySource(locations = \"classpath:test.properties\")\nclass IntegrationTest { }\n\n// Override specific profile\n@SpringBootTest\n@ActiveProfiles(\"test\")\n@TestPropertySource(\n    locations = \"classpath:application-test.properties\",\n    properties = \"logging.level.com.example=DEBUG\"\n)\nclass DebugTest { }\n\n// Dynamic properties (e.g., Testcontainers)\n@SpringBootTest\nclass ContainerTest {\n    @Container\n    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>(\"postgres:15\");\n    \n    @DynamicPropertySource\n    static void properties(DynamicPropertyRegistry registry) {\n        registry.add(\"spring.datasource.url\", postgres::getJdbcUrl);\n        registry.add(\"spring.datasource.username\", postgres::getUsername);\n        registry.add(\"spring.datasource.password\", postgres::getPassword);\n    }\n}"
    },
    {
      "id": 71,
      "question": "What is Spring Boot Testcontainers integration?",
      "answer": "Testcontainers provides real services in Docker for tests:\n\nBenefits:\n• Real databases, not mocks\n• Kafka, Redis, etc.\n• Isolated test environment\n• Disposable containers\n\nSetup:\n• @Container annotation\n• @DynamicPropertySource\n• JUnit 5 integration\n\nAuto-cleanup after tests.\n\nBetter than embedded alternatives for integration tests.",
      "explanation": "Testcontainers use Docker for real dependencies in tests. More realistic than H2/embedded. Essential for integration testing.",
      "difficulty": "Hard",
      "code": "<!-- pom.xml -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-testcontainers</artifactId>\n    <scope>test</scope>\n</dependency>\n<dependency>\n    <groupId>org.testcontainers</groupId>\n    <artifactId>postgresql</artifactId>\n    <scope>test</scope>\n</dependency>\n<dependency>\n    <groupId>org.testcontainers</groupId>\n    <artifactId>junit-jupiter</artifactId>\n    <scope>test</scope>\n</dependency>\n\n@SpringBootTest\n@Testcontainers\nclass UserRepositoryTest {\n    \n    @Container\n    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>(\"postgres:15\")\n        .withDatabaseName(\"testdb\")\n        .withUsername(\"test\")\n        .withPassword(\"test\");\n    \n    @DynamicPropertySource\n    static void configureProperties(DynamicPropertyRegistry registry) {\n        registry.add(\"spring.datasource.url\", postgres::getJdbcUrl);\n        registry.add(\"spring.datasource.username\", postgres::getUsername);\n        registry.add(\"spring.datasource.password\", postgres::getPassword);\n    }\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    @Test\n    void testSaveUser() {\n        User user = new User(\"john@example.com\", \"John\");\n        User saved = userRepository.save(user);\n        assertNotNull(saved.getId());\n    }\n}\n\n// Multiple containers\n@SpringBootTest\n@Testcontainers\nclass IntegrationTest {\n    @Container\n    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>(\"postgres:15\");\n    \n    @Container\n    static GenericContainer<?> redis = new GenericContainer<>(\"redis:7\")\n        .withExposedPorts(6379);\n}"
    },
    {
      "id": 72,
      "question": "What is Spring Boot @Cacheable vs @CachePut vs @CacheEvict?",
      "answer": "Spring Cache annotations with different behaviors:\n\n@Cacheable:\n• Checks cache first\n• Executes if miss\n• Stores result\n\n@CachePut:\n• Always executes\n• Updates cache\n• For updates\n\n@CacheEvict:\n• Removes from cache\n• Use on delete/update\n• allEntries for clearing\n\n@Caching:\n• Combine multiple operations",
      "explanation": "@Cacheable for reads, @CachePut for updates that should update cache, @CacheEvict for deletes. Improves performance significantly.",
      "difficulty": "Medium",
      "code": "@Service\npublic class ProductService {\n    \n    @Cacheable(value = \"products\", key = \"#id\")\n    public Product findById(Long id) {\n        // Only called on cache miss\n        return productRepository.findById(id).orElseThrow();\n    }\n    \n    @Cacheable(value = \"products\", key = \"#name\", \n               unless = \"#result == null\")\n    public Product findByName(String name) {\n        // Don't cache null results\n        return productRepository.findByName(name);\n    }\n    \n    @CachePut(value = \"products\", key = \"#product.id\")\n    public Product update(Product product) {\n        // Always executes, updates cache\n        return productRepository.save(product);\n    }\n    \n    @CacheEvict(value = \"products\", key = \"#id\")\n    public void delete(Long id) {\n        // Removes from cache\n        productRepository.deleteById(id);\n    }\n    \n    @CacheEvict(value = \"products\", allEntries = true)\n    public void deleteAll() {\n        // Clears entire cache\n        productRepository.deleteAll();\n    }\n    \n    @Caching(\n        put = {@CachePut(value = \"products\", key = \"#product.id\")},\n        evict = {@CacheEvict(value = \"productList\", allEntries = true)}\n    )\n    public Product save(Product product) {\n        return productRepository.save(product);\n    }\n}"
    },
    {
      "id": 73,
      "question": "What is Spring Boot Redis Cache?",
      "answer": "Redis as distributed cache for Spring Boot:\n\nSetup:\n• spring-boot-starter-data-redis\n• spring-boot-starter-cache\n• RedisCacheManager\n\nFeatures:\n• Distributed caching\n• TTL support\n• Serialization (JSON, JDK)\n• Pub/sub\n\nBetter than local cache for:\n• Multiple instances\n• Microservices\n• Session sharing",
      "explanation": "Redis cache shared across application instances. Essential for clustered/cloud deployments. Configure TTL per cache.",
      "difficulty": "Medium",
      "code": "<!-- pom.xml -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-cache</artifactId>\n</dependency>\n\n# application.properties\nspring.data.redis.host=localhost\nspring.data.redis.port=6379\nspring.cache.type=redis\nspring.cache.redis.time-to-live=600000\n\n@Configuration\n@EnableCaching\npublic class CacheConfig {\n    \n    @Bean\n    public RedisCacheConfiguration cacheConfiguration() {\n        return RedisCacheConfiguration.defaultCacheConfig()\n            .entryTtl(Duration.ofMinutes(10))\n            .disableCachingNullValues()\n            .serializeValuesWith(\n                RedisSerializationContext.SerializationPair.fromSerializer(\n                    new GenericJackson2JsonRedisSerializer()\n                )\n            );\n    }\n    \n    @Bean\n    public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {\n        Map<String, RedisCacheConfiguration> cacheConfigs = new HashMap<>();\n        cacheConfigs.put(\"users\", \n            RedisCacheConfiguration.defaultCacheConfig()\n                .entryTtl(Duration.ofMinutes(30)));\n        cacheConfigs.put(\"products\", \n            RedisCacheConfiguration.defaultCacheConfig()\n                .entryTtl(Duration.ofHours(1)));\n        \n        return RedisCacheManager.builder(connectionFactory)\n            .cacheDefaults(cacheConfiguration())\n            .withInitialCacheConfigurations(cacheConfigs)\n            .build();\n    }\n}"
    },
    {
      "id": 74,
      "question": "What is Spring Boot Session Management with Redis?",
      "answer": "Spring Session stores HTTP sessions in Redis:\n\nBenefits:\n• Shared sessions across instances\n• Stateless application servers\n• Session failover\n• Scalability\n\nSetup:\n• spring-session-data-redis\n• @EnableRedisHttpSession\n• Auto-configuration\n\nTransparent to application code.\n\nEssential for cloud deployments.",
      "explanation": "Redis session sharing enables horizontal scaling. No sticky sessions needed. Session survives server restarts.",
      "difficulty": "Medium",
      "code": "<!-- pom.xml -->\n<dependency>\n    <groupId>org.springframework.session</groupId>\n    <artifactId>spring-session-data-redis</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n\n# application.properties\nspring.data.redis.host=localhost\nspring.data.redis.port=6379\nspring.session.store-type=redis\nspring.session.redis.namespace=spring:session\nserver.servlet.session.timeout=30m\n\n@Configuration\n@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 1800)\npublic class SessionConfig { }\n\n@RestController\npublic class SessionController {\n    \n    @GetMapping(\"/set-session\")\n    public String setSession(HttpSession session) {\n        session.setAttribute(\"user\", \"John\");\n        session.setAttribute(\"loginTime\", LocalDateTime.now());\n        return \"Session created: \" + session.getId();\n    }\n    \n    @GetMapping(\"/get-session\")\n    public Map<String, Object> getSession(HttpSession session) {\n        return Map.of(\n            \"sessionId\", session.getId(),\n            \"user\", session.getAttribute(\"user\"),\n            \"loginTime\", session.getAttribute(\"loginTime\")\n        );\n    }\n    \n    @GetMapping(\"/invalidate\")\n    public String invalidate(HttpSession session) {\n        session.invalidate();\n        return \"Session invalidated\";\n    }\n}"
    },
    {
      "id": 75,
      "question": "What is Spring Boot Flyway database migration?",
      "answer": "Flyway manages database schema versions:\n\nFeatures:\n• SQL migration scripts\n• Version control\n• Auto-apply on startup\n• Rollback support\n• Team collaboration\n\nNaming: V1__Initial_schema.sql\n\nSchema history table tracks applied migrations.\n\nBest practice:\n• Never modify applied migrations\n• Always create new version",
      "explanation": "Flyway essential for database versioning. Migrations in VCS with code. Ensures all environments have same schema.",
      "difficulty": "Medium",
      "code": "<!-- pom.xml -->\n<dependency>\n    <groupId>org.flywaydb</groupId>\n    <artifactId>flyway-core</artifactId>\n</dependency>\n\n# application.properties\nspring.flyway.enabled=true\nspring.flyway.locations=classpath:db/migration\nspring.flyway.baseline-on-migrate=true\n\n# src/main/resources/db/migration/V1__Initial_schema.sql\nCREATE TABLE users (\n    id BIGSERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n# V2__Add_user_status.sql\nALTER TABLE users ADD COLUMN status VARCHAR(20) DEFAULT 'ACTIVE';\nCREATE INDEX idx_user_status ON users(status);\n\n# V3__Create_orders_table.sql\nCREATE TABLE orders (\n    id BIGSERIAL PRIMARY KEY,\n    user_id BIGINT REFERENCES users(id),\n    total DECIMAL(10, 2),\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n// Programmatic configuration\n@Configuration\npublic class FlywayConfig {\n    @Bean\n    public Flyway flyway(DataSource dataSource) {\n        Flyway flyway = Flyway.configure()\n            .dataSource(dataSource)\n            .locations(\"classpath:db/migration\")\n            .baselineOnMigrate(true)\n            .load();\n        flyway.migrate();\n        return flyway;\n    }\n}"
    },
    {
      "id": 76,
      "question": "What is Spring Boot Liquibase?",
      "answer": "Liquibase manages database changes with changelogs:\n\nFormats:\n• XML, YAML, JSON, SQL\n• Database-independent\n\nFeatures:\n• Rollback support\n• Conditional execution\n• Contexts and labels\n• Preconditions\n\nChangelog tracks what's applied.\n\nAlternative to Flyway - more features, more complex.",
      "explanation": "Liquibase more powerful than Flyway - supports rollback, preconditions. XML format database-independent.",
      "difficulty": "Medium",
      "code": "<!-- pom.xml -->\n<dependency>\n    <groupId>org.liquibase</groupId>\n    <artifactId>liquibase-core</artifactId>\n</dependency>\n\n# application.properties\nspring.liquibase.change-log=classpath:db/changelog/db.changelog-master.xml\n\n<!-- db/changelog/db.changelog-master.xml -->\n<databaseChangeLog\n    xmlns=\"http://www.liquibase.org/xml/ns/dbchangelog\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.liquibase.org/xml/ns/dbchangelog\n        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.20.xsd\">\n    \n    <changeSet id=\"1\" author=\"john\">\n        <createTable tableName=\"users\">\n            <column name=\"id\" type=\"bigint\" autoIncrement=\"true\">\n                <constraints primaryKey=\"true\"/>\n            </column>\n            <column name=\"username\" type=\"varchar(50)\">\n                <constraints nullable=\"false\" unique=\"true\"/>\n            </column>\n            <column name=\"email\" type=\"varchar(100)\">\n                <constraints nullable=\"false\"/>\n            </column>\n        </createTable>\n        <rollback>\n            <dropTable tableName=\"users\"/>\n        </rollback>\n    </changeSet>\n    \n    <changeSet id=\"2\" author=\"john\">\n        <addColumn tableName=\"users\">\n            <column name=\"status\" type=\"varchar(20)\" defaultValue=\"ACTIVE\"/>\n        </addColumn>\n    </changeSet>\n</databaseChangeLog>"
    },
    {
      "id": 77,
      "question": "What is Spring Boot Native Image with GraalVM?",
      "answer": "GraalVM compiles Spring Boot to native executable:\n\nBenefits:\n• Instant startup (milliseconds)\n• Low memory footprint\n• Small binary size\n• No JVM needed\n\nLimitations:\n• Build time longer\n• Reflection needs hints\n• Not all libraries supported\n\nSetup:\n• Spring Native\n• GraalVM\n• Build configuration",
      "explanation": "Native image perfect for serverless/containers - fast startup, low memory. Trade-off: longer build, some limitations.",
      "difficulty": "Hard",
      "code": "<!-- pom.xml -->\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.graalvm.buildtools</groupId>\n            <artifactId>native-maven-plugin</artifactId>\n        </plugin>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n            <configuration>\n                <image>\n                    <builder>paketobuildpacks/builder:tiny</builder>\n                    <env>\n                        <BP_NATIVE_IMAGE>true</BP_NATIVE_IMAGE>\n                    </env>\n                </image>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n\n# Build native image\nmvn -Pnative native:compile\n\n# Or with Spring Boot plugin\nmvn spring-boot:build-image\n\n# Run\n./target/myapp\n\n// Runtime hints for reflection\n@Configuration\n@RegisterReflectionForBinding(User.class)\npublic class AppConfig {\n    \n    @Bean\n    public RuntimeHintsRegistrar runtimeHintsRegistrar() {\n        return (hints, classLoader) -> {\n            hints.reflection()\n                .registerType(User.class, \n                    MemberCategory.INVOKE_PUBLIC_METHODS);\n        };\n    }\n}\n\n// Comparison\n// JVM: 3-5 seconds startup, 100-500 MB memory\n// Native: 0.05 seconds startup, 20-50 MB memory"
    },
    {
      "id": 78,
      "question": "What is Spring Boot @ConditionalOnCloudPlatform?",
      "answer": "@ConditionalOnCloudPlatform activates beans based on cloud environment:\n\nSupported platforms:\n• CLOUD_FOUNDRY\n• KUBERNETES\n• HEROKU\n• SAP\n• AZURE\n• AWS\n\nUse cases:\n• Cloud-specific config\n• Platform services\n• Conditional features\n\nDetects platform automatically.",
      "explanation": "@ConditionalOnCloudPlatform enables cloud-specific configurations. Auto-detects Kubernetes, Cloud Foundry, etc.",
      "difficulty": "Medium",
      "code": "@Configuration\npublic class CloudConfig {\n    \n    @Bean\n    @ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES)\n    public KubernetesService kubernetesService() {\n        return new KubernetesService();\n    }\n    \n    @Bean\n    @ConditionalOnCloudPlatform(CloudPlatform.CLOUD_FOUNDRY)\n    public CloudFoundryService cloudFoundryService() {\n        return new CloudFoundryService();\n    }\n    \n    @Bean\n    @ConditionalOnCloudPlatform(CloudPlatform.HEROKU)\n    public HerokuService herokuService() {\n        return new HerokuService();\n    }\n}\n\n// Check platform programmatically\n@Component\npublic class PlatformChecker implements CommandLineRunner {\n    @Override\n    public void run(String... args) {\n        CloudPlatform platform = CloudPlatform.getActive(new StandardEnvironment());\n        if (platform != null) {\n            System.out.println(\"Running on: \" + platform);\n        } else {\n            System.out.println(\"Not running on cloud platform\");\n        }\n    }\n}\n\n// Kubernetes-specific properties\n@Configuration\n@ConditionalOnCloudPlatform(CloudPlatform.KUBERNETES)\n@ConfigurationProperties(prefix = \"kubernetes\")\npublic class KubernetesProperties {\n    private String namespace;\n    private String serviceName;\n    // getters/setters\n}"
    },
    {
      "id": 79,
      "question": "What is Spring Boot @MockBean vs @SpyBean?",
      "answer": "Test annotations for mocking dependencies:\n\n@MockBean:\n• Creates mock - no real implementation\n• All behavior defined by when()\n• Replaces bean in context\n\n@SpyBean:\n• Wraps real bean\n• Real methods called unless stubbed\n• Partial mocking\n\nUse @MockBean for external dependencies.\nUse @SpyBean to verify real bean.",
      "explanation": "@MockBean for complete mocks (databases, APIs). @SpyBean for partial mocking - real logic with verification.",
      "difficulty": "Easy",
      "code": "@SpringBootTest\nclass OrderServiceTest {\n    \n    @Autowired\n    private OrderService orderService;\n    \n    @MockBean\n    private PaymentService paymentService;\n    \n    @MockBean\n    private EmailService emailService;\n    \n    @Test\n    void testPlaceOrder() {\n        // Mock external service\n        when(paymentService.charge(any())).thenReturn(true);\n        doNothing().when(emailService).sendConfirmation(any());\n        \n        Order order = orderService.placeOrder(new Order());\n        \n        assertNotNull(order.getId());\n        verify(paymentService).charge(any());\n        verify(emailService).sendConfirmation(any());\n    }\n}\n\n@SpringBootTest\nclass UserServiceTest {\n    \n    @SpyBean\n    private UserService userService;\n    \n    @Test\n    void testWithSpy() {\n        // Real method called\n        User user = userService.findById(1L);\n        \n        // Verify real method was called\n        verify(userService).findById(1L);\n        \n        // Can stub specific methods\n        doReturn(new User()).when(userService).findById(2L);\n    }\n}\n\n// Difference\n// @MockBean: when(mock.method()).thenReturn(value) - must stub everything\n// @SpyBean: Real methods work, can stub selectively"
    },
    {
      "id": 80,
      "question": "What is Spring Boot GraalVM Reachability Metadata?",
      "answer": "Reachability metadata helps GraalVM native compilation:\n\nTypes:\n• Reflection\n• Resources\n• JNI\n• Proxies\n• Serialization\n\nProvided by:\n• Spring Boot auto-configuration\n• Libraries\n• Manual configuration\n\nRepository:\n• graalvm-reachability-metadata\n• Community contributions\n\nEssential for native image success.",
      "explanation": "GraalVM needs hints for reflection/resources used dynamically. Spring Boot provides most. Custom code may need hints.",
      "difficulty": "Hard",
      "code": "// Runtime hints registration\n@Configuration\npublic class MyRuntimeHints implements RuntimeHintsRegistrar {\n    \n    @Override\n    public void registerHints(RuntimeHints hints, ClassLoader classLoader) {\n        // Reflection\n        hints.reflection()\n            .registerType(User.class, \n                MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS,\n                MemberCategory.INVOKE_PUBLIC_METHODS,\n                MemberCategory.DECLARED_FIELDS);\n        \n        // Resources\n        hints.resources()\n            .registerPattern(\"static/*\")\n            .registerPattern(\"templates/*.html\");\n        \n        // Serialization\n        hints.serialization()\n            .registerType(Order.class);\n        \n        // Proxies\n        hints.proxies()\n            .registerJdkProxy(UserRepository.class);\n    }\n}\n\n// Or use annotation\n@Configuration\n@RegisterReflectionForBinding({\n    User.class,\n    Order.class,\n    Product.class\n})\npublic class AppConfig { }\n\n// Test native configuration\n@SpringBootTest\n@ImportRuntimeHints(MyRuntimeHints.class)\nclass NativeTest {\n    @Test\n    void testReflection() throws Exception {\n        Class<?> clazz = Class.forName(\"com.example.User\");\n        Object instance = clazz.getDeclaredConstructor().newInstance();\n        assertNotNull(instance);\n    }\n}"
    },
    {
      "id": 81,
      "question": "What is Spring Boot Virtual Threads (Java 21)?",
      "answer": "Virtual threads enable lightweight concurrency:\n\nBenefits:\n• Millions of threads possible\n• Better resource utilization\n• Simpler than reactive\n• Blocking I/O efficient\n\nConfiguration:\n• spring.threads.virtual.enabled=true\n• Java 21+ required\n• Tomcat auto-uses virtual threads\n\nGreat for:\n• I/O-heavy applications\n• High concurrency",
      "explanation": "Virtual threads revolutionize Spring Boot concurrency. Thousands of blocking requests without thread pool exhaustion.",
      "difficulty": "Hard",
      "code": "# application.properties (Java 21+)\nspring.threads.virtual.enabled=true\n\n@SpringBootApplication\npublic class MyApp {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApp.class, args);\n    }\n}\n\n@RestController\npublic class UserController {\n    \n    @GetMapping(\"/users/{id}\")\n    public User getUser(@PathVariable Long id) throws InterruptedException {\n        // Blocking call - no problem with virtual threads\n        Thread.sleep(1000);\n        return userService.findById(id);\n    }\n    \n    @GetMapping(\"/external\")\n    public String callExternal() {\n        // Blocking HTTP call\n        return restTemplate.getForObject(externalUrl, String.class);\n    }\n}\n\n// Manual virtual thread usage\n@Service\npublic class AsyncService {\n    \n    public void processAsync() throws ExecutionException, InterruptedException {\n        try (ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()) {\n            List<Future<String>> futures = new ArrayList<>();\n            \n            for (int i = 0; i < 1000; i++) {\n                futures.add(executor.submit(() -> {\n                    Thread.sleep(1000);\n                    return \"Task completed: \" + Thread.currentThread();\n                }));\n            }\n            \n            for (Future<String> future : futures) {\n                System.out.println(future.get());\n            }\n        }\n    }\n}"
    },
    {
      "id": 82,
      "question": "What is Spring Boot Observability?",
      "answer": "Observability combines metrics, tracing, and logging:\n\nThree pillars:\n• Metrics: Micrometer\n• Tracing: Micrometer Tracing\n• Logging: Structured logs\n\nIntegrations:\n• Prometheus (metrics)\n• Zipkin/Jaeger (tracing)\n• ELK (logging)\n\nSpring Boot 3+ unified observability.\n\n@Observed for custom observations.",
      "explanation": "Observability essential for production. Unified API across metrics/tracing. Spring Boot auto-instruments common scenarios.",
      "difficulty": "Hard",
      "code": "<!-- pom.xml -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.micrometer</groupId>\n    <artifactId>micrometer-tracing-bridge-brave</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.micrometer</groupId>\n    <artifactId>micrometer-registry-prometheus</artifactId>\n</dependency>\n\n# application.properties\nmanagement.endpoints.web.exposure.include=health,info,metrics,prometheus\nmanagement.metrics.tags.application=${spring.application.name}\nmanagement.tracing.sampling.probability=1.0\nlogging.pattern.level=%5p [${spring.application.name:},%X{traceId:-},%X{spanId:-}]\n\n@Configuration\n@EnableObservability\npublic class ObservabilityConfig { }\n\n@Service\npublic class OrderService {\n    \n    @Observed(\n        name = \"orders.create\",\n        contextualName = \"create-order\",\n        lowCardinalityKeyValues = {\"operation\", \"create\"}\n    )\n    public Order createOrder(Order order) {\n        // Automatically creates metrics and traces\n        return orderRepository.save(order);\n    }\n}\n\n// Custom observation\n@Service\npublic class PaymentService {\n    @Autowired\n    private ObservationRegistry observationRegistry;\n    \n    public Payment process(Payment payment) {\n        return Observation.createNotStarted(\"payment.process\", observationRegistry)\n            .lowCardinalityKeyValue(\"type\", payment.getType())\n            .observe(() -> {\n                // Business logic\n                return gateway.charge(payment);\n            });\n    }\n}"
    },
    {
      "id": 83,
      "question": "What is Spring Boot HATEOAS?",
      "answer": "HATEOAS provides hypermedia links in REST responses:\n\nPrinciples:\n• Self-discoverable APIs\n• Links to related resources\n• HAL format\n• RepresentationModel\n\nBenefits:\n• API discoverability\n• Client decoupling\n• Navigation\n\nLinkbuilders:\n• linkTo(), methodOn()\n• WebMvcLinkBuilder",
      "explanation": "HATEOAS makes REST APIs self-documenting. Clients follow links instead of hardcoding URLs. True REST level 3.",
      "difficulty": "Hard",
      "code": "<!-- pom.xml -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-hateoas</artifactId>\n</dependency>\n\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    @GetMapping(\"/{id}\")\n    public EntityModel<User> getUser(@PathVariable Long id) {\n        User user = userService.findById(id);\n        \n        return EntityModel.of(user,\n            linkTo(methodOn(UserController.class).getUser(id)).withSelfRel(),\n            linkTo(methodOn(UserController.class).getOrders(id)).withRel(\"orders\"),\n            linkTo(methodOn(UserController.class).getAllUsers()).withRel(\"all-users\")\n        );\n    }\n    \n    @GetMapping\n    public CollectionModel<EntityModel<User>> getAllUsers() {\n        List<EntityModel<User>> users = userService.findAll().stream()\n            .map(user -> EntityModel.of(user,\n                linkTo(methodOn(UserController.class).getUser(user.getId())).withSelfRel()\n            ))\n            .collect(Collectors.toList());\n        \n        return CollectionModel.of(users,\n            linkTo(methodOn(UserController.class).getAllUsers()).withSelfRel()\n        );\n    }\n}\n\n// Response example:\n{\n  \"id\": 1,\n  \"name\": \"John\",\n  \"email\": \"john@example.com\",\n  \"_links\": {\n    \"self\": {\"href\": \"http://localhost:8080/api/users/1\"},\n    \"orders\": {\"href\": \"http://localhost:8080/api/users/1/orders\"},\n    \"all-users\": {\"href\": \"http://localhost:8080/api/users\"}\n  }\n}"
    },
    {
      "id": 84,
      "question": "What is Spring Boot Problem Details (RFC 7807)?",
      "answer": "Problem Details provides standard error responses:\n\nRFC 7807 format:\n• type: Error category URI\n• title: Short description\n• status: HTTP status code\n• detail: Detailed message\n• instance: Specific occurrence URI\n\nSpring Boot 3+ support:\n• ProblemDetail class\n• @ControllerAdvice\n• ErrorResponse\n\nConsistent error handling.",
      "explanation": "Problem Details standardizes error responses. Better than custom error formats. Built into Spring Boot 3.",
      "difficulty": "Medium",
      "code": "# application.properties\nspring.mvc.problemdetails.enabled=true\n\n@RestController\npublic class UserController {\n    \n    @GetMapping(\"/users/{id}\")\n    public User getUser(@PathVariable Long id) {\n        return userService.findById(id)\n            .orElseThrow(() -> new UserNotFoundException(id));\n    }\n}\n\n@ResponseStatus(HttpStatus.NOT_FOUND)\npublic class UserNotFoundException extends RuntimeException \n        implements ErrorResponse {\n    private final ProblemDetail problemDetail;\n    \n    public UserNotFoundException(Long id) {\n        this.problemDetail = ProblemDetail.forStatusAndDetail(\n            HttpStatus.NOT_FOUND,\n            \"User with id \" + id + \" not found\"\n        );\n        problemDetail.setType(URI.create(\"about:blank\"));\n        problemDetail.setTitle(\"User Not Found\");\n        problemDetail.setProperty(\"userId\", id);\n    }\n    \n    @Override\n    public ProblemDetail getBody() {\n        return problemDetail;\n    }\n}\n\n// Response:\n{\n  \"type\": \"about:blank\",\n  \"title\": \"User Not Found\",\n  \"status\": 404,\n  \"detail\": \"User with id 123 not found\",\n  \"instance\": \"/api/users/123\",\n  \"userId\": 123\n}\n\n// Global handler\n@ControllerAdvice\npublic class GlobalExceptionHandler {\n    @ExceptionHandler(IllegalArgumentException.class)\n    public ProblemDetail handleIllegalArgument(IllegalArgumentException ex) {\n        return ProblemDetail.forStatusAndDetail(\n            HttpStatus.BAD_REQUEST,\n            ex.getMessage()\n        );\n    }\n}"
    },
    {
      "id": 85,
      "question": "What is Spring Boot Modulith?",
      "answer": "Spring Modulith enforces modular monolith architecture:\n\nFeatures:\n• Module boundaries\n• Dependency verification\n• Event-driven communication\n• Documentation generation\n• Integration testing\n\nModules:\n• Package-based\n• Explicit APIs\n• Internal/external separation\n\nAlternative to microservices.\n\nGood for growing applications.",
      "explanation": "Modulith provides microservices benefits in monolith. Enforces clean architecture. Can split to microservices later.",
      "difficulty": "Hard",
      "code": "<!-- pom.xml -->\n<dependency>\n    <groupId>org.springframework.experimental</groupId>\n    <artifactId>spring-modulith-starter-core</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.experimental</groupId>\n    <artifactId>spring-modulith-starter-test</artifactId>\n    <scope>test</scope>\n</dependency>\n\n// Project structure\ncom.example.myapp\n├── order (module)\n│   ├── Order.java\n│   ├── OrderService.java (public API)\n│   └── internal\n│       └── OrderRepository.java (internal)\n├── inventory (module)\n│   ├── Inventory.java\n│   └── InventoryService.java\n└── payment (module)\n\n// Module communication via events\n@Service\npublic class OrderService {\n    @Autowired\n    private ApplicationEventPublisher events;\n    \n    public Order placeOrder(Order order) {\n        Order saved = orderRepository.save(order);\n        events.publishEvent(new OrderPlacedEvent(saved.getId()));\n        return saved;\n    }\n}\n\n// Other module listens\n@Service\nclass InventoryService {\n    @ApplicationModuleListener\n    void on(OrderPlacedEvent event) {\n        reduceStock(event.getOrderId());\n    }\n}\n\n// Test module structure\n@ModulithTest\nclass ModuleStructureTest {\n    @Test\n    void verifyModules(ApplicationModules modules) {\n        modules.verify();\n    }\n    \n    @Test\n    void documentModules(ApplicationModules modules) {\n        new Documenter(modules)\n            .writeDocumentation()\n            .writeModuleCanvases();\n    }\n}"
    },
    {
      "id": 86,
      "question": "What is Spring Boot Docker Compose support?",
      "answer": "Spring Boot 3.1+ integrates with Docker Compose:\n\nFeatures:\n• Auto-start services\n• Wait for readiness\n• Dynamic configuration\n• Lifecycle management\n\nDev convenience:\n• No manual docker-compose up\n• Automatic connection\n• Clean shutdown\n\nSupported services:\n• Databases, Redis, Kafka, etc.\n\nDevelopment only.",
      "explanation": "Docker Compose support eliminates manual service startup in development. Spring Boot starts/stops services automatically.",
      "difficulty": "Medium",
      "code": "<!-- pom.xml -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-docker-compose</artifactId>\n    <scope>runtime</scope>\n    <optional>true</optional>\n</dependency>\n\n# compose.yaml (root of project)\nservices:\n  postgres:\n    image: postgres:15\n    environment:\n      POSTGRES_DB: mydb\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n    ports:\n      - \"5432:5432\"\n  \n  redis:\n    image: redis:7\n    ports:\n      - \"6379:6379\"\n\n# application.properties\n# No datasource config needed!\n# Spring Boot auto-configures from compose.yaml\n\nspring.docker.compose.enabled=true\nspring.docker.compose.file=compose.yaml\nspring.docker.compose.lifecycle-management=start-and-stop\nspring.docker.compose.start.command=up\nspring.docker.compose.stop.command=down\nspring.docker.compose.stop.timeout=30s\n\n// Application automatically:\n// 1. Starts docker-compose up\n// 2. Waits for services to be ready\n// 3. Configures DataSource with container URLs\n// 4. On shutdown: docker-compose down\n\n// Custom service connection\n@Configuration\npublic class DockerConfig {\n    @Bean\n    @ServiceConnection(name = \"postgres\")\n    PostgreSQLContainer<?> postgresContainer() {\n        return new PostgreSQLContainer<>(\"postgres:15\");\n    }\n}"
    },
    {
      "id": 87,
      "question": "What is Spring Boot CRaC (Coordinated Restore at Checkpoint)?",
      "answer": "CRaC enables checkpoint/restore for instant startup:\n\nBenefits:\n• Near-instant startup\n• Snapshot warm JVM\n• Restore pre-initialized state\n• Serverless optimization\n\nProcess:\n• Warm up application\n• Create checkpoint\n• Restore from checkpoint\n\nRequires:\n• CRaC-enabled JDK\n• Linux\n• Privileges",
      "explanation": "CRaC revolutionary for JVM startup. Checkpoint after warmup, restore in milliseconds. Alternative to native image.",
      "difficulty": "Hard",
      "code": "<!-- pom.xml -->\n<dependency>\n    <groupId>org.crac</groupId>\n    <artifactId>crac</artifactId>\n    <version>1.3.0</version>\n</dependency>\n\n@SpringBootApplication\npublic class MyApp {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApp.class, args);\n    }\n}\n\n// Resource that needs checkpoint/restore hook\n@Component\npublic class DatabaseConnection implements Resource {\n    private Connection connection;\n    \n    @PostConstruct\n    public void init() {\n        Core.getGlobalContext().register(this);\n    }\n    \n    @Override\n    public void beforeCheckpoint(Context<? extends Resource> context) {\n        // Close connection before checkpoint\n        if (connection != null) {\n            connection.close();\n        }\n    }\n    \n    @Override\n    public void afterRestore(Context<? extends Resource> context) {\n        // Reconnect after restore\n        connection = createConnection();\n    }\n}\n\n# Create checkpoint\n# 1. Start application\njava -XX:CRaCCheckpointTo=/tmp/cr -jar myapp.jar\n\n# 2. Trigger checkpoint (in another terminal)\njcmd myapp.jar JDK.checkpoint\n\n# 3. Restore from checkpoint\njava -XX:CRaCRestoreFrom=/tmp/cr\n\n# Startup time comparison:\n# Regular JVM: 3-5 seconds\n# Native image: 0.05 seconds\n# CRaC: 0.02 seconds"
    },
    {
      "id": 88,
      "question": "What is Spring Boot @Fallback and Resiliency patterns?",
      "answer": "Resiliency patterns handle failures gracefully:\n\nPatterns:\n• Circuit Breaker: Stop calling failing service\n• Retry: Automatic retries\n• Timeout: Time limits\n• Fallback: Default responses\n• Bulkhead: Isolate resources\n• Rate Limiter: Control throughput\n\nResilience4j:\n• Annotations\n• Programmatic API\n• Metrics integration\n\nEssential for distributed systems.",
      "explanation": "Combine patterns for robust microservices. Circuit breaker + fallback prevents cascading failures. Resilience4j de facto standard.",
      "difficulty": "Hard",
      "code": "<!-- pom.xml -->\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>\n</dependency>\n\n# application.yml\nresilience4j:\n  circuitbreaker:\n    instances:\n      userService:\n        sliding-window-size: 10\n        failure-rate-threshold: 50\n        wait-duration-in-open-state: 10s\n  retry:\n    instances:\n      userService:\n        max-attempts: 3\n        wait-duration: 1s\n  timelimiter:\n    instances:\n      userService:\n        timeout-duration: 2s\n\n@Service\npublic class UserService {\n    \n    @CircuitBreaker(\n        name = \"userService\",\n        fallbackMethod = \"getUserFallback\"\n    )\n    @Retry(name = \"userService\")\n    @TimeLimiter(name = \"userService\")\n    public User getUser(Long id) {\n        return restTemplate.getForObject(\n            externalUserServiceUrl + \"/\" + id,\n            User.class\n        );\n    }\n    \n    public User getUserFallback(Long id, Exception e) {\n        return new User(id, \"Unknown\", \"cached@example.com\");\n    }\n    \n    @Bulkhead(\n        name = \"orderService\",\n        fallbackMethod = \"processOrderFallback\",\n        type = Bulkhead.Type.THREADPOOL\n    )\n    public CompletableFuture<Order> processOrder(Order order) {\n        return CompletableFuture.supplyAsync(() -> \n            orderRepository.save(order)\n        );\n    }\n    \n    @RateLimiter(name = \"apiService\")\n    public String callExternalApi() {\n        return restTemplate.getForObject(apiUrl, String.class);\n    }\n}"
    },
    {
      "id": 89,
      "question": "What is Spring Boot Configuration Processor?",
      "answer": "Configuration Processor generates metadata for IDE autocomplete:\n\nFeatures:\n• Property autocomplete\n• Documentation\n• Validation\n• Deprecation warnings\n\nGenerates:\n• spring-configuration-metadata.json\n• From @ConfigurationProperties\n\nIDE benefits:\n• IntelliJ, VS Code support\n• Property suggestions\n• Type checking\n\nDevelopment-time only.",
      "explanation": "Configuration Processor improves developer experience - IDE autocompletes application.properties. No runtime impact.",
      "difficulty": "Easy",
      "code": "<!-- pom.xml -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-configuration-processor</artifactId>\n    <optional>true</optional>\n</dependency>\n\n@ConfigurationProperties(prefix = \"app\")\npublic class AppProperties {\n    \n    /**\n     * Application name displayed in UI\n     */\n    private String name;\n    \n    /**\n     * Maximum number of concurrent users\n     */\n    private int maxUsers = 100;\n    \n    /**\n     * Feature flags\n     */\n    private Features features = new Features();\n    \n    public static class Features {\n        /**\n         * Enable new dashboard UI\n         */\n        private boolean newDashboard = false;\n        \n        // getters/setters\n    }\n    \n    // getters/setters\n}\n\n// Generated metadata enables:\n# application.properties\napp.name=MyApp                    # Autocomplete suggests \"app.name\"\napp.max-users=200                 # Shows description and type\napp.features.new-dashboard=true   # Nested property completion\n\n// Additional metadata\n@ConfigurationProperties(prefix = \"database\")\npublic class DatabaseProperties {\n    \n    @DeprecatedConfigurationProperty(\n        replacement = \"spring.datasource.url\"\n    )\n    public String getUrl() {\n        return this.url;\n    }\n    \n    @DefaultValue(\"30\")\n    private int timeout;\n}"
    },
    {
      "id": 90,
      "question": "What is Spring Boot AOT (Ahead-of-Time) compilation?",
      "answer": "AOT pre-processes Spring application for optimization:\n\nBenefits:\n• Faster startup\n• Lower memory\n• Native image support\n• Build-time optimization\n\nProcess:\n• Analyzes beans\n• Generates code\n• Optimizes configuration\n\nSpring Boot 3+ feature.\n\nRequired for:\n• GraalVM native image\n• Optional for JVM\n\nTrade-offs: Build time vs runtime.",
      "explanation": "AOT moves work from runtime to build time. Essential for native images. Optional optimization for JVM apps.",
      "difficulty": "Hard",
      "code": "<!-- pom.xml -->\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n            <executions>\n                <execution>\n                    <id>process-aot</id>\n                    <goals>\n                        <goal>process-aot</goal>\n                    </goals>\n                </execution>\n            </executions>\n        </plugin>\n    </plugins>\n</build>\n\n# Build with AOT\nmvn clean package -Pnative\n\n// What AOT does:\n// 1. Scans for @Component, @Bean, etc.\n// 2. Generates BeanDefinition code\n// 3. Creates reflection hints\n// 4. Optimizes configuration\n\n// Generated code example (target/spring-aot/main/sources)\npublic class MyApp__BeanDefinitions {\n    public static void registerBeanDefinitions(\n            DefaultListableBeanFactory beanFactory) {\n        BeanDefinitionRegistrar.of(\"userService\", UserService.class)\n            .instanceSupplier(UserService::new)\n            .register(beanFactory);\n    }\n}\n\n// Runtime hints for native image\n@Configuration\npublic class AotConfig {\n    @Bean\n    @RegisterReflectionForBinding(User.class)\n    public CommandLineRunner init() {\n        return args -> {\n            // Initialization\n        };\n    }\n}\n\n// Startup time comparison:\n// Regular JVM: 3-5 seconds\n// JVM with AOT: 2-3 seconds (marginal improvement)\n// Native with AOT: 0.05 seconds (required)"
    },
    {
      "id": 91,
      "question": "What is Spring Boot @ConstructorBinding?",
      "answer": "@ConstructorBinding enables immutable configuration properties:\n\nBenefits:\n• Immutable configuration\n• Constructor injection\n• No setters needed\n• Thread-safe\n• Record support\n\nRequirement:\n• All parameters must match properties\n\nSpring Boot 3+:\n• Auto-detected on records\n• Optional for regular classes\n\nBest practice for config classes.",
      "explanation": "@ConstructorBinding creates immutable config objects. Perfect with Java records. Safer than mutable properties.",
      "difficulty": "Medium",
      "code": "@ConfigurationProperties(prefix = \"app\")\n@ConstructorBinding\npublic class AppProperties {\n    private final String name;\n    private final int maxUsers;\n    private final Duration timeout;\n    \n    public AppProperties(String name, int maxUsers, Duration timeout) {\n        this.name = name;\n        this.maxUsers = maxUsers;\n        this.timeout = timeout;\n    }\n    \n    // Only getters, no setters\n    public String getName() { return name; }\n    public int getMaxUsers() { return maxUsers; }\n    public Duration getTimeout() { return timeout; }\n}\n\n// With Java Record (Spring Boot 3+)\n@ConfigurationProperties(prefix = \"app\")\npublic record AppProperties(\n    String name,\n    int maxUsers,\n    Duration timeout\n) {\n    // @ConstructorBinding auto-detected for records\n}\n\n// Nested immutable properties\n@ConfigurationProperties(prefix = \"database\")\npublic record DatabaseProperties(\n    String url,\n    String username,\n    String password,\n    Pool pool\n) {\n    public record Pool(\n        int minSize,\n        int maxSize,\n        Duration timeout\n    ) {}\n}\n\n# application.properties\napp.name=MyApp\napp.max-users=100\napp.timeout=30s\n\ndatabase.url=jdbc:postgresql://localhost/mydb\ndatabase.username=user\ndatabase.password=pass\ndatabase.pool.min-size=5\ndatabase.pool.max-size=20\ndatabase.pool.timeout=30s"
    },
    {
      "id": 92,
      "question": "What is Spring Boot Startup tracking?",
      "answer": "Spring Boot provides startup monitoring:\n\nMetrics:\n• ApplicationStartup interface\n• BufferingApplicationStartup\n• FlightRecorderApplicationStartup\n\nData captured:\n• Bean initialization times\n• Auto-configuration times\n• Event processing\n\nTools:\n• Spring Boot Dashboard\n• JFR (Java Flight Recorder)\n• Custom analysis\n\nHelps identify slow startup.",
      "explanation": "Startup tracking identifies bottlenecks. Use to optimize cold starts. Essential for serverless and containers.",
      "difficulty": "Medium",
      "code": "@SpringBootApplication\npublic class MyApp {\n    \n    public static void main(String[] args) {\n        SpringApplication app = new SpringApplication(MyApp.class);\n        \n        // Buffer startup events\n        app.setApplicationStartup(\n            new BufferingApplicationStartup(2048)\n        );\n        \n        app.run(args);\n    }\n}\n\n// Access startup data\n@RestController\npublic class StartupController {\n    \n    @Autowired\n    private BufferingApplicationStartup startup;\n    \n    @GetMapping(\"/startup\")\n    public String getStartupInfo() {\n        StringBuilder sb = new StringBuilder();\n        startup.drainBufferedTimeline().forEach(step -> {\n            sb.append(step.getName())\n              .append(\": \")\n              .append(step.getDuration().toMillis())\n              .append(\"ms\\n\");\n        });\n        return sb.toString();\n    }\n}\n\n// With Java Flight Recorder\npublic static void main(String[] args) {\n    SpringApplication app = new SpringApplication(MyApp.class);\n    app.setApplicationStartup(\n        new FlightRecorderApplicationStartup()\n    );\n    app.run(args);\n}\n\n# Run with JFR\njava -XX:StartFlightRecording:filename=startup.jfr -jar myapp.jar\n\n# Analyze with JDK Mission Control\njmc startup.jfr\n\n// Custom startup listener\n@Component\npublic class StartupLogger implements ApplicationListener<ApplicationStartedEvent> {\n    @Override\n    public void onApplicationEvent(ApplicationStartedEvent event) {\n        ApplicationStartup startup = event.getSpringApplication()\n            .getApplicationStartup();\n        // Log or process startup data\n    }\n}"
    },
    {
      "id": 93,
      "question": "What is Spring Boot Graceful Shutdown?",
      "answer": "Graceful shutdown completes in-flight requests before stopping:\n\nConfiguration:\n• server.shutdown=graceful\n• spring.lifecycle.timeout-per-shutdown-phase\n\nBehavior:\n• Stop accepting new requests\n• Wait for active requests\n• Timeout after period\n• Force shutdown if needed\n\nEssential for:\n• Zero-downtime deployments\n• Kubernetes\n• Cloud platforms",
      "explanation": "Graceful shutdown prevents request failures during deployment. Critical for production. Kubernetes sends SIGTERM before killing.",
      "difficulty": "Medium",
      "code": "# application.properties\nserver.shutdown=graceful\nspring.lifecycle.timeout-per-shutdown-phase=30s\n\n// How it works:\n// 1. Receive shutdown signal (SIGTERM)\n// 2. Stop accepting new requests (503 response)\n// 3. Wait for active requests to complete\n// 4. Timeout after 30s\n// 5. Force shutdown\n\n@Component\npublic class ShutdownListener {\n    \n    @EventListener\n    public void onShutdown(ContextClosedEvent event) {\n        System.out.println(\"Application shutting down...\");\n    }\n}\n\n// Custom cleanup logic\n@Component\npublic class ResourceCleanup implements DisposableBean {\n    \n    @Override\n    public void destroy() {\n        // Cleanup resources\n        closeConnections();\n        flushBuffers();\n        saveState();\n    }\n}\n\n// Kubernetes deployment\napiVersion: apps/v1\nkind: Deployment\nspec:\n  template:\n    spec:\n      containers:\n      - name: myapp\n        image: myapp:1.0\n        lifecycle:\n          preStop:\n            exec:\n              command: [\"sh\", \"-c\", \"sleep 10\"]\n        # Gives Spring Boot time to gracefully shutdown\n      terminationGracePeriodSeconds: 40\n\n// Test graceful shutdown\npublic static void main(String[] args) {\n    ConfigurableApplicationContext context = \n        SpringApplication.run(MyApp.class, args);\n    \n    Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n        System.out.println(\"Shutdown hook triggered\");\n        context.close();\n    }));\n}"
    },
    {
      "id": 94,
      "question": "What is Spring Boot SSL/TLS configuration?",
      "answer": "Spring Boot supports HTTPS configuration:\n\nKeystore:\n• JKS, PKCS12 formats\n• Self-signed or CA-signed\n\nConfiguration:\n• server.ssl.enabled\n• Key store location\n• Password\n• Protocol\n\nCertificate:\n• Let's Encrypt\n• Corporate CA\n• Self-signed (dev only)\n\nHTTP redirect to HTTPS.",
      "explanation": "HTTPS essential for production. Use Let's Encrypt for free certificates. Self-signed only for development.",
      "difficulty": "Medium",
      "code": "# Generate self-signed certificate (dev only)\nkeytool -genkeypair -alias myapp -keyalg RSA -keysize 2048 \\\n  -storetype PKCS12 -keystore keystore.p12 -validity 365\n\n# application.properties\nserver.port=8443\nserver.ssl.enabled=true\nserver.ssl.key-store=classpath:keystore.p12\nserver.ssl.key-store-password=changeit\nserver.ssl.key-store-type=PKCS12\nserver.ssl.key-alias=myapp\n\n# Protocol and cipher suites\nserver.ssl.protocol=TLS\nserver.ssl.enabled-protocols=TLSv1.2,TLSv1.3\nserver.ssl.ciphers=TLS_AES_128_GCM_SHA256,TLS_AES_256_GCM_SHA384\n\n// Redirect HTTP to HTTPS\n@Configuration\npublic class SecurityConfig {\n    \n    @Bean\n    public ServletWebServerFactory servletContainer() {\n        TomcatServletWebServerFactory tomcat = \n            new TomcatServletWebServerFactory() {\n            @Override\n            protected void postProcessContext(Context context) {\n                SecurityConstraint constraint = new SecurityConstraint();\n                constraint.setUserConstraint(\"CONFIDENTIAL\");\n                SecurityCollection collection = new SecurityCollection();\n                collection.addPattern(\"/*\");\n                constraint.addCollection(collection);\n                context.addConstraint(constraint);\n            }\n        };\n        tomcat.addAdditionalTomcatConnectors(httpConnector());\n        return tomcat;\n    }\n    \n    private Connector httpConnector() {\n        Connector connector = new Connector(TomcatServletWebServerFactory.DEFAULT_PROTOCOL);\n        connector.setScheme(\"http\");\n        connector.setPort(8080);\n        connector.setSecure(false);\n        connector.setRedirectPort(8443);\n        return connector;\n    }\n}"
    },
    {
      "id": 95,
      "question": "What is Spring Boot Distributed Logging with ELK?",
      "answer": "ELK Stack (Elasticsearch, Logstash, Kibana) for centralized logging:\n\nComponents:\n• Elasticsearch: Storage and search\n• Logstash: Processing\n• Kibana: Visualization\n• Filebeat: Log shipping\n\nSpring Boot:\n• Logback configuration\n• JSON format\n• Trace ID correlation\n• Structured logging\n\nBenefits:\n• Aggregated logs\n• Search and analysis\n• Dashboards",
      "explanation": "ELK essential for microservices. Centralized logs from all instances. Correlate with trace IDs. Search across services.",
      "difficulty": "Hard",
      "code": "<!-- pom.xml -->\n<dependency>\n    <groupId>net.logstash.logback</groupId>\n    <artifactId>logstash-logback-encoder</artifactId>\n    <version>7.4</version>\n</dependency>\n\n# logback-spring.xml\n<configuration>\n    <appender name=\"LOGSTASH\" class=\"net.logstash.logback.appender.LogstashTcpSocketAppender\">\n        <destination>logstash:5000</destination>\n        <encoder class=\"net.logstash.logback.encoder.LogstashEncoder\">\n            <customFields>{\"application\":\"myapp\"}</customFields>\n            <includeMdcKeyName>traceId</includeMdcKeyName>\n            <includeMdcKeyName>spanId</includeMdcKeyName>\n        </encoder>\n    </appender>\n    \n    <appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder class=\"net.logstash.logback.encoder.LogstashEncoder\"/>\n    </appender>\n    \n    <root level=\"INFO\">\n        <appender-ref ref=\"CONSOLE\"/>\n        <appender-ref ref=\"LOGSTASH\"/>\n    </root>\n</configuration>\n\n# docker-compose.yml for ELK\nversion: '3.8'\nservices:\n  elasticsearch:\n    image: elasticsearch:8.11.0\n    environment:\n      - discovery.type=single-node\n    ports:\n      - \"9200:9200\"\n  \n  logstash:\n    image: logstash:8.11.0\n    volumes:\n      - ./logstash.conf:/usr/share/logstash/pipeline/logstash.conf\n    ports:\n      - \"5000:5000\"\n  \n  kibana:\n    image: kibana:8.11.0\n    ports:\n      - \"5601:5601\"\n\n# logstash.conf\ninput {\n  tcp {\n    port => 5000\n    codec => json\n  }\n}\n\noutput {\n  elasticsearch {\n    hosts => [\"elasticsearch:9200\"]\n    index => \"myapp-%{+YYYY.MM.dd}\"\n  }\n}"
    },
    {
      "id": 96,
      "question": "What is Spring Boot Distributed Tracing with Zipkin?",
      "answer": "Zipkin provides distributed tracing visualization:\n\nConcepts:\n• Trace: Request flow\n• Span: Single operation\n• Service dependency graph\n• Latency analysis\n\nIntegration:\n• Micrometer Tracing\n• Brave instrumentation\n• Auto-instrumentation\n\nSends traces to:\n• Zipkin server\n• Jaeger\n• Wavefront\n\nEssential for microservices debugging.",
      "explanation": "Zipkin shows request flow across services. Identifies slow operations. Auto-instruments HTTP, DB calls.",
      "difficulty": "Hard",
      "code": "<!-- pom.xml -->\n<dependency>\n    <groupId>io.micrometer</groupId>\n    <artifactId>micrometer-tracing-bridge-brave</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.zipkin.reporter2</groupId>\n    <artifactId>zipkin-reporter-brave</artifactId>\n</dependency>\n\n# application.properties\nspring.application.name=order-service\nmanagement.tracing.sampling.probability=1.0\nmanagement.zipkin.tracing.endpoint=http://localhost:9411/api/v2/spans\nlogging.pattern.level=%5p [${spring.application.name:},%X{traceId:-},%X{spanId:-}]\n\n# Run Zipkin with Docker\ndocker run -d -p 9411:9411 openzipkin/zipkin\n\n@RestController\npublic class OrderController {\n    @Autowired\n    private Tracer tracer;\n    \n    @GetMapping(\"/orders/{id}\")\n    public Order getOrder(@PathVariable Long id) {\n        // Automatically traced\n        Order order = orderService.findById(id);\n        \n        // Custom span\n        Span span = tracer.nextSpan().name(\"validate-order\");\n        try (Tracer.SpanInScope ws = tracer.withSpan(span.start())) {\n            span.tag(\"orderId\", id.toString());\n            span.tag(\"status\", order.getStatus());\n            validateOrder(order);\n        } finally {\n            span.end();\n        }\n        \n        return order;\n    }\n}\n\n// Trace propagation across services\n@Service\npublic class PaymentService {\n    @Autowired\n    private RestTemplate restTemplate;\n    \n    public Payment processPayment(Payment payment) {\n        // Trace ID automatically propagated in headers\n        return restTemplate.postForObject(\n            \"http://payment-service/process\",\n            payment,\n            Payment.class\n        );\n    }\n}\n\n// Zipkin UI: http://localhost:9411\n// Shows: Service dependencies, trace timeline, span details"
    },
    {
      "id": 97,
      "question": "What is Spring Boot Cloud Config Server?",
      "answer": "Cloud Config Server centralizes external configuration:\n\nFeatures:\n• Git-backed config\n• Environment-specific\n• Refresh without restart\n• Encryption support\n• Multiple backends\n\nClient:\n• Fetch config on startup\n• @RefreshScope\n• Actuator /refresh\n\nBenefits:\n• Centralized management\n• Version control\n• Audit trail\n• Consistency",
      "explanation": "Config Server separates config from code. Store in Git. Multiple apps share config. Environment-specific overrides.",
      "difficulty": "Hard",
      "code": "<!-- Config Server pom.xml -->\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-config-server</artifactId>\n</dependency>\n\n@SpringBootApplication\n@EnableConfigServer\npublic class ConfigServerApp {\n    public static void main(String[] args) {\n        SpringApplication.run(ConfigServerApp.class, args);\n    }\n}\n\n# application.properties (Config Server)\nserver.port=8888\nspring.cloud.config.server.git.uri=https://github.com/myorg/config-repo\nspring.cloud.config.server.git.default-label=main\n\n# Git repo structure:\nconfig-repo/\n├── application.yml          # Common to all apps\n├── application-dev.yml      # Dev environment\n├── application-prod.yml     # Prod environment\n├── order-service.yml        # Specific app\n└── order-service-prod.yml   # App + environment\n\n<!-- Config Client pom.xml -->\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-config</artifactId>\n</dependency>\n\n# bootstrap.properties (Client)\nspring.application.name=order-service\nspring.profiles.active=prod\nspring.cloud.config.uri=http://localhost:8888\nspring.cloud.config.fail-fast=true\n\n@RestController\n@RefreshScope\npublic class ConfigController {\n    @Value(\"${app.message}\")\n    private String message;\n    \n    @GetMapping(\"/message\")\n    public String getMessage() {\n        return message;\n    }\n}\n\n# Refresh config without restart\ncurl -X POST http://localhost:8080/actuator/refresh\n\n# Encryption\nencrypt.key=mySecretKey\n# Store encrypted: {cipher}AQA7Hd...encrypted-value"
    },
    {
      "id": 98,
      "question": "What is Spring Boot Service Discovery with Eureka?",
      "answer": "Eureka provides service discovery for microservices:\n\nComponents:\n• Eureka Server: Service registry\n• Eureka Client: Service registration\n\nFeatures:\n• Auto-registration\n• Health checks\n• Load balancing\n• Failover\n• Instances tracking\n\nClient:\n• @EnableEurekaClient\n• Heartbeats\n• Service lookup\n\nAlternatives: Consul, Zookeeper.",
      "explanation": "Service discovery enables dynamic microservices. No hardcoded URLs. Auto-scaling friendly. Load balancing built-in.",
      "difficulty": "Hard",
      "code": "<!-- Eureka Server pom.xml -->\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n</dependency>\n\n@SpringBootApplication\n@EnableEurekaServer\npublic class EurekaServerApp {\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaServerApp.class, args);\n    }\n}\n\n# application.properties (Eureka Server)\nserver.port=8761\neureka.client.register-with-eureka=false\neureka.client.fetch-registry=false\n\n<!-- Eureka Client pom.xml -->\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n\n@SpringBootApplication\npublic class OrderServiceApp {\n    public static void main(String[] args) {\n        SpringApplication.run(OrderServiceApp.class, args);\n    }\n}\n\n# application.properties (Eureka Client)\nspring.application.name=order-service\nserver.port=8080\neureka.client.service-url.defaultZone=http://localhost:8761/eureka/\neureka.instance.prefer-ip-address=true\n\n// Call other service by name\n@Service\npublic class OrderService {\n    @Autowired\n    private RestTemplate restTemplate;\n    \n    public User getUser(Long userId) {\n        // Service name instead of URL\n        return restTemplate.getForObject(\n            \"http://user-service/users/\" + userId,\n            User.class\n        );\n    }\n}\n\n@Configuration\npublic class RestConfig {\n    @Bean\n    @LoadBalanced  // Enable load balancing\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n}\n\n// Eureka Dashboard: http://localhost:8761"
    },
    {
      "id": 99,
      "question": "What is Spring Boot API Gateway?",
      "answer": "Spring Cloud Gateway provides API gateway:\n\nFeatures:\n• Routing\n• Load balancing\n• Rate limiting\n• Authentication\n• Request/response transformation\n• Circuit breaker\n\nRoutes:\n• Predicates: Matching rules\n• Filters: Modifications\n• URI: Target service\n\nBenefits:\n• Single entry point\n• Cross-cutting concerns\n• Service aggregation",
      "explanation": "API Gateway handles cross-cutting concerns. Single entry for microservices. Authentication, logging, rate limiting in one place.",
      "difficulty": "Hard",
      "code": "<!-- pom.xml -->\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-gateway</artifactId>\n</dependency>\n\n# application.yml\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: user-service\n        uri: lb://user-service\n        predicates:\n        - Path=/users/**\n        filters:\n        - StripPrefix=1\n        - AddRequestHeader=X-Request-Source, gateway\n        \n      - id: order-service\n        uri: lb://order-service\n        predicates:\n        - Path=/orders/**\n        - Method=GET,POST\n        filters:\n        - RewritePath=/orders/(?<segment>.*), /$\\{segment}\n        \n      - id: auth-required\n        uri: lb://protected-service\n        predicates:\n        - Path=/api/**\n        filters:\n        - name: CircuitBreaker\n          args:\n            name: protectedCircuit\n            fallbackUri: forward:/fallback\n        - name: RequestRateLimiter\n          args:\n            redis-rate-limiter.replenishRate: 10\n            redis-rate-limiter.burstCapacity: 20\n\n// Programmatic routing\n@Configuration\npublic class GatewayConfig {\n    @Bean\n    public RouteLocator customRoutes(RouteLocatorBuilder builder) {\n        return builder.routes()\n            .route(\"user-service\", r -> r\n                .path(\"/users/**\")\n                .filters(f -> f\n                    .addRequestHeader(\"X-Gateway\", \"true\")\n                    .circuitBreaker(c -> c\n                        .setName(\"userCircuit\")\n                        .setFallbackUri(\"/fallback\"))\n                )\n                .uri(\"lb://user-service\")\n            )\n            .build();\n    }\n}\n\n// Global filter\n@Component\npublic class LoggingFilter implements GlobalFilter {\n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n        System.out.println(\"Request: \" + exchange.getRequest().getPath());\n        return chain.filter(exchange).then(Mono.fromRunnable(() -> {\n            System.out.println(\"Response: \" + exchange.getResponse().getStatusCode());\n        }));\n    }\n}"
    },
    {
      "id": 100,
      "question": "What are Spring Boot Best Practices?",
      "answer": "Essential Spring Boot best practices:\n\n1. Use proper packaging (JAR)\n2. Externalize configuration\n3. Use profiles correctly\n4. Enable Actuator (secured)\n5. Implement health checks\n6. Use proper logging levels\n7. Handle exceptions globally\n8. Validate input\n9. Use constructor injection\n10. Write tests (@SpringBootTest, slices)\n11. Use caching appropriately\n12. Enable compression\n13. Secure endpoints\n14. Monitor performance\n15. Document APIs",
      "explanation": "Following best practices ensures maintainable, performant, secure applications. Use dependency injection properly, externalize config, test thoroughly.",
      "difficulty": "Medium",
      "code": "// 1. Constructor injection (recommended)\n@Service\npublic class UserService {\n    private final UserRepository repository;\n    private final EmailService emailService;\n    \n    public UserService(UserRepository repository, EmailService emailService) {\n        this.repository = repository;\n        this.emailService = emailService;\n    }\n}\n\n// 2. Global exception handling\n@ControllerAdvice\npublic class GlobalExceptionHandler {\n    @ExceptionHandler(Exception.class)\n    public ResponseEntity<ErrorResponse> handleException(Exception ex) {\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n            .body(new ErrorResponse(ex.getMessage()));\n    }\n}\n\n// 3. Input validation\n@RestController\npublic class UserController {\n    @PostMapping(\"/users\")\n    public User createUser(@Valid @RequestBody UserDto user) {\n        return userService.create(user);\n    }\n}\n\npublic class UserDto {\n    @NotBlank\n    @Size(min = 3, max = 50)\n    private String name;\n    \n    @Email\n    private String email;\n}\n\n// 4. Configuration\n# application.properties\n# External config\napp.feature.enabled=${APP_FEATURE_ENABLED:false}\n\n# Compression\nserver.compression.enabled=true\nserver.compression.mime-types=application/json,text/html\n\n# Actuator security\nmanagement.endpoints.web.exposure.include=health,info,metrics\n\n# Logging\nlogging.level.root=INFO\nlogging.level.com.example=DEBUG\n\n// 5. Custom health indicator\n@Component\npublic class DatabaseHealthIndicator implements HealthIndicator {\n    @Override\n    public Health health() {\n        if (checkDatabase()) {\n            return Health.up().build();\n        }\n        return Health.down().build();\n    }\n}\n\n// 6. API documentation\n@Operation(summary = \"Get user by ID\")\n@ApiResponses({\n    @ApiResponse(responseCode = \"200\", description = \"User found\"),\n    @ApiResponse(responseCode = \"404\", description = \"User not found\")\n})\n@GetMapping(\"/users/{id}\")\npublic User getUser(@PathVariable Long id) {\n    return userService.findById(id);\n}"
    }
  ]
}
