{
  "topic": "Spring Framework",
  "questions": [
    {
      "id": 1,
      "question": "What is Spring Framework and its key features?",
      "answer": "Spring is a comprehensive framework for enterprise Java applications:\n\nKey features:\n• Inversion of Control (IoC): Dependency injection\n• Aspect-Oriented Programming (AOP): Cross-cutting concerns\n• Transaction Management: Declarative transactions\n• MVC Framework: Web applications\n• Data Access: JDBC, ORM integration\n• Testing Support: Mock objects, test fixtures\n• Modular: Use only what you need\n\nCore principle: Write loosely coupled, testable code.",
      "explanation": "Spring simplifies Java development by providing infrastructure support. Focus on business logic while Spring handles plumbing.",
      "difficulty": "Easy",
      "code": "// Before Spring - tight coupling\npublic class OrderService {\n    private PaymentService paymentService = new PaymentService();\n}\n\n// With Spring - loose coupling\n@Service\npublic class OrderService {\n    private final PaymentService paymentService;\n    \n    @Autowired\n    public OrderService(PaymentService paymentService) {\n        this.paymentService = paymentService;\n    }\n}"
    },
    {
      "id": 2,
      "question": "What is Inversion of Control (IoC)?",
      "answer": "IoC inverts the flow of control - framework controls object creation:\n\nTraditional:\n• Application creates objects\n• Application manages dependencies\n\nIoC:\n• Framework creates objects\n• Framework injects dependencies\n• Application just uses objects\n\nBenefits:\n• Loose coupling\n• Easier testing (mock dependencies)\n• Centralized configuration\n• Better separation of concerns",
      "explanation": "IoC means 'Don't call us, we'll call you'. Instead of creating dependencies, Spring provides them. Hollywood Principle.",
      "difficulty": "Easy",
      "code": "// Without IoC - you control object creation\npublic class UserService {\n    private UserRepository repository = new UserRepository();\n    private EmailService emailService = new EmailService();\n    \n    public void createUser(User user) {\n        repository.save(user);\n        emailService.send(user);\n    }\n}\n\n// With IoC - Spring controls object creation\n@Service\npublic class UserService {\n    private final UserRepository repository;\n    private final EmailService emailService;\n    \n    @Autowired\n    public UserService(UserRepository repository, EmailService emailService) {\n        this.repository = repository;\n        this.emailService = emailService;\n    }\n    \n    public void createUser(User user) {\n        repository.save(user);\n        emailService.send(user);\n    }\n}"
    },
    {
      "id": 3,
      "question": "What is Dependency Injection (DI) and its types?",
      "answer": "DI is a pattern where dependencies are provided to objects:\n\nTypes:\n• Constructor Injection: Dependencies via constructor (recommended)\n• Setter Injection: Dependencies via setter methods\n• Field Injection: Dependencies via @Autowired on fields (not recommended)\n• Method Injection: Dependencies via any method\n\nConstructor injection benefits:\n• Immutable dependencies\n• Required dependencies enforced\n• Better testability\n• No null references",
      "explanation": "Constructor injection is best practice - makes dependencies explicit and prevents null pointer exceptions.",
      "difficulty": "Easy",
      "code": "// 1. Constructor Injection (BEST)\n@Service\npublic class OrderService {\n    private final PaymentService paymentService;\n    private final InventoryService inventoryService;\n    \n    @Autowired  // Optional in Spring 4.3+\n    public OrderService(PaymentService paymentService, \n                       InventoryService inventoryService) {\n        this.paymentService = paymentService;\n        this.inventoryService = inventoryService;\n    }\n}\n\n// 2. Setter Injection (for optional dependencies)\n@Service\npublic class NotificationService {\n    private EmailService emailService;\n    \n    @Autowired(required = false)\n    public void setEmailService(EmailService emailService) {\n        this.emailService = emailService;\n    }\n}\n\n// 3. Field Injection (NOT RECOMMENDED)\n@Service\npublic class UserService {\n    @Autowired\n    private UserRepository repository;  // Hard to test, allows nulls\n}"
    },
    {
      "id": 4,
      "question": "What is BeanFactory vs ApplicationContext?",
      "answer": "Both are IoC containers, ApplicationContext is more advanced:\n\nBeanFactory:\n• Basic container\n• Lazy initialization\n• Minimal features\n• Lightweight\n\nApplicationContext:\n• Extends BeanFactory\n• Eager initialization (default)\n• Event propagation\n• Internationalization (i18n)\n• Resource loading\n• AOP integration\n• Web application contexts\n\nUse ApplicationContext in almost all scenarios.",
      "explanation": "ApplicationContext is production-ready container. BeanFactory only for resource-constrained environments.",
      "difficulty": "Medium",
      "code": "// BeanFactory - basic container\nBeanFactory factory = new XmlBeanFactory(\n    new ClassPathResource(\"beans.xml\")\n);\nUserService service = (UserService) factory.getBean(\"userService\");\n\n// ApplicationContext - full-featured (RECOMMENDED)\nApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\");\n// Or Java-based\nApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);\n\nUserService service = context.getBean(UserService.class);\n\n// ApplicationContext features\ncontext.publishEvent(new CustomEvent(this));  // Events\nString message = context.getMessage(\"greeting\", null, Locale.US);  // i18n\nResource resource = context.getResource(\"classpath:data.txt\");  // Resources\n\n// Hierarchy\npublic interface ApplicationContext extends \n    EnvironmentCapable, \n    ListableBeanFactory,\n    HierarchicalBeanFactory,\n    MessageSource,\n    ApplicationEventPublisher,\n    ResourcePatternResolver"
    },
    {
      "id": 5,
      "question": "What are Spring Bean Scopes?",
      "answer": "Bean scope defines lifecycle and visibility:\n\nScopes:\n• Singleton (default): One instance per container\n• Prototype: New instance each request\n• Request: One per HTTP request (Web)\n• Session: One per HTTP session (Web)\n• Application: One per ServletContext (Web)\n• WebSocket: One per WebSocket (Web)\n\nSingleton is default and most common.\n\nUse prototype for stateful beans.",
      "explanation": "Singleton beans are shared. Prototype creates new instance each time. Choose based on whether bean is stateful.",
      "difficulty": "Medium",
      "code": "// Singleton (default) - one instance shared\n@Component\n@Scope(\"singleton\")  // or ConfigurableBeanFactory.SCOPE_SINGLETON\npublic class ConfigService {\n    // Shared across application\n}\n\n// Prototype - new instance each time\n@Component\n@Scope(\"prototype\")  // or ConfigurableBeanFactory.SCOPE_PROTOTYPE\npublic class ShoppingCart {\n    // New cart for each user\n}\n\n// Request scope - one per HTTP request\n@Component\n@Scope(value = WebApplicationContext.SCOPE_REQUEST, \n       proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class RequestContext {\n    // New instance per request\n}\n\n// Session scope - one per HTTP session\n@Component\n@Scope(value = WebApplicationContext.SCOPE_SESSION, \n       proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class UserSession {\n    private String userId;\n    // Persists across requests in same session\n}\n\n// Custom scope\n@Bean\npublic CustomScopeConfigurer customScope() {\n    CustomScopeConfigurer configurer = new CustomScopeConfigurer();\n    configurer.addScope(\"thread\", new SimpleThreadScope());\n    return configurer;\n}"
    },
    {
      "id": 6,
      "question": "What is Spring Bean Lifecycle?",
      "answer": "Bean lifecycle phases:\n\n1. Instantiation: Constructor called\n2. Populate properties: DI happens\n3. BeanNameAware: setBeanName() called\n4. BeanFactoryAware: setBeanFactory() called\n5. Pre-initialization: BeanPostProcessor.postProcessBefore()\n6. @PostConstruct: Init method\n7. InitializingBean: afterPropertiesSet()\n8. Custom init-method\n9. Post-initialization: BeanPostProcessor.postProcessAfter()\n10. Bean ready to use\n11. @PreDestroy: Cleanup\n12. DisposableBean: destroy()\n13. Custom destroy-method",
      "explanation": "Understanding lifecycle helps with initialization and cleanup. Use @PostConstruct for init, @PreDestroy for cleanup.",
      "difficulty": "Hard",
      "code": "@Component\npublic class LifecycleBean implements \n        BeanNameAware, \n        BeanFactoryAware,\n        InitializingBean, \n        DisposableBean {\n    \n    private String name;\n    \n    // 1. Constructor\n    public LifecycleBean() {\n        System.out.println(\"1. Constructor called\");\n    }\n    \n    // 2. Property injection\n    @Autowired\n    public void setName(String name) {\n        System.out.println(\"2. Property injected: \" + name);\n        this.name = name;\n    }\n    \n    // 3. BeanNameAware\n    @Override\n    public void setBeanName(String name) {\n        System.out.println(\"3. Bean name: \" + name);\n    }\n    \n    // 4. BeanFactoryAware\n    @Override\n    public void setBeanFactory(BeanFactory beanFactory) {\n        System.out.println(\"4. BeanFactory set\");\n    }\n    \n    // 5. @PostConstruct (RECOMMENDED)\n    @PostConstruct\n    public void postConstruct() {\n        System.out.println(\"5. @PostConstruct\");\n    }\n    \n    // 6. InitializingBean\n    @Override\n    public void afterPropertiesSet() {\n        System.out.println(\"6. afterPropertiesSet()\");\n    }\n    \n    // 7. Custom init method\n    public void customInit() {\n        System.out.println(\"7. custom init\");\n    }\n    \n    // Destruction\n    @PreDestroy\n    public void preDestroy() {\n        System.out.println(\"Cleanup: @PreDestroy\");\n    }\n    \n    @Override\n    public void destroy() {\n        System.out.println(\"Cleanup: destroy()\");\n    }\n}\n\n@Configuration\npublic class Config {\n    @Bean(initMethod = \"customInit\", destroyMethod = \"customDestroy\")\n    public MyBean myBean() {\n        return new MyBean();\n    }\n}"
    },
    {
      "id": 7,
      "question": "What is @Component, @Service, @Repository, @Controller?",
      "answer": "Stereotype annotations for component scanning:\n\n@Component:\n• Generic stereotype\n• Any Spring-managed component\n\n@Service:\n• Business logic layer\n• Indicates service class\n\n@Repository:\n• Data access layer\n• Exception translation (SQL to Spring)\n• Persistence logic\n\n@Controller:\n• MVC controller\n• Web request handling\n\nAll create singleton beans by default.",
      "explanation": "@Service, @Repository, @Controller are specialized @Component. Use specific annotations for clarity and additional features.",
      "difficulty": "Easy",
      "code": "// Generic component\n@Component\npublic class UtilityHelper {\n    public String format(String text) {\n        return text.toUpperCase();\n    }\n}\n\n// Service layer - business logic\n@Service\npublic class UserService {\n    @Autowired\n    private UserRepository repository;\n    \n    public User createUser(User user) {\n        // Business logic\n        return repository.save(user);\n    }\n}\n\n// Repository layer - data access\n@Repository\npublic class UserRepository {\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n    \n    public User save(User user) {\n        // SQL exceptions translated to DataAccessException\n        jdbcTemplate.update(\"INSERT INTO users...\");\n        return user;\n    }\n}\n\n// Controller - web layer\n@Controller\npublic class UserController {\n    @Autowired\n    private UserService userService;\n    \n    @GetMapping(\"/users\")\n    @ResponseBody\n    public List<User> getUsers() {\n        return userService.findAll();\n    }\n}\n\n// Enable component scanning\n@Configuration\n@ComponentScan(basePackages = \"com.example\")\npublic class AppConfig {\n}"
    },
    {
      "id": 8,
      "question": "What is @Configuration and @Bean?",
      "answer": "@Configuration classes define beans programmatically:\n\n@Configuration:\n• Java-based configuration\n• Replaces XML configuration\n• Contains @Bean methods\n• Itself a component\n\n@Bean:\n• Method produces bean\n• Return object managed by Spring\n• Method name = bean name (default)\n• Full control over instantiation\n\nUse for third-party classes or complex initialization.",
      "explanation": "@Configuration is type-safe alternative to XML. Gives full control over bean creation with Java code.",
      "difficulty": "Easy",
      "code": "@Configuration\npublic class AppConfig {\n    \n    // Bean with default name \"dataSource\"\n    @Bean\n    public DataSource dataSource() {\n        HikariDataSource dataSource = new HikariDataSource();\n        dataSource.setJdbcUrl(\"jdbc:postgresql://localhost/mydb\");\n        dataSource.setUsername(\"user\");\n        dataSource.setPassword(\"pass\");\n        return dataSource;\n    }\n    \n    // Bean with custom name\n    @Bean(name = \"customName\")\n    public UserService userService() {\n        return new UserService(userRepository());\n    }\n    \n    // Bean with dependency\n    @Bean\n    public OrderService orderService(UserService userService, \n                                    PaymentService paymentService) {\n        return new OrderService(userService, paymentService);\n    }\n    \n    // Init and destroy methods\n    @Bean(initMethod = \"init\", destroyMethod = \"cleanup\")\n    public CacheManager cacheManager() {\n        return new CaffeineCacheManager();\n    }\n    \n    // Scoped bean\n    @Bean\n    @Scope(\"prototype\")\n    public ShoppingCart shoppingCart() {\n        return new ShoppingCart();\n    }\n}\n\n// Equivalent XML\n<bean id=\"dataSource\" class=\"com.zaxxer.hikari.HikariDataSource\">\n    <property name=\"jdbcUrl\" value=\"jdbc:postgresql://localhost/mydb\"/>\n    <property name=\"username\" value=\"user\"/>\n    <property name=\"password\" value=\"pass\"/>\n</bean>"
    },
    {
      "id": 9,
      "question": "What is @Autowired and its modes?",
      "answer": "@Autowired enables automatic dependency injection:\n\nBy type (default):\n• Matches bean type\n• Fails if multiple candidates\n\nBy name:\n• Use @Qualifier\n• Matches bean name\n\nRequired:\n• required=true (default): Fails if not found\n• required=false: Optional dependency\n\nCan inject:\n• Single bean\n• List/Array of beans\n• Map of beans\n• Optional<Bean>",
      "explanation": "@Autowired by type is most common. Use @Qualifier to resolve multiple candidates. Constructor injection preferred.",
      "difficulty": "Medium",
      "code": "// By type\n@Service\npublic class OrderService {\n    @Autowired\n    private PaymentService paymentService;  // Injects PaymentService bean\n}\n\n// Multiple candidates - use @Qualifier\n@Service\npublic class EmailService {\n    @Autowired\n    @Qualifier(\"smtpProvider\")\n    private EmailProvider emailProvider;\n}\n\n@Component(\"smtpProvider\")\npublic class SmtpEmailProvider implements EmailProvider { }\n\n@Component(\"sendGridProvider\")\npublic class SendGridEmailProvider implements EmailProvider { }\n\n// Optional dependency\n@Service\npublic class NotificationService {\n    @Autowired(required = false)\n    private SmsService smsService;  // May be null\n}\n\n// Inject list of all beans\n@Service\npublic class PaymentProcessor {\n    @Autowired\n    private List<PaymentGateway> gateways;  // All PaymentGateway beans\n    \n    public void processPayment(Payment payment) {\n        for (PaymentGateway gateway : gateways) {\n            if (gateway.supports(payment)) {\n                gateway.process(payment);\n                break;\n            }\n        }\n    }\n}\n\n// Inject map\n@Service\npublic class HandlerService {\n    @Autowired\n    private Map<String, MessageHandler> handlers;  // bean name -> bean\n}\n\n// Java 8 Optional\n@Service\npublic class UserService {\n    @Autowired\n    private Optional<CacheService> cacheService;\n    \n    public User getUser(Long id) {\n        return cacheService\n            .map(cache -> cache.get(id))\n            .orElseGet(() -> repository.findById(id));\n    }\n}"
    },
    {
      "id": 10,
      "question": "What is @Primary and @Qualifier?",
      "answer": "Resolve multiple bean candidates:\n\n@Primary:\n• Marks preferred bean\n• Used when multiple candidates exist\n• Autowired without qualifier uses @Primary\n\n@Qualifier:\n• Specifies bean by name\n• More specific than @Primary\n• Overrides @Primary selection\n\nPrecedence: @Qualifier > @Primary > by type",
      "explanation": "@Primary sets default bean. @Qualifier selects specific bean. Use @Primary for default, @Qualifier when specific bean needed.",
      "difficulty": "Medium",
      "code": "// Multiple EmailService implementations\n@Component\n@Primary  // Default choice\npublic class SmtpEmailService implements EmailService {\n    public void send(Email email) {\n        // SMTP implementation\n    }\n}\n\n@Component\npublic class SendGridEmailService implements EmailService {\n    public void send(Email email) {\n        // SendGrid implementation\n    }\n}\n\n// Uses @Primary bean (SmtpEmailService)\n@Service\npublic class NotificationService {\n    @Autowired\n    private EmailService emailService;  // Gets SmtpEmailService\n}\n\n// Override with @Qualifier\n@Service\npublic class MarketingService {\n    @Autowired\n    @Qualifier(\"sendGridEmailService\")\n    private EmailService emailService;  // Gets SendGridEmailService\n}\n\n// Custom qualifier annotation\n@Qualifier\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Smtp { }\n\n@Qualifier\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface SendGrid { }\n\n@Component\n@Smtp\npublic class SmtpEmailService implements EmailService { }\n\n@Component\n@SendGrid\npublic class SendGridEmailService implements EmailService { }\n\n@Service\npublic class EmailSender {\n    @Autowired\n    @Smtp\n    private EmailService smtpService;\n    \n    @Autowired\n    @SendGrid\n    private EmailService sendGridService;\n}"
    },
    {
      "id": 11,
      "question": "What is Spring AOP (Aspect-Oriented Programming)?",
      "answer": "AOP handles cross-cutting concerns separately from business logic:\n\nKey concepts:\n• Aspect: Modularized concern (logging, security)\n• Join Point: Point in execution (method call)\n• Advice: Action taken (before, after, around)\n• Pointcut: Expression matching join points\n• Weaving: Linking aspects with objects\n\nAdvice types:\n• @Before: Before method\n• @After: After method (always)\n• @AfterReturning: After successful return\n• @AfterThrowing: After exception\n• @Around: Wrap method execution",
      "explanation": "AOP lets you extract cross-cutting concerns (logging, transactions) from business logic. Keeps code clean and maintainable.",
      "difficulty": "Hard",
      "code": "@Aspect\n@Component\npublic class LoggingAspect {\n    \n    // Before advice\n    @Before(\"execution(* com.example.service.*.*(..))\")\n    public void logBefore(JoinPoint joinPoint) {\n        System.out.println(\"Before: \" + joinPoint.getSignature().getName());\n    }\n    \n    // After returning\n    @AfterReturning(pointcut = \"execution(* com.example.service.*.*(..))\", \n                    returning = \"result\")\n    public void logAfterReturning(JoinPoint joinPoint, Object result) {\n        System.out.println(\"Returned: \" + result);\n    }\n    \n    // After throwing\n    @AfterThrowing(pointcut = \"execution(* com.example.service.*.*(..))\", \n                   throwing = \"error\")\n    public void logAfterThrowing(JoinPoint joinPoint, Throwable error) {\n        System.out.println(\"Exception: \" + error.getMessage());\n    }\n    \n    // Around advice - full control\n    @Around(\"execution(* com.example.service.*.*(..))\")\n    public Object logAround(ProceedingJoinPoint joinPoint) throws Throwable {\n        long start = System.currentTimeMillis();\n        \n        Object result = joinPoint.proceed();  // Execute method\n        \n        long duration = System.currentTimeMillis() - start;\n        System.out.println(\"Duration: \" + duration + \"ms\");\n        return result;\n    }\n}\n\n@Configuration\n@EnableAspectJAutoProxy\npublic class AppConfig { }"
    },
    {
      "id": 12,
      "question": "What are AOP Pointcut expressions?",
      "answer": "Pointcut expressions match join points:\n\nDesignators:\n• execution: Method execution\n• within: Types within package/class\n• this: Proxy instance type\n• target: Target object type\n• args: Method arguments\n• @annotation: Methods with annotation\n• @within: Types with annotation\n\nWildcards:\n• *: Any characters\n• ..: Any number of parameters\n\nCombining: &&, ||, !",
      "explanation": "Pointcut expressions use AspectJ syntax. Master common patterns for precise aspect matching.",
      "difficulty": "Hard",
      "code": "@Aspect\n@Component\npublic class SecurityAspect {\n    \n    // All methods in service package\n    @Before(\"execution(* com.example.service.*.*(..))\")\n    public void beforeService() { }\n    \n    // All methods returning User\n    @AfterReturning(\n        pointcut = \"execution(com.example.User com.example.service.*.*(..))\"\n    )\n    public void afterUserReturn() { }\n    \n    // Methods starting with 'get'\n    @Before(\"execution(* get*(..))\")\n    public void beforeGetter() { }\n    \n    // Methods with specific arguments\n    @Before(\"execution(* *(Long, String))\")\n    public void withSpecificArgs() { }\n    \n    // All methods in UserService\n    @Around(\"within(com.example.service.UserService)\")\n    public Object aroundUserService(ProceedingJoinPoint pjp) throws Throwable {\n        return pjp.proceed();\n    }\n    \n    // Methods with @Transactional\n    @Around(\"@annotation(org.springframework.transaction.annotation.Transactional)\")\n    public Object aroundTransactional(ProceedingJoinPoint pjp) throws Throwable {\n        return pjp.proceed();\n    }\n    \n    // Classes with @Service\n    @Before(\"@within(org.springframework.stereotype.Service)\")\n    public void beforeServiceClass() { }\n    \n    // Reusable pointcut\n    @Pointcut(\"execution(* com.example.service.*.*(..))\")\n    public void serviceMethods() { }\n    \n    @Pointcut(\"execution(public * *(..))\")\n    public void publicMethods() { }\n    \n    // Combine pointcuts\n    @Before(\"serviceMethods() && publicMethods()\")\n    public void beforePublicServiceMethod() { }\n    \n    // With args\n    @Before(\"execution(* process(..)) && args(order)\")\n    public void beforeProcessOrder(Order order) {\n        System.out.println(\"Processing order: \" + order.getId());\n    }\n}"
    },
    {
      "id": 13,
      "question": "What is Spring Transaction Management?",
      "answer": "Transaction management ensures ACID properties:\n\nTypes:\n• Programmatic: Manual transaction control\n• Declarative: @Transactional annotation (preferred)\n\nPropagation:\n• REQUIRED (default): Use existing or create new\n• REQUIRES_NEW: Always new transaction\n• SUPPORTS: Use if exists\n• MANDATORY: Must have transaction\n• NOT_SUPPORTED: Execute non-transactionally\n• NEVER: Throw exception if transaction exists\n• NESTED: Nested transaction\n\nIsolation: Controls concurrent access",
      "explanation": "@Transactional simplifies transaction management. Spring handles commit/rollback automatically based on exceptions.",
      "difficulty": "Hard",
      "code": "@Service\npublic class OrderService {\n    @Autowired\n    private OrderRepository orderRepository;\n    @Autowired\n    private InventoryService inventoryService;\n    \n    // Basic transaction\n    @Transactional\n    public Order placeOrder(Order order) {\n        orderRepository.save(order);\n        inventoryService.reduceStock(order);\n        // Commits if no exception, rolls back on RuntimeException\n        return order;\n    }\n    \n    // Custom configuration\n    @Transactional(\n        propagation = Propagation.REQUIRED,\n        isolation = Isolation.READ_COMMITTED,\n        timeout = 30,\n        rollbackFor = Exception.class,\n        noRollbackFor = IllegalArgumentException.class,\n        readOnly = false\n    )\n    public void complexOperation() { }\n    \n    // Read-only transaction (optimization)\n    @Transactional(readOnly = true)\n    public List<Order> findOrders() {\n        return orderRepository.findAll();\n    }\n    \n    // New transaction always\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    public void createAuditLog(String action) {\n        // Commits even if parent transaction rolls back\n        auditRepository.save(new AuditLog(action));\n    }\n}\n\n// Enable transaction management\n@Configuration\n@EnableTransactionManagement\npublic class AppConfig {\n    \n    @Bean\n    public PlatformTransactionManager transactionManager(DataSource dataSource) {\n        return new DataSourceTransactionManager(dataSource);\n    }\n}\n\n// Programmatic transactions (rare)\n@Service\npublic class PaymentService {\n    @Autowired\n    private TransactionTemplate transactionTemplate;\n    \n    public void processPayment(Payment payment) {\n        transactionTemplate.execute(status -> {\n            try {\n                paymentGateway.charge(payment);\n                return \"SUCCESS\";\n            } catch (Exception e) {\n                status.setRollbackOnly();\n                return \"FAILED\";\n            }\n        });\n    }\n}"
    },
    {
      "id": 14,
      "question": "What is Spring MVC architecture?",
      "answer": "Spring MVC follows Front Controller pattern:\n\nComponents:\n• DispatcherServlet: Front controller\n• HandlerMapping: Maps requests to controllers\n• Controller: Handles requests\n• ViewResolver: Resolves views\n• View: Renders response\n\nRequest flow:\n1. Request to DispatcherServlet\n2. DispatcherServlet consults HandlerMapping\n3. Controller processes request\n4. Returns ModelAndView\n5. ViewResolver finds view\n6. View renders response",
      "explanation": "DispatcherServlet coordinates everything. Controllers handle logic. Views render HTML/JSON. Clean separation of concerns.",
      "difficulty": "Medium",
      "code": "// 1. Configure DispatcherServlet\npublic class WebAppInitializer implements WebApplicationInitializer {\n    @Override\n    public void onStartup(ServletContext container) {\n        AnnotationConfigWebApplicationContext context = \n            new AnnotationConfigWebApplicationContext();\n        context.register(WebConfig.class);\n        \n        DispatcherServlet servlet = new DispatcherServlet(context);\n        ServletRegistration.Dynamic registration = \n            container.addServlet(\"dispatcher\", servlet);\n        registration.setLoadOnStartup(1);\n        registration.addMapping(\"/\");\n    }\n}\n\n// 2. Configuration\n@Configuration\n@EnableWebMvc\n@ComponentScan(\"com.example\")\npublic class WebConfig implements WebMvcConfigurer {\n    \n    @Bean\n    public ViewResolver viewResolver() {\n        InternalResourceViewResolver resolver = \n            new InternalResourceViewResolver();\n        resolver.setPrefix(\"/WEB-INF/views/\");\n        resolver.setSuffix(\".jsp\");\n        return resolver;\n    }\n}\n\n// 3. Controller\n@Controller\npublic class UserController {\n    @Autowired\n    private UserService userService;\n    \n    @GetMapping(\"/users\")\n    public String listUsers(Model model) {\n        model.addAttribute(\"users\", userService.findAll());\n        return \"users/list\";  // View name\n    }\n    \n    @GetMapping(\"/users/{id}\")\n    @ResponseBody\n    public User getUser(@PathVariable Long id) {\n        return userService.findById(id);  // JSON response\n    }\n    \n    @PostMapping(\"/users\")\n    public String createUser(@ModelAttribute User user, \n                           RedirectAttributes attrs) {\n        userService.save(user);\n        attrs.addFlashAttribute(\"message\", \"User created\");\n        return \"redirect:/users\";\n    }\n}"
    },
    {
      "id": 15,
      "question": "What is @RequestMapping and its variants?",
      "answer": "@RequestMapping maps HTTP requests to methods:\n\nVariants (shortcuts):\n• @GetMapping: GET requests\n• @PostMapping: POST requests\n• @PutMapping: PUT requests\n• @DeleteMapping: DELETE requests\n• @PatchMapping: PATCH requests\n\nParameters:\n• path/value: URL patterns\n• method: HTTP methods\n• params: Request parameters\n• headers: HTTP headers\n• consumes: Content-Type\n• produces: Accept header",
      "explanation": "Use specific mapping annotations for clarity. @GetMapping clearer than @RequestMapping(method = GET).",
      "difficulty": "Easy",
      "code": "@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    // GET /api/users\n    @GetMapping\n    public List<User> getAllUsers() {\n        return userService.findAll();\n    }\n    \n    // GET /api/users/123\n    @GetMapping(\"/{id}\")\n    public User getUser(@PathVariable Long id) {\n        return userService.findById(id);\n    }\n    \n    // POST /api/users\n    @PostMapping\n    public User createUser(@RequestBody User user) {\n        return userService.save(user);\n    }\n    \n    // PUT /api/users/123\n    @PutMapping(\"/{id}\")\n    public User updateUser(@PathVariable Long id, @RequestBody User user) {\n        return userService.update(id, user);\n    }\n    \n    // DELETE /api/users/123\n    @DeleteMapping(\"/{id}\")\n    public void deleteUser(@PathVariable Long id) {\n        userService.delete(id);\n    }\n    \n    // Advanced mapping\n    @GetMapping(value = \"/search\", params = \"name\")\n    public List<User> searchByName(@RequestParam String name) {\n        return userService.findByName(name);\n    }\n    \n    // Multiple paths\n    @GetMapping({\"/users\", \"/all-users\"})\n    public List<User> getUsers() {\n        return userService.findAll();\n    }\n    \n    // Content negotiation\n    @GetMapping(value = \"/export\", produces = \"application/json\")\n    public List<User> exportJson() {\n        return userService.findAll();\n    }\n    \n    @GetMapping(value = \"/export\", produces = \"application/xml\")\n    public List<User> exportXml() {\n        return userService.findAll();\n    }\n    \n    // Consumes\n    @PostMapping(consumes = \"application/json\")\n    public User createFromJson(@RequestBody User user) {\n        return userService.save(user);\n    }\n}"
    },
    {
      "id": 16,
      "question": "What is @PathVariable, @RequestParam, @RequestBody?",
      "answer": "Annotations to extract request data:\n\n@PathVariable:\n• Extract from URI path\n• Required by default\n• Part of URL\n\n@RequestParam:\n• Extract query parameters\n• Optional with defaultValue\n• Key-value pairs after ?\n\n@RequestBody:\n• Extract request body\n• Deserialize JSON/XML to object\n• Used in POST/PUT\n\n@RequestHeader: Extract headers",
      "explanation": "@PathVariable for RESTful URLs. @RequestParam for filters/search. @RequestBody for complex data in POST/PUT.",
      "difficulty": "Easy",
      "code": "@RestController\n@RequestMapping(\"/api\")\npublic class UserController {\n    \n    // @PathVariable - /api/users/123\n    @GetMapping(\"/users/{id}\")\n    public User getUser(@PathVariable Long id) {\n        return userService.findById(id);\n    }\n    \n    // Multiple path variables - /api/users/123/orders/456\n    @GetMapping(\"/users/{userId}/orders/{orderId}\")\n    public Order getUserOrder(@PathVariable Long userId, \n                             @PathVariable Long orderId) {\n        return orderService.findByUserAndOrder(userId, orderId);\n    }\n    \n    // Optional path variable\n    @GetMapping(value = {\"/users\", \"/users/{id}\"})\n    public Object getUsers(@PathVariable(required = false) Long id) {\n        return id != null ? userService.findById(id) : userService.findAll();\n    }\n    \n    // @RequestParam - /api/search?name=John&age=30\n    @GetMapping(\"/search\")\n    public List<User> search(@RequestParam String name,\n                            @RequestParam(required = false) Integer age) {\n        return userService.search(name, age);\n    }\n    \n    // Default value\n    @GetMapping(\"/users\")\n    public List<User> getUsers(\n        @RequestParam(defaultValue = \"0\") int page,\n        @RequestParam(defaultValue = \"10\") int size,\n        @RequestParam(defaultValue = \"name\") String sort\n    ) {\n        return userService.findAll(page, size, sort);\n    }\n    \n    // Optional parameter\n    @GetMapping(\"/filter\")\n    public List<User> filter(@RequestParam Optional<String> status) {\n        return status.map(userService::findByStatus)\n                    .orElse(userService.findAll());\n    }\n    \n    // @RequestBody - POST request with JSON body\n    @PostMapping(\"/users\")\n    public User createUser(@RequestBody User user) {\n        return userService.save(user);\n    }\n    \n    // @RequestHeader\n    @GetMapping(\"/info\")\n    public String getInfo(@RequestHeader(\"User-Agent\") String userAgent,\n                         @RequestHeader(\"Authorization\") String auth) {\n        return \"User-Agent: \" + userAgent;\n    }\n}"
    },
    {
      "id": 17,
      "question": "What is @ModelAttribute and Model?",
      "answer": "@ModelAttribute and Model work with form data:\n\n@ModelAttribute:\n• Bind request parameters to object\n• Add attributes to model\n• Initialize objects\n\nModel:\n• Container for view data\n• Key-value pairs\n• Passed to view\n\nModelAndView:\n• Combines model and view name\n\nUse for:\n• Form submission\n• Data binding\n• View rendering",
      "explanation": "@ModelAttribute binds form fields to object automatically. Model passes data to JSP/Thymeleaf views.",
      "difficulty": "Medium",
      "code": "@Controller\n@RequestMapping(\"/users\")\npublic class UserController {\n    \n    // Display form\n    @GetMapping(\"/new\")\n    public String showForm(Model model) {\n        model.addAttribute(\"user\", new User());\n        return \"users/form\";\n    }\n    \n    // Process form submission\n    @PostMapping\n    public String createUser(@ModelAttribute User user, \n                           Model model) {\n        userService.save(user);\n        model.addAttribute(\"message\", \"User created successfully\");\n        return \"users/success\";\n    }\n    \n    // @ModelAttribute on method - runs before all handlers\n    @ModelAttribute(\"countries\")\n    public List<String> populateCountries() {\n        return Arrays.asList(\"USA\", \"UK\", \"Canada\");\n    }\n    \n    // All handler methods will have countries in model\n    @GetMapping\n    public String listUsers() {\n        // countries already in model\n        return \"users/list\";\n    }\n    \n    // ModelAndView approach\n    @GetMapping(\"/{id}\")\n    public ModelAndView getUser(@PathVariable Long id) {\n        User user = userService.findById(id);\n        ModelAndView mav = new ModelAndView(\"users/detail\");\n        mav.addObject(\"user\", user);\n        mav.addObject(\"title\", \"User Details\");\n        return mav;\n    }\n    \n    // With validation\n    @PostMapping(\"/register\")\n    public String register(@Valid @ModelAttribute User user,\n                          BindingResult result,\n                          Model model) {\n        if (result.hasErrors()) {\n            return \"users/form\";\n        }\n        userService.save(user);\n        return \"redirect:/users\";\n    }\n}\n\n// View (Thymeleaf)\n<form th:action=\"@{/users}\" th:object=\"${user}\" method=\"post\">\n    <input type=\"text\" th:field=\"*{name}\" />\n    <input type=\"email\" th:field=\"*{email}\" />\n    <button type=\"submit\">Submit</button>\n</form>"
    },
    {
      "id": 18,
      "question": "What is Spring Validation with @Valid?",
      "answer": "Spring integrates JSR-380 Bean Validation:\n\nConstraints:\n• @NotNull: Not null\n• @NotBlank: Not null/empty/whitespace\n• @NotEmpty: Not null/empty\n• @Size: Size range\n• @Min/@Max: Number range\n• @Email: Valid email\n• @Pattern: Regex match\n• @Past/@Future: Date validation\n\n@Valid: Triggers validation\nBindingResult: Validation errors\n\nCustom validators possible.",
      "explanation": "@Valid + BindingResult provides clean validation. Define constraints on model, check errors in controller.",
      "difficulty": "Medium",
      "code": "// Model with validation\npublic class User {\n    @NotBlank(message = \"Name is required\")\n    @Size(min = 3, max = 50, message = \"Name must be 3-50 characters\")\n    private String name;\n    \n    @NotBlank\n    @Email(message = \"Invalid email format\")\n    private String email;\n    \n    @Min(value = 18, message = \"Must be at least 18\")\n    @Max(value = 100, message = \"Must be at most 100\")\n    private int age;\n    \n    @Pattern(regexp = \"^\\\\d{10}$\", message = \"Phone must be 10 digits\")\n    private String phone;\n    \n    @Past(message = \"Birth date must be in past\")\n    private LocalDate birthDate;\n    \n    @Valid  // Nested validation\n    private Address address;\n}\n\npublic class Address {\n    @NotBlank\n    private String street;\n    \n    @NotBlank\n    @Size(min = 2, max = 2)\n    private String state;\n}\n\n// Controller\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    @PostMapping\n    public ResponseEntity<?> createUser(@Valid @RequestBody User user,\n                                       BindingResult result) {\n        if (result.hasErrors()) {\n            Map<String, String> errors = new HashMap<>();\n            result.getFieldErrors().forEach(error ->\n                errors.put(error.getField(), error.getDefaultMessage())\n            );\n            return ResponseEntity.badRequest().body(errors);\n        }\n        \n        User saved = userService.save(user);\n        return ResponseEntity.ok(saved);\n    }\n}\n\n// Custom validator\n@Constraint(validatedBy = AgeValidator.class)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ValidAge {\n    String message() default \"Invalid age\";\n    Class<?>[] groups() default {};\n    Class<? extends Payload>[] payload() default {};\n}\n\npublic class AgeValidator implements ConstraintValidator<ValidAge, Integer> {\n    @Override\n    public boolean isValid(Integer age, ConstraintValidatorContext context) {\n        return age != null && age >= 18 && age <= 100;\n    }\n}\n\npublic class User {\n    @ValidAge\n    private Integer age;\n}"
    },
    {
      "id": 19,
      "question": "What is Spring Exception Handling?",
      "answer": "Spring provides multiple ways to handle exceptions:\n\n@ExceptionHandler:\n• Method-level exception handling\n• Return error response\n• In controller\n\n@ControllerAdvice:\n• Global exception handling\n• Applies to all controllers\n• Centralized error handling\n\n@ResponseStatus:\n• Map exception to HTTP status\n• Simple cases\n\nHandlerExceptionResolver:\n• Custom resolution logic\n• Advanced scenarios",
      "explanation": "@ControllerAdvice + @ExceptionHandler provides clean global error handling. Map exceptions to proper HTTP responses.",
      "difficulty": "Medium",
      "code": "// Custom exceptions\n@ResponseStatus(HttpStatus.NOT_FOUND)\npublic class ResourceNotFoundException extends RuntimeException {\n    public ResourceNotFoundException(String message) {\n        super(message);\n    }\n}\n\npublic class ValidationException extends RuntimeException {\n    private List<String> errors;\n    \n    public ValidationException(List<String> errors) {\n        this.errors = errors;\n    }\n}\n\n// Global exception handler\n@ControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    @ExceptionHandler(ResourceNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleNotFound(\n            ResourceNotFoundException ex) {\n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.NOT_FOUND.value(),\n            ex.getMessage(),\n            LocalDateTime.now()\n        );\n        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);\n    }\n    \n    @ExceptionHandler(ValidationException.class)\n    public ResponseEntity<Map<String, Object>> handleValidation(\n            ValidationException ex) {\n        Map<String, Object> body = new HashMap<>();\n        body.put(\"errors\", ex.getErrors());\n        body.put(\"timestamp\", LocalDateTime.now());\n        return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);\n    }\n    \n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity<Map<String, String>> handleMethodArgumentNotValid(\n            MethodArgumentNotValidException ex) {\n        Map<String, String> errors = new HashMap<>();\n        ex.getBindingResult().getFieldErrors().forEach(error ->\n            errors.put(error.getField(), error.getDefaultMessage())\n        );\n        return new ResponseEntity<>(errors, HttpStatus.BAD_REQUEST);\n    }\n    \n    @ExceptionHandler(Exception.class)\n    public ResponseEntity<ErrorResponse> handleGeneral(Exception ex) {\n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.INTERNAL_SERVER_ERROR.value(),\n            \"Internal server error\",\n            LocalDateTime.now()\n        );\n        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n}\n\n// Local exception handler\n@RestController\npublic class UserController {\n    \n    @ExceptionHandler(IllegalArgumentException.class)\n    public ResponseEntity<String> handleIllegalArgument(\n            IllegalArgumentException ex) {\n        return ResponseEntity.badRequest().body(ex.getMessage());\n    }\n    \n    @GetMapping(\"/users/{id}\")\n    public User getUser(@PathVariable Long id) {\n        return userService.findById(id)\n            .orElseThrow(() -> new ResourceNotFoundException(\"User not found\"));\n    }\n}\n\n// Error response DTO\npublic class ErrorResponse {\n    private int status;\n    private String message;\n    private LocalDateTime timestamp;\n    \n    // constructors, getters, setters\n}"
    },
    {
      "id": 20,
      "question": "What is Spring Interceptor vs Filter?",
      "answer": "Both intercept requests, but at different levels:\n\nFilter (Servlet):\n• Servlet container level\n• Before DispatcherServlet\n• Can modify request/response\n• Part of Java EE\n• URL patterns\n\nInterceptor (Spring):\n• Spring MVC level\n• After DispatcherServlet\n• Access to handler, model\n• Spring beans (DI available)\n• Granular control\n\nPreInterceptor → Controller → PostInterceptor",
      "explanation": "Use Filter for requests before Spring (auth, logging). Use Interceptor for Spring-specific logic (model manipulation).",
      "difficulty": "Hard",
      "code": "// Filter - Servlet level\n@Component\npublic class LoggingFilter implements Filter {\n    \n    @Override\n    public void doFilter(ServletRequest request, \n                        ServletResponse response, \n                        FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest req = (HttpServletRequest) request;\n        System.out.println(\"Filter: \" + req.getRequestURI());\n        \n        chain.doFilter(request, response);  // Continue\n        \n        System.out.println(\"Filter: Response completed\");\n    }\n}\n\n// Register filter\n@Configuration\npublic class FilterConfig {\n    @Bean\n    public FilterRegistrationBean<LoggingFilter> loggingFilter() {\n        FilterRegistrationBean<LoggingFilter> registrationBean = \n            new FilterRegistrationBean<>();\n        registrationBean.setFilter(new LoggingFilter());\n        registrationBean.addUrlPatterns(\"/api/*\");\n        registrationBean.setOrder(1);\n        return registrationBean;\n    }\n}\n\n// Interceptor - Spring MVC level\n@Component\npublic class AuthInterceptor implements HandlerInterceptor {\n    @Autowired\n    private AuthService authService;\n    \n    @Override\n    public boolean preHandle(HttpServletRequest request,\n                            HttpServletResponse response,\n                            Object handler) throws Exception {\n        String token = request.getHeader(\"Authorization\");\n        if (authService.isValid(token)) {\n            return true;  // Continue\n        }\n        response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n        return false;  // Stop\n    }\n    \n    @Override\n    public void postHandle(HttpServletRequest request,\n                          HttpServletResponse response,\n                          Object handler,\n                          ModelAndView modelAndView) throws Exception {\n        // After controller, before view\n        if (modelAndView != null) {\n            modelAndView.addObject(\"timestamp\", LocalDateTime.now());\n        }\n    }\n    \n    @Override\n    public void afterCompletion(HttpServletRequest request,\n                               HttpServletResponse response,\n                               Object handler,\n                               Exception ex) throws Exception {\n        // After view rendering\n        System.out.println(\"Request completed\");\n    }\n}\n\n// Register interceptor\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    @Autowired\n    private AuthInterceptor authInterceptor;\n    \n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(authInterceptor)\n            .addPathPatterns(\"/api/**\")\n            .excludePathPatterns(\"/api/public/**\")\n            .order(1);\n    }\n}"
    },
    {
      "id": 21,
      "question": "What is @Value and Property Injection?",
      "answer": "@Value injects values from properties:\n\nSources:\n• application.properties\n• application.yml\n• System properties\n• Environment variables\n\nFeatures:\n• Default values: ${prop:default}\n• SpEL expressions: #{expression}\n• Type conversion: String to int, etc.\n• Collections: CSV to List\n\n@PropertySource: Load custom files",
      "explanation": "@Value externalizes configuration. Keep config separate from code. Easy to change without recompiling.",
      "difficulty": "Easy",
      "code": "// application.properties\napp.name=SmartList\napp.version=1.0.0\napp.max-users=1000\napp.admins=admin@example.com,super@example.com\napp.enabled=true\napp.timeout=30\ndb.url=jdbc:mysql://localhost:3306/mydb\ndb.username=root\n\n// Configuration class\n@Configuration\n@PropertySource(\"classpath:custom.properties\")\npublic class AppConfig {\n    \n    // Simple value injection\n    @Value(\"${app.name}\")\n    private String appName;\n    \n    // With default value\n    @Value(\"${app.description:My Application}\")\n    private String description;\n    \n    // Type conversion\n    @Value(\"${app.max-users}\")\n    private int maxUsers;\n    \n    @Value(\"${app.enabled}\")\n    private boolean enabled;\n    \n    @Value(\"${app.timeout}\")\n    private Duration timeout;\n    \n    // Collection from CSV\n    @Value(\"${app.admins}\")\n    private List<String> admins;\n    \n    // SpEL expression\n    @Value(\"#{systemProperties['user.home']}\")\n    private String userHome;\n    \n    @Value(\"#{${app.max-users} * 2}\")\n    private int doubleMaxUsers;\n    \n    // Methods\n    @Value(\"#{T(java.lang.Math).random() * 100}\")\n    private double randomNumber;\n    \n    // Bean reference\n    @Value(\"#{userService.count}\")\n    private int userCount;\n}\n\n// Constructor injection (preferred)\n@Service\npublic class EmailService {\n    private final String smtpHost;\n    private final int smtpPort;\n    \n    public EmailService(\n        @Value(\"${smtp.host}\") String smtpHost,\n        @Value(\"${smtp.port}\") int smtpPort\n    ) {\n        this.smtpHost = smtpHost;\n        this.smtpPort = smtpPort;\n    }\n}\n\n// @ConfigurationProperties - type-safe alternative\n@Configuration\n@ConfigurationProperties(prefix = \"app\")\npublic class AppProperties {\n    private String name;\n    private String version;\n    private int maxUsers;\n    private List<String> admins;\n    \n    // Nested properties\n    private Database database = new Database();\n    \n    public static class Database {\n        private String url;\n        private String username;\n        private String password;\n        \n        // getters/setters\n    }\n    \n    // getters/setters\n}\n\n// Usage\n@Service\npublic class UserService {\n    @Autowired\n    private AppProperties appProperties;\n    \n    public void doSomething() {\n        String name = appProperties.getName();\n        String dbUrl = appProperties.getDatabase().getUrl();\n    }\n}"
    },
    {
      "id": 22,
      "question": "What is @Profile in Spring?",
      "answer": "@Profile enables beans based on environment:\n\nCommon profiles:\n• dev: Development\n• test: Testing\n• prod: Production\n\nActivation:\n• spring.profiles.active=dev\n• JVM arg: -Dspring.profiles.active=prod\n• Environment variable\n• Programmatic\n\nMultiple profiles:\n• @Profile({\"dev\", \"test\"})\n• @Profile(\"!prod\"): All except prod",
      "explanation": "@Profile allows environment-specific beans. Different config for dev/prod without code changes.",
      "difficulty": "Medium",
      "code": "// Profile-specific beans\n@Configuration\n@Profile(\"dev\")\npublic class DevConfig {\n    \n    @Bean\n    public DataSource dataSource() {\n        // H2 in-memory database\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.H2)\n            .build();\n    }\n}\n\n@Configuration\n@Profile(\"prod\")\npublic class ProdConfig {\n    \n    @Bean\n    public DataSource dataSource() {\n        // Production database\n        HikariConfig config = new HikariConfig();\n        config.setJdbcUrl(\"jdbc:mysql://prod-server:3306/mydb\");\n        config.setUsername(\"produser\");\n        config.setPassword(\"prodpass\");\n        return new HikariDataSource(config);\n    }\n}\n\n// Component-level profile\n@Service\n@Profile(\"dev\")\npublic class MockEmailService implements EmailService {\n    public void send(String to, String message) {\n        System.out.println(\"Mock email to \" + to + \": \" + message);\n    }\n}\n\n@Service\n@Profile(\"prod\")\npublic class RealEmailService implements EmailService {\n    public void send(String to, String message) {\n        // Real SMTP logic\n    }\n}\n\n// Multiple profiles\n@Component\n@Profile({\"dev\", \"test\"})\npublic class DebugHelper { }\n\n// Negation - all except prod\n@Component\n@Profile(\"!prod\")\npublic class DebugLogger { }\n\n// Profile-specific properties\n// application-dev.properties\nlogging.level.root=DEBUG\nspring.h2.console.enabled=true\n\n// application-prod.properties\nlogging.level.root=WARN\nspring.h2.console.enabled=false\n\n// Activate profiles\n// 1. application.properties\nspring.profiles.active=dev\n\n// 2. Command line\njava -jar -Dspring.profiles.active=prod app.jar\n\n// 3. Environment variable\nexport SPRING_PROFILES_ACTIVE=prod\n\n// 4. Programmatically\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication app = new SpringApplication(Application.class);\n        app.setAdditionalProfiles(\"dev\");\n        app.run(args);\n    }\n}\n\n// Test with profile\n@SpringBootTest\n@ActiveProfiles(\"test\")\nclass UserServiceTest {\n    // Uses test profile beans\n}"
    },
    {
      "id": 23,
      "question": "What is SpEL (Spring Expression Language)?",
      "answer": "SpEL evaluates expressions at runtime:\n\nFeatures:\n• Access properties: #{bean.property}\n• Call methods: #{bean.method()}\n• Operators: +, -, *, /, %, &&, ||\n• Collections: #{list[0]}, #{map['key']}\n• Conditionals: #{condition ? true : false}\n• Regex: matches\n• Static methods: #{T(Class).method()}\n\nUsage:\n• @Value annotations\n• XML configuration\n• Query definitions",
      "explanation": "SpEL provides powerful runtime expression evaluation. Access beans, properties, invoke methods dynamically.",
      "difficulty": "Medium",
      "code": "@Configuration\npublic class SpELExamples {\n    \n    // Literal values\n    @Value(\"#{100}\")\n    private int number;\n    \n    @Value(\"#{'Hello'}\")\n    private String text;\n    \n    // Bean reference\n    @Value(\"#{userService}\")\n    private UserService userService;\n    \n    // Bean property\n    @Value(\"#{userService.count}\")\n    private int userCount;\n    \n    // Method invocation\n    @Value(\"#{userService.getActiveCount()}\")\n    private int activeUsers;\n    \n    // Arithmetic\n    @Value(\"#{10 + 20}\")\n    private int sum;\n    \n    @Value(\"#{100 * 0.9}\")\n    private double discount;\n    \n    // Relational operators\n    @Value(\"#{userService.count > 100}\")\n    private boolean hasMany;\n    \n    // Logical operators\n    @Value(\"#{userService.count > 100 && userService.active}\")\n    private boolean condition;\n    \n    // Ternary\n    @Value(\"#{userService.count > 100 ? 'Many' : 'Few'}\")\n    private String status;\n    \n    // Elvis operator (default if null)\n    @Value(\"#{userService.name ?: 'Default'}\")\n    private String name;\n    \n    // Safe navigation (?. prevents NPE)\n    @Value(\"#{userService.manager?.name}\")\n    private String managerName;\n    \n    // Collection selection\n    @Value(\"#{users.?[age > 18]}\")\n    private List<User> adults;\n    \n    // Collection projection\n    @Value(\"#{users.![name]}\")\n    private List<String> names;\n    \n    // Array/List access\n    @Value(\"#{users[0]}\")\n    private User firstUser;\n    \n    // Map access\n    @Value(\"#{config['database.url']}\")\n    private String dbUrl;\n    \n    // System properties\n    @Value(\"#{systemProperties['user.home']}\")\n    private String userHome;\n    \n    // Environment variables\n    @Value(\"#{systemEnvironment['PATH']}\")\n    private String path;\n    \n    // Static method\n    @Value(\"#{T(java.lang.Math).random()}\")\n    private double random;\n    \n    @Value(\"#{T(java.time.LocalDate).now()}\")\n    private LocalDate today;\n    \n    // Static field\n    @Value(\"#{T(java.lang.Math).PI}\")\n    private double pi;\n    \n    // Regex\n    @Value(\"#{email matches '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}'}\")\n    private boolean validEmail;\n}\n\n// In @Query\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    @Query(\"SELECT u FROM User u WHERE u.age > #{#minAge}\")\n    List<User> findAdults(@Param(\"minAge\") int minAge);\n}\n\n// Programmatic usage\npublic class SpELDemo {\n    public void demo() {\n        ExpressionParser parser = new SpelExpressionParser();\n        Expression exp = parser.parseExpression(\"'Hello'.concat(' World')\");\n        String message = (String) exp.getValue();\n        \n        // With context\n        User user = new User(\"John\", 30);\n        EvaluationContext context = new StandardEvaluationContext(user);\n        String name = (String) parser.parseExpression(\"name\").getValue(context);\n        int age = (Integer) parser.parseExpression(\"age\").getValue(context);\n    }\n}"
    },
    {
      "id": 24,
      "question": "What are Bean Post Processors?",
      "answer": "BeanPostProcessor customizes bean creation:\n\nMethods:\n• postProcessBeforeInitialization: Before init\n• postProcessAfterInitialization: After init\n\nUse cases:\n• Modify beans\n• Wrap in proxy\n• Validate configuration\n• Custom initialization\n\nSpring uses internally:\n• @Autowired processing\n• AOP proxy creation\n• @Value injection",
      "explanation": "BeanPostProcessor hooks into bean lifecycle. Powerful for framework-level customizations. AOP, validation, proxies use this.",
      "difficulty": "Hard",
      "code": "// Custom post processor\n@Component\npublic class LoggingBeanPostProcessor implements BeanPostProcessor {\n    \n    @Override\n    public Object postProcessBeforeInitialization(\n            Object bean, String beanName) throws BeansException {\n        System.out.println(\"Before init: \" + beanName);\n        return bean;  // Return modified bean if needed\n    }\n    \n    @Override\n    public Object postProcessAfterInitialization(\n            Object bean, String beanName) throws BeansException {\n        System.out.println(\"After init: \" + beanName);\n        return bean;\n    }\n}\n\n// Conditional processing\n@Component\npublic class ValidationPostProcessor implements BeanPostProcessor {\n    \n    @Override\n    public Object postProcessAfterInitialization(\n            Object bean, String beanName) throws BeansException {\n        \n        // Only process @Service beans\n        if (bean.getClass().isAnnotationPresent(Service.class)) {\n            System.out.println(\"Validating service: \" + beanName);\n            // Perform validation\n        }\n        return bean;\n    }\n}\n\n// Proxy creation example\n@Component\npublic class ProxyPostProcessor implements BeanPostProcessor {\n    \n    @Override\n    public Object postProcessAfterInitialization(\n            Object bean, String beanName) throws BeansException {\n        \n        // Create proxy for beans with @Monitored\n        if (bean.getClass().isAnnotationPresent(Monitored.class)) {\n            return Proxy.newProxyInstance(\n                bean.getClass().getClassLoader(),\n                bean.getClass().getInterfaces(),\n                (proxy, method, args) -> {\n                    long start = System.currentTimeMillis();\n                    Object result = method.invoke(bean, args);\n                    long duration = System.currentTimeMillis() - start;\n                    System.out.println(method.getName() + \": \" + duration + \"ms\");\n                    return result;\n                }\n            );\n        }\n        return bean;\n    }\n}\n\n@Retention(RetentionPolicy.RUNTIME)\n@interface Monitored { }\n\n@Service\n@Monitored\npublic class UserService {\n    public List<User> findAll() {\n        // Method execution will be monitored\n        return users;\n    }\n}\n\n// Built-in post processors\n@Configuration\npublic class AppConfig {\n    \n    // Enable @Autowired\n    @Bean\n    public static AutowiredAnnotationBeanPostProcessor autowiredProcessor() {\n        return new AutowiredAnnotationBeanPostProcessor();\n    }\n    \n    // Enable @Required\n    @Bean\n    public static RequiredAnnotationBeanPostProcessor requiredProcessor() {\n        return new RequiredAnnotationBeanPostProcessor();\n    }\n}"
    },
    {
      "id": 25,
      "question": "What are ApplicationContext Events?",
      "answer": "ApplicationContext publishes events:\n\nBuilt-in events:\n• ContextRefreshedEvent: Context initialized\n• ContextStartedEvent: Context started\n• ContextStoppedEvent: Context stopped\n• ContextClosedEvent: Context closed\n• RequestHandledEvent: HTTP request handled\n\nCustom events:\n• Extend ApplicationEvent\n• Publish with ApplicationEventPublisher\n• Listen with @EventListener\n\nAsync: @EnableAsync + @Async",
      "explanation": "Events decouple components. Publisher doesn't know listeners. Good for notifications, audit logs.",
      "difficulty": "Medium",
      "code": "// Built-in event listener\n@Component\npublic class ApplicationStartupListener {\n    \n    @EventListener\n    public void handleContextRefresh(ContextRefreshedEvent event) {\n        System.out.println(\"Context refreshed!\");\n        // Initialize caches, warm up data\n    }\n    \n    @EventListener\n    public void handleContextClosed(ContextClosedEvent event) {\n        System.out.println(\"Context closing!\");\n        // Cleanup resources\n    }\n}\n\n// Custom event\npublic class UserRegisteredEvent extends ApplicationEvent {\n    private final User user;\n    \n    public UserRegisteredEvent(Object source, User user) {\n        super(source);\n        this.user = user;\n    }\n    \n    public User getUser() {\n        return user;\n    }\n}\n\n// Or with @Component (Spring 4.2+)\npublic class OrderCreatedEvent {\n    private final Order order;\n    \n    public OrderCreatedEvent(Order order) {\n        this.order = order;\n    }\n    \n    public Order getOrder() {\n        return order;\n    }\n}\n\n// Publisher\n@Service\npublic class UserService {\n    @Autowired\n    private ApplicationEventPublisher eventPublisher;\n    \n    public User register(User user) {\n        user = userRepository.save(user);\n        \n        // Publish event\n        eventPublisher.publishEvent(new UserRegisteredEvent(this, user));\n        \n        return user;\n    }\n}\n\n// Listeners\n@Component\npublic class EmailNotificationListener {\n    \n    @EventListener\n    public void handleUserRegistered(UserRegisteredEvent event) {\n        User user = event.getUser();\n        emailService.sendWelcomeEmail(user.getEmail());\n    }\n    \n    // Async listener\n    @EventListener\n    @Async\n    public void sendAnalytics(UserRegisteredEvent event) {\n        analyticsService.track(\"user_registered\", event.getUser());\n    }\n    \n    // Conditional listener\n    @EventListener(condition = \"#event.user.premium\")\n    public void handlePremiumUser(UserRegisteredEvent event) {\n        premiumService.setup(event.getUser());\n    }\n}\n\n@Component\npublic class AuditListener {\n    @EventListener\n    public void log(UserRegisteredEvent event) {\n        auditLog.log(\"User registered: \" + event.getUser().getEmail());\n    }\n}\n\n// Multiple events\n@Component\npublic class NotificationService {\n    @EventListener({UserRegisteredEvent.class, OrderCreatedEvent.class})\n    public void handleEvent(ApplicationEvent event) {\n        if (event instanceof UserRegisteredEvent) {\n            // Handle user registration\n        } else if (event instanceof OrderCreatedEvent) {\n            // Handle order creation\n        }\n    }\n}\n\n// Generic event\n@Component\npublic class GenericListener {\n    @EventListener\n    public void handleEntityCreated(EntityCreatedEvent<User> event) {\n        User user = event.getEntity();\n    }\n}\n\n// Enable async\n@Configuration\n@EnableAsync\npublic class AsyncConfig { }"
    },
    {
      "id": 26,
      "question": "What is ResourceLoader and Resource?",
      "answer": "ResourceLoader loads resources from various locations:\n\nPrefixes:\n• classpath:: Classpath resource\n• file:: File system\n• http:: HTTP URL\n• ftp:: FTP URL\n• No prefix: Depends on ApplicationContext\n\nResource interface:\n• getInputStream()\n• exists()\n• getFile()\n• getURL()\n\nApplicationContext implements ResourceLoader.",
      "explanation": "ResourceLoader abstracts resource location. Load from classpath, file system, URL uniformly.",
      "difficulty": "Medium",
      "code": "@Service\npublic class FileService {\n    @Autowired\n    private ResourceLoader resourceLoader;\n    \n    public void loadResources() throws IOException {\n        // Classpath resource\n        Resource resource = resourceLoader.getResource(\n            \"classpath:templates/email.html\");\n        String content = new String(resource.getInputStream().readAllBytes());\n        \n        // File system\n        Resource fileResource = resourceLoader.getResource(\n            \"file:/tmp/data.txt\");\n        boolean exists = fileResource.exists();\n        \n        // HTTP URL\n        Resource httpResource = resourceLoader.getResource(\n            \"http://example.com/data.json\");\n        InputStream is = httpResource.getInputStream();\n        \n        // Get File object\n        File file = resource.getFile();\n        \n        // Get URL\n        URL url = resource.getURL();\n        \n        // Get description\n        String description = resource.getDescription();\n    }\n}\n\n// @Value with Resource\n@Component\npublic class ConfigLoader {\n    @Value(\"classpath:config/application.yaml\")\n    private Resource configFile;\n    \n    @PostConstruct\n    public void loadConfig() throws IOException {\n        String yaml = new String(\n            configFile.getInputStream().readAllBytes());\n        // Parse YAML\n    }\n}\n\n// Multiple resources with wildcards\n@Service\npublic class TemplateLoader {\n    @Autowired\n    private ResourcePatternResolver resourceResolver;\n    \n    public void loadTemplates() throws IOException {\n        // Load all HTML files in templates folder\n        Resource[] resources = resourceResolver.getResources(\n            \"classpath:templates/*.html\");\n        \n        for (Resource resource : resources) {\n            String filename = resource.getFilename();\n            String content = new String(\n                resource.getInputStream().readAllBytes());\n            System.out.println(\"Loaded: \" + filename);\n        }\n    }\n}\n\n// ClassPathResource directly\npublic class DirectResourceUsage {\n    public void load() throws IOException {\n        Resource resource = new ClassPathResource(\"data/users.csv\");\n        if (resource.exists()) {\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(resource.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        }\n    }\n}\n\n// Other Resource implementations\npublic class ResourceExamples {\n    public void examples() throws IOException {\n        // File system\n        Resource fileRes = new FileSystemResource(\"/tmp/file.txt\");\n        \n        // URL\n        Resource urlRes = new UrlResource(\"http://example.com/data\");\n        \n        // Byte array\n        byte[] data = \"Hello\".getBytes();\n        Resource byteRes = new ByteArrayResource(data);\n        \n        // Input stream\n        InputStream is = new FileInputStream(\"/tmp/data\");\n        Resource inputRes = new InputStreamResource(is);\n    }\n}"
    },
    {
      "id": 27,
      "question": "What is MessageSource for i18n?",
      "answer": "MessageSource provides internationalization (i18n):\n\nFeatures:\n• Load messages from properties\n• Support multiple locales\n• Parameterized messages\n• Fallback to default\n\nFiles:\n• messages.properties (default)\n• messages_en.properties (English)\n• messages_es.properties (Spanish)\n• messages_fr.properties (French)\n\nUsage: getMessage(code, args, locale)",
      "explanation": "MessageSource enables multi-language apps. Store translations in properties files. Select based on locale.",
      "difficulty": "Medium",
      "code": "// Configuration\n@Configuration\npublic class I18nConfig {\n    \n    @Bean\n    public MessageSource messageSource() {\n        ResourceBundleMessageSource messageSource = \n            new ResourceBundleMessageSource();\n        messageSource.setBasename(\"messages\");\n        messageSource.setDefaultEncoding(\"UTF-8\");\n        messageSource.setCacheSeconds(3600);\n        messageSource.setFallbackToSystemLocale(false);\n        return messageSource;\n    }\n    \n    @Bean\n    public LocaleResolver localeResolver() {\n        SessionLocaleResolver resolver = new SessionLocaleResolver();\n        resolver.setDefaultLocale(Locale.ENGLISH);\n        return resolver;\n    }\n    \n    @Bean\n    public LocaleChangeInterceptor localeChangeInterceptor() {\n        LocaleChangeInterceptor interceptor = \n            new LocaleChangeInterceptor();\n        interceptor.setParamName(\"lang\");\n        return interceptor;\n    }\n}\n\n// messages.properties (default English)\nwelcome.message=Welcome to our application!\nuser.greeting=Hello, {0}!\ncount.users={0} user(s) found\nerror.notfound=Resource not found\n\n// messages_es.properties (Spanish)\nwelcome.message=¡Bienvenido a nuestra aplicación!\nuser.greeting=¡Hola, {0}!\ncount.users={0} usuario(s) encontrado(s)\nerror.notfound=Recurso no encontrado\n\n// messages_fr.properties (French)\nwelcome.message=Bienvenue dans notre application!\nuser.greeting=Bonjour, {0}!\ncount.users={0} utilisateur(s) trouvé(s)\nerror.notfound=Ressource non trouvée\n\n// Service usage\n@Service\npublic class NotificationService {\n    @Autowired\n    private MessageSource messageSource;\n    \n    public String getWelcomeMessage(Locale locale) {\n        return messageSource.getMessage(\n            \"welcome.message\", \n            null, \n            locale\n        );\n    }\n    \n    public String getUserGreeting(String name, Locale locale) {\n        return messageSource.getMessage(\n            \"user.greeting\", \n            new Object[]{name}, \n            locale\n        );\n    }\n    \n    public String getCountMessage(int count, Locale locale) {\n        return messageSource.getMessage(\n            \"count.users\", \n            new Object[]{count}, \n            locale\n        );\n    }\n    \n    // With default message\n    public String getMessageOrDefault(String code, Locale locale) {\n        return messageSource.getMessage(\n            code, \n            null, \n            \"Default message\", \n            locale\n        );\n    }\n}\n\n// Controller usage\n@RestController\npublic class UserController {\n    @Autowired\n    private MessageSource messageSource;\n    \n    @GetMapping(\"/welcome\")\n    public String welcome(Locale locale) {\n        return messageSource.getMessage(\"welcome.message\", null, locale);\n    }\n    \n    @GetMapping(\"/greet/{name}\")\n    public String greet(@PathVariable String name, Locale locale) {\n        return messageSource.getMessage(\n            \"user.greeting\", \n            new Object[]{name}, \n            locale\n        );\n    }\n}\n\n// Change locale via URL parameter\n// http://localhost:8080/welcome?lang=es\n// http://localhost:8080/welcome?lang=fr"
    },
    {
      "id": 28,
      "question": "What is Environment abstraction?",
      "answer": "Environment provides access to configuration:\n\nComponents:\n• PropertySources: Multiple property sources\n• Profiles: Active profiles\n\nProperty sources hierarchy:\n1. JVM system properties\n2. System environment variables\n3. application.properties\n4. @PropertySource files\n\nMethods:\n• getProperty()\n• containsProperty()\n• getActiveProfiles()\n• getDefaultProfiles()",
      "explanation": "Environment unifies all configuration sources. Access properties from any source. Check active profiles.",
      "difficulty": "Medium",
      "code": "@Service\npublic class ConfigService {\n    @Autowired\n    private Environment environment;\n    \n    public void useEnvironment() {\n        // Get property\n        String appName = environment.getProperty(\"app.name\");\n        \n        // With default value\n        String port = environment.getProperty(\"server.port\", \"8080\");\n        \n        // With type conversion\n        int maxUsers = environment.getProperty(\"app.max-users\", Integer.class);\n        Integer timeout = environment.getProperty(\n            \"app.timeout\", \n            Integer.class, \n            30\n        );\n        \n        // Check if property exists\n        boolean hasDb = environment.containsProperty(\"db.url\");\n        \n        // Required property (throws if missing)\n        String dbUrl = environment.getRequiredProperty(\"db.url\");\n        \n        // Get active profiles\n        String[] profiles = environment.getActiveProfiles();\n        System.out.println(\"Active profiles: \" + Arrays.toString(profiles));\n        \n        // Check if profile is active\n        boolean isDev = Arrays.asList(profiles).contains(\"dev\");\n        \n        // Default profiles\n        String[] defaultProfiles = environment.getDefaultProfiles();\n        \n        // Accept profiles (check if any match)\n        boolean matches = environment.acceptsProfiles(\n            Profiles.of(\"dev\", \"test\")\n        );\n    }\n}\n\n// Custom property source\n@Configuration\npublic class CustomConfigLoader {\n    \n    @Bean\n    public static PropertySourcesPlaceholderConfigurer propertyConfigurer() {\n        return new PropertySourcesPlaceholderConfigurer();\n    }\n    \n    @Autowired\n    public void configureEnvironment(ConfigurableEnvironment environment) {\n        // Add custom property source\n        Map<String, Object> props = new HashMap<>();\n        props.put(\"custom.property\", \"value\");\n        \n        PropertySource<?> propertySource = \n            new MapPropertySource(\"customSource\", props);\n        environment.getPropertySources().addFirst(propertySource);\n    }\n}\n\n// Conditional bean based on environment\n@Configuration\npublic class ConditionalConfig {\n    @Autowired\n    private Environment environment;\n    \n    @Bean\n    public DataSource dataSource() {\n        if (environment.acceptsProfiles(Profiles.of(\"dev\"))) {\n            return createH2DataSource();\n        } else {\n            return createProductionDataSource();\n        }\n    }\n}\n\n// Profile-specific property resolution\n@Component\npublic class AppInfo {\n    @Autowired\n    private Environment env;\n    \n    @PostConstruct\n    public void printInfo() {\n        System.out.println(\"Active profiles: \" + \n            Arrays.toString(env.getActiveProfiles()));\n        System.out.println(\"App name: \" + env.getProperty(\"app.name\"));\n        System.out.println(\"Environment type: \" + \n            (env.acceptsProfiles(Profiles.of(\"prod\")) \n                ? \"Production\" : \"Development\"));\n    }\n}"
    },
    {
      "id": 29,
      "question": "What is @PropertySource?",
      "answer": "@PropertySource loads external properties:\n\nFeatures:\n• Load from classpath\n• Load from file system\n• Multiple files\n• Encoding support\n• Ignore if not found\n\nOrder:\n• Later sources override earlier\n• Use @Order for precedence\n\nAccess:\n• @Value injection\n• Environment.getProperty()\n• @ConfigurationProperties",
      "explanation": "@PropertySource externalizes config to separate files. Keep different configs organized. Override in different environments.",
      "difficulty": "Easy",
      "code": "// Single property source\n@Configuration\n@PropertySource(\"classpath:database.properties\")\npublic class DatabaseConfig {\n    @Value(\"${db.url}\")\n    private String url;\n    \n    @Value(\"${db.username}\")\n    private String username;\n    \n    @Value(\"${db.password}\")\n    private String password;\n}\n\n// Multiple property sources\n@Configuration\n@PropertySource(\"classpath:app.properties\")\n@PropertySource(\"classpath:db.properties\")\n@PropertySource(\"classpath:cache.properties\")\npublic class AppConfig { }\n\n// Or array syntax\n@Configuration\n@PropertySources({\n    @PropertySource(\"classpath:app.properties\"),\n    @PropertySource(\"classpath:db.properties\"),\n    @PropertySource(\"classpath:cache.properties\")\n})\npublic class MultiConfig { }\n\n// With encoding\n@Configuration\n@PropertySource(\n    value = \"classpath:i18n.properties\", \n    encoding = \"UTF-8\"\n)\npublic class I18nConfig { }\n\n// Ignore if not found\n@Configuration\n@PropertySource(\n    value = \"classpath:optional.properties\", \n    ignoreResourceNotFound = true\n)\npublic class OptionalConfig { }\n\n// File system resource\n@Configuration\n@PropertySource(\"file:/etc/myapp/config.properties\")\npublic class ExternalConfig { }\n\n// With placeholders\n@Configuration\n@PropertySource(\"classpath:${config.file:default}.properties\")\npublic class DynamicConfig { }\n\n// Order matters - last wins\n@Configuration\n@PropertySource(\"classpath:default.properties\")  // Base values\n@PropertySource(\"classpath:override.properties\")  // Override values\npublic class PriorityConfig { }\n\n// database.properties\ndb.url=jdbc:mysql://localhost:3306/mydb\ndb.username=root\ndb.password=secret\ndb.driver=com.mysql.cj.jdbc.Driver\ndb.pool.size=10\n\n// app.properties\napp.name=SmartList\napp.version=1.0.0\napp.timeout=30\napp.max-users=1000\n\n// Usage with Environment\n@Service\npublic class ConfigService {\n    @Autowired\n    private Environment env;\n    \n    public void printConfig() {\n        System.out.println(\"DB URL: \" + env.getProperty(\"db.url\"));\n        System.out.println(\"App Name: \" + env.getProperty(\"app.name\"));\n    }\n}\n\n// Type-safe with @ConfigurationProperties\n@Configuration\n@PropertySource(\"classpath:email.properties\")\n@ConfigurationProperties(prefix = \"email\")\npublic class EmailProperties {\n    private String host;\n    private int port;\n    private String username;\n    private String password;\n    \n    // getters/setters\n}"
    },
    {
      "id": 30,
      "question": "What is placeholder resolution in Spring?",
      "answer": "Placeholders use ${property} syntax:\n\nFeatures:\n• Property references: ${app.name}\n• Default values: ${app.port:8080}\n• Nested references: ${db.${env}.url}\n• System properties: ${user.home}\n• Environment variables: ${PATH}\n\nResolver:\n• PropertySourcesPlaceholderConfigurer\n• Enabled by default in Spring Boot\n• @EnableConfigurationProperties\n\nUse in:\n• @Value\n• XML configuration\n• @PropertySource",
      "explanation": "Placeholders externalize config values. Reference properties dynamically. Provide defaults. Support multiple sources.",
      "difficulty": "Medium",
      "code": "// application.properties\napp.name=SmartList\napp.version=1.0.0\napp.description=${app.name} v${app.version}\napp.port=8080\napp.base-url=http://localhost:${app.port}\n\n// Environment-specific\nenv=dev\ndb.url=${db.${env}.url}\ndb.dev.url=jdbc:h2:mem:testdb\ndb.prod.url=jdbc:mysql://prod-server:3306/mydb\n\n// With defaults\napp.timeout=${timeout:30}\napp.cache-size=${cache.size:100}\n\n// System properties\nuser.home.dir=${user.home}\njava.version=${java.version}\n\n// Usage in @Value\n@Component\npublic class AppConfig {\n    // Simple placeholder\n    @Value(\"${app.name}\")\n    private String appName;\n    \n    // With default\n    @Value(\"${app.timeout:30}\")\n    private int timeout;\n    \n    // Composed value\n    @Value(\"${app.description}\")\n    private String description;\n    \n    // URL composition\n    @Value(\"${app.base-url}\")\n    private String baseUrl;\n    \n    // Environment variable\n    @Value(\"${PATH}\")\n    private String path;\n    \n    // System property\n    @Value(\"${user.home}\")\n    private String userHome;\n    \n    // Nested reference\n    @Value(\"${db.url}\")\n    private String dbUrl;\n}\n\n// Enable placeholder resolution\n@Configuration\npublic class PlaceholderConfig {\n    \n    @Bean\n    public static PropertySourcesPlaceholderConfigurer \n            propertyConfigurer() {\n        PropertySourcesPlaceholderConfigurer configurer = \n            new PropertySourcesPlaceholderConfigurer();\n        configurer.setIgnoreUnresolvablePlaceholders(false);\n        configurer.setIgnoreResourceNotFound(false);\n        return configurer;\n    }\n}\n\n// Programmatic resolution\n@Service\npublic class ConfigService {\n    @Autowired\n    private Environment env;\n    \n    public String resolvePlaceholder(String placeholder) {\n        PropertyResolver resolver = \n            (PropertyResolver) env;\n        return resolver.resolvePlaceholders(placeholder);\n    }\n    \n    public void demo() {\n        // Resolve at runtime\n        String url = resolvePlaceholder(\"http://localhost:${app.port}/api\");\n        System.out.println(url);  // http://localhost:8080/api\n    }\n}\n\n// In bean definitions\n@Configuration\npublic class DataSourceConfig {\n    \n    @Bean\n    public DataSource dataSource(\n        @Value(\"${db.url}\") String url,\n        @Value(\"${db.username}\") String username,\n        @Value(\"${db.password}\") String password\n    ) {\n        HikariConfig config = new HikariConfig();\n        config.setJdbcUrl(url);\n        config.setUsername(username);\n        config.setPassword(password);\n        return new HikariDataSource(config);\n    }\n}"
    },
    {
      "id": 31,
      "question": "What is JdbcTemplate in Spring?",
      "answer": "JdbcTemplate simplifies JDBC operations:\n\nBenefits:\n•Eliminates boilerplate\n• Auto resource management\n• Exception translation\n• No connection leaks\n\nOperations:\n• query: SELECT\n• update: INSERT/UPDATE/DELETE\n• execute: DDL statements\n• batchUpdate: Batch operations\n\nRowMapper: Map ResultSet to object\nResultSetExtractor: Custom extraction",
      "explanation": "JdbcTemplate removes JDBC boilerplate. No try-catch-finally. Spring manages connections. Clean, concise code.",
      "difficulty": "Medium",
      "code": "@Repository\npublic class UserRepository {\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n    \n    // Query for single object\n    public User findById(Long id) {\n        String sql = \"SELECT * FROM users WHERE id = ?\";\n        return jdbcTemplate.queryForObject(sql, new UserRowMapper(), id);\n    }\n    \n    // Query for list\n    public List<User> findAll() {\n        String sql = \"SELECT * FROM users\";\n        return jdbcTemplate.query(sql, new UserRowMapper());\n    }\n    \n    // Query with lambda\n    public List<User> findByStatus(String status) {\n        String sql = \"SELECT * FROM users WHERE status = ?\";\n        return jdbcTemplate.query(sql, \n            (rs, rowNum) -> new User(\n                rs.getLong(\"id\"),\n                rs.getString(\"name\"),\n                rs.getString(\"email\")\n            ),\n            status\n        );\n    }\n    \n    // Query for primitive\n    public int count() {\n        String sql = \"SELECT COUNT(*) FROM users\";\n        return jdbcTemplate.queryForObject(sql, Integer.class);\n    }\n    \n    // Insert\n    public int insert(User user) {\n        String sql = \"INSERT INTO users (name, email, age) VALUES (?, ?, ?)\";\n        return jdbcTemplate.update(sql, \n            user.getName(), \n            user.getEmail(), \n            user.getAge()\n        );\n    }\n    \n    // Update\n    public int update(User user) {\n        String sql = \"UPDATE users SET name = ?, email = ? WHERE id = ?\";\n        return jdbcTemplate.update(sql, \n            user.getName(), \n            user.getEmail(), \n            user.getId()\n        );\n    }\n    \n    // Delete\n    public int delete(Long id) {\n        String sql = \"DELETE FROM users WHERE id = ?\";\n        return jdbcTemplate.update(sql, id);\n    }\n    \n    // Batch operations\n    public int[] batchInsert(List<User> users) {\n        String sql = \"INSERT INTO users (name, email) VALUES (?, ?)\";\n        return jdbcTemplate.batchUpdate(sql, \n            new BatchPreparedStatementSetter() {\n                @Override\n                public void setValues(PreparedStatement ps, int i) \n                        throws SQLException {\n                    User user = users.get(i);\n                    ps.setString(1, user.getName());\n                    ps.setString(2, user.getEmail());\n                }\n                \n                @Override\n                public int getBatchSize() {\n                    return users.size();\n                }\n            }\n        );\n    }\n    \n    // RowMapper implementation\n    private static class UserRowMapper implements RowMapper<User> {\n        @Override\n        public User mapRow(ResultSet rs, int rowNum) throws SQLException {\n            User user = new User();\n            user.setId(rs.getLong(\"id\"));\n            user.setName(rs.getString(\"name\"));\n            user.setEmail(rs.getString(\"email\"));\n            user.setAge(rs.getInt(\"age\"));\n            return user;\n        }\n    }\n}\n\n// Configuration\n@Configuration\npublic class DataConfig {\n    @Bean\n    public JdbcTemplate jdbcTemplate(DataSource dataSource) {\n        return new JdbcTemplate(dataSource);\n    }\n}"
    },
    {
      "id": 32,
      "question": "What is NamedParameterJdbcTemplate?",
      "answer": "NamedParameterJdbcTemplate uses named parameters:\n\nBenefits:\n• Named params instead of ?\n• More readable\n• Less error-prone\n• Easier maintenance\n\nParameter sources:\n• MapSqlParameterSource\n• BeanPropertySqlParameterSource\n• Map<String, Object>\n\nSyntax: :paramName",
      "explanation": "Named parameters clearer than positional ?. Easy to see what each parameter represents. Less mistakes.",
      "difficulty": "Medium",
      "code": "@Repository\npublic class UserRepository {\n    @Autowired\n    private NamedParameterJdbcTemplate namedJdbcTemplate;\n    \n    // Using Map\n    public User findById(Long id) {\n        String sql = \"SELECT * FROM users WHERE id = :id\";\n        Map<String, Object> params = new HashMap<>();\n        params.put(\"id\", id);\n        return namedJdbcTemplate.queryForObject(sql, params, new UserRowMapper());\n    }\n    \n    // Multiple named parameters\n    public List<User> findByNameAndAge(String name, int age) {\n        String sql = \"SELECT * FROM users WHERE name = :name AND age > :age\";\n        Map<String, Object> params = new HashMap<>();\n        params.put(\"name\", name);\n        params.put(\"age\", age);\n        return namedJdbcTemplate.query(sql, params, new UserRowMapper());\n    }\n    \n    // MapSqlParameterSource\n    public int insert(User user) {\n        String sql = \"INSERT INTO users (name, email, age) \" +\n                    \"VALUES (:name, :email, :age)\";\n        \n        MapSqlParameterSource params = new MapSqlParameterSource()\n            .addValue(\"name\", user.getName())\n            .addValue(\"email\", user.getEmail())\n            .addValue(\"age\", user.getAge());\n        \n        return namedJdbcTemplate.update(sql, params);\n    }\n    \n    // BeanPropertySqlParameterSource - maps bean properties\n    public int insertFromBean(User user) {\n        String sql = \"INSERT INTO users (name, email, age) \" +\n                    \"VALUES (:name, :email, :age)\";\n        \n        SqlParameterSource params = \n            new BeanPropertySqlParameterSource(user);\n        \n        return namedJdbcTemplate.update(sql, params);\n    }\n    \n    // IN clause with List\n    public List<User> findByIds(List<Long> ids) {\n        String sql = \"SELECT * FROM users WHERE id IN (:ids)\";\n        Map<String, Object> params = new HashMap<>();\n        params.put(\"ids\", ids);\n        return namedJdbcTemplate.query(sql, params, new UserRowMapper());\n    }\n    \n    // Complex query\n    public List<User> search(String name, Integer minAge, Integer maxAge, \n                            String status) {\n        StringBuilder sql = new StringBuilder(\n            \"SELECT * FROM users WHERE 1=1\");\n        \n        MapSqlParameterSource params = new MapSqlParameterSource();\n        \n        if (name != null) {\n            sql.append(\" AND name LIKE :name\");\n            params.addValue(\"name\", \"%\" + name + \"%\");\n        }\n        if (minAge != null) {\n            sql.append(\" AND age >= :minAge\");\n            params.addValue(\"minAge\", minAge);\n        }\n        if (maxAge != null) {\n            sql.append(\" AND age <= :maxAge\");\n            params.addValue(\"maxAge\", maxAge);\n        }\n        if (status != null) {\n            sql.append(\" AND status = :status\");\n            params.addValue(\"status\", status);\n        }\n        \n        return namedJdbcTemplate.query(sql.toString(), params, \n            new UserRowMapper());\n    }\n    \n    // Batch operations\n    public int[] batchInsert(List<User> users) {\n        String sql = \"INSERT INTO users (name, email) VALUES (:name, :email)\";\n        \n        SqlParameterSource[] batch = \n            SqlParameterSourceUtils.createBatch(users.toArray());\n        \n        return namedJdbcTemplate.batchUpdate(sql, batch);\n    }\n}\n\n// Configuration\n@Configuration\npublic class DataConfig {\n    @Bean\n    public NamedParameterJdbcTemplate namedParameterJdbcTemplate(\n            DataSource dataSource) {\n        return new NamedParameterJdbcTemplate(dataSource);\n    }\n}"
    },
    {
      "id": 33,
      "question": "What is Spring Data Access Exception Hierarchy?",
      "answer": "Spring translates vendor-specific exceptions:\n\nBase: DataAccessException (unchecked)\n\nCategories:\n• NonTransientDataAccessException: Retry won't help\n• RecoverableDataAccessException: Might recover\n• ScriptException: SQL script errors\n• TransientDataAccessException: Temporary, retry may help\n\nCommon:\n• DuplicateKeyException\n• DataIntegrityViolationException\n• EmptyResultDataAccessException\n• IncorrectResultSizeDataAccessException",
      "explanation": "Spring provides consistent exception hierarchy. Same exceptions regardless of database. No vendor lock-in.",
      "difficulty": "Hard",
      "code": "@Service\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n    \n    public User createUser(User user) {\n        try {\n            return userRepository.save(user);\n        } catch (DuplicateKeyException e) {\n            // Unique constraint violation\n            throw new BusinessException(\"User already exists\");\n        } catch (DataIntegrityViolationException e) {\n            // Foreign key, check constraint violations\n            throw new BusinessException(\"Invalid data\");\n        }\n    }\n    \n    public User findById(Long id) {\n        try {\n            return userRepository.findById(id);\n        } catch (EmptyResultDataAccessException e) {\n            // No rows returned\n            throw new NotFoundException(\"User not found\");\n        } catch (IncorrectResultSizeDataAccessException e) {\n            // Expected 1, got multiple\n            throw new BusinessException(\"Multiple users found\");\n        }\n    }\n    \n    public void performOperation() {\n        try {\n            userRepository.complexOperation();\n        } catch (TransientDataAccessException e) {\n            // Temporary failure - retry may succeed\n            // Deadlock, timeout\n            retryOperation();\n        } catch (NonTransientDataAccessException e) {\n            // Permanent failure - retry won't help\n            // Bad SQL, invalid table\n            throw new SystemException(\"Operation failed\", e);\n        }\n    }\n}\n\n// Exception hierarchy\n// DataAccessException (abstract, unchecked)\n//   ├── NonTransientDataAccessException\n//   │   ├── DataAccessResourceFailureException\n//   │   ├── DataIntegrityViolationException\n//   │   │   └── DuplicateKeyException\n//   │   ├── DataRetrievalFailureException\n//   │   │   ├── EmptyResultDataAccessException\n//   │   │   └── IncorrectResultSizeDataAccessException\n//   │   ├── InvalidDataAccessApiUsageException\n//   │   └── PermissionDeniedDataAccessException\n//   ├── RecoverableDataAccessException\n//   ├── ScriptException\n//   └── TransientDataAccessException\n//       ├── ConcurrencyFailureException\n//       │   └── OptimisticLockingFailureException\n//       ├── QueryTimeoutException\n//       └── TransientDataAccessResourceException\n\n// Global exception handler\n@ControllerAdvice\npublic class DataAccessExceptionHandler {\n    \n    @ExceptionHandler(DuplicateKeyException.class)\n    public ResponseEntity<String> handleDuplicate(DuplicateKeyException e) {\n        return ResponseEntity.status(HttpStatus.CONFLICT)\n            .body(\"Resource already exists\");\n    }\n    \n    @ExceptionHandler(EmptyResultDataAccessException.class)\n    public ResponseEntity<String> handleNotFound(\n            EmptyResultDataAccessException e) {\n        return ResponseEntity.status(HttpStatus.NOT_FOUND)\n            .body(\"Resource not found\");\n    }\n    \n    @ExceptionHandler(DataIntegrityViolationException.class)\n    public ResponseEntity<String> handleIntegrityViolation(\n            DataIntegrityViolationException e) {\n        return ResponseEntity.status(HttpStatus.BAD_REQUEST)\n            .body(\"Data integrity violation\");\n    }\n    \n    @ExceptionHandler(QueryTimeoutException.class)\n    public ResponseEntity<String> handleTimeout(QueryTimeoutException e) {\n        return ResponseEntity.status(HttpStatus.REQUEST_TIMEOUT)\n            .body(\"Query timeout - try again\");\n    }\n    \n    @ExceptionHandler(DataAccessException.class)\n    public ResponseEntity<String> handleGeneral(DataAccessException e) {\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n            .body(\"Database error\");\n    }\n}"
    },
    {
      "id": 34,
      "question": "What is @Transactional propagation?",
      "answer": "Propagation defines transaction behavior:\n\nTypes:\n• REQUIRED (default): Use existing or create\n• REQUIRES_NEW: Always new, suspend existing\n• SUPPORTS: Use if exists, non-tx if not\n• MANDATORY: Must have tx, throw if not\n• NOT_SUPPORTED: Execute non-tx, suspend existing\n• NEVER: Throw if tx exists\n• NESTED: Nested tx (savepoint)\n\nUse case:\n• REQUIRED: Normal operations\n• REQUIRES_NEW: Independent logging/audit\n• NESTED: Partial rollback",
      "explanation": "Propagation controls how methods participate in transactions. REQUIRED for most cases. REQUIRES_NEW for independent operations.",
      "difficulty": "Hard",
      "code": "@Service\npublic class OrderService {\n    @Autowired\n    private AuditService auditService;\n    @Autowired\n    private InventoryService inventoryService;\n    \n    // REQUIRED - default\n    @Transactional(propagation = Propagation.REQUIRED)\n    public void placeOrder(Order order) {\n        orderRepository.save(order);\n        // Uses same transaction if called within transaction\n        // Creates new if no transaction exists\n        inventoryService.reduceStock(order);  // Same transaction\n    }\n    \n    // REQUIRES_NEW - independent transaction\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    public void createAuditLog(String action) {\n        // Always creates new transaction\n        // Suspends existing transaction if any\n        // Commits even if parent transaction rolls back\n        auditRepository.save(new AuditLog(action));\n    }\n    \n    @Transactional\n    public void complexOperation() {\n        orderRepository.save(order);\n        \n        // Audit log in separate transaction\n        auditService.createAuditLog(\"Order created\");  // REQUIRES_NEW\n        \n        // If this throws exception, order rolls back\n        // But audit log already committed\n        inventoryService.processOrder(order);\n    }\n    \n    // SUPPORTS - optional transaction\n    @Transactional(propagation = Propagation.SUPPORTS)\n    public Order findOrder(Long id) {\n        // Participates in transaction if exists\n        // Executes non-transactionally if no transaction\n        return orderRepository.findById(id);\n    }\n    \n    // MANDATORY - must have transaction\n    @Transactional(propagation = Propagation.MANDATORY)\n    public void updateOrder(Order order) {\n        // Must be called within existing transaction\n        // Throws exception if no transaction exists\n        orderRepository.update(order);\n    }\n    \n    @Transactional\n    public void parentMethod() {\n        // OK - called within transaction\n        updateOrder(order);\n    }\n    \n    // NOT_SUPPORTED - never in transaction\n    @Transactional(propagation = Propagation.NOT_SUPPORTED)\n    public void generateReport() {\n        // Always executes non-transactionally\n        // Suspends transaction if exists\n        // Use for long-running operations\n        reportService.generate();\n    }\n    \n    // NEVER - throw if transaction exists\n    @Transactional(propagation = Propagation.NEVER)\n    public void externalApiCall() {\n        // Must not be called within transaction\n        // Throws exception if transaction exists\n        externalService.call();\n    }\n    \n    // NESTED - savepoint\n    @Transactional(propagation = Propagation.NESTED)\n    public void processItem(Item item) {\n        // Creates nested transaction (savepoint)\n        // Rolls back to savepoint on exception\n        // Doesn't affect parent transaction\n        itemRepository.save(item);\n    }\n    \n    @Transactional\n    public void processBatch(List<Item> items) {\n        for (Item item : items) {\n            try {\n                processItem(item);  // NESTED\n            } catch (Exception e) {\n                // Item processing failed, but continue\n                // Parent transaction not affected\n                log.error(\"Failed to process item\", e);\n            }\n        }\n        // Commit all successful items\n    }\n}\n\n// Real-world example\n@Service\npublic class PaymentService {\n    @Transactional\n    public void processPayment(Payment payment) {\n        // Main transaction\n        paymentRepository.save(payment);\n        \n        // Log in separate transaction (always commits)\n        auditService.log(\"Payment initiated\");  // REQUIRES_NEW\n        \n        // Process payment\n        if (!paymentGateway.charge(payment)) {\n            throw new PaymentException(\"Charge failed\");\n        }\n        \n        // Update order (same transaction)\n        orderService.markAsPaid(payment.getOrderId());  // REQUIRED\n        \n        // Log success (separate transaction)\n        auditService.log(\"Payment successful\");  // REQUIRES_NEW\n    }\n}"
    },
    {
      "id": 35,
      "question": "What is @Transactional isolation?",
      "answer": "Isolation defines concurrent transaction behavior:\n\nLevels (from weak to strong):\n• READ_UNCOMMITTED: Dirty reads possible\n• READ_COMMITTED: No dirty reads\n• REPEATABLE_READ: No dirty/non-repeatable reads\n• SERIALIZABLE: Full isolation\n\nProblems:\n• Dirty Read: Read uncommitted data\n• Non-repeatable Read: Same query, different results\n• Phantom Read: New rows appear\n\nDefault: Database default (usually READ_COMMITTED)",
      "explanation": "Isolation controls data visibility between transactions. Higher isolation = fewer anomalies but lower concurrency. Choose based on needs.",
      "difficulty": "Hard",
      "code": "@Service\npublic class AccountService {\n    \n    // READ_UNCOMMITTED - lowest isolation\n    // Can read uncommitted changes from other transactions\n    // Dirty reads possible\n    @Transactional(isolation = Isolation.READ_UNCOMMITTED)\n    public BigDecimal getApproximateBalance(Long accountId) {\n        // May read uncommitted values\n        // Use for approximate data where accuracy not critical\n        return accountRepository.findBalance(accountId);\n    }\n    \n    // READ_COMMITTED - default for most databases\n    // Can only read committed data\n    // Prevents dirty reads\n    @Transactional(isolation = Isolation.READ_COMMITTED)\n    public Account getAccount(Long id) {\n        // Reads only committed data\n        // But same query may return different results if run again\n        Account account = accountRepository.findById(id);\n        // If another transaction commits here\n        Account account2 = accountRepository.findById(id);  // May differ\n        return account;\n    }\n    \n    // REPEATABLE_READ - prevents non-repeatable reads\n    // Same query returns same results\n    @Transactional(isolation = Isolation.REPEATABLE_READ)\n    public void transfer(Long fromId, Long toId, BigDecimal amount) {\n        Account from = accountRepository.findById(fromId);\n        // Even if another transaction updates this account,\n        // reading it again returns same values\n        Account from2 = accountRepository.findById(fromId);  // Same as from\n        \n        if (from.getBalance().compareTo(amount) >= 0) {\n            from.setBalance(from.getBalance().subtract(amount));\n            Account to = accountRepository.findById(toId);\n            to.setBalance(to.getBalance().add(amount));\n            accountRepository.save(from);\n            accountRepository.save(to);\n        }\n    }\n    \n    // SERIALIZABLE - highest isolation\n    // Full isolation, transactions execute serially\n    // Prevents all anomalies but slowest\n    @Transactional(isolation = Isolation.SERIALIZABLE)\n    public void criticalOperation() {\n        // Complete isolation\n        // Use for critical financial operations\n        // May cause deadlocks\n        List<Account> accounts = accountRepository.findAll();\n        // No other transaction can modify these accounts\n        // until this transaction completes\n        processAccounts(accounts);\n    }\n}\n\n// Problem demonstrations\n@Service\npublic class IsolationProblems {\n    \n    // Dirty Read problem\n    // Transaction 1\n    @Transactional(isolation = Isolation.READ_UNCOMMITTED)\n    public void dirtyReadExample() {\n        // Reads balance = 1000\n        BigDecimal balance = accountRepository.findBalance(1L);\n        \n        // Transaction 2 updates balance to 2000 but hasn't committed\n        // This reads 2000 (dirty read)\n        balance = accountRepository.findBalance(1L);  // 2000\n        \n        // Transaction 2 rolls back\n        // balance value 2000 was never committed (dirty)\n    }\n    \n    // Non-repeatable Read problem\n    @Transactional(isolation = Isolation.READ_COMMITTED)\n    public void nonRepeatableReadExample() {\n        // Reads balance = 1000\n        BigDecimal balance1 = accountRepository.findBalance(1L);\n        \n        // Another transaction updates and commits balance to 2000\n        \n        // Reads balance = 2000 (different!)\n        BigDecimal balance2 = accountRepository.findBalance(1L);\n        \n        // balance1 != balance2 (non-repeatable read)\n    }\n    \n    // Phantom Read problem\n    @Transactional(isolation = Isolation.REPEATABLE_READ)\n    public void phantomReadExample() {\n        // Reads 5 accounts\n        List<Account> accounts1 = accountRepository.findAll();\n        \n        // Another transaction inserts new account and commits\n        \n        // Reads 6 accounts (phantom row appeared)\n        List<Account> accounts2 = accountRepository.findAll();\n        \n        // accounts1.size() != accounts2.size() (phantom read)\n    }\n}\n\n// Real-world usage\n@Service\npublic class BankingService {\n    \n    // READ_COMMITTED - default, good for most operations\n    @Transactional(isolation = Isolation.READ_COMMITTED)\n    public void processTransaction(Transaction tx) {\n        // Normal transaction processing\n    }\n    \n    // REPEATABLE_READ - for consistent calculations\n    @Transactional(isolation = Isolation.REPEATABLE_READ)\n    public Report generateAccountReport(Long accountId) {\n        // Ensure consistent data throughout report generation\n        Account account = accountRepository.findById(accountId);\n        List<Transaction> txs = transactionRepository.findByAccount(accountId);\n        // Data remains consistent even if generation takes time\n        return createReport(account, txs);\n    }\n    \n    // SERIALIZABLE - for critical operations\n    @Transactional(isolation = Isolation.SERIALIZABLE)\n    public void endOfDayProcessing() {\n        // Critical batch processing\n        // Need complete isolation\n        calculateInterest();\n        applyCharges();\n        generateStatements();\n    }\n}"
    },
    {
      "id": 36,
      "question": "What is @Transactional timeout and readOnly?",
      "answer": "@Transactional additional attributes:\n\ntimeout:\n• Max transaction duration (seconds)\n• Prevents long-running transactions\n• Rolls back if exceeded\n• Default: -1 (no timeout)\n\nreadOnly:\n• Optimization hint\n• No modifications expected\n• Database can optimize\n• Flush mode NEVER in Hibernate\n• Better performance for queries\n\nUse readOnly=true for all queries.",
      "explanation": "timeout prevents hanging transactions. readOnly optimizes read operations - no dirty checking, better performance.",
      "difficulty": "Medium",
      "code": "@Service\npublic class UserService {\n    \n    // Read-only transaction - optimization\n    @Transactional(readOnly = true)\n    public List<User> findAll() {\n        // Database knows no modifications\n        // Can optimize (skip locking, no flush)\n        // Hibernate skips dirty checking\n        return userRepository.findAll();\n    }\n    \n    @Transactional(readOnly = true)\n    public User findById(Long id) {\n        return userRepository.findById(id);\n    }\n    \n    @Transactional(readOnly = true)\n    public List<User> search(String name) {\n        // Complex query\n        // Read-only improves performance\n        return userRepository.searchByName(name);\n    }\n    \n    // Timeout - prevent long-running transactions\n    @Transactional(timeout = 30)  // 30 seconds\n    public void processOrder(Order order) {\n        // Must complete within 30 seconds\n        // Throws TransactionTimedOutException if exceeded\n        orderRepository.save(order);\n        inventoryService.reduceStock(order);\n        emailService.sendConfirmation(order);\n    }\n    \n    // Short timeout for quick operations\n    @Transactional(timeout = 5)\n    public void updateStatus(Long id, String status) {\n        User user = userRepository.findById(id);\n        user.setStatus(status);\n        userRepository.save(user);\n        // Must complete within 5 seconds\n    }\n    \n    // Combined attributes\n    @Transactional(\n        readOnly = true,\n        timeout = 60\n    )\n    public Report generateReport() {\n        // Read-only with timeout\n        // Report generation may take time but has limit\n        List<User> users = userRepository.findAll();\n        List<Order> orders = orderRepository.findAll();\n        return reportService.generate(users, orders);\n    }\n    \n    // Write operation - readOnly=false (default)\n    @Transactional(\n        timeout = 30,\n        rollbackFor = Exception.class\n    )\n    public User createUser(User user) {\n        // Not read-only (can modify)\n        // 30 second timeout\n        // Rollback on any exception\n        validate(user);\n        user = userRepository.save(user);\n        auditService.log(\"User created: \" + user.getId());\n        return user;\n    }\n}\n\n// Performance comparison\n@Service\npublic class PerformanceExample {\n    @Autowired\n    private EntityManager em;\n    \n    // WITHOUT readOnly\n    @Transactional\n    public List<User> findUsers() {\n        List<User> users = userRepository.findAll();\n        // Hibernate tracks all entities for changes\n        // On commit, checks all entities (dirty checking)\n        // Flushes changes to database\n        return users;\n    }\n    \n    // WITH readOnly\n    @Transactional(readOnly = true)\n    public List<User> findUsersOptimized() {\n        // Hibernate sets flush mode to NEVER\n        List<User> users = userRepository.findAll();\n        // NO dirty checking\n        // NO flush to database\n        // Better performance\n        return users;\n    }\n    \n    // Read-only prevents modifications\n    @Transactional(readOnly = true)\n    public void tryModify() {\n        User user = userRepository.findById(1L);\n        user.setName(\"New Name\");\n        // Changes won't be persisted\n        // Flush mode is NEVER\n    }\n}\n\n// Timeout handling\n@Service\npublic class TimeoutExample {\n    \n    @Transactional(timeout = 5)\n    public void fastOperation() {\n        // Completes in 2 seconds - OK\n        userRepository.save(user);\n    }\n    \n    @Transactional(timeout = 5)\n    public void slowOperation() {\n        // Takes 10 seconds\n        Thread.sleep(10000);\n        userRepository.save(user);\n        // Throws TransactionTimedOutException\n    }\n    \n    public void handleTimeout() {\n        try {\n            slowOperation();\n        } catch (TransactionTimedOutException e) {\n            log.error(\"Transaction timed out\", e);\n            // Handle timeout\n        }\n    }\n}\n\n// Best practices\n@Service\npublic class BestPractices {\n    \n    // Always use readOnly=true for queries\n    @Transactional(readOnly = true)\n    public List<Order> findOrders() {\n        return orderRepository.findAll();\n    }\n    \n    // Set reasonable timeouts\n    @Transactional(\n        timeout = 30,\n        readOnly = false\n    )\n    public void updateData() {\n        // Prevent hanging transactions\n    }\n    \n    // Long-running reports with timeout\n    @Transactional(\n        readOnly = true,\n        timeout = 300  // 5 minutes\n    )\n    public Report complexReport() {\n        // Long-running but has limit\n        return reportService.generate();\n    }\n}"
    },
    {
      "id": 37,
      "question": "What is @Transactional rollbackFor and noRollbackFor?",
      "answer": "@Transactional rollback configuration:\n\nDefault behavior:\n• Rollback on RuntimeException\n• Rollback on Error\n• Commit on checked Exception\n\nrollbackFor:\n• Specify exceptions to rollback\n• Include checked exceptions\n• Class array\n\nnoRollbackFor:\n• Specify exceptions NOT to rollback\n• Override default behavior\n\nrollbackForClassName: String class names",
      "explanation": "Default: rollback on unchecked exceptions only. Use rollbackFor to include checked exceptions. noRollbackFor to exclude specific exceptions.",
      "difficulty": "Medium",
      "code": "@Service\npublic class OrderService {\n    \n    // Default behavior\n    @Transactional\n    public void defaultRollback() {\n        orderRepository.save(order);\n        \n        // RuntimeException - ROLLS BACK\n        throw new IllegalArgumentException(\"Invalid order\");\n        \n        // Error - ROLLS BACK\n        throw new Error(\"System error\");\n    }\n    \n    @Transactional\n    public void checkedExceptionNoRollback() throws Exception {\n        orderRepository.save(order);\n        \n        // Checked Exception - COMMITS (doesn't rollback)\n        throw new Exception(\"Checked exception\");\n    }\n    \n    // Rollback on specific checked exceptions\n    @Transactional(rollbackFor = Exception.class)\n    public void rollbackOnAllExceptions() throws Exception {\n        orderRepository.save(order);\n        \n        // NOW checked exceptions also rollback\n        throw new Exception(\"This will rollback\");\n    }\n    \n    // Multiple exceptions\n    @Transactional(\n        rollbackFor = {IOException.class, SQLException.class}\n    )\n    public void rollbackOnSpecific() throws IOException, SQLException {\n        orderRepository.save(order);\n        \n        // IOException - ROLLS BACK\n        throw new IOException(\"IO error\");\n        \n        // SQLException - ROLLS BACK  \n        throw new SQLException(\"DB error\");\n        \n        // Other checked exceptions - COMMITS\n    }\n    \n    // Don't rollback on specific exceptions\n    @Transactional(noRollbackFor = IllegalArgumentException.class)\n    public void noRollbackOnSpecific() {\n        orderRepository.save(order);\n        \n        // IllegalArgumentException - COMMITS (doesn't rollback)\n        throw new IllegalArgumentException(\"Invalid\");\n        \n        // Other RuntimeExceptions - ROLL BACK\n        throw new NullPointerException();  // Rolls back\n    }\n    \n    // Combined\n    @Transactional(\n        rollbackFor = Exception.class,\n        noRollbackFor = {ValidationException.class, IgnorableException.class}\n    )\n    public void combinedRollback() throws Exception {\n        orderRepository.save(order);\n        \n        // ValidationException - COMMITS (excluded)\n        throw new ValidationException(\"Validation failed\");\n        \n        // Other exceptions - ROLL BACK\n        throw new Exception(\"Other error\");  // Rolls back\n    }\n    \n    // String class names\n    @Transactional(\n        rollbackForClassName = {\"java.io.IOException\"},\n        noRollbackForClassName = {\"com.example.IgnoredException\"}\n    )\n    public void stringClassNames() {\n        // Use when exception classes not available at compile time\n    }\n}\n\n// Real-world examples\n@Service\npublic class PaymentService {\n    \n    // Business exceptions shouldn't rollback transaction\n    @Transactional(\n        rollbackFor = Exception.class,\n        noRollbackFor = InsufficientFundsException.class\n    )\n    public Payment processPayment(Payment payment) {\n        payment = paymentRepository.save(payment);\n        \n        Account account = accountRepository.findById(payment.getAccountId());\n        if (account.getBalance().compareTo(payment.getAmount()) < 0) {\n            payment.setStatus(\"FAILED\");\n            payment.setReason(\"Insufficient funds\");\n            paymentRepository.save(payment);  // Save failure reason\n            \n            // Don't rollback - we want to keep the payment record\n            throw new InsufficientFundsException();\n        }\n        \n        account.setBalance(account.getBalance().subtract(payment.getAmount()));\n        accountRepository.save(account);\n        payment.setStatus(\"SUCCESS\");\n        return payment;\n    }\n    \n    // Always rollback on any exception\n    @Transactional(rollbackFor = Exception.class)\n    public void criticalOperation() throws Exception {\n        // Any exception rolls back\n        performCriticalTask();\n    }\n}\n\n// Custom exceptions\npublic class InsufficientFundsException extends Exception { }\npublic class ValidationException extends Exception { }\npublic class IgnorableException extends RuntimeException { }\n\n// Exception handling\n@Service\npublic class OrderProcessingService {\n    \n    @Transactional(\n        rollbackFor = Exception.class,\n        noRollbackFor = NotificationException.class\n    )\n    public void processOrder(Order order) throws Exception {\n        // Save order (part of transaction)\n        orderRepository.save(order);\n        \n        // Update inventory (part of transaction)\n        inventoryService.reduceStock(order);\n        \n        try {\n            // Send notification (not critical)\n            notificationService.send(order);\n        } catch (NotificationException e) {\n            // Log but don't rollback transaction\n            log.error(\"Notification failed\", e);\n            // Transaction still commits\n        }\n        \n        // Create invoice (part of transaction)\n        invoiceService.create(order);\n    }\n}\n\n// Best practices\n@Service\npublic class BestPractices {\n    \n    // Include checked exceptions in rollback\n    @Transactional(rollbackFor = Exception.class)\n    public void saveWithCheckedExceptions() throws Exception {\n        // Safer - all exceptions rollback\n    }\n    \n    // Exclude business exceptions\n    @Transactional(\n        rollbackFor = Exception.class,\n        noRollbackFor = {ValidationException.class, BusinessException.class}\n    )\n    public void handleBusinessExceptions() {\n        // Rollback on system errors\n        // Commit on business rule violations (want to keep audit trail)\n    }\n}"
    },
    {
      "id": 38,
      "question": "What is programmatic transaction management?",
      "answer": "Programmatic transactions give manual control:\n\nOptions:\n• TransactionTemplate: Template pattern\n• PlatformTransactionManager: Low-level API\n\nTransactionTemplate:\n• execute(): With return value\n• executeWithoutResult(): No return\n• setRollbackOnly(): Force rollback\n\nUse when:\n• Fine-grained control needed\n• Dynamic transaction boundaries\n• Declarative insufficient",
      "explanation": "TransactionTemplate for programmatic control. More verbose than @Transactional but flexible. Use rarely - prefer declarative.",
      "difficulty": "Hard",
      "code": "// Configuration\n@Configuration\npublic class TransactionConfig {\n    @Bean\n    public TransactionTemplate transactionTemplate(\n            PlatformTransactionManager transactionManager) {\n        return new TransactionTemplate(transactionManager);\n    }\n}\n\n@Service\npublic class PaymentService {\n    @Autowired\n    private TransactionTemplate transactionTemplate;\n    @Autowired\n    private PlatformTransactionManager transactionManager;\n    \n    // TransactionTemplate with return value\n    public Payment processPayment(Payment payment) {\n        return transactionTemplate.execute(status -> {\n            // Inside transaction\n            payment.setStatus(\"PROCESSING\");\n            paymentRepository.save(payment);\n            \n            try {\n                chargeCard(payment);\n                payment.setStatus(\"SUCCESS\");\n            } catch (PaymentException e) {\n                // Rollback transaction\n                status.setRollbackOnly();\n                payment.setStatus(\"FAILED\");\n            }\n            \n            return paymentRepository.save(payment);\n        });\n    }\n    \n    // Without return value\n    public void updateAccount(Account account) {\n        transactionTemplate.executeWithoutResult(status -> {\n            accountRepository.save(account);\n            auditLog.log(\"Account updated\");\n        });\n    }\n    \n    // Conditional rollback\n    public boolean processOrder(Order order) {\n        return transactionTemplate.execute(status -> {\n            orderRepository.save(order);\n            \n            boolean success = paymentGateway.charge(order);\n            if (!success) {\n                // Rollback\n                status.setRollbackOnly();\n                return false;\n            }\n            \n            inventoryService.reduceStock(order);\n            return true;\n        });\n    }\n    \n    // Custom configuration\n    public void customTransaction() {\n        TransactionTemplate template = new TransactionTemplate(transactionManager);\n        template.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);\n        template.setIsolationLevel(TransactionDefinition.ISOLATION_SERIALIZABLE);\n        template.setTimeout(30);\n        \n        template.execute(status -> {\n            // Custom transaction settings\n            performOperation();\n            return null;\n        });\n    }\n    \n    // Using PlatformTransactionManager directly\n    public void lowLevelTransaction() {\n        TransactionDefinition def = new DefaultTransactionDefinition();\n        TransactionStatus status = transactionManager.getTransaction(def);\n        \n        try {\n            // Transaction operations\n            userRepository.save(user);\n            orderRepository.save(order);\n            \n            // Commit\n            transactionManager.commit(status);\n        } catch (Exception e) {\n            // Rollback\n            transactionManager.rollback(status);\n            throw e;\n        }\n    }\n    \n    // Multiple transactions\n    public void multiplTransactions() {\n        // First transaction\n        transactionTemplate.execute(status -> {\n            userRepository.save(user);\n            return null;\n        });\n        \n        // Second transaction (independent)\n        transactionTemplate.execute(status -> {\n            orderRepository.save(order);\n            return null;\n        });\n    }\n    \n    // Nested transactions\n    public void nestedTransaction() {\n        transactionTemplate.execute(status -> {\n            orderRepository.save(order);\n            \n            // Inner transaction\n            TransactionTemplate innerTemplate = \n                new TransactionTemplate(transactionManager);\n            innerTemplate.setPropagationBehavior(\n                TransactionDefinition.PROPAGATION_REQUIRES_NEW);\n            \n            innerTemplate.execute(innerStatus -> {\n                auditLog.log(\"Order saved\");\n                return null;\n            });\n            \n            return null;\n        });\n    }\n}\n\n// Complex transaction logic\n@Service\npublic class BatchProcessor {\n    @Autowired\n    private TransactionTemplate transactionTemplate;\n    \n    public void processBatch(List<Order> orders) {\n        for (Order order : orders) {\n            // Each order in separate transaction\n            try {\n                transactionTemplate.execute(status -> {\n                    orderRepository.save(order);\n                    inventoryService.processOrder(order);\n                    return null;\n                });\n            } catch (Exception e) {\n                // One order fails, others continue\n                log.error(\"Failed to process order: \" + order.getId(), e);\n            }\n        }\n    }\n    \n    public void processWithPartialRollback(List<Item> items) {\n        transactionTemplate.execute(status -> {\n            for (Item item : items) {\n                try {\n                    itemRepository.save(item);\n                } catch (Exception e) {\n                    if (isCritical(e)) {\n                        // Rollback everything\n                        status.setRollbackOnly();\n                        throw e;\n                    } else {\n                        // Continue with other items\n                        log.error(\"Failed item: \" + item.getId(), e);\n                    }\n                }\n            }\n            return null;\n        });\n    }\n}\n\n// When to use programmatic transactions\n@Service\npublic class DynamicTransactionService {\n    \n    public void processWithDynamicBoundary(boolean needsTransaction) {\n        if (needsTransaction) {\n            // Use transaction\n            transactionTemplate.execute(status -> {\n                performOperation();\n                return null;\n            });\n        } else {\n            // No transaction\n            performOperation();\n        }\n    }\n}"
    },
    {
      "id": 39,
      "question": "What is Spring Test Context Framework?",
      "answer": "Spring Test Context provides testing support:\n\nAnnotations:\n• @SpringBootTest: Full application context\n• @WebMvcTest: Web layer testing\n• @DataJpaTest: JPA testing\n• @MockBean: Mock beans\n• @TestConfiguration: Test config\n\nFeatures:\n• Context caching\n• Dependency injection in tests\n• Transaction management\n• Profile activation\n\n@DirtiesContext: Force reload",
      "explanation": "Spring Test Context loads ApplicationContext for tests. Inject dependencies. Use specialized annotations for layer testing.",
      "difficulty": "Medium",
      "code": "// Full integration test\n@SpringBootTest\nclass UserServiceIntegrationTest {\n    @Autowired\n    private UserService userService;\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    @Test\n    void testCreateUser() {\n        User user = new User(\"John\", \"john@example.com\");\n        User saved = userService.createUser(user);\n        \n        assertNotNull(saved.getId());\n        assertEquals(\"John\", saved.getName());\n    }\n}\n\n// Web layer test\n@WebMvcTest(UserController.class)\nclass UserControllerTest {\n    @Autowired\n    private MockMvc mockMvc;\n    \n    @MockBean\n    private UserService userService;\n    \n    @Test\n    void testGetUser() throws Exception {\n        User user = new User(1L, \"John\", \"john@example.com\");\n        when(userService.findById(1L)).thenReturn(user);\n        \n        mockMvc.perform(get(\"/users/1\"))\n            .andExpect(status().isOk())\n            .andExpect(jsonPath(\"$.name\").value(\"John\"))\n            .andExpect(jsonPath(\"$.email\").value(\"john@example.com\"));\n    }\n    \n    @Test\n    void testCreateUser() throws Exception {\n        mockMvc.perform(post(\"/users\")\n                .contentType(MediaType.APPLICATION_JSON)\n                .content(\"{\\\"name\\\":\\\"John\\\",\\\"email\\\":\\\"john@example.com\\\"}\"))\n            .andExpect(status().isCreated());\n    }\n}\n\n// Data layer test\n@DataJpaTest\nclass UserRepositoryTest {\n    @Autowired\n    private UserRepository userRepository;\n    \n    @Autowired\n    private TestEntityManager entityManager;\n    \n    @Test\n    void testFindByName() {\n        User user = new User(\"John\", \"john@example.com\");\n        entityManager.persist(user);\n        entityManager.flush();\n        \n        List<User> found = userRepository.findByName(\"John\");\n        \n        assertEquals(1, found.size());\n        assertEquals(\"John\", found.get(0).getName());\n    }\n}\n\n// Test configuration\n@TestConfiguration\nstatic class TestConfig {\n    @Bean\n    public EmailService emailService() {\n        return new MockEmailService();\n    }\n}\n\n// Using test configuration\n@SpringBootTest\n@Import(TestConfig.class)\nclass ServiceTest {\n    @Autowired\n    private EmailService emailService;  // Mock version\n}\n\n// Active profiles\n@SpringBootTest\n@ActiveProfiles(\"test\")\nclass ProfileTest {\n    // Uses test profile beans and properties\n}\n\n// Mock beans\n@SpringBootTest\nclass MockBeanTest {\n    @MockBean\n    private EmailService emailService;\n    \n    @Autowired\n    private UserService userService;\n    \n    @Test\n    void testWithMock() {\n        when(emailService.send(any())).thenReturn(true);\n        \n        userService.registerUser(new User(\"John\", \"john@example.com\"));\n        \n        verify(emailService).send(any());\n    }\n}\n\n// Spy bean - partial mock\n@SpringBootTest\nclass SpyBeanTest {\n    @SpyBean\n    private UserRepository userRepository;\n    \n    @Test\n    void testWithSpy() {\n        // Real method calls work\n        userRepository.save(user);\n        \n        // But can verify\n        verify(userRepository).save(any());\n    }\n}\n\n// Transactional tests\n@SpringBootTest\n@Transactional  // Rolls back after each test\nclass TransactionalTest {\n    @Autowired\n    private UserRepository userRepository;\n    \n    @Test\n    void testCreate() {\n        userRepository.save(new User(\"John\", \"john@example.com\"));\n        assertEquals(1, userRepository.count());\n        // Automatically rolled back\n    }\n}\n\n// Disable rollback\n@SpringBootTest\nclass NoRollbackTest {\n    @Test\n    @Transactional\n    @Rollback(false)\n    void testCommit() {\n        userRepository.save(user);\n        // Changes committed\n    }\n}\n\n// Dirty context - force reload\n@SpringBootTest\nclass DirtyContextTest {\n    @Test\n    @DirtiesContext\n    void testThatModifiesContext() {\n        // Modify application context\n        // Context reloaded after this test\n    }\n}\n\n// Custom port\n@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)\nclass RandomPortTest {\n    @LocalServerPort\n    private int port;\n    \n    @Autowired\n    private TestRestTemplate restTemplate;\n    \n    @Test\n    void testEndpoint() {\n        String url = \"http://localhost:\" + port + \"/users\";\n        ResponseEntity<String> response = restTemplate.getForEntity(url, String.class);\n        assertEquals(HttpStatus.OK, response.getStatusCode());\n    }\n}\n\n// Test property source\n@SpringBootTest\n@TestPropertySource(properties = {\n    \"app.name=Test App\",\n    \"app.version=1.0.0\"\n})\nclass PropertyTest {\n    @Value(\"${app.name}\")\n    private String appName;\n    \n    @Test\n    void testProperty() {\n        assertEquals(\"Test App\", appName);\n    }\n}"
    },
    {
      "id": 40,
      "question": "What is MockMvc for testing?",
      "answer": "MockMvc tests Spring MVC controllers:\n\nFeatures:\n• Test without server\n• Mock HTTP requests\n• Verify responses\n• Test request/response\n• No network overhead\n\nMethods:\n• perform(): Execute request\n• andExpect(): Verify result\n• andDo(): Perform action\n• andReturn(): Get result\n\nUse @WebMvcTest for controller tests.",
      "explanation": "MockMvc tests web layer without starting server. Fast, focused tests. Mock dependencies with @MockBean.",
      "difficulty": "Medium",
      "code": "@WebMvcTest(UserController.class)\nclass UserControllerTest {\n    @Autowired\n    private MockMvc mockMvc;\n    \n    @MockBean\n    private UserService userService;\n    \n    // GET request\n    @Test\n    void testGetUser() throws Exception {\n        User user = new User(1L, \"John\", \"john@example.com\");\n        when(userService.findById(1L)).thenReturn(user);\n        \n        mockMvc.perform(get(\"/users/1\"))\n            .andExpect(status().isOk())\n            .andExpect(content().contentType(MediaType.APPLICATION_JSON))\n            .andExpect(jsonPath(\"$.id\").value(1))\n            .andExpect(jsonPath(\"$.name\").value(\"John\"))\n            .andExpect(jsonPath(\"$.email\").value(\"john@example.com\"));\n    }\n    \n    // POST request\n    @Test\n    void testCreateUser() throws Exception {\n        User user = new User(null, \"John\", \"john@example.com\");\n        User saved = new User(1L, \"John\", \"john@example.com\");\n        when(userService.save(any())).thenReturn(saved);\n        \n        mockMvc.perform(post(\"/users\")\n                .contentType(MediaType.APPLICATION_JSON)\n                .content(\"{\\\"name\\\":\\\"John\\\",\\\"email\\\":\\\"john@example.com\\\"}\"))\n            .andExpect(status().isCreated())\n            .andExpect(header().exists(\"Location\"))\n            .andExpect(jsonPath(\"$.id\").value(1));\n    }\n    \n    // PUT request\n    @Test\n    void testUpdateUser() throws Exception {\n        mockMvc.perform(put(\"/users/1\")\n                .contentType(MediaType.APPLICATION_JSON)\n                .content(\"{\\\"name\\\":\\\"John Updated\\\",\\\"email\\\":\\\"john@example.com\\\"}\"))\n            .andExpect(status().isOk());\n        \n        verify(userService).update(eq(1L), any());\n    }\n    \n    // DELETE request\n    @Test\n    void testDeleteUser() throws Exception {\n        mockMvc.perform(delete(\"/users/1\"))\n            .andExpect(status().isNoContent());\n        \n        verify(userService).delete(1L);\n    }\n    \n    // Query parameters\n    @Test\n    void testSearchUsers() throws Exception {\n        List<User> users = Arrays.asList(\n            new User(1L, \"John\", \"john@example.com\")\n        );\n        when(userService.search(\"John\")).thenReturn(users);\n        \n        mockMvc.perform(get(\"/users/search\")\n                .param(\"name\", \"John\"))\n            .andExpect(status().isOk())\n            .andExpect(jsonPath(\"$\").isArray())\n            .andExpect(jsonPath(\"$[0].name\").value(\"John\"));\n    }\n    \n    // Request headers\n    @Test\n    void testWithHeaders() throws Exception {\n        mockMvc.perform(get(\"/users/1\")\n                .header(\"Authorization\", \"Bearer token123\")\n                .accept(MediaType.APPLICATION_JSON))\n            .andExpect(status().isOk());\n    }\n    \n    // Cookies\n    @Test\n    void testWithCookie() throws Exception {\n        mockMvc.perform(get(\"/users/1\")\n                .cookie(new Cookie(\"session\", \"abc123\")))\n            .andExpect(status().isOk());\n    }\n    \n    // Exception handling\n    @Test\n    void testNotFound() throws Exception {\n        when(userService.findById(999L))\n            .thenThrow(new ResourceNotFoundException(\"User not found\"));\n        \n        mockMvc.perform(get(\"/users/999\"))\n            .andExpect(status().isNotFound())\n            .andExpect(jsonPath(\"$.message\").value(\"User not found\"));\n    }\n    \n    // Validation errors\n    @Test\n    void testValidationError() throws Exception {\n        mockMvc.perform(post(\"/users\")\n                .contentType(MediaType.APPLICATION_JSON)\n                .content(\"{\\\"name\\\":\\\"\\\",\\\"email\\\":\\\"invalid\\\"}\"))\n            .andExpect(status().isBadRequest())\n            .andExpect(jsonPath(\"$.errors\").exists());\n    }\n    \n    // Print response\n    @Test\n    void testWithPrint() throws Exception {\n        mockMvc.perform(get(\"/users/1\"))\n            .andDo(print())  // Print request/response\n            .andExpect(status().isOk());\n    }\n    \n    // Get result\n    @Test\n    void testGetResult() throws Exception {\n        MvcResult result = mockMvc.perform(get(\"/users/1\"))\n            .andExpect(status().isOk())\n            .andReturn();\n        \n        String content = result.getResponse().getContentAsString();\n        assertNotNull(content);\n    }\n    \n    // File upload\n    @Test\n    void testFileUpload() throws Exception {\n        MockMultipartFile file = new MockMultipartFile(\n            \"file\",\n            \"test.txt\",\n            MediaType.TEXT_PLAIN_VALUE,\n            \"Test content\".getBytes()\n        );\n        \n        mockMvc.perform(multipart(\"/users/upload\")\n                .file(file))\n            .andExpect(status().isOk());\n    }\n    \n    // Session attributes\n    @Test\n    void testSession() throws Exception {\n        mockMvc.perform(get(\"/users/1\")\n                .sessionAttr(\"userId\", 1L))\n            .andExpect(status().isOk());\n    }\n}\n\n// Standalone setup (no Spring context)\nclass StandaloneTest {\n    private MockMvc mockMvc;\n    private UserService userService;\n    \n    @BeforeEach\n    void setup() {\n        userService = mock(UserService.class);\n        UserController controller = new UserController(userService);\n        \n        mockMvc = MockMvcBuilders.standaloneSetup(controller)\n            .setControllerAdvice(new GlobalExceptionHandler())\n            .build();\n    }\n    \n    @Test\n    void test() throws Exception {\n        mockMvc.perform(get(\"/users/1\"))\n            .andExpect(status().isOk());\n    }\n}"
    },
    {
      "id": 41,
      "question": "What is @RestController vs @Controller?",
      "answer": "@RestController vs @Controller differences:\n\n@Controller:\n• Returns view names\n• For web pages (JSP, Thymeleaf)\n• Need @ResponseBody for JSON\n• Spring MVC traditional\n\n@RestController:\n• Returns data directly\n• JSON/XML responses\n• @Controller + @ResponseBody\n• RESTful services\n\nEquivalent:\n@RestController = @Controller + @ResponseBody",
      "explanation": "@Controller for views (HTML). @RestController for APIs (JSON). @RestController adds @ResponseBody to all methods automatically.",
      "difficulty": "Easy",
      "code": "// @Controller - returns views\n@Controller\npublic class WebController {\n    \n    // Returns view name \"users/list\"\n    @GetMapping(\"/users\")\n    public String listUsers(Model model) {\n        model.addAttribute(\"users\", userService.findAll());\n        return \"users/list\";  // JSP/Thymeleaf view\n    }\n    \n    // Returns JSON - need @ResponseBody\n    @GetMapping(\"/api/users\")\n    @ResponseBody\n    public List<User> getUsersJson() {\n        return userService.findAll();  // JSON response\n    }\n    \n    // Returns view\n    @GetMapping(\"/users/{id}\")\n    public String getUser(@PathVariable Long id, Model model) {\n        model.addAttribute(\"user\", userService.findById(id));\n        return \"users/detail\";\n    }\n}\n\n// @RestController - returns data\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserRestController {\n    \n    // Automatically returns JSON\n    // No @ResponseBody needed\n    @GetMapping\n    public List<User> getAllUsers() {\n        return userService.findAll();  // JSON response\n    }\n    \n    @GetMapping(\"/{id}\")\n    public User getUser(@PathVariable Long id) {\n        return userService.findById(id);  // JSON response\n    }\n    \n    @PostMapping\n    public User createUser(@RequestBody User user) {\n        return userService.save(user);  // JSON response\n    }\n    \n    @PutMapping(\"/{id}\")\n    public User updateUser(@PathVariable Long id, @RequestBody User user) {\n        return userService.update(id, user);  // JSON response\n    }\n    \n    @DeleteMapping(\"/{id}\")\n    public void deleteUser(@PathVariable Long id) {\n        userService.delete(id);\n    }\n}\n\n// Same as @RestController\n@Controller\n@ResponseBody  // All methods return data\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    @GetMapping\n    public List<User> getAllUsers() {\n        return userService.findAll();\n    }\n}\n\n// Mixed usage in @Controller\n@Controller\npublic class MixedController {\n    \n    // Returns view\n    @GetMapping(\"/users\")\n    public String listUsers(Model model) {\n        model.addAttribute(\"users\", userService.findAll());\n        return \"users/list\";\n    }\n    \n    // Returns JSON\n    @GetMapping(\"/api/users\")\n    @ResponseBody\n    public List<User> getUsersJson() {\n        return userService.findAll();\n    }\n}\n\n// ResponseEntity for complex responses\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserApiController {\n    \n    @GetMapping(\"/{id}\")\n    public ResponseEntity<User> getUser(@PathVariable Long id) {\n        User user = userService.findById(id);\n        if (user == null) {\n            return ResponseEntity.notFound().build();\n        }\n        return ResponseEntity.ok(user);\n    }\n    \n    @PostMapping\n    public ResponseEntity<User> createUser(@RequestBody User user) {\n        User saved = userService.save(user);\n        URI location = ServletUriComponentsBuilder\n            .fromCurrentRequest()\n            .path(\"/{id}\")\n            .buildAndExpand(saved.getId())\n            .toUri();\n        return ResponseEntity.created(location).body(saved);\n    }\n    \n    @PutMapping(\"/{id}\")\n    public ResponseEntity<User> updateUser(\n            @PathVariable Long id, @RequestBody User user) {\n        if (!userService.exists(id)) {\n            return ResponseEntity.notFound().build();\n        }\n        User updated = userService.update(id, user);\n        return ResponseEntity.ok(updated);\n    }\n    \n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {\n        if (!userService.exists(id)) {\n            return ResponseEntity.notFound().build();\n        }\n        userService.delete(id);\n        return ResponseEntity.noContent().build();\n    }\n}\n\n// Best practices\n// Use @Controller for web pages\n@Controller\npublic class WebPageController {\n    @GetMapping(\"/home\")\n    public String home() {\n        return \"home\";  // home.jsp or home.html\n    }\n}\n\n// Use @RestController for REST APIs\n@RestController\n@RequestMapping(\"/api\")\npublic class RestApiController {\n    @GetMapping(\"/data\")\n    public Data getData() {\n        return new Data();  // JSON response\n    }\n}"
    },
    {
      "id": 42,
      "question": "What is ResponseEntity in Spring?",
      "answer": "ResponseEntity represents HTTP response:\n\nComponents:\n• Body: Response data\n• Status: HTTP status code\n• Headers: HTTP headers\n\nBenefits:\n• Full control over response\n• Set custom headers\n• Different status codes\n• Conditional responses\n\nBuilders:\n• ResponseEntity.ok()\n• ResponseEntity.created()\n• ResponseEntity.notFound()\n• ResponseEntity.status()",
      "explanation": "ResponseEntity gives complete HTTP response control. Set status, headers, body. Better than just returning object.",
      "difficulty": "Medium",
      "code": "@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    // Simple OK response\n    @GetMapping(\"/{id}\")\n    public ResponseEntity<User> getUser(@PathVariable Long id) {\n        User user = userService.findById(id);\n        return ResponseEntity.ok(user);  // 200 OK\n    }\n    \n    // Not found\n    @GetMapping(\"/search/{email}\")\n    public ResponseEntity<User> findByEmail(@PathVariable String email) {\n        User user = userService.findByEmail(email);\n        if (user == null) {\n            return ResponseEntity.notFound().build();  // 404\n        }\n        return ResponseEntity.ok(user);\n    }\n    \n    // Created with location header\n    @PostMapping\n    public ResponseEntity<User> createUser(@RequestBody User user) {\n        User saved = userService.save(user);\n        \n        URI location = ServletUriComponentsBuilder\n            .fromCurrentRequest()\n            .path(\"/{id}\")\n            .buildAndExpand(saved.getId())\n            .toUri();\n        \n        return ResponseEntity.created(location).body(saved);  // 201\n    }\n    \n    // No content (successful DELETE)\n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {\n        userService.delete(id);\n        return ResponseEntity.noContent().build();  // 204\n    }\n    \n    // Bad request\n    @PostMapping(\"/validate\")\n    public ResponseEntity<String> validateUser(@RequestBody User user) {\n        if (user.getEmail() == null) {\n            return ResponseEntity\n                .badRequest()\n                .body(\"Email is required\");  // 400\n        }\n        return ResponseEntity.ok(\"Valid\");\n    }\n    \n    // Custom status\n    @GetMapping(\"/status/{id}\")\n    public ResponseEntity<User> getUserStatus(@PathVariable Long id) {\n        User user = userService.findById(id);\n        if (user == null) {\n            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();\n        }\n        if (!user.isActive()) {\n            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();\n        }\n        return ResponseEntity.ok(user);\n    }\n    \n    // Custom headers\n    @GetMapping(\"/download/{id}\")\n    public ResponseEntity<byte[]> downloadFile(@PathVariable Long id) {\n        byte[] file = fileService.getFile(id);\n        \n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_PDF);\n        headers.setContentDisposition(\n            ContentDisposition.attachment()\n                .filename(\"document.pdf\")\n                .build()\n        );\n        headers.setCacheControl(\"no-cache\");\n        \n        return ResponseEntity\n            .ok()\n            .headers(headers)\n            .body(file);\n    }\n    \n    // Conditional response\n    @GetMapping(\"/conditional/{id}\")\n    public ResponseEntity<User> getConditional(\n            @PathVariable Long id,\n            @RequestHeader(value = \"If-None-Match\", required = false) String ifNoneMatch) {\n        \n        User user = userService.findById(id);\n        String etag = \"\\\"\" + user.getVersion() + \"\\\"\";\n        \n        // Return 304 if not modified\n        if (etag.equals(ifNoneMatch)) {\n            return ResponseEntity\n                .status(HttpStatus.NOT_MODIFIED)\n                .eTag(etag)\n                .build();\n        }\n        \n        return ResponseEntity\n            .ok()\n            .eTag(etag)\n            .body(user);\n    }\n    \n    // Multiple status options\n    @PutMapping(\"/{id}\")\n    public ResponseEntity<User> updateUser(\n            @PathVariable Long id, @RequestBody User user) {\n        \n        if (!userService.exists(id)) {\n            return ResponseEntity.notFound().build();  // 404\n        }\n        \n        if (!user.isValid()) {\n            return ResponseEntity.badRequest().build();  // 400\n        }\n        \n        User updated = userService.update(id, user);\n        return ResponseEntity.ok(updated);  // 200\n    }\n    \n    // Accepted (async processing)\n    @PostMapping(\"/async\")\n    public ResponseEntity<String> processAsync(@RequestBody User user) {\n        asyncService.process(user);\n        return ResponseEntity\n            .accepted()\n            .body(\"Processing started\");  // 202\n    }\n    \n    // Partial content\n    @GetMapping(\"/partial/{id}\")\n    public ResponseEntity<byte[]> getPartial(\n            @PathVariable Long id,\n            @RequestHeader(value = \"Range\", required = false) String range) {\n        \n        byte[] content = fileService.getFile(id);\n        \n        if (range != null) {\n            // Parse range and return partial content\n            byte[] partial = extractRange(content, range);\n            return ResponseEntity\n                .status(HttpStatus.PARTIAL_CONTENT)\n                .header(\"Content-Range\", \"bytes 0-99/\" + content.length)\n                .body(partial);  // 206\n        }\n        \n        return ResponseEntity.ok(content);\n    }\n}\n\n// Generic error responses\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    @ExceptionHandler(ResourceNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleNotFound(\n            ResourceNotFoundException ex) {\n        ErrorResponse error = new ErrorResponse(\n            \"Resource not found\",\n            ex.getMessage()\n        );\n        return ResponseEntity\n            .status(HttpStatus.NOT_FOUND)\n            .body(error);\n    }\n    \n    @ExceptionHandler(ValidationException.class)\n    public ResponseEntity<Map<String, String>> handleValidation(\n            ValidationException ex) {\n        return ResponseEntity\n            .badRequest()\n            .body(ex.getErrors());\n    }\n}\n\n// Builder pattern\npublic ResponseEntity<User> complexResponse() {\n    return ResponseEntity\n        .status(HttpStatus.OK)\n        .header(\"X-Custom-Header\", \"value\")\n        .header(\"X-Another-Header\", \"value2\")\n        .contentType(MediaType.APPLICATION_JSON)\n        .eTag(\"\\\"version-1\\\"\")\n        .lastModified(Instant.now())\n        .cacheControl(CacheControl.maxAge(60, TimeUnit.SECONDS))\n        .body(user);\n}"
    },
    {
      "id": 43,
      "question": "What is Content Negotiation in Spring?",
      "answer": "Content Negotiation selects response format:\n\nMethods:\n• Accept header: application/json, application/xml\n• File extension: /users.json, /users.xml\n• Query parameter: /users?format=json\n\nSpring supports:\n• JSON (default)\n• XML\n• Custom formats\n\nproduces attribute:\n• Restricts response types\n\nHttpMessageConverter handles conversion.",
      "explanation": "Content negotiation lets client choose response format. Same endpoint returns JSON or XML based on Accept header.",
      "difficulty": "Medium",
      "code": "// Configuration\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    \n    @Override\n    public void configureContentNegotiation(\n            ContentNegotiationConfigurer configurer) {\n        configurer\n            // Favor Accept header\n            .favorParameter(false)\n            .favorPathExtension(false)\n            .ignoreAcceptHeader(false)\n            // Default to JSON\n            .defaultContentType(MediaType.APPLICATION_JSON)\n            // Supported media types\n            .mediaType(\"json\", MediaType.APPLICATION_JSON)\n            .mediaType(\"xml\", MediaType.APPLICATION_XML);\n    }\n}\n\n// Controller with content negotiation\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    // Supports both JSON and XML\n    @GetMapping(produces = {MediaType.APPLICATION_JSON_VALUE, \n                           MediaType.APPLICATION_XML_VALUE})\n    public List<User> getAllUsers() {\n        return userService.findAll();\n    }\n    \n    // JSON only\n    @GetMapping(value = \"/{id}\", produces = MediaType.APPLICATION_JSON_VALUE)\n    public User getUserJson(@PathVariable Long id) {\n        return userService.findById(id);\n    }\n    \n    // XML only\n    @GetMapping(value = \"/{id}\", produces = MediaType.APPLICATION_XML_VALUE)\n    public User getUserXml(@PathVariable Long id) {\n        return userService.findById(id);\n    }\n    \n    // Consumes JSON or XML\n    @PostMapping(consumes = {MediaType.APPLICATION_JSON_VALUE,\n                            MediaType.APPLICATION_XML_VALUE})\n    public User createUser(@RequestBody User user) {\n        return userService.save(user);\n    }\n}\n\n// Entity with XML support\n@XmlRootElement\npublic class User {\n    private Long id;\n    private String name;\n    private String email;\n    \n    @XmlElement\n    public Long getId() { return id; }\n    \n    @XmlElement\n    public String getName() { return name; }\n    \n    @XmlElement\n    public String getEmail() { return email; }\n    \n    // setters\n}\n\n// Client requests\n// JSON request\n// GET /api/users\n// Accept: application/json\n// Response: [{\"id\":1,\"name\":\"John\"}]\n\n// XML request\n// GET /api/users\n// Accept: application/xml\n// Response: <users><user><id>1</id><name>John</name></user></users>\n\n// Custom media type\n@Configuration\npublic class CustomMediaConfig implements WebMvcConfigurer {\n    \n    @Override\n    public void configureContentNegotiation(\n            ContentNegotiationConfigurer configurer) {\n        configurer\n            .mediaType(\"csv\", new MediaType(\"text\", \"csv\"));\n    }\n    \n    @Override\n    public void configureMessageConverters(\n            List<HttpMessageConverter<?>> converters) {\n        converters.add(new CsvMessageConverter());\n    }\n}\n\n@RestController\npublic class DataController {\n    \n    @GetMapping(value = \"/data\", produces = \"text/csv\")\n    public List<User> getDataCsv() {\n        return userService.findAll();\n    }\n}\n\n// Custom message converter\npublic class CsvMessageConverter \n        extends AbstractHttpMessageConverter<List<User>> {\n    \n    public CsvMessageConverter() {\n        super(new MediaType(\"text\", \"csv\"));\n    }\n    \n    @Override\n    protected boolean supports(Class<?> clazz) {\n        return List.class.isAssignableFrom(clazz);\n    }\n    \n    @Override\n    protected List<User> readInternal(\n            Class<? extends List<User>> clazz,\n            HttpInputMessage inputMessage) throws IOException {\n        // Parse CSV to User list\n        return parseCsv(inputMessage.getBody());\n    }\n    \n    @Override\n    protected void writeInternal(\n            List<User> users,\n            HttpOutputMessage outputMessage) throws IOException {\n        // Write User list as CSV\n        String csv = users.stream()\n            .map(u -> u.getId() + \",\" + u.getName() + \",\" + u.getEmail())\n            .collect(Collectors.joining(\"\\n\"));\n        outputMessage.getBody().write(csv.getBytes());\n    }\n}\n\n// Query parameter negotiation\n@Configuration\npublic class QueryParamConfig implements WebMvcConfigurer {\n    @Override\n    public void configureContentNegotiation(\n            ContentNegotiationConfigurer configurer) {\n        configurer\n            .favorParameter(true)\n            .parameterName(\"format\")\n            .mediaType(\"json\", MediaType.APPLICATION_JSON)\n            .mediaType(\"xml\", MediaType.APPLICATION_XML);\n    }\n}\n\n// Client can use: /api/users?format=json or /api/users?format=xml\n\n// Multiple response types\n@RestController\npublic class FlexibleController {\n    \n    @GetMapping(\"/report\")\n    public ResponseEntity<?> getReport(@RequestHeader(\"Accept\") String accept) {\n        \n        List<User> users = userService.findAll();\n        \n        if (accept.contains(\"application/json\")) {\n            return ResponseEntity.ok()\n                .contentType(MediaType.APPLICATION_JSON)\n                .body(users);\n        }\n        \n        if (accept.contains(\"application/xml\")) {\n            return ResponseEntity.ok()\n                .contentType(MediaType.APPLICATION_XML)\n                .body(users);\n        }\n        \n        if (accept.contains(\"text/csv\")) {\n            String csv = generateCsv(users);\n            return ResponseEntity.ok()\n                .contentType(new MediaType(\"text\", \"csv\"))\n                .body(csv);\n        }\n        \n        return ResponseEntity\n            .status(HttpStatus.NOT_ACCEPTABLE)\n            .build();\n    }\n}"
    },
    {
      "id": 44,
      "question": "What is CORS in Spring?",
      "answer": "CORS (Cross-Origin Resource Sharing) allows cross-domain requests:\n\nDefault: Browsers block cross-origin requests\n\nSpring support:\n• @CrossOrigin: Controller/method level\n• Global configuration\n• CorsConfiguration\n\nHeaders:\n• Access-Control-Allow-Origin\n• Access-Control-Allow-Methods\n• Access-Control-Allow-Headers\n• Access-Control-Max-Age\n\nUse for: Frontend (different domain) calling API",
      "explanation": "CORS needed when frontend on different domain than API. Browser security blocks without CORS. Spring makes configuration easy.",
      "difficulty": "Medium",
      "code": "// Method level CORS\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    // Allow all origins\n    @CrossOrigin\n    @GetMapping\n    public List<User> getAllUsers() {\n        return userService.findAll();\n    }\n    \n    // Specific origin\n    @CrossOrigin(origins = \"http://localhost:3000\")\n    @GetMapping(\"/{id}\")\n    public User getUser(@PathVariable Long id) {\n        return userService.findById(id);\n    }\n    \n    // Multiple origins\n    @CrossOrigin(origins = {\"http://localhost:3000\", \"http://example.com\"})\n    @PostMapping\n    public User createUser(@RequestBody User user) {\n        return userService.save(user);\n    }\n    \n    // Custom configuration\n    @CrossOrigin(\n        origins = \"http://localhost:3000\",\n        methods = {RequestMethod.GET, RequestMethod.POST},\n        allowedHeaders = {\"Authorization\", \"Content-Type\"},\n        exposedHeaders = {\"X-Total-Count\"},\n        allowCredentials = \"true\",\n        maxAge = 3600\n    )\n    @GetMapping(\"/secure\")\n    public List<User> getSecureUsers() {\n        return userService.findAll();\n    }\n}\n\n// Controller level CORS\n@CrossOrigin(origins = \"http://localhost:3000\")\n@RestController\n@RequestMapping(\"/api/products\")\npublic class ProductController {\n    // All methods allow http://localhost:3000\n    \n    @GetMapping\n    public List<Product> getAll() {\n        return productService.findAll();\n    }\n    \n    @PostMapping\n    public Product create(@RequestBody Product product) {\n        return productService.save(product);\n    }\n}\n\n// Global CORS configuration\n@Configuration\npublic class CorsConfig implements WebMvcConfigurer {\n    \n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(\"/**\")\n            .allowedOrigins(\"http://localhost:3000\")\n            .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\")\n            .allowedHeaders(\"*\")\n            .allowCredentials(true)\n            .maxAge(3600);\n    }\n}\n\n// Multiple patterns\n@Configuration\npublic class MultiCorsConfig implements WebMvcConfigurer {\n    \n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        // Public API - allow all\n        registry.addMapping(\"/api/public/**\")\n            .allowedOrigins(\"*\")\n            .allowedMethods(\"GET\")\n            .maxAge(3600);\n        \n        // Secured API - specific origin\n        registry.addMapping(\"/api/secure/**\")\n            .allowedOrigins(\"http://localhost:3000\", \"https://example.com\")\n            .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\")\n            .allowedHeaders(\"Authorization\", \"Content-Type\")\n            .allowCredentials(true)\n            .maxAge(1800);\n    }\n}\n\n// CORS filter (alternative approach)\n@Configuration\npublic class CorsFilterConfig {\n    \n    @Bean\n    public CorsFilter corsFilter() {\n        CorsConfiguration config = new CorsConfiguration();\n        config.setAllowCredentials(true);\n        config.addAllowedOrigin(\"http://localhost:3000\");\n        config.addAllowedHeader(\"*\");\n        config.addAllowedMethod(\"*\");\n        \n        UrlBasedCorsConfigurationSource source = \n            new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration(\"/**\", config);\n        \n        return new CorsFilter(source);\n    }\n}\n\n// Security with CORS\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    \n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n            .cors()  // Enable CORS\n            .and()\n            .csrf().disable()\n            .authorizeRequests()\n            .anyRequest().authenticated();\n    }\n    \n    @Bean\n    public CorsConfigurationSource corsConfigurationSource() {\n        CorsConfiguration configuration = new CorsConfiguration();\n        configuration.setAllowedOrigins(\n            Arrays.asList(\"http://localhost:3000\"));\n        configuration.setAllowedMethods(\n            Arrays.asList(\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"));\n        configuration.setAllowedHeaders(Arrays.asList(\"*\"));\n        configuration.setAllowCredentials(true);\n        \n        UrlBasedCorsConfigurationSource source = \n            new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration(\"/**\", configuration);\n        return source;\n    }\n}\n\n// Environment-specific CORS\n@Configuration\npublic class EnvironmentCorsConfig implements WebMvcConfigurer {\n    \n    @Value(\"${cors.allowed.origins}\")\n    private String[] allowedOrigins;\n    \n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(\"/api/**\")\n            .allowedOrigins(allowedOrigins)\n            .allowedMethods(\"*\")\n            .allowedHeaders(\"*\");\n    }\n}\n\n// application-dev.properties\n// cors.allowed.origins=http://localhost:3000,http://localhost:4200\n\n// application-prod.properties\n// cors.allowed.origins=https://example.com\n\n// Testing CORS\n// Preflight request (OPTIONS)\n// Browser automatically sends before actual request\n// OPTIONS /api/users\n// Origin: http://localhost:3000\n// Access-Control-Request-Method: POST\n// Access-Control-Request-Headers: Content-Type\n\n// Response\n// Access-Control-Allow-Origin: http://localhost:3000\n// Access-Control-Allow-Methods: GET, POST, PUT, DELETE\n// Access-Control-Allow-Headers: Content-Type\n// Access-Control-Max-Age: 3600"
    },
    {
      "id": 45,
      "question": "What is @Async in Spring?",
      "answer": "@Async enables asynchronous method execution:\n\nFeatures:\n• Run method in separate thread\n• Non-blocking\n• Return Future/CompletableFuture\n• Thread pool configuration\n\nRequires:\n• @EnableAsync on configuration\n• @Async on method\n• Public method\n• Called from different bean\n\nReturn types:\n• void: Fire and forget\n• Future: Get result later\n• CompletableFuture: Modern async",
      "explanation": "@Async moves method execution to background thread. Main thread continues. Good for slow operations (email, file processing).",
      "difficulty": "Medium",
      "code": "// Enable async\n@Configuration\n@EnableAsync\npublic class AsyncConfig {\n    \n    // Custom thread pool\n    @Bean(name = \"taskExecutor\")\n    public Executor taskExecutor() {\n        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n        executor.setCorePoolSize(5);\n        executor.setMaxPoolSize(10);\n        executor.setQueueCapacity(100);\n        executor.setThreadNamePrefix(\"async-\");\n        executor.initialize();\n        return executor;\n    }\n}\n\n// Async methods\n@Service\npublic class EmailService {\n    \n    // Fire and forget\n    @Async\n    public void sendEmail(String to, String subject, String body) {\n        // Runs in separate thread\n        // Caller doesn't wait\n        System.out.println(\"Sending email to: \" + to);\n        // Simulate slow operation\n        Thread.sleep(3000);\n        System.out.println(\"Email sent\");\n    }\n    \n    // With Future\n    @Async\n    public Future<String> processReport() {\n        // Long-running task\n        Thread.sleep(5000);\n        String result = \"Report completed\";\n        return new AsyncResult<>(result);\n    }\n    \n    // With CompletableFuture (recommended)\n    @Async\n    public CompletableFuture<User> findUser(Long id) {\n        User user = userRepository.findById(id);\n        return CompletableFuture.completedFuture(user);\n    }\n    \n    // Custom executor\n    @Async(\"taskExecutor\")\n    public void processWithCustomPool() {\n        // Uses taskExecutor bean\n    }\n}\n\n// Using async methods\n@Service\npublic class UserService {\n    @Autowired\n    private EmailService emailService;\n    \n    public User registerUser(User user) {\n        // Save user (synchronous)\n        user = userRepository.save(user);\n        \n        // Send email (asynchronous - doesn't block)\n        emailService.sendEmail(\n            user.getEmail(),\n            \"Welcome\",\n            \"Welcome to our app!\"\n        );\n        \n        // Returns immediately (email sending in background)\n        return user;\n    }\n    \n    // Wait for async result\n    public String getReport() throws Exception {\n        Future<String> future = emailService.processReport();\n        \n        // Do other work\n        performOtherTasks();\n        \n        // Wait for result (blocks here)\n        String result = future.get();  // Blocks until complete\n        return result;\n    }\n    \n    // With timeout\n    public String getReportWithTimeout() throws Exception {\n        Future<String> future = emailService.processReport();\n        \n        try {\n            // Wait max 10 seconds\n            return future.get(10, TimeUnit.SECONDS);\n        } catch (TimeoutException e) {\n            future.cancel(true);\n            throw new RuntimeException(\"Report timeout\");\n        }\n    }\n}\n\n// CompletableFuture composition\n@Service\npublic class DataService {\n    \n    @Async\n    public CompletableFuture<List<User>> getUsers() {\n        return CompletableFuture.completedFuture(userRepository.findAll());\n    }\n    \n    @Async\n    public CompletableFuture<List<Order>> getOrders() {\n        return CompletableFuture.completedFuture(orderRepository.findAll());\n    }\n    \n    public CompletableFuture<Report> generateReport() {\n        CompletableFuture<List<User>> usersFuture = getUsers();\n        CompletableFuture<List<Order>> ordersFuture = getOrders();\n        \n        // Combine results\n        return usersFuture.thenCombine(ordersFuture, (users, orders) -> {\n            Report report = new Report();\n            report.setUsers(users);\n            report.setOrders(orders);\n            return report;\n        });\n    }\n    \n    // Chain async operations\n    public CompletableFuture<String> processChain() {\n        return CompletableFuture.supplyAsync(() -> {\n            // Step 1\n            return \"Data\";\n        }).thenApply(data -> {\n            // Step 2\n            return data.toUpperCase();\n        }).thenApply(result -> {\n            // Step 3\n            return result + \" processed\";\n        });\n    }\n}\n\n// Exception handling\n@Service\npublic class AsyncExceptionService {\n    \n    @Async\n    public CompletableFuture<String> processWithException() {\n        try {\n            // Risky operation\n            if (Math.random() > 0.5) {\n                throw new RuntimeException(\"Error\");\n            }\n            return CompletableFuture.completedFuture(\"Success\");\n        } catch (Exception e) {\n            return CompletableFuture.failedFuture(e);\n        }\n    }\n    \n    public void handleAsync() {\n        processWithException()\n            .thenAccept(result -> {\n                System.out.println(\"Success: \" + result);\n            })\n            .exceptionally(ex -> {\n                System.out.println(\"Error: \" + ex.getMessage());\n                return null;\n            });\n    }\n}\n\n// Custom exception handler\n@Component\npublic class AsyncExceptionHandler \n        implements AsyncUncaughtExceptionHandler {\n    \n    @Override\n    public void handleUncaughtException(\n            Throwable ex, Method method, Object... params) {\n        System.out.println(\"Async exception in: \" + method.getName());\n        System.out.println(\"Exception: \" + ex.getMessage());\n    }\n}\n\n@Configuration\n@EnableAsync\npublic class AsyncConfigWithHandler implements AsyncConfigurer {\n    \n    @Override\n    public Executor getAsyncExecutor() {\n        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n        executor.setCorePoolSize(5);\n        executor.setMaxPoolSize(10);\n        executor.initialize();\n        return executor;\n    }\n    \n    @Override\n    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {\n        return new AsyncExceptionHandler();\n    }\n}\n\n// Best practices\n@Service\npublic class BestPractices {\n    \n    // DON'T - same class call (won't work)\n    public void method1() {\n        method2();  // Not async!\n    }\n    \n    @Async\n    public void method2() {\n        // This won't run asynchronously\n    }\n    \n    // DO - call from different bean\n    @Autowired\n    private OtherService otherService;\n    \n    public void correctUsage() {\n        otherService.asyncMethod();  // Works!\n    }\n}\n\n@Service\nclass OtherService {\n    @Async\n    public void asyncMethod() {\n        // Runs asynchronously\n    }\n}"
    },
    {
      "id": 46,
      "question": "What is @Scheduled in Spring?",
      "answer": "@Scheduled enables task scheduling:\n\nScheduling types:\n• Fixed Rate: Every N milliseconds\n• Fixed Delay: N ms after completion\n• Cron: Cron expression\n• Initial Delay: Delay first execution\n\nRequires:\n• @EnableScheduling\n• @Scheduled on method\n• void return type\n\nCron format:\n• second, minute, hour, day, month, weekday\n• */10 * * * * *: Every 10 seconds",
      "explanation": "@Scheduled runs methods periodically. Use for background tasks (cleanup, reports, sync). Choose fixedRate, fixedDelay, or cron.",
      "difficulty": "Medium",
      "code": "// Enable scheduling\n@Configuration\n@EnableScheduling\npublic class SchedulingConfig {\n    // Optional: custom task scheduler\n    @Bean\n    public TaskScheduler taskScheduler() {\n        ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();\n        scheduler.setPoolSize(10);\n        scheduler.setThreadNamePrefix(\"scheduled-\");\n        scheduler.initialize();\n        return scheduler;\n    }\n}\n\n@Component\npublic class ScheduledTasks {\n    \n    // Fixed rate - every 5 seconds\n    // Starts next execution 5s after previous START\n    @Scheduled(fixedRate = 5000)\n    public void fixedRateTask() {\n        System.out.println(\"Fixed rate task: \" + new Date());\n        // If takes 10s, next starts immediately after\n    }\n    \n    // Fixed delay - 5 seconds after completion\n    // Starts next execution 5s after previous COMPLETION\n    @Scheduled(fixedDelay = 5000)\n    public void fixedDelayTask() {\n        System.out.println(\"Fixed delay task: \" + new Date());\n        // If takes 10s, next starts 5s after it finishes\n    }\n    \n    // Initial delay - wait before first execution\n    @Scheduled(fixedRate = 5000, initialDelay = 10000)\n    public void taskWithInitialDelay() {\n        System.out.println(\"Task with initial delay\");\n        // Waits 10s, then runs every 5s\n    }\n    \n    // Cron - specific times\n    // Every day at 2 AM\n    @Scheduled(cron = \"0 0 2 * * *\")\n    public void dailyTask() {\n        System.out.println(\"Daily task at 2 AM\");\n    }\n    \n    // Every Monday at 9 AM\n    @Scheduled(cron = \"0 0 9 * * MON\")\n    public void weeklyTask() {\n        System.out.println(\"Weekly task on Monday 9 AM\");\n    }\n    \n    // Every 10 seconds\n    @Scheduled(cron = \"*/10 * * * * *\")\n    public void every10Seconds() {\n        System.out.println(\"Every 10 seconds\");\n    }\n    \n    // First day of month at midnight\n    @Scheduled(cron = \"0 0 0 1 * *\")\n    public void monthlyTask() {\n        System.out.println(\"Monthly task\");\n    }\n    \n    // Business hours (9 AM - 5 PM, weekdays)\n    @Scheduled(cron = \"0 0 9-17 * * MON-FRI\")\n    public void businessHoursTask() {\n        System.out.println(\"During business hours\");\n    }\n}\n\n// Cron expression format\n// ┌───────────── second (0-59)\n// │ ┌───────────── minute (0-59)\n// │ │ ┌───────────── hour (0-23)\n// │ │ │ ┌───────────── day of month (1-31)\n// │ │ │ │ ┌───────────── month (1-12 or JAN-DEC)\n// │ │ │ │ │ ┌───────────── day of week (0-7 or SUN-SAT)\n// │ │ │ │ │ │\n// * * * * * *\n\n// Common cron examples\n@Component\npublic class CronExamples {\n    \n    @Scheduled(cron = \"0 0 * * * *\")  // Every hour\n    public void hourly() { }\n    \n    @Scheduled(cron = \"0 */15 * * * *\")  // Every 15 minutes\n    public void every15Minutes() { }\n    \n    @Scheduled(cron = \"0 0 0 * * *\")  // Every day at midnight\n    public void daily() { }\n    \n    @Scheduled(cron = \"0 0 12 * * *\")  // Every day at noon\n    public void noon() { }\n    \n    @Scheduled(cron = \"0 0 0 * * SUN\")  // Every Sunday midnight\n    public void weekly() { }\n    \n    @Scheduled(cron = \"0 0 0 1 1 *\")  // Jan 1st every year\n    public void yearly() { }\n}\n\n// Externalized cron\n@Component\npublic class ConfigurableTask {\n    \n    @Scheduled(cron = \"${app.cron.cleanup}\")\n    public void cleanupTask() {\n        System.out.println(\"Cleanup task\");\n    }\n}\n\n// application.properties\n// app.cron.cleanup=0 0 2 * * *\n\n// Conditional scheduling\n@Component\npublic class ConditionalTask {\n    \n    @Scheduled(cron = \"${app.cron.task}\", \n              zone = \"America/New_York\")\n    @ConditionalOnProperty(name = \"app.scheduling.enabled\", \n                          havingValue = \"true\")\n    public void conditionalTask() {\n        System.out.println(\"Conditional task\");\n    }\n}\n\n// Real-world examples\n@Component\npublic class MaintenanceTasks {\n    @Autowired\n    private UserRepository userRepository;\n    @Autowired\n    private CacheManager cacheManager;\n    \n    // Clean expired sessions every hour\n    @Scheduled(cron = \"0 0 * * * *\")\n    public void cleanExpiredSessions() {\n        sessionService.cleanExpired();\n    }\n    \n    // Generate reports daily at 1 AM\n    @Scheduled(cron = \"0 0 1 * * *\")\n    public void generateDailyReports() {\n        reportService.generateDaily();\n    }\n    \n    // Clear cache every 30 minutes\n    @Scheduled(fixedDelay = 1800000)\n    public void clearCache() {\n        cacheManager.getCacheNames()\n            .forEach(name -> cacheManager.getCache(name).clear());\n    }\n    \n    // Sync with external API every 5 minutes\n    @Scheduled(fixedRate = 300000)\n    public void syncData() {\n        externalApiService.sync();\n    }\n    \n    // Delete old records weekly\n    @Scheduled(cron = \"0 0 2 * * SUN\")\n    public void deleteOldRecords() {\n        LocalDateTime cutoff = LocalDateTime.now().minusDays(90);\n        userRepository.deleteByCreatedBefore(cutoff);\n    }\n}\n\n// Async scheduling\n@Component\npublic class AsyncScheduledTasks {\n    \n    @Async\n    @Scheduled(fixedRate = 5000)\n    public void asyncTask() {\n        // Runs asynchronously in separate thread\n        System.out.println(\"Async scheduled task: \" + \n            Thread.currentThread().getName());\n    }\n}\n\n// Exception handling\n@Component\npublic class RobustTasks {\n    \n    @Scheduled(fixedRate = 60000)\n    public void robustTask() {\n        try {\n            performTask();\n        } catch (Exception e) {\n            log.error(\"Scheduled task failed\", e);\n            // Don't let exception break scheduler\n        }\n    }\n}\n\n// Dynamic scheduling (programmatic)\n@Service\npublic class DynamicScheduler {\n    @Autowired\n    private TaskScheduler taskScheduler;\n    \n    public void scheduleDynamicTask() {\n        taskScheduler.schedule(\n            () -> System.out.println(\"Dynamic task\"),\n            new CronTrigger(\"0 0 * * * *\")\n        );\n    }\n}"
    },
    {
      "id": 47,
      "question": "What is Caching in Spring?",
      "answer": "Spring Cache abstraction:\n\nAnnotations:\n• @Cacheable: Cache result\n• @CachePut: Update cache\n• @CacheEvict: Remove from cache\n• @Caching: Combine operations\n\nProviders:\n• ConcurrentHashMap (default)\n• EhCache\n• Caffeine\n• Redis\n• Hazelcast\n\nFeatures:\n• SpEL for keys\n• Conditional caching\n• Multiple caches",
      "explanation": "Caching stores method results. Subsequent calls return cached value instead of executing method. Improves performance for expensive operations.",
      "difficulty": "Medium",
      "code": "// Enable caching\n@Configuration\n@EnableCaching\npublic class CacheConfig {\n    \n    // Simple cache manager (ConcurrentHashMap)\n    @Bean\n    public CacheManager cacheManager() {\n        return new ConcurrentMapCacheManager(\"users\", \"products\");\n    }\n}\n\n// Cacheable - cache result\n@Service\npublic class UserService {\n    \n    @Cacheable(\"users\")\n    public User findById(Long id) {\n        System.out.println(\"Fetching from database\");\n        return userRepository.findById(id);\n        // First call: executes method, caches result\n        // Subsequent calls: returns cached value\n    }\n    \n    // Custom key\n    @Cacheable(value = \"users\", key = \"#id\")\n    public User getUser(Long id) {\n        return userRepository.findById(id);\n    }\n    \n    // Composite key\n    @Cacheable(value = \"users\", key = \"#name + '-' + #age\")\n    public List<User> findByNameAndAge(String name, int age) {\n        return userRepository.findByNameAndAge(name, age);\n    }\n    \n    // Conditional caching\n    @Cacheable(value = \"users\", condition = \"#id > 10\")\n    public User findByIdConditional(Long id) {\n        // Only cache if id > 10\n        return userRepository.findById(id);\n    }\n    \n    // Unless condition\n    @Cacheable(value = \"users\", unless = \"#result == null\")\n    public User findByEmail(String email) {\n        // Don't cache if result is null\n        return userRepository.findByEmail(email);\n    }\n}\n\n// CachePut - always execute and update cache\n@Service\npublic class UserUpdateService {\n    \n    @CachePut(value = \"users\", key = \"#user.id\")\n    public User updateUser(User user) {\n        // Method always executes\n        // Result updates cache\n        return userRepository.save(user);\n    }\n}\n\n// CacheEvict - remove from cache\n@Service\npublic class UserDeleteService {\n    \n    @CacheEvict(value = \"users\", key = \"#id\")\n    public void deleteUser(Long id) {\n        userRepository.deleteById(id);\n        // Removes from cache after execution\n    }\n    \n    // Clear entire cache\n    @CacheEvict(value = \"users\", allEntries = true)\n    public void deleteAllUsers() {\n        userRepository.deleteAll();\n    }\n    \n    // Clear before execution\n    @CacheEvict(value = \"users\", beforeInvocation = true)\n    public void clearCache() {\n        // Evicts before method execution\n        // Useful if method might throw exception\n    }\n}\n\n// Caching - combine multiple cache operations\n@Service\npublic class ComplexCacheService {\n    \n    @Caching(\n        cacheable = {\n            @Cacheable(value = \"users\", key = \"#user.id\"),\n            @Cacheable(value = \"usersByEmail\", key = \"#user.email\")\n        },\n        put = {\n            @CachePut(value = \"users\", key = \"#user.id\")\n        },\n        evict = {\n            @CacheEvict(value = \"oldUsers\", key = \"#user.id\")\n        }\n    )\n    public User complexOperation(User user) {\n        return userRepository.save(user);\n    }\n}\n\n// Caffeine cache (better than ConcurrentHashMap)\n@Configuration\n@EnableCaching\npublic class CaffeineCacheConfig {\n    \n    @Bean\n    public CacheManager cacheManager() {\n        CaffeineCacheManager cacheManager = new CaffeineCacheManager(\n            \"users\", \"products\"\n        );\n        cacheManager.setCaffeine(\n            Caffeine.newBuilder()\n                .expireAfterWrite(10, TimeUnit.MINUTES)\n                .maximumSize(1000)\n        );\n        return cacheManager;\n    }\n}\n\n// Multiple caches with different configs\n@Configuration\npublic class MultiCacheConfig {\n    \n    @Bean\n    public CacheManager cacheManager() {\n        SimpleCacheManager cacheManager = new SimpleCacheManager();\n        \n        cacheManager.setCaches(Arrays.asList(\n            new ConcurrentMapCache(\"users\"),\n            new ConcurrentMapCache(\"products\"),\n            buildCaffeineCache(\"orders\", 600),\n            buildCaffeineCache(\"temp\", 60)\n        ));\n        \n        return cacheManager;\n    }\n    \n    private CaffeineCache buildCaffeineCache(String name, int seconds) {\n        return new CaffeineCache(name,\n            Caffeine.newBuilder()\n                .expireAfterWrite(seconds, TimeUnit.SECONDS)\n                .maximumSize(100)\n                .build()\n        );\n    }\n}\n\n// Redis cache\n@Configuration\npublic class RedisCacheConfig {\n    \n    @Bean\n    public CacheManager cacheManager(RedisConnectionFactory factory) {\n        RedisCacheConfiguration config = RedisCacheConfiguration\n            .defaultCacheConfig()\n            .entryTtl(Duration.ofMinutes(10))\n            .serializeKeysWith(\n                RedisSerializationContext.SerializationPair\n                    .fromSerializer(new StringRedisSerializer())\n            )\n            .serializeValuesWith(\n                RedisSerializationContext.SerializationPair\n                    .fromSerializer(new GenericJackson2JsonRedisSerializer())\n            );\n        \n        return RedisCacheManager.builder(factory)\n            .cacheDefaults(config)\n            .build();\n    }\n}\n\n// Manual cache operations\n@Service\npublic class ManualCacheService {\n    @Autowired\n    private CacheManager cacheManager;\n    \n    public void manualCache() {\n        Cache cache = cacheManager.getCache(\"users\");\n        \n        // Put\n        cache.put(1L, new User(1L, \"John\"));\n        \n        // Get\n        Cache.ValueWrapper wrapper = cache.get(1L);\n        if (wrapper != null) {\n            User user = (User) wrapper.get();\n        }\n        \n        // Evict\n        cache.evict(1L);\n        \n        // Clear\n        cache.clear();\n    }\n}\n\n// Best practices\n@Service\npublic class CacheBestPractices {\n    \n    // Cache expensive operations\n    @Cacheable(\"reports\")\n    public Report generateReport() {\n        // Expensive calculation\n        return report;\n    }\n    \n    // Cache external API calls\n    @Cacheable(value = \"api-data\", \n              key = \"#url\",\n              unless = \"#result == null\")\n    public String callExternalApi(String url) {\n        return restTemplate.getForObject(url, String.class);\n    }\n    \n    // Update cache on modification\n    @CachePut(value = \"users\", key = \"#result.id\")\n    public User save(User user) {\n        return userRepository.save(user);\n    }\n    \n    // Evict on deletion\n    @CacheEvict(value = \"users\", key = \"#id\")\n    public void delete(Long id) {\n        userRepository.deleteById(id);\n    }\n}"
    },
    {
      "id": 48,
      "question": "What is @ConditionalOnProperty?",
      "answer": "@ConditionalOn annotations enable beans conditionally:\n\n@ConditionalOnProperty:\n• Check property value\n• Enable/disable features\n• Environment-specific beans\n\nOther conditionals:\n• @ConditionalOnClass: Class present\n• @ConditionalOnMissingBean: Bean not exists\n• @ConditionalOnWebApplication: Web app\n• @ConditionalOnExpression: SpEL\n\nUse for: Feature flags, environment configs",
      "explanation": "@ConditionalOnProperty activates beans based on properties. Great for feature toggles and environment-specific configurations.",
      "difficulty": "Medium",
      "code": "// ConditionalOnProperty\n@Configuration\npublic class FeatureConfig {\n    \n    // Enable if property exists and is true\n    @Bean\n    @ConditionalOnProperty(name = \"feature.email.enabled\", havingValue = \"true\")\n    public EmailService emailService() {\n        return new RealEmailService();\n    }\n    \n    // Enable if property is false\n    @Bean\n    @ConditionalOnProperty(name = \"feature.email.enabled\", havingValue = \"false\")\n    public EmailService mockEmailService() {\n        return new MockEmailService();\n    }\n    \n    // Enable if property exists (any value)\n    @Bean\n    @ConditionalOnProperty(\"feature.caching.enabled\")\n    public CacheManager cacheManager() {\n        return new ConcurrentMapCacheManager();\n    }\n    \n    // Multiple properties (AND condition)\n    @Bean\n    @ConditionalOnProperty({\n        \"feature.analytics.enabled\",\n        \"feature.analytics.provider\"\n    })\n    public AnalyticsService analyticsService() {\n        return new AnalyticsService();\n    }\n    \n    // Default if missing\n    @Bean\n    @ConditionalOnProperty(\n        name = \"feature.logging.enabled\",\n        havingValue = \"true\",\n        matchIfMissing = true  // Enabled by default\n    )\n    public LoggingService loggingService() {\n        return new LoggingService();\n    }\n    \n    // Prefix for related properties\n    @Bean\n    @ConditionalOnProperty(\n        prefix = \"app.features\",\n        name = \"notifications\",\n        havingValue = \"true\"\n    )\n    public NotificationService notificationService() {\n        return new NotificationService();\n    }\n}\n\n// application.properties\n// feature.email.enabled=true\n// feature.caching.enabled=true\n// feature.analytics.enabled=true\n// feature.analytics.provider=google\n// app.features.notifications=true\n\n// ConditionalOnClass\n@Configuration\npublic class DependencyConfig {\n    \n    // Enable if Redis is on classpath\n    @Bean\n    @ConditionalOnClass(RedisConnectionFactory.class)\n    public RedisCacheManager cacheManager() {\n        return new RedisCacheManager();\n    }\n    \n    // Enable if Kafka is available\n    @Bean\n    @ConditionalOnClass(name = \"org.apache.kafka.clients.producer.KafkaProducer\")\n    public KafkaTemplate<String, String> kafkaTemplate() {\n        return new KafkaTemplate<>();\n    }\n}\n\n// ConditionalOnMissingBean\n@Configuration\npublic class DefaultConfig {\n    \n    // Use custom if provided, otherwise default\n    @Bean\n    @ConditionalOnMissingBean\n    public DataSource dataSource() {\n        // Default H2 datasource\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.H2)\n            .build();\n    }\n}\n\n// ConditionalOnBean\n@Configuration\npublic class DependentConfig {\n    \n    // Only if DataSource exists\n    @Bean\n    @ConditionalOnBean(DataSource.class)\n    public JdbcTemplate jdbcTemplate(DataSource dataSource) {\n        return new JdbcTemplate(dataSource);\n    }\n}\n\n// ConditionalOnWebApplication\n@Configuration\npublic class WebConfig {\n    \n    @Bean\n    @ConditionalOnWebApplication\n    public FilterRegistrationBean<CustomFilter> customFilter() {\n        // Only in web application\n        return new FilterRegistrationBean<>(new CustomFilter());\n    }\n}\n\n// ConditionalOnExpression\n@Configuration\npublic class ExpressionConfig {\n    \n    @Bean\n    @ConditionalOnExpression(\n        \"${feature.advanced.enabled:false} && ${user.role} == 'admin'\"\n    )\n    public AdminFeatures adminFeatures() {\n        return new AdminFeatures();\n    }\n    \n    @Bean\n    @ConditionalOnExpression(\n        \"#{environment['spring.profiles.active'] == 'prod'}\"\n    )\n    public ProductionMonitoring monitoring() {\n        return new ProductionMonitoring();\n    }\n}\n\n// Component-level conditional\n@Service\n@ConditionalOnProperty(\"service.user.enabled\")\npublic class UserService {\n    // Entire service enabled/disabled by property\n}\n\n// Multiple conditions\n@Configuration\npublic class ComplexConditionalConfig {\n    \n    @Bean\n    @ConditionalOnProperty(\"feature.enabled\")\n    @ConditionalOnClass(SomeLibrary.class)\n    @ConditionalOnMissingBean(CustomService.class)\n    public DefaultService defaultService() {\n        // All conditions must be true\n        return new DefaultService();\n    }\n}\n\n// Custom conditional\n@Conditional(OnDevelopmentCondition.class)\n@Component\npublic class DevelopmentOnlyBean { }\n\npublic class OnDevelopmentCondition implements Condition {\n    @Override\n    public boolean matches(ConditionContext context, \n                          AnnotatedTypeMetadata metadata) {\n        String[] profiles = context.getEnvironment().getActiveProfiles();\n        return Arrays.asList(profiles).contains(\"dev\");\n    }\n}\n\n// Real-world feature flags\n@Configuration\npublic class FeatureFlagsConfig {\n    \n    // New payment gateway\n    @Bean\n    @ConditionalOnProperty(\n        name = \"features.payment.new-gateway\",\n        havingValue = \"true\"\n    )\n    public PaymentGateway newPaymentGateway() {\n        return new NewPaymentGateway();\n    }\n    \n    // Old payment gateway (fallback)\n    @Bean\n    @ConditionalOnProperty(\n        name = \"features.payment.new-gateway\",\n        havingValue = \"false\",\n        matchIfMissing = true\n    )\n    public PaymentGateway oldPaymentGateway() {\n        return new OldPaymentGateway();\n    }\n    \n    // Beta features\n    @Bean\n    @ConditionalOnProperty(\"features.beta.enabled\")\n    public BetaFeatures betaFeatures() {\n        return new BetaFeatures();\n    }\n}\n\n// Environment-specific beans\n// application-dev.properties\n// feature.mock-services=true\n// feature.debug-logging=true\n\n// application-prod.properties\n// feature.mock-services=false\n// feature.debug-logging=false\n\n@Configuration\npublic class EnvironmentConfig {\n    \n    @Bean\n    @ConditionalOnProperty(\"feature.mock-services\")\n    public ExternalService mockExternalService() {\n        return new MockExternalService();\n    }\n    \n    @Bean\n    @ConditionalOnProperty(name = \"feature.mock-services\", havingValue = \"false\")\n    public ExternalService realExternalService() {\n        return new RealExternalService();\n    }\n}"
    },
    {
      "id": 49,
      "question": "What is RestTemplate in Spring?",
      "answer": "RestTemplate is HTTP client for RESTful APIs:\n\nMethods:\n• getForObject/getForEntity: GET\n• postForObject/postForEntity: POST\n• put: PUT\n• delete: DELETE\n• exchange: Generic method\n• execute: Low-level\n\nFeatures:\n• Automatic serialization/deserialization\n• Error handling\n• Message converters\n• Interceptors\n\nNote: Deprecated in favor of WebClient",
      "explanation": "RestTemplate simplifies HTTP calls. Handles JSON/XML conversion automatically. Synchronous (blocks until response). WebClient preferred for new code.",
      "difficulty": "Medium",
      "code": "// Configuration\n@Configuration\npublic class RestTemplateConfig {\n    \n    @Bean\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n    \n    // With timeout\n    @Bean\n    public RestTemplate restTemplateWithTimeout() {\n        SimpleClientHttpRequestFactory factory = \n            new SimpleClientHttpRequestFactory();\n        factory.setConnectTimeout(5000);\n        factory.setReadTimeout(5000);\n        return new RestTemplate(factory);\n    }\n}\n\n@Service\npublic class ApiClient {\n    @Autowired\n    private RestTemplate restTemplate;\n    \n    // GET - return object\n    public User getUser(Long id) {\n        String url = \"http://api.example.com/users/\" + id;\n        User user = restTemplate.getForObject(url, User.class);\n        return user;\n    }\n    \n    // GET - return ResponseEntity\n    public ResponseEntity<User> getUserWithStatus(Long id) {\n        String url = \"http://api.example.com/users/\" + id;\n        ResponseEntity<User> response = \n            restTemplate.getForEntity(url, User.class);\n        \n        HttpStatus status = response.getStatusCode();\n        User user = response.getBody();\n        HttpHeaders headers = response.getHeaders();\n        \n        return response;\n    }\n    \n    // GET with URL parameters\n    public List<User> searchUsers(String name, int age) {\n        String url = \"http://api.example.com/users?name={name}&age={age}\";\n        \n        // With map\n        Map<String, Object> params = new HashMap<>();\n        params.put(\"name\", name);\n        params.put(\"age\", age);\n        User[] users = restTemplate.getForObject(url, User[].class, params);\n        \n        return Arrays.asList(users);\n    }\n    \n    // POST - create resource\n    public User createUser(User user) {\n        String url = \"http://api.example.com/users\";\n        User created = restTemplate.postForObject(url, user, User.class);\n        return created;\n    }\n    \n    // POST - with location header\n    public URI createUserWithLocation(User user) {\n        String url = \"http://api.example.com/users\";\n        URI location = restTemplate.postForLocation(url, user);\n        return location;  // Location header from response\n    }\n    \n    // POST - with ResponseEntity\n    public ResponseEntity<User> createUserFull(User user) {\n        String url = \"http://api.example.com/users\";\n        ResponseEntity<User> response = \n            restTemplate.postForEntity(url, user, User.class);\n        return response;\n    }\n    \n    // PUT - update resource\n    public void updateUser(Long id, User user) {\n        String url = \"http://api.example.com/users/\" + id;\n        restTemplate.put(url, user);\n    }\n    \n    // DELETE - remove resource\n    public void deleteUser(Long id) {\n        String url = \"http://api.example.com/users/\" + id;\n        restTemplate.delete(url);\n    }\n    \n    // exchange - generic method\n    public User updateUserWithExchange(Long id, User user) {\n        String url = \"http://api.example.com/users/\" + id;\n        \n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_JSON);\n        headers.set(\"Authorization\", \"Bearer token\");\n        \n        HttpEntity<User> request = new HttpEntity<>(user, headers);\n        \n        ResponseEntity<User> response = restTemplate.exchange(\n            url,\n            HttpMethod.PUT,\n            request,\n            User.class\n        );\n        \n        return response.getBody();\n    }\n    \n    // GET with headers\n    public User getUserWithAuth(Long id, String token) {\n        String url = \"http://api.example.com/users/\" + id;\n        \n        HttpHeaders headers = new HttpHeaders();\n        headers.set(\"Authorization\", \"Bearer \" + token);\n        \n        HttpEntity<Void> request = new HttpEntity<>(headers);\n        \n        ResponseEntity<User> response = restTemplate.exchange(\n            url,\n            HttpMethod.GET,\n            request,\n            User.class\n        );\n        \n        return response.getBody();\n    }\n    \n    // Generic type with ParameterizedTypeReference\n    public List<User> getAllUsers() {\n        String url = \"http://api.example.com/users\";\n        \n        ResponseEntity<List<User>> response = restTemplate.exchange(\n            url,\n            HttpMethod.GET,\n            null,\n            new ParameterizedTypeReference<List<User>>() {}\n        );\n        \n        return response.getBody();\n    }\n}\n\n// Error handling\n@Service\npublic class ApiClientWithErrorHandling {\n    @Autowired\n    private RestTemplate restTemplate;\n    \n    public User getUser(Long id) {\n        String url = \"http://api.example.com/users/\" + id;\n        \n        try {\n            return restTemplate.getForObject(url, User.class);\n        } catch (HttpClientErrorException.NotFound e) {\n            // 404\n            throw new ResourceNotFoundException(\"User not found\");\n        } catch (HttpClientErrorException.BadRequest e) {\n            // 400\n            throw new ValidationException(\"Invalid request\");\n        } catch (HttpServerErrorException e) {\n            // 5xx\n            throw new ServiceException(\"Server error\");\n        } catch (ResourceAccessException e) {\n            // Timeout, connection error\n            throw new ServiceException(\"Service unavailable\");\n        }\n    }\n}\n\n// Custom error handler\npublic class CustomErrorHandler extends DefaultResponseErrorHandler {\n    @Override\n    public void handleError(ClientHttpResponse response) throws IOException {\n        HttpStatus status = response.getStatusCode();\n        \n        if (status == HttpStatus.NOT_FOUND) {\n            throw new ResourceNotFoundException();\n        } else if (status == HttpStatus.BAD_REQUEST) {\n            String body = StreamUtils.copyToString(\n                response.getBody(), Charset.defaultCharset());\n            throw new ValidationException(body);\n        } else {\n            super.handleError(response);\n        }\n    }\n}\n\n@Configuration\npublic class RestTemplateErrorConfig {\n    @Bean\n    public RestTemplate restTemplate() {\n        RestTemplate restTemplate = new RestTemplate();\n        restTemplate.setErrorHandler(new CustomErrorHandler());\n        return restTemplate;\n    }\n}\n\n// Interceptor\npublic class LoggingInterceptor implements ClientHttpRequestInterceptor {\n    @Override\n    public ClientHttpResponse intercept(\n            HttpRequest request,\n            byte[] body,\n            ClientHttpRequestExecution execution) throws IOException {\n        \n        System.out.println(\"Request: \" + request.getMethod() + \" \" + \n                          request.getURI());\n        \n        ClientHttpResponse response = execution.execute(request, body);\n        \n        System.out.println(\"Response: \" + response.getStatusCode());\n        \n        return response;\n    }\n}\n\n@Configuration\npublic class RestTemplateInterceptorConfig {\n    @Bean\n    public RestTemplate restTemplate() {\n        RestTemplate restTemplate = new RestTemplate();\n        restTemplate.setInterceptors(\n            Collections.singletonList(new LoggingInterceptor())\n        );\n        return restTemplate;\n    }\n}"
    },
    {
      "id": 50,
      "question": "What is WebClient in Spring?",
      "answer": "WebClient is modern reactive HTTP client:\n\nFeatures:\n• Non-blocking (reactive)\n• Fluent API\n• Functional style\n• Supports reactive types (Mono, Flux)\n• Better than RestTemplate\n\nMethods:\n• get(), post(), put(), delete()\n• retrieve(): Simple response\n• exchange(): Full control\n• bodyToMono/bodyToFlux\n\nRecommended for new projects.",
      "explanation": "WebClient replaces RestTemplate. Non-blocking = better performance. Returns Mono/Flux for reactive. Can still use synchronously with block().",
      "difficulty": "Hard",
      "code": "// Dependency\n// implementation 'org.springframework.boot:spring-boot-starter-webflux'\n\n// Configuration\n@Configuration\npublic class WebClientConfig {\n    \n    @Bean\n    public WebClient webClient() {\n        return WebClient.builder()\n            .baseUrl(\"http://api.example.com\")\n            .defaultHeader(HttpHeaders.CONTENT_TYPE, \n                          MediaType.APPLICATION_JSON_VALUE)\n            .build();\n    }\n    \n    // With timeout\n    @Bean\n    public WebClient webClientWithTimeout() {\n        return WebClient.builder()\n            .baseUrl(\"http://api.example.com\")\n            .clientConnector(new ReactorClientHttpConnector(\n                HttpClient.create()\n                    .responseTimeout(Duration.ofSeconds(5))\n            ))\n            .build();\n    }\n}\n\n@Service\npublic class  ApiClient {\n    @Autowired\n    private WebClient webClient;\n    \n    // GET - reactive (non-blocking)\n    public Mono<User> getUser(Long id) {\n        return webClient.get()\n            .uri(\"/users/{id}\", id)\n            .retrieve()\n            .bodyToMono(User.class);\n    }\n    \n    // GET - synchronous (blocking)\n    public User getUserSync(Long id) {\n        return webClient.get()\n            .uri(\"/users/{id}\", id)\n            .retrieve()\n            .bodyToMono(User.class)\n            .block();  // Blocks until response\n    }\n    \n    // GET - list (Flux)\n    public Flux<User> getAllUsers() {\n        return webClient.get()\n            .uri(\"/users\")\n            .retrieve()\n            .bodyToFlux(User.class);\n    }\n    \n    // GET - with query parameters\n    public Mono<List<User>> searchUsers(String name, int age) {\n        return webClient.get()\n            .uri(uriBuilder -> uriBuilder\n                .path(\"/users\")\n                .queryParam(\"name\", name)\n                .queryParam(\"age\", age)\n                .build())\n            .retrieve()\n            .bodyToMono(new ParameterizedTypeReference<List<User>>() {});\n    }\n    \n    // POST - create\n    public Mono<User> createUser(User user) {\n        return webClient.post()\n            .uri(\"/users\")\n            .bodyValue(user)\n            .retrieve()\n            .bodyToMono(User.class);\n    }\n    \n    // PUT - update\n    public Mono<User> updateUser(Long id, User user) {\n        return webClient.put()\n            .uri(\"/users/{id}\", id)\n            .bodyValue(user)\n            .retrieve()\n            .bodyToMono(User.class);\n    }\n    \n    // DELETE\n    public Mono<Void> deleteUser(Long id) {\n        return webClient.delete()\n            .uri(\"/users/{id}\", id)\n            .retrieve()\n            .bodyToMono(Void.class);\n    }\n    \n    // With headers\n    public Mono<User> getUserWithAuth(Long id, String token) {\n        return webClient.get()\n            .uri(\"/users/{id}\", id)\n            .header(\"Authorization\", \"Bearer \" + token)\n            .retrieve()\n            .bodyToMono(User.class);\n    }\n    \n    // With ResponseEntity\n    public Mono<ResponseEntity<User>> getUserFull(Long id) {\n        return webClient.get()\n            .uri(\"/users/{id}\", id)\n            .retrieve()\n            .toEntity(User.class);\n    }\n    \n    // Error handling\n    public Mono<User> getUserWithErrorHandling(Long id) {\n        return webClient.get()\n            .uri(\"/users/{id}\", id)\n            .retrieve()\n            .onStatus(HttpStatus::is4xxClientError, response -> {\n                return Mono.error(new ResourceNotFoundException());\n            })\n            .onStatus(HttpStatus::is5xxServerError, response -> {\n                return Mono.error(new ServiceException());\n            })\n            .bodyToMono(User.class)\n            .onErrorResume(WebClientException.class, e -> {\n                // Handle connection errors\n                return Mono.error(new ServiceException(\"Connection failed\"));\n            });\n    }\n    \n    // exchange - full control\n    public Mono<User> getUserWithExchange(Long id) {\n        return webClient.get()\n            .uri(\"/users/{id}\", id)\n            .exchangeToMono(response -> {\n                if (response.statusCode().is2xxSuccessful()) {\n                    return response.bodyToMono(User.class);\n                } else if (response.statusCode() == HttpStatus.NOT_FOUND) {\n                    return Mono.error(new ResourceNotFoundException());\n                } else {\n                    return response.createException()\n                        .flatMap(Mono::error);\n                }\n            });\n    }\n}\n\n// Reactive service\n@Service\npublic class ReactiveUserService {\n    @Autowired\n    private ApiClient apiClient;\n    \n    public Mono<User> processUser(Long id) {\n        return apiClient.getUser(id)\n            .map(user -> {\n                // Transform\n                user.setName(user.getName().toUpperCase());\n                return user;\n            })\n            .flatMap(user -> {\n                // Chain another async operation\n                return apiClient.updateUser(user.getId(), user);\n            });\n    }\n    \n    public Flux<User> processAllUsers() {\n        return apiClient.getAllUsers()\n            .filter(user -> user.getAge() > 18)\n            .map(user -> {\n                user.setStatus(\"ADULT\");\n                return user;\n            });\n    }\n}\n\n// Multiple concurrent requests\n@Service\npublic class ConcurrentApiClient {\n    @Autowired\n    private WebClient webClient;\n    \n    public Mono<Report> generateReport() {\n        Mono<List<User>> users = webClient.get()\n            .uri(\"/users\")\n            .retrieve()\n            .bodyToMono(new ParameterizedTypeReference<List<User>>() {});\n        \n        Mono<List<Order>> orders = webClient.get()\n            .uri(\"/orders\")\n            .retrieve()\n            .bodyToMono(new ParameterizedTypeReference<List<Order>>() {});\n        \n        // Execute in parallel\n        return Mono.zip(users, orders)\n            .map(tuple -> {\n                Report report = new Report();\n                report.setUsers(tuple.getT1());\n                report.setOrders(tuple.getT2());\n                return report;\n            });\n    }\n}\n\n// Filter (interceptor)\npublic class LoggingFilter implements ExchangeFilterFunction {\n    @Override\n    public Mono<ClientResponse> filter(\n            ClientRequest request, ExchangeFunction next) {\n        \n        System.out.println(\"Request: \" + request.method() + \" \" + \n                          request.url());\n        \n        return next.exchange(request)\n            .doOnNext(response -> {\n                System.out.println(\"Response: \" + response.statusCode());\n            });\n    }\n}\n\n@Configuration\npublic class WebClientFilterConfig {\n    @Bean\n    public WebClient webClient() {\n        return WebClient.builder()\n            .baseUrl(\"http://api.example.com\")\n            .filter(new LoggingFilter())\n            .build();\n    }\n}"
    },
    {
      "id": 51,
      "question": "What is Spring Caching?",
      "answer": "Spring caching abstraction speeds up applications:\n\nAnnotations:\n• @Cacheable: Cache method result\n• @CachePut: Update cache\n• @CacheEvict: Remove from cache\n• @Caching: Combine multiple\n• @EnableCaching: Enable caching\n\nProviders:\n• Simple (ConcurrentHashMap)\n• EhCache\n• Caffeine\n• Redis\n• Hazelcast\n\nTransparent caching via AOP.",
      "explanation": "@Cacheable caches method results. Next calls return cached value instead of executing method. @CacheEvict clears cache. Improves performance dramatically.",
      "difficulty": "Medium",
      "code": "@Configuration\n@EnableCaching\npublic class CacheConfig {\n    @Bean\n    public CacheManager cacheManager() {\n        return new ConcurrentMapCacheManager(\"users\", \"products\");\n    }\n}\n\n@Service\npublic class UserService {\n    \n    @Cacheable(\"users\")  // Cache result\n    public User findById(Long id) {\n        System.out.println(\"Fetching from database: \" + id);\n        return userRepository.findById(id).orElseThrow();\n        // First call: executes, caches result\n        // Second call: returns from cache\n    }\n    \n    @Cacheable(value = \"users\", key = \"#email\")\n    public User findByEmail(String email) {\n        System.out.println(\"Database query: \" + email);\n        return userRepository.findByEmail(email);\n    }\n    \n    @CachePut(value = \"users\", key = \"#user.id\")\n    public User updateUser(User user) {\n        System.out.println(\"Updating user: \" + user.getId());\n        return userRepository.save(user);\n        // Executes method AND updates cache\n    }\n    \n    @CacheEvict(value = \"users\", key = \"#id\")\n    public void deleteUser(Long id) {\n        System.out.println(\"Deleting user: \" + id);\n        userRepository.deleteById(id);\n        // Removes from cache\n    }\n    \n    @CacheEvict(value = \"users\", allEntries = true)\n    public void deleteAllUsers() {\n        System.out.println(\"Deleting all users\");\n        userRepository.deleteAll();\n        // Clears entire cache\n    }\n    \n    @Cacheable(value = \"users\", condition = \"#id > 10\")\n    public User findByIdConditional(Long id) {\n        // Only cache if id > 10\n        return userRepository.findById(id).orElseThrow();\n    }\n    \n    @Cacheable(value = \"users\", unless = \"#result == null\")\n    public User findByIdUnless(Long id) {\n        // Don't cache null results\n        return userRepository.findById(id).orElse(null);\n    }\n    \n    @Caching(\n        cacheable = {@Cacheable(\"users\")},\n        evict = {@CacheEvict(value = \"statistics\", allEntries = true)}\n    )\n    public User createUser(User user) {\n        return userRepository.save(user);\n    }\n}\n\n// Complex key\n@Service\npublic class ProductService {\n    \n    @Cacheable(value = \"products\", \n               key = \"#category + '-' + #priceRange\")\n    public List<Product> findByCategoryAndPrice(\n            String category, String priceRange) {\n        return productRepository.search(category, priceRange);\n    }\n    \n    @Cacheable(value = \"products\", \n               key = \"{#category, #minPrice, #maxPrice}\")\n    public List<Product> search(\n            String category, BigDecimal minPrice, BigDecimal maxPrice) {\n        return productRepository.search(category, minPrice, maxPrice);\n    }\n}\n\n// Redis cache configuration\n@Configuration\n@EnableCaching\npublic class RedisCacheConfig {\n    \n    @Bean\n    public RedisCacheManager cacheManager(RedisConnectionFactory factory) {\n        RedisCacheConfiguration config = RedisCacheConfiguration\n            .defaultCacheConfig()\n            .entryTtl(Duration.ofMinutes(10))  // TTL\n            .disableCachingNullValues();\n        \n        return RedisCacheManager.builder(factory)\n            .cacheDefaults(config)\n            .build();\n    }\n}\n\n// Caffeine cache (better performance)\n@Configuration\n@EnableCaching\npublic class CaffeineCacheConfig {\n    \n    @Bean\n    public CacheManager cacheManager() {\n        CaffeineCacheManager cacheManager = new CaffeineCacheManager();\n        cacheManager.setCaffeine(Caffeine.newBuilder()\n            .expireAfterWrite(10, TimeUnit.MINUTES)\n            .maximumSize(1000));\n        return cacheManager;\n    }\n}\n\n// Multiple cache managers\n@Configuration\n@EnableCaching\npublic class MultiCacheConfig{\n    \n    @Bean\n    @Primary\n    public CacheManager primaryCacheManager() {\n        return new ConcurrentMapCacheManager(\"default\");\n    }\n    \n    @Bean\n    public CacheManager redisCacheManager(RedisConnectionFactory factory) {\n        return RedisCacheManager.create(factory);\n    }\n}\n\n@Service\npublic class MultiCacheService {\n    \n    @Cacheable(value = \"users\", cacheManager = \"primaryCacheManager\")\n    public User findById(Long id) {\n        return userRepository.findById(id).orElseThrow();\n    }\n    \n    @Cacheable(value = \"sessions\", cacheManager = \"redisCacheManager\")\n    public Session findSession(String token) {\n        return sessionRepository.findByToken(token);\n    }\n}"
    },
    {
      "id": 52,
      "question": "What is Spring @Component vs @Service vs @Repository?",
      "answer": "All create Spring beans but semantic differences:\n\n@Component:\n• Generic stereotype\n• Base annotation\n• For any Spring-managed component\n\n@Service:\n• Business logic layer\n• Service classes\n• Extends @Component\n\n@Repository:\n• Data access layer\n• DAO classes\n• Extends @Component\n• Exception translation\n\nAll function identically, differ in semantics.",
      "explanation": "@Component generic. @Service for business logic. @Repository for database. @Repository adds exception translation. Use appropriate one for clarity.",
      "difficulty": "Easy",
      "code": "// @Component - Generic\n@Component\npublic class EmailValidator {\n    public boolean isValid(String email) {\n        return email.matches(\"^[A-Za-z0-9+_.-]+@(.+)$\");\n    }\n}\n\n@Component\npublic class PriceCalculator {\n    public BigDecimal calculate(Order order) {\n        return order.getItems().stream()\n            .map(Item::getPrice)\n            .reduce(BigDecimal.ZERO, BigDecimal::add);\n    }\n}\n\n// @Service - Business logic\n@Service\npublic class UserService {\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    @Autowired\n    private EmailService emailService;\n    \n    public User createUser(User user) {\n        // Business logic\n        User saved = userRepository.save(user);\n        emailService.sendWelcome(user.getEmail());\n        return saved;\n    }\n    \n    public List<User> findActiveUsers() {\n        return userRepository.findByStatus(Status.ACTIVE);\n    }\n}\n\n@Service\npublic class OrderService {\n    \n    @Autowired\n    private OrderRepository orderRepository;\n    \n    @Autowired\n    private PaymentService paymentService;\n    \n    @Transactional\n    public Order placeOrder(OrderDto orderDto) {\n        // Business logic\n        Order order = new Order();\n        order.setItems(orderDto.getItems());\n        order.setTotal(calculateTotal(order));\n        \n        Order saved = orderRepository.save(order);\n        paymentService.processPayment(saved);\n        \n        return saved;\n    }\n    \n    private BigDecimal calculateTotal(Order order) {\n        return order.getItems().stream()\n            .map(item -> item.getPrice().multiply(\n                BigDecimal.valueOf(item.getQuantity())))\n            .reduce(BigDecimal.ZERO, BigDecimal::add);\n    }\n}\n\n// @Repository - Data access\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    List<User> findByStatus(Status status);\n    User findByEmail(String email);\n    List<User> findByAgeGreaterThan(Integer age);\n}\n\n@Repository\npublic class CustomUserRepository {\n    \n    @PersistenceContext\n    private EntityManager entityManager;\n    \n    public List<User> findByCustomCriteria(String name, Integer age) {\n        CriteriaBuilder cb = entityManager.getCriteriaBuilder();\n        CriteriaQuery<User> query = cb.createQuery(User.class);\n        Root<User> root = query.from(User.class);\n        \n        List<Predicate> predicates = new ArrayList<>();\n        if (name != null) {\n            predicates.add(cb.equal(root.get(\"name\"), name));\n        }\n        if (age != null) {\n            predicates.add(cb.greaterThan(root.get(\"age\"), age));\n        }\n        \n        query.where(predicates.toArray(new Predicate[0]));\n        return entityManager.createQuery(query).getResultList();\n    }\n}\n\n// Exception translation in @Repository\n@Repository\npublic class JdbcUserRepository {\n    \n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n    \n    public User findById(Long id) {\n        try {\n            return jdbcTemplate.queryForObject(\n                \"SELECT * FROM users WHERE id = ?\",\n                new UserRowMapper(),\n                id\n            );\n        } catch (EmptyResultDataAccessException e) {\n            // @Repository translates JDBC exceptions\n            // to Spring's DataAccessException\n            throw new ResourceNotFoundException(\"User not found\");\n        }\n    }\n}\n\n// Layer architecture\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {  // No stereotype needed\n    \n    @Autowired\n    private UserService userService;  // @Service\n    \n    @GetMapping(\"/{id}\")\n    public User getUser(@PathVariable Long id) {\n        return userService.findById(id);\n    }\n}\n\n@Service\npublic class UserService {\n    \n    @Autowired\n    private UserRepository userRepository;  // @Repository\n    \n    @Autowired\n    private EmailValidator emailValidator;  // @Component\n    \n    public User createUser(User user) {\n        if (!emailValidator.isValid(user.getEmail())) {\n            throw new ValidationException(\"Invalid email\");\n        }\n        return userRepository.save(user);\n    }\n}\n\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    // Data access\n}\n\n// All are @Component under the hood\n@Component  // Base\npublic class MyComponent {}\n\n@Service  // @Component + semantics\npublic class MyService {}\n\n@Repository  // @Component + exception translation\npublic class MyRepository {}\n\n// Functionally equivalent\n@Component\npublic class Service1 {}\n\n@Service\npublic class Service2 {}\n// Both work as Spring beans!\n// But @Service shows intent\n\n// Component scanning\n@SpringBootApplication\n@ComponentScan(basePackages = \"com.example\")\npublic class Application {\n    // Scans for @Component, @Service, @Repository\n}\n\n// Best practices\n/*\nController Layer:\n  @RestController / @Controller\n  HTTP handling, validation\n  \nService Layer:\n  @Service\n  Business logic, transactions\n  \nData Layer:\n  @Repository\n  Database operations\n  \nUtility:\n  @Component\n  Helpers, validators, etc.\n*/"
    },
    {
      "id": 53,
      "question": "What is Spring @Scope?",
      "answer": "@Scope defines bean lifecycle:\n\nScopes:\n• singleton (default): One instance\n• prototype: New instance each time\n• request: Per HTTP request (web)\n• session: Per HTTP session (web)\n• application: Per ServletContext\n• websocket: Per WebSocket\n\nSingleton for stateless services.\nPrototype for stateful objects.\n\nDefault is singleton.",
      "explanation": "Singleton = one bean for entire application. Prototype = new bean each injection. Request/session for web apps. 99% use singleton (stateless).",
      "difficulty": "Medium",
      "code": "// Singleton (default)\n@Service  // Singleton by default\npublic class UserService {\n    // Single instance shared by all\n    private int counter = 0;  // DANGER: Shared state!\n    \n    public void increment() {\n        counter++;  // NOT thread-safe!\n    }\n}\n\n// Explicit singleton\n@Service\n@Scope(\"singleton\")  // Same as default\npublic class ProductService {\n    // One instance per application\n}\n\n// Prototype - new instance per injection\n@Component\n@Scope(\"prototype\")\npublic class ShoppingCart {\n    private List<Item> items = new ArrayList<>();\n    \n    public void addItem(Item item) {\n        items.add(item);  // Safe: each user gets own instance\n    }\n}\n\n@Service\npublic class OrderService {\n    \n    @Autowired\n    private ApplicationContext context;\n    \n    public void processOrder() {\n        // Get new ShoppingCart each time\n        ShoppingCart cart1 = context.getBean(ShoppingCart.class);\n        ShoppingCart cart2 = context.getBean(ShoppingCart.class);\n        \n        System.out.println(cart1 == cart2);  // false\n    }\n}\n\n// Request scope (web)\n@Component\n@Scope(value = \"request\", proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class RequestContext {\n    private String requestId;\n    private String username;\n    \n    // New instance per HTTP request\n    // Available for duration of request\n}\n\n@RestController\npublic class UserController {\n    \n    @Autowired\n    private RequestContext requestContext;  // Proxied\n    \n    @GetMapping(\"/api/users\")\n    public List<User> getUsers() {\n        requestContext.setRequestId(UUID.randomUUID().toString());\n        // RequestContext unique to this HTTP request\n        return userService.findAll();\n    }\n}\n\n// Session scope (web)\n@Component\n@Scope(value = \"session\", proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class UserSession {\n    private User currentUser;\n    private LocalDateTime loginTime;\n    \n    // One instance per HTTP session\n    // Shared across requests from same user\n}\n\n@RestController\npublic class ProfileController {\n    \n    @Autowired\n    private UserSession userSession;\n    \n    @GetMapping(\"/profile\")\n    public User getProfile() {\n        return userSession.getCurrentUser();\n        // Same UserSession for all requests in same session\n    }\n}\n\n// Application scope\n@Component\n@Scope(\"application\")\npublic class AppConfig {\n    // One instance per ServletContext\n    // Shared across all sessions\n}\n\n// Prototype in Singleton problem\n@Service  // Singleton\npublic class BadService {\n    \n    @Autowired\n    private ShoppingCart cart;  // Prototype\n    \n    // PROBLEM: Prototype injected once at startup\n    // Same cart instance used always!\n}\n\n// Solution 1: Method injection\n@Service\npublic class GoodService {\n    \n    @Autowired\n    private ApplicationContext context;\n    \n    public void processCart() {\n        ShoppingCart cart = context.getBean(ShoppingCart.class);\n        // Get new prototype each time\n    }\n}\n\n// Solution 2: ObjectProvider\n@Service\npublic class BetterService {\n    \n    @Autowired\n    private ObjectProvider<ShoppingCart> cartProvider;\n    \n    public void processCart() {\n        ShoppingCart cart = cartProvider.getObject();\n        // Get new prototype\n    }\n}\n\n// Solution 3: @Lookup\n@Service\npublic class LookupService {\n    \n    @Lookup\n    public ShoppingCart getShoppingCart() {\n        // Spring implements this method\n        return null;  // Placeholder\n    }\n    \n    public void processCart() {\n        ShoppingCart cart = getShoppingCart();\n        // New prototype each call\n    }\n}\n\n// Scoped proxy\n@Component\n@Scope(value = \"prototype\", \n       proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class PrototypeWithProxy {\n    // Proxy ensures new instance\n}\n\n@Service\npublic class ConsumerService {\n    \n    @Autowired\n    private PrototypeWithProxy prototype;  // Actually a proxy\n    \n    public void use() {\n        // Proxy delegates to new instance each time\n    }\n}\n\n// Configuration\n@Configuration\npublic class ScopeConfig {\n    \n    @Bean\n    @Scope(\"singleton\")\n    public DataSource dataSource() {\n        return new HikariDataSource();\n    }\n    \n    @Bean\n    @Scope(\"prototype\")\n    public Report report() {\n        return new Report();\n    }\n}\n\n// Thread scope (custom)\n@Component\n@Scope(\"thread\")\npublic class ThreadLocalContext {\n    // Custom scope implementation\n}\n\n// Scope comparison\n/*\nSingleton:\n  Created: Application startup\n  Destroyed: Application shutdown\n  Count: 1 per container\n  Use: Stateless services\n  Thread-safe: Must be\n  \nPrototype:\n  Created: Each injection/getBean()\n  Destroyed: By garbage collector\n  Count: Many\n  Use: Stateful objects\n  Thread-safe: Not needed\n  \nRequest:\n  Created: Per HTTP request\n  Destroyed: After request\n  Count: 1 per request\n  Use: Request data\n  \nSession:\n  Created: Per HTTP session\n  Destroyed: Session timeout\n  Count: 1 per session\n  Use: User session data\n*/"
    },
    {
      "id": 54,
      "question": "What is Spring @Conditional?",
      "answer": "@Conditional enables conditional bean registration:\n\nTypes:\n• @ConditionalOnProperty: If property exists\n• @ConditionalOnClass: If class present\n• @Conditional OnMissingBean: If bean absent\n• @ConditionalOnBean: If bean present\n• @ConditionalOnExpression: SpEL\n• Custom: Implement Condition\n\nBeans created only if condition met.\n\nGreat for feature flags, environment-specific configs.",
      "explanation": "@Conditional controls bean creation. Check properties, classes, other beans. Create beans dynamically based on conditions. Auto-configuration uses this heavily.",
      "difficulty": "Medium",
      "code": "// @ConditionalOnProperty\n@Configuration\npublic class FeatureConfig {\n    \n    @Bean\n    @ConditionalOnProperty(name = \"feature.enabled\", havingValue = \"true\")\n    public FeatureService featureService() {\n        return new FeatureServiceImpl();\n    }\n    \n    @Bean\n    @ConditionalOnProperty(\n        name = \"cache.enabled\",\n        havingValue = \"true\",\n        matchIfMissing = true  // Default if property missing\n    )\n    public CacheManager cacheManager() {\n        return new ConcurrentMapCacheManager();\n    }\n}\n\n# application.properties\nfeature.enabled=true\ncache.enabled=false\n\n// @ConditionalOnClass\n@Configuration\npublic class RedisConfig {\n    \n    @Bean\n    @ConditionalOnClass(name = \"redis.clients.jedis.Jedis\")\n    public RedisTemplate redisTemplate() {\n        // Only if Jedis on classpath\n        return new RedisTemplate();\n    }\n}\n\n// @ConditionalOnMissingBean\n@Configuration\npublic class DataSourceConfig {\n    \n    @Bean\n    @ConditionalOnMissingBean  // Only if no DataSource exists\n    public DataSource dataSource() {\n        // Provide default DataSource\n        return new HikariDataSource();\n    }\n}\n\n// @ConditionalOnBean\n@Configuration\npublic class CacheConfig {\n    \n    @Bean\n    @ConditionalOnBean(DataSource.class)  // Only if DataSource exists\n    public CacheManager cacheManager(DataSource dataSource) {\n        return new JdbcCacheManager(dataSource);\n    }\n}\n\n// @ConditionalOnExpression (SpEL)\n@Configuration\npublic class ExpressionConfig {\n    \n    @Bean\n    @ConditionalOnExpression(\n        \"${feature.enabled:false} and ${debug.mode:false}\"\n    )\n    public DebugService debugService() {\n        return new DebugService();\n    }\n    \n    @Bean\n    @ConditionalOnExpression(\n        \"'${spring.profiles.active}'.contains('prod')\"\n    )\n    public MonitoringService monitoringService() {\n        return new MonitoringService();\n    }\n}\n\n// Custom condition\npublic class OnWindowsCondition implements Condition {\n    \n    @Override\n    public boolean matches(\n            ConditionContext context, \n            AnnotatedTypeMetadata metadata) {\n        String os = System.getProperty(\"os.name\").toLowerCase();\n        return os.contains(\"windows\");\n    }\n}\n\n@Configuration\npublic class OsConfig {\n    \n    @Bean\n    @Conditional(OnWindowsCondition.class)\n    public FileService windowsFileService() {\n        return new WindowsFileService();\n    }\n    \n    @Bean\n    @ConditionalOnExpression(\n        \"'${os.name}'.toLowerCase().contains('linux')\"\n    )\n    public FileService linuxFileService() {\n        return new LinuxFileService();\n    }\n}\n\n// Multiple conditions\n@Configuration\npublic class MultiConditionConfig {\n    \n    @Bean\n    @ConditionalOnProperty(\"feature.enabled\")\n    @ConditionalOnClass(name = \"com.example.FeatureLib\")\n    @ConditionalOnBean(DataSource.class)\n    public ComplexService complexService() {\n        // All conditions must match\n        return new ComplexService();\n    }\n}\n\n// Component with @Conditional\n@Service\n@ConditionalOnProperty(\"service.enabled\", havingValue = \"true\")\npublic class ConditionalService {\n    // Service only created if property is true\n}\n\n// Profile vs Conditional\n@Configuration\npublic class ProfileVsConditional {\n    \n    @Bean\n    @Profile(\"dev\")  // Simple profile check\n    public MockService mockService() {\n        return new MockService();\n    }\n    \n    @Bean\n    @ConditionalOnProperty(\"mock.enabled\")  // More flexible\n    public MockService mockService2() {\n        return new MockService();\n    }\n}\n\n// Advanced custom condition\npublic class OnDatabaseCondition implements Condition {\n    \n    @Override\n    public boolean matches(\n            ConditionContext context,\n            AnnotatedTypeMetadata metadata) {\n        \n        Environment env = context.getEnvironment();\n        String dbType = env.getProperty(\"database.type\");\n        \n        if (\"postgresql\".equals(dbType)) {\n            // Check if PostgreSQL driver available\n            try {\n                Class.forName(\"org.postgresql.Driver\");\n                return true;\n            } catch (ClassNotFoundException e) {\n                return false;\n            }\n        }\n        \n        return false;\n    }\n}\n\n@Configuration\npublic class DatabaseConfig {\n    \n    @Bean\n    @Conditional(OnDatabaseCondition.class)\n    public DataSource postgresDataSource() {\n        return new PostgreSQLDataSource();\n    }\n}\n\n// Conditional with metadata\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Conditional(OnFeatureCondition.class)\npublic @interface ConditionalOnFeature {\n    String value();\n}\n\npublic class OnFeatureCondition implements Condition {\n    \n    @Override\n    public boolean matches(\n            ConditionContext context,\n            AnnotatedTypeMetadata metadata) {\n        \n        Map<String, Object> attributes = \n            metadata.getAnnotationAttributes(\n                ConditionalOnFeature.class.getName());\n        \n        String feature = (String) attributes.get(\"value\");\n        return context.getEnvironment()\n            .getProperty(\"feature.\" + feature + \".enabled\", \n                        Boolean.class, false);\n    }\n}\n\n@Configuration\npublic class CustomAnnotationConfig {\n    \n    @Bean\n    @ConditionalOnFeature(\"analytics\")\n    public AnalyticsService analyticsService() {\n        return new AnalyticsService();\n    }\n}\n\n# application.properties\nfeature.analytics.enabled=true\n\n// Spring Boot auto-configuration example\n@Configuration\n@ConditionalOnClass(RedisTemplate.class)\n@ConditionalOnProperty(\n    name = \"spring.redis.enabled\",\n    havingValue = \"true\",\n    matchIfMissing = true\n)\npublic class RedisAutoConfiguration {\n    \n    @Bean\n    @ConditionalOnMissingBean\n    public RedisConnectionFactory redisConnectionFactory() {\n        return new JedisConnectionFactory();\n    }\n    \n    @Bean\n    @ConditionalOnBean(RedisConnectionFactory.class)\n    public RedisTemplate<?, ?> redisTemplate(\n            RedisConnectionFactory factory) {\n        RedisTemplate<?, ?> template = new RedisTemplate<>();\n        template.setConnectionFactory(factory);\n        return template;\n    }\n}"
    },
    {
      "id": 55,
      "question": "What is Spring Boot Actuator?",
      "answer": "Actuator provides production-ready features:\n\nEndpoints:\n• /actuator/health: Application health\n• /actuator/info: App information\n• /actuator/metrics: Metrics\n• /actuator/env: Environment properties\n• /actuator/loggers: Log levels\n• /actuator/threaddump: Thread dump\n• /actuator/heapdump: Heap dump\n\nMonitoring, health checks, metrics.\n\nEssential for production applications.",
      "explanation": "Actuator = application monitoring. Health checks for load balancers. Metrics for dashboards. Secure sensitive endpoints. Enable only needed ones.",
      "difficulty": "Easy",
      "code": "// Dependency\n// implementation 'org.springframework.boot:spring-boot-starter-actuator'\n\n# application.properties\n# Expose endpoints\nmanagement.endpoints.web.exposure.include=health,info,metrics\n# Or all\nmanagement.endpoints.web.exposure.include=*\n\n# Base path\nmanagement.endpoints.web.base-path=/actuator\n\n# Health endpoint\nmanagement.endpoint.health.show-details=always\n\n# Info endpoint\ninfo.app.name=My Application\ninfo.app.version=1.0.0\ninfo.app.description=My Spring Boot App\n\n// Health indicator\n@Component\npublic class CustomHealthIndicator implements HealthIndicator {\n    \n    @Override\n    public Health health() {\n        // Check custom health\n        boolean databaseUp = checkDatabase();\n        \n        if (databaseUp) {\n            return Health.up()\n                .withDetail(\"database\", \"Available\")\n                .withDetail(\"connections\", 5)\n                .build();\n        } else {\n            return Health.down()\n                .withDetail(\"database\", \"Unavailable\")\n                .withDetail(\"error\", \"Connection timeout\")\n                .build();\n        }\n    }\n    \n    private boolean checkDatabase() {\n        // Check database connection\n        return true;\n    }\n}\n\n// GET /actuator/health response\n/*\n{\n  \"status\": \"UP\",\n  \"components\": {\n    \"custom\": {\n      \"status\": \"UP\",\n      \"details\": {\n        \"database\": \"Available\",\n        \"connections\": 5\n      }\n    },\n    \"db\": {\n      \"status\": \"UP\"\n    },\n    \"diskSpace\": {\n      \"status\": \"UP\"\n    }\n  }\n}\n*/\n\n// Info contributor\n@Component\npublic class CustomInfoContributor implements InfoContributor {\n    \n    @Override\n    public void contribute(Info.Builder builder) {\n        builder.withDetail(\"custom\", \n            Map.of(\n                \"key1\", \"value1\",\n                \"key2\", \"value2\"\n            ));\n    }\n}\n\n// GET /actuator/info response\n/*\n{\n  \"app\": {\n    \"name\": \"My Application\",\n    \"version\": \"1.0.0\",\n    \"description\": \"My Spring Boot App\"\n  },\n  \"custom\": {\n    \"key1\": \"value1\",\n    \"key2\": \"value2\"\n  }\n}\n*/\n\n// Custom metrics\n@Service\npublic class UserService {\n    \n    private final MeterRegistry meterRegistry;\n    private final Counter userCreatedCounter;\n    \n    public UserService(MeterRegistry meterRegistry) {\n        this.meterRegistry = meterRegistry;\n        this.userCreatedCounter = Counter.builder(\"users.created\")\n            .description(\"Number of users created\")\n            .register(meterRegistry);\n    }\n    \n    public User createUser(User user) {\n        User saved = userRepository.save(user);\n        userCreatedCounter.increment();\n        return saved;\n    }\n    \n    public List<User> getAllUsers() {\n        return meterRegistry.timer(\"users.fetch\").record(() -> {\n            return userRepository.findAll();\n        });\n    }\n}\n\n// GET /actuator/metrics/users.created\n/*\n{\n  \"name\": \"users.created\",\n  \"measurements\": [\n    {\n      \"statistic\": \"COUNT\",\n      \"value\": 42.0\n    }\n  ]\n}\n*/\n\n// Security\n@Configuration\npublic class SecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) \n            throws Exception {\n        http\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/actuator/health\").permitAll()\n                .requestMatchers(\"/actuator/**\").hasRole(\"ADMIN\")\n                .anyRequest().authenticated()\n            );\n        return http.build();\n    }\n}\n\n# application.properties - Security\nspring.security.user.name=admin\nspring.security.user.password=secret\n\n// Custom endpoint\n@Component\n@Endpoint(id = \"custom\")\npublic class CustomEndpoint {\n    \n    @ReadOperation\n    public Map<String, Object> customEndpoint() {\n        Map<String, Object> details = new HashMap<>();\n        details.put(\"timestamp\", LocalDateTime.now());\n        details.put(\"status\", \"OK\");\n        return details;\n    }\n    \n    @WriteOperation\n    public void updateSomething(@Selector String name, String value) {\n        // POST /actuator/custom/{name}\n        System.out.println(\"Updating \" + name + \" to \" + value);\n    }\n}\n\n// GET /actuator/custom\n/*\n{\n  \"timestamp\": \"2024-01-15T10:30:00\",\n  \"status\": \"OK\"\n}\n*/\n\n// Disable specific endpoints\n# application.properties\nmanagement.endpoint.shutdown.enabled=false\nmanagement.endpoint.heapdump.enabled=false\n\n// Enable shutdown endpoint (dangerous!)\n# application.properties\nmanagement.endpoint.shutdown.enabled=true\n\n// POST /actuator/shutdown\n// Gracefully shuts down application\n\n// Liveness and Readiness probes (Kubernetes)\n# application.properties\nmanagement.endpoint.health.probes.enabled=true\n\n// GET /actuator/health/liveness\n/*\n{\n  \"status\": \"UP\"\n}\n*/\n\n// GET /actuator/health/readiness\n/*\n{\n  \"status\": \"UP\"\n}\n*/\n\n// Metrics with tags\n@Service\npublic class OrderService {\n    \n    private final MeterRegistry meterRegistry;\n    \n    public OrderService(MeterRegistry meterRegistry) {\n        this.meterRegistry = meterRegistry;\n    }\n    \n    public void processOrder(Order order) {\n        meterRegistry.counter(\"orders.processed\",\n            \"status\", order.getStatus(),\n            \"type\", order.getType()\n        ).increment();\n    }\n}\n\n// GET /actuator/metrics/orders.processed?tag=status:completed\n\n// Available endpoints\n/*\n/actuator/health      - Health status\n/actuator/info        - Application info\n/actuator/metrics     - Metrics\n/actuator/env         - Environment variables\n/actuator/configprops - Configuration properties\n/actuator/beans       - All beans\n/actuator/mappings    - Request mappings\n/actuator/loggers     - Logger configuration\n/actuator/threaddump  - Thread dump\n/actuator/heapdump    - Heap dump\n/actuator/prometheus  - Prometheus metrics\n*/"
    },
    {
      "id": 56,
      "question": "What is Spring Boot Auto-Configuration?",
      "answer": "Auto-configuration automatically configures beans:\n\nHow it works:\n• @EnableAutoConfiguration\n• Scans META-INF/spring.factories\n• @Conditional checks\n• Creates default beans\n• User beans override defaults\n\nExamples:\n• DataSource from properties\n• JPA EntityManager\n• Jackson ObjectMapper\n• Embedded Tomcat\n\nReduces boilerplate configuration.",
      "explanation": "Auto-config = convention over configuration. Spring Boot configures beans based on classpath and properties. Override with own @Bean. Debug with --debug flag.",
      "difficulty": "Medium",
      "code": "// Spring Boot application\n@SpringBootApplication  // Includes @EnableAutoConfiguration\npublic class MyApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApplication.class, args);\n    }\n}\n\n// @SpringBootApplication expands to:\n@Configuration\n@EnableAuto Configuration\n@ComponentScan\npublic class MyApplication {}\n\n// DataSource auto-configuration\n# application.properties\nspring.datasource.url=jdbc:postgresql://localhost/mydb\nspring.datasource.username=user\nspring.datasource.password=pass\n\n// Spring Boot automatically creates:\n// - DataSource bean\n// - JdbcTemplate bean\n// - TransactionManager bean\n// No @Bean needed!\n\n@Service\npublic class UserService {\n    \n    @Autowired\n    private JdbcTemplate jdbcTemplate;  // Auto-configured!\n    \n    public List<User> findAll() {\n        return jdbcTemplate.query(\n            \"SELECT * FROM users\",\n            new BeanPropertyRowMapper<>(User.class)\n        );\n    }\n}\n\n// JPA auto-configuration\n# application.properties\nspring.jpa.hibernate.ddl-auto=update\nspring.jpa.show-sql=true\n\n// Spring Boot automatically creates:\n// - EntityManagerFactory\n// - JpaTransactionManager\n// - JpaRepositories\n\n@Entity\npublic class User {\n    @Id\n    @GeneratedValue\n    private Long id;\n    private String name;\n}\n\npublic interface UserRepository extends JpaRepository<User, Long> {\n    // Auto-implemented by Spring Data JPA!\n}\n\n// Web auto-configuration\n// Just add spring-boot-starter-web dependency\n// Automatically configures:\n// - Embedded Tomcat\n// - DispatcherServlet\n// - HttpMessageConverters\n// - Jackson ObjectMapper\n\n@RestController\npublic class UserController {\n    \n    @GetMapping(\"/users\")\n    public List<User> getUsers() {\n        return userService.findAll();\n        // Jackson automatically serializes to JSON\n    }\n}\n\n// Override auto-configuration\n@Configuration\npublic class CustomConfig {\n    \n    @Bean\n    @Primary  // Override auto-configured DataSource\n    public DataSource customDataSource() {\n        HikariDataSource ds = new HikariDataSource();\n        ds.setJdbcUrl(\"jdbc:postgresql://prod-db\");\n        ds.setMaximumPoolSize(20);\n        return ds;\n    }\n    \n    @Bean\n    public ObjectMapper customObjectMapper() {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.configure(\n            SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);\n        return mapper;  // Overrides auto-configured\n    }\n}\n\n// Disable specific auto-configuration\n@SpringBootApplication(exclude = {\n    DataSourceAutoConfiguration.class,\n    SecurityAutoConfiguration.class\n})\npublic class MyApplication {}\n\n// Or in properties\n# application.properties\nspring.autoconfigure.exclude=\\\n  org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration\n\n// Conditional auto-configuration example\n@Configuration\n@ConditionalOnClass(DataSource.class)  // Only if DataSource on classpath\n@ConditionalOnMissingBean(DataSource.class)  // Only if user didn't define\npublic class DataSourceAutoConfiguration {\n    \n    @Bean\n    public DataSource dataSource() {\n        // Create default DataSource\n        return new HikariDataSource();\n    }\n}\n\n// Custom auto-configuration\n@Configuration\n@ConditionalOnClass(MyService.class)\n@EnableConfigurationProperties(MyProperties.class)\npublic class MyAutoConfiguration {\n    \n    @Bean\n    @ConditionalOnMissingBean\n    public MyService myService(MyProperties properties) {\n        return new MyServiceImpl(properties);\n    }\n}\n\n// META-INF/spring.factories\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\ncom.example.MyAutoConfiguration\n\n// View auto-configuration report\n# application.properties\nlogging.level.org.springframework.boot.autoconfigure=DEBUG\n\n// Or run with --debug\n// java -jar app.jar --debug\n\n/*\nAuto-configuration report:\n\nPositive matches:\n-----------------\n  DataSourceAutoConfiguration matched:\n    - @ConditionalOnClass found required classes\n    - @ConditionalOnMissingBean no DataSource defined\n    \nNegative matches:\n-----------------\n  RedisAutoConfiguration did not match:\n    - @ConditionalOnClass did not find required class\n    \nExclusions:\n-----------\n  SecurityAutoConfiguration\n  \nUnconditional classes:\n----------------------\n  JacksonAutoConfiguration\n*/\n\n// Common auto-configurations\n/*\nDataSourceAutoConfiguration\n  - Creates DataSource from properties\n  \nJpaRepositoriesAutoConfiguration\n  - Enables JPA repositories\n  \nWebMvcAutoConfiguration  \n  - Configures Spring MVC\n  \nJacksonAutoConfiguration\n  - Configures Jackson JSON\n  \nSecurityAutoConfiguration\n  - Basic security setup\n  \nRedisAutoConfiguration\n  - Configures Redis if available\n  \nMongoAutoConfiguration\n  - Configures MongoDB\n*/\n\n// Configuration properties\n@ConfigurationProperties(prefix = \"myapp\")\npublic class MyProperties {\n    private String name;\n    private int timeout;\n    // getters/setters\n}\n\n# application.properties\nmyapp.name=MyApp\nmyapp.timeout=5000\n\n@Configuration\n@EnableConfigurationProperties(MyProperties.class)\npublic class MyConfig {\n    \n    @Bean\n    public MyService myService(MyProperties properties) {\n        return new MyService(properties.getName(), \n                           properties.getTimeout());\n    }\n}"
    },
    {
      "id": 57,
      "question": "What is Spring Boot Starter?",
      "answer": "Starters are convenient dependency descriptors:\n\nCommon starters:\n• spring-boot-starter-web: Web applications\n• spring-boot-starter-data-jpa: JPA\n• spring-boot-starter-security: Security\n• spring-boot-starter-test: Testing\n• spring-boot-starter-actuator: Monitoring\n\nBenefits:\n• Single dependency\n• Compatible versions\n• Auto-configuration\n• Reduced dependency conflicts\n\nJust add one starter, get everything needed.",
      "explanation": "Starter = bundle of dependencies. Add spring-boot-starter-web, get Tomcat, Spring MVC, Jackson. No version management needed. Curated dependencies.",
      "difficulty": "Easy",
      "code": "// build.gradle (Gradle)\ndependencies {\n    // Web starter\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    // Includes:\n    // - spring-web, spring-webmvc\n    // - tomcat-embed-core\n    // - jackson-databind\n    // - spring-boot-starter-json\n    \n    // JPA starter\n    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'\n    // Includes:\n    // - spring-data-jpa\n    // - hibernate-core\n    // - spring-orm\n    // - jakarta.persistence-api\n    \n    // Database\n    runtimeOnly 'org.postgresql:postgresql'\n    \n    // Test starter\n    testImplementation 'org.springframework.boot:spring-boot-starter-test'\n    // Includes:\n    // - junit-jupiter\n    // - mockito\n    // - assertj\n    // - hamcrest\n    // - spring-test\n}\n\n// pom.xml (Maven)\n<dependencies>\n    <!-- Web starter -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    \n    <!-- JPA starter -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-data-jpa</artifactId>\n    </dependency>\n    \n    <!-- Database -->\n    <dependency>\n        <groupId>org.postgresql</groupId>\n        <artifactId>postgresql</artifactId>\n        <scope>runtime</scope>\n    </dependency>\n    \n    <!-- Test starter -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n\n// Common starters\n\n// Web applications\nimplementation 'org.springframework.boot:spring-boot-starter-web'\n\n// REST APIs with validation\nimplementation 'org.springframework.boot:spring-boot-starter-web'\nimplementation 'org.springframework.boot:spring-boot-starter-validation'\n\n// Traditional web with templates\nimplementation 'org.springframework.boot:spring-boot-starter-web'\nimplementation 'org.springframework.boot:spring-boot-starter-thymeleaf'\n\n// Reactive web\nimplementation 'org.springframework.boot:spring-boot-starter-webflux'\n\n// Database access\nimplementation 'org.springframework.boot:spring-boot-starter-data-jpa'\nimplementation 'org.springframework.boot:spring-boot-starter-data-mongodb'\nimplementation 'org.springframework.boot:spring-boot-starter-data-redis'\nimplementation 'org.springframework.boot:spring-boot-starter-jdbc'\n\n// Security\nimplementation 'org.springframework.boot:spring-boot-starter-security'\n\n// Monitoring\nimplementation 'org.springframework.boot:spring-boot-starter-actuator'\n\n// Message queue\nimplementation 'org.springframework.boot:spring-boot-starter-amqp'  // RabbitMQ\nimplementation 'org.springframework.boot:spring-boot-starter-artemis'  // ActiveMQ\n\n// Caching\nimplementation 'org.springframework.boot:spring-boot-starter-cache'\n\n// Email\nimplementation 'org.springframework.boot:spring-boot-starter-mail'\n\n// Scheduling\nimplementation 'org.springframework.boot:spring-boot-starter-quartz'\n\n// WebSocket\nimplementation 'org.springframework.boot:spring-boot-starter-websocket'\n\n// Full REST API example\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'\n    implementation 'org.springframework.boot:spring-boot-starter-validation'\n    implementation 'org.springframework.boot:spring-boot-starter-security'\n    implementation 'org.springframework.boot:spring-boot-starter-actuator'\n    \n    runtimeOnly 'org.postgresql:postgresql'\n    \n    testImplementation 'org.springframework.boot:spring-boot-starter-test'\n    testImplementation 'org.springframework.security:spring-security-test'\n}\n\n// Application with these starters\n@SpringBootApplication\npublic class RestApiApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(RestApiApplication.class, args);\n    }\n}\n\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    // Web starter provides this\n}\n\n@Entity\npublic class User {\n    // JPA starter provides this\n}\n\npublic interface UserRepository extends JpaRepository<User, Long> {\n    // spring-boot-starter-data-jpa provides this\n}\n\n// Custom starter\n// my-spring-boot-starter/pom.xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>com.example</groupId>\n        <artifactId>my-library</artifactId>\n    </dependency>\n</dependencies>\n\n// my-spring-boot-autoconfigure\n@Configuration\n@ConditionalOnClass(MyService.class)\n@EnableConfigurationProperties(MyProperties.class)\npublic class MyAutoConfiguration {\n    \n    @Bean\n    @ConditionalOnMissingBean\n    public MyService myService(MyProperties properties) {\n        return new MyServiceImpl(properties);\n    }\n}\n\n// META-INF/spring.factories\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\ncom.example.MyAutoConfiguration\n\n// Use custom starter\ndependencies {\n    implementation 'com.example:my-spring-boot-starter:1.0.0'\n}\n\n// Exclude transitive dependencies\ndependencies {\n    implementation('org.springframework.boot:spring-boot-starter-web') {\n        exclude group: 'org.springframework.boot', \n                module: 'spring-boot-starter-tomcat'\n    }\n    implementation 'org.springframework.boot:spring-boot-starter-jetty'\n}\n\n// Version management\n// Spring Boot manages versions\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    // No version needed! Spring Boot provides it\n}\n\n// Override version\next {\n    set('jacksonVersion', '2.15.0')\n}\n\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    implementation \"com.fasterxml.jackson.core:jackson-databind:${jacksonVersion}\"\n}"
    },
    {
      "id": 58,
      "question": "What is Spring Boot @SpringBootApplication?",
      "answer": "@SpringBootApplication is composite annotation:\n\nCombines:\n• @SpringBootConfiguration (@Configuration)\n• @EnableAutoConfiguration\n• @ComponentScan\n\nFunctions:\n• Marks configuration class\n• Enables auto-configuration\n• Scans components\n• Entry point for application\n\nEquivalent to three separate annotations.\n\nAlways on main class.",
      "explanation": "@SpringBootApplication = 3 annotations in 1. Marks Spring Boot app. Enables auto-config and component scan. Put on class with main().",
      "difficulty": "Easy",
      "code": "// Standard Spring Boot application\n@SpringBootApplication\npublic class MyApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApplication.class, args);\n    }\n}\n\n// Equivalent to:\n@SpringBootConfiguration  // = @Configuration\n@EnableAutoConfiguration\n@ComponentScan\npublic class MyApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApplication.class, args);\n    }\n}\n\n// @SpringBootConfiguration\n@Configuration\npublic class MyApplication {\n    // Can define @Bean methods\n    \n    @Bean\n    public MyService myService() {\n        return new MyServiceImpl();\n    }\n}\n\n// @EnableAutoConfiguration\n// Enables Spring Boot's auto-configuration\n// Scans META-INF/spring.factories\n// Applies @Conditional checks\n\n// @ComponentScan\n// Scans package and sub-packages for:\n// @Component, @Service, @Repository, @Controller\n\n// Custom scan packages\n@SpringBootApplication(scanBasePackages = {\n    \"com.example.app\",\n    \"com.example.lib\"\n})\npublic class MyApplication {}\n\n// Or by class\n@SpringBootApplication(scanBasePackageClasses = {\n    MyApplication.class,\n    LibraryConfig.class\n})\npublic class MyApplication {}\n\n// Exclude auto-configuration\n@SpringBootApplication(exclude = {\n    DataSourceAutoConfiguration.class,\n    SecurityAutoConfiguration.class\n})\npublic class MyApplication {}\n\n// Or by name\n@SpringBootApplication(excludeName = {\n    \"org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration\"\n})\npublic class MyApplication {}\n\n// With configuration properties\n@SpringBootApplication\n@EnableConfigurationProperties(AppProperties.class)\npublic class MyApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApplication.class, args);\n    }\n}\n\n// With scheduling\n@SpringBootApplication\n@EnableScheduling\npublic class MyApplication {}\n\n// With async\n@SpringBootApplication\n@EnableAsync\npublic class MyApplication {}\n\n// With caching\n@SpringBootApplication\n@EnableCaching\npublic class MyApplication {}\n\n// Package structure\n/*\ncom.example.myapp\n├── MyApplication.java  (@SpringBootApplication)\n├── controller/\n│   └── UserController.java  (@RestController)\n├── service/\n│   └── UserService.java  (@Service)\n├── repository/\n│   └── UserRepository.java  (@Repository)\n└── model/\n    └── User.java\n*/\n\n// All components in com.example.myapp and sub-packages\n// are automatically scanned\n\n// Run application\npublic class MyApplication {\n    public static void main(String[] args) {\n        // Default\n        SpringApplication.run(MyApplication.class, args);\n        \n        // Custom\n        SpringApplication app = new SpringApplication(MyApplication.class);\n        app.setBannerMode(Banner.Mode.OFF);\n        app.setAdditionalProfiles(\"dev\");\n        app.run(args);\n    }\n}\n\n// Access ApplicationContext\n@SpringBootApplication\npublic class MyApplication {\n    public static void main(String[] args) {\n        ConfigurableApplicationContext context = \n            SpringApplication.run(MyApplication.class, args);\n        \n        // Get bean\n        UserService userService = context.getBean(UserService.class);\n        userService.doSomething();\n        \n        // Close context\n        context.close();\n    }\n}\n\n// Command line runner\n@SpringBootApplication\npublic class MyApplication {\n    \n    public static void main(String[] args) {\n        SpringApplication.run(MyApplication.class, args);\n    }\n    \n    @Bean\n    public CommandLineRunner run() {\n        return args -> {\n            System.out.println(\"Application started!\");\n            // Runs after context loaded\n        };\n    }\n}\n\n// Application runner\n@SpringBootApplication\npublic class MyApplication {\n    \n    @Bean\n    public ApplicationRunner runner() {\n        return args -> {\n            System.out.println(\"Arguments: \" + \n                Arrays.toString(args.getSourceArgs()));\n        };\n    }\n}\n\n// Multiple profiles\n@SpringBootApplication\npublic class MyApplication {\n    public static void main(String[] args) {\n        SpringApplication app = new SpringApplication(MyApplication.class);\n        app.setAdditionalProfiles(\"dev\", \"debug\");\n        app.run(args);\n    }\n}\n\n// Custom banner\n@SpringBootApplication\npublic class MyApplication {\n    public static void main(String[] args) {\n        SpringApplication app = new SpringApplication(MyApplication.class);\n        app.setBanner(new Banner() {\n            @Override\n            public void printBanner(\n                    Environment env, \n                    Class<?> sourceClass, \n                    PrintStream out) {\n                out.println(\"=== My Application ===\");\n            }\n        });\n        app.run(args);\n    }\n}\n\n// src/main/resources/banner.txt\n/*\n  __  __                              \n |  \\/  | _   _     /\\   _ __  _ __  \n | |\\/| || | | |   /  \\ | '_ \\| '_ \\ \n | |  | || |_| |  / /\\ \\| |_) | |_) |\n |_|  |_| \\__, | /_/  \\_\\ .__/| .__/ \n          |___/         |_|   |_|    \n\nVersion: ${application.version}\nSpring Boot: ${spring-boot.version}\n*/\n\n// Lazy initialization\n@SpringBootApplication\npublic class MyApplication {\n    public static void main(String[] args) {\n        SpringApplication app = new SpringApplication(MyApplication.class);\n        app.setLazyInitialization(true);\n        app.run(args);\n    }\n}\n\n# Or in application.properties\nspring.main.lazy-initialization=true"
    },
    {
      "id": 59,
      "question": "What is Spring Boot application.properties vs application.yml?",
      "answer": "Both configure Spring Boot applications:\n\napplication.properties:\n• Key=value format\n• Simple, flat\n• Traditional Java style\n\napplication.yml:\n• YAML format\n• Hierarchical\n• More readable\n• Less repetitive\n\nBoth equally valid. Choose based on preference.\n\nYML better for complex configs.",
      "explanation": "Properties = flat (spring.datasource.url=...). YAML = hierarchical (spring: datasource: url:). Same functionality. YAML more readable for complex configs.",
      "difficulty": "Easy",
      "code": "// application.properties\nspring.application.name=MyApp\nspring.profiles.active=dev\n\nserver.port=8080\nserver.servlet.context-path=/api\n\nspring.datasource.url=jdbc:postgresql://localhost/mydb\nspring.datasource.username=user\nspring.datasource.password=pass\nspring.datasource.driver-class-name=org.postgresql.Driver\n\nspring.jpa.hibernate.ddl-auto=update\nspring.jpa.show-sql=true\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect\n\nlogging.level.root=INFO\nlogging.level.com.example=DEBUG\nlogging.file.name=app.log\n\napp.feature.enabled=true\napp.timeout=5000\napp.servers[0]=server1\napp.servers[1]=server2\n\n// application.yml (equivalent)\nspring:\n  application:\n    name: MyApp\n  profiles:\n    active: dev\n    \nserver:\n  port: 8080\n  servlet:\n    context-path: /api\n    \nspring:\n  datasource:\n    url: jdbc:postgresql://localhost/mydb\n    username: user\n    password: pass\n    driver-class-name: org.postgresql.Driver\n    \n  jpa:\n    hibernate:\n      ddl-auto: update\n    show-sql: true\n    properties:\n      hibernate:\n        dialect: org.hibernate.dialect.PostgreSQLDialect\n        \nlogging:\n  level:\n    root: INFO\n    com.example: DEBUG\n  file:\n    name: app.log\n    \napp:\n  feature:\n    enabled: true\n  timeout: 5000\n  servers:\n    - server1\n    - server2\n\n// Complex configuration\n\n// application.properties\napp.database.master.url=jdbc:postgresql://master/db\napp.database.master.username=master_user\napp.database.master.password=master_pass\napp.database.slave.url=jdbc:postgresql://slave/db\napp.database.slave.username=slave_user\napp.database.slave.password=slave_pass\n\n// application.yml (more readable)\napp:\n  database:\n    master:\n      url: jdbc:postgresql://master/db\n      username: master_user\n      password: master_pass\n    slave:\n      url: jdbc:postgresql://slave/db\n      username: slave_user\n      password: slave_pass\n\n// Lists\n\n// application.properties\napp.servers[0].host=server1.example.com\napp.servers[0].port=8080\napp.servers[1].host=server2.example.com\napp.servers[1].port=8081\n\n// application.yml\napp:\n  servers:\n    - host: server1.example.com\n      port: 8080\n    - host: server2.example.com\n      port: 8081\n\n// Maps\n\n// application.properties\napp.credentials.user1=pass1\napp.credentials.user2=pass2\n\n// application.yml\napp:\n  credentials:\n    user1: pass1\n    user2: pass2\n\n// Multi-line values\n\n// application.properties\napp.description=This is a long description \\\n  that spans multiple lines \\\n  in properties file\n\n// application.yml\napp:\n  description: |\n    This is a long description\n    that spans multiple lines\n    in YAML file\n\n// Profile-specific files\n\n// application-dev.properties\nspring.datasource.url=jdbc:h2:mem:devdb\nlogging.level.root=DEBUG\n\n// application-dev.yml\nspring:\n  datasource:\n    url: jdbc:h2:mem:devdb\nlogging:\n  level:\n    root: DEBUG\n\n// application-prod.properties\nspring.datasource.url=jdbc:postgresql://prod-db/mydb\nlogging.level.root=WARN\n\n// application-prod.yml\nspring:\n  datasource:\n    url: jdbc:postgresql://prod-db/mydb\nlogging:\n  level:\n    root: WARN\n\n// Activate profile\njava -jar app.jar --spring.profiles.active=prod\n\n// Or in application.properties\nspring.profiles.active=dev\n\n// @ConfigurationProperties\n@ConfigurationProperties(prefix = \"app\")\npublic class AppProperties {\n    private String name;\n    private Database database;\n    private List<Server> servers;\n    \n    public static class Database {\n        private String url;\n        private String username;\n        // getters/setters\n    }\n    \n    public static class Server {\n        private String host;\n        private int port;\n        // getters/setters\n    }\n    \n    // getters/setters\n}\n\n// Works with both properties and YAML\n\n// Environment variables\n# application.properties\nspring.datasource.url=${DB_URL:jdbc:h2:mem:default}\nspring.datasource.username=${DB_USER:sa}\nspring.datasource.password=${DB_PASS:}\n\n# application.yml\nspring:\n  datasource:\n    url: ${DB_URL:jdbc:h2:mem:default}\n    username: ${DB_USER:sa}\n    password: ${DB_PASS:}\n\n// Multiple profiles in YAML\n# application.yml\nspring:\n  application:\n    name: MyApp\n\n---\nspring:\n  config:\n    activate:\n      on-profile: dev\n  datasource:\n    url: jdbc:h2:mem:devdb\n\n---\nspring:\n  config:\n    activate:\n      on-profile: prod\n  datasource:\n    url: jdbc:postgresql://prod-db/mydb\n\n// Cannot do this in .properties file!\n// Must use separate files\n\n// Precedence (highest to lowest)\n/*\n1. Command line arguments\n2. System properties\n3. OS environment variables\n4. application-{profile}.properties/yml\n5. application.properties/yml\n6. @PropertySource\n7. Default properties\n*/\n\n// Example override\n# application.yml\nserver:\n  port: 8080\n\n# application-dev.yml\nserver:\n  port: 9090  // Overrides for dev profile\n\n// Command line\njava -jar app.jar --server.port=7070  // Overrides all"
    },
    {
      "id": 60,
      "question": "What is Spring Boot Profiles?",
      "answer": "Profiles enable environment-specific configurations:\n\nUsage:\n• Different configs per environment\n• dev, test, prod profiles\n• @Profile on beans\n• application-{profile}.properties\n\nActivation:\n• spring.profiles.active\n• Command line argument\n• Environment variable\n• @ActiveProfiles (tests)\n\nMultiple profiles can be active simultaneously.",
      "explanation": "Profiles = environment configs. Dev uses H2, prod uses PostgreSQL. Mock services in test, real in prod. Activate with spring.profiles.active=prod.",
      "difficulty": "Easy",
      "code": "# application.properties (default)\nspring.application.name=MyApp\napp.feature.enabled=false\n\n# application-dev.properties\nspring.datasource.url=jdbc:h2:mem:devdb\nspring.datasource.username=sa\nspring.datasource.password=\n\nlogging.level.root=DEBUG\napp.feature.enabled=true\n\n# application-prod.properties\nspring.datasource.url=jdbc:postgresql://prod-db/mydb\nspring.datasource.username=prod_user\nspring.datasource.password=${DB_PASSWORD}\n\nlogging.level.root=WARN\napp.feature.enabled=false\n\n// Activate profile\n# application.properties\nspring.profiles.active=dev\n\n// Command line\njava -jar app.jar --spring.profiles.active=prod\n\n// Environment variable\nexport SPRING_PROFILES_ACTIVE=prod\n\n// Programmatically\n@SpringBootApplication\npublic class MyApplication {\n    public static void main(String[] args) {\n        SpringApplication app = new SpringApplication(MyApplication.class);\n        app.setAdditionalProfiles(\"dev\");\n        app.run(args);\n    }\n}\n\n// Profile-specific beans\n@Configuration\npublic class DataSourceConfig {\n    \n    @Bean\n    @Profile(\"dev\")\n    public DataSource devDataSource() {\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.H2)\n            .build();\n    }\n    \n    @Bean\n    @Profile(\"prod\")\n    public DataSource prodDataSource() {\n        HikariDataSource ds = new HikariDataSource();\n        ds.setJdbcUrl(\"jdbc:postgresql://prod-db/mydb\");\n        return ds;\n    }\n}\n\n// Profile on components\n@Service\n@Profile(\"dev\")\npublic class MockEmailService implements EmailService {\n    public void send(String to, String message) {\n        System.out.println(\"Mock email: \" + message);\n    }\n}\n\n@Service\n@Profile(\"prod\")\npublic class SmtpEmailService implements EmailService {\n    public void send(String to, String message) {\n        // Real SMTP implementation\n    }\n}\n\n// Multiple profiles\n@Service\n@Profile({\"dev\", \"test\"})\npublic class DevTestService {}\n\n// NOT prod\n@Service\n@Profile(\"!prod\")\npublic class NonProdService {}\n\n// Complex expressions\n@Service\n@Profile(\"prod & cloud\")\npublic class ProdCloudService {}\n\n@Service\n@Profile(\"dev | test\")\npublic class DevOrTestService {}\n\n// Activate multiple profiles\nspring.profiles.active=dev,debug\n\n// Or\njava -jar app.jar --spring.profiles.active=dev,debug\n\n// Profile groups\n# application.properties\nspring.profiles.group.development=dev,debug,local\nspring.profiles.group.production=prod,cloud\n\n// Activate group\nspring.profiles.active=development\n// Activates: dev, debug, local\n\n// YAML with profiles\n# application.yml\nspring:\n  application:\n    name: MyApp\n  profiles:\n    active: dev\n\n---\n# Dev profile\nspring:\n  config:\n    activate:\n      on-profile: dev\n  datasource:\n    url: jdbc:h2:mem:devdb\n\n---\n# Prod profile\nspring:\n  config:\n    activate:\n      on-profile: prod\n  datasource:\n    url: jdbc:postgresql://prod-db/mydb\n\n// Testing with profiles\n@SpringBootTest\n@ActiveProfiles(\"test\")\nclass UserServiceTest {\n    \n    @Autowired\n    private UserService userService;\n    \n    @Test\n    void testCreate() {\n        // Uses test profile configuration\n    }\n}\n\n// Profile-specific test config\n@TestConfiguration\n@Profile(\"test\")\npublic class TestConfig {\n    \n    @Bean\n    @Primary\n    public EmailService mockEmailService() {\n        return new MockEmailService();\n    }\n}\n\n// Check active profile\n@Service\npublic class ConfigService {\n    \n    @Autowired\n    private Environment environment;\n    \n    public void printActiveProfiles() {\n        String[] profiles = environment.getActiveProfiles();\n        System.out.println(\"Active profiles: \" + \n            Arrays.toString(profiles));\n    }\n    \n    public boolean isDevMode() {\n        return Arrays.asList(environment.getActiveProfiles())\n            .contains(\"dev\");\n    }\n}\n\n// Conditional on profile\n@Component\npublic class StartupRunner implements CommandLineRunner {\n    \n    @Autowired\n    private Environment environment;\n    \n    @Override\n    public void run(String... args) {\n        if (Arrays.asList(environment.getActiveProfiles())\n                .contains(\"dev\")) {\n            System.out.println(\"Running in DEV mode\");\n            loadTestData();\n        }\n    }\n    \n    private void loadTestData() {\n        // Load test data\n    }\n}\n\n// Profile precedence\n/*\n1. Active profiles from command line\n2. Active profiles from application.properties\n3. Default profile\n\nProperty precedence:\n1. Command line arguments\n2. application-{profile}.properties\n3. application.properties\n*/\n\n// Default profile\n# application.properties\nspring.profiles.default=dev\n// Used if no profile specified\n\n// Best practices\n/*\ndev:\n  - H2 database\n  - Mock external services\n  - Debug logging\n  - Test data\n  \ntest:\n  - H2 database  \n  - Mock services\n  - Test configuration\n  \nprod:\n  - Production database\n  - Real services\n  - Warn logging\n  - Security enabled\n  - Monitoring enabled\n*/"
    },
    {
      "id": 61,
      "question": "What is Spring @Component, @Service, @Repository, @Controller purpose difference?",
      "answer": "All create beans but semantic purpose differs:\n\n@Component: Generic component\n@Service: Business logic layer\n@Repository: Data access + exception translation\n@Controller: Web layer, returns views\n@RestController: REST endpoints, returns data\n\nAll@Component specializations.\n\nUse appropriate for code clarity.",
      "explanation": "Semantic difference only. @Repository adds DB exception translation. @RestController adds @ResponseBody. Use right annotation for layer clarity.",
      "difficulty": "Easy",
      "code": "@Component\npublic class Utility {}\n\n@Service\npublic class BusinessService {}\n\n@Repository\npublic class DataAccess {}\n\n@Controller\npublic class ViewController {}\n\n@RestController\npublic class ApiController {}"
    },
    {
      "id": 62,
      "question": "What are Spring Framework modules?",
      "answer": "Spring is modular framework:\n\nCore:\n• spring-core: IoC, DI\n• spring-beans: BeanFactory\n• spring-context: ApplicationContext\n• spring-expression: SpEL\n\nData:\n• spring-jdbc: JDBC support\n• spring-orm: ORM integration\n• spring-tx: Transaction management\n\nWeb:\n• spring-web: Web support\n• spring-webmvc: MVC framework\n\nMiscellaneous:\n• spring-aop: AOP\n• spring-test: Testing",
      "explanation": "Modular design = use only needed modules. Core + Context = basic IoC. Add spring-webmvc for web. Add spring-data-jpa for database.",
      "difficulty": "Easy",
      "code": "// Minimal dependencies\nspring-core\nspring-beans\nspring-context\n\n// Web application\nspring-webmvc\nspring-web\n\n// Database\nspring-jdbc\nspring-tx\n\n// Full stack\nspring-boot-starter-web\nspring-boot-starter-data-jpa"
    },
    {
      "id": 63,
      "question": "What is Spring @Autowired vs @Resource vs @Inject?",
      "answer": "All inject dependencies but different sources:\n\n@Autowired (Spring):\n• By type\n• required=false option\n• @Qualifier for name\n\n@Resource (Java EE):\n• By name, then type\n• name attribute\n\n@Inject (Java EE):\n• By type\n• @Named for name\n• JSR-330 standard\n\n@Autowired most common in Spring.",
      "explanation": "@Autowired Spring-specific, by type. @Resource JavaEE, by name. @Inject JSR-330 standard. All work similarly. @Autowired most popular.",
      "difficulty": "Medium",
      "code": "@Service\npublic class Service1 {\n    @Autowired\n    private Repository repo;  // By type\n    \n    @Resource(name=\"myRepo\")\n    private Repository repo2;  // By name\n    \n    @Inject\n    private Repository repo3;  // By type (JSR-330)\n}"
    },
    {
      "id": 64,
      "question": "What is BeanFactory vs ApplicationContext?",
      "answer": "Both are IoC containers, ApplicationContext more powerful:\n\nBeanFactory:\n• Basic container\n• Lazy initialization\n• Manual configuration\n\nApplicationContext:\n• Enterprise features\n• Eager initialization\n• Event publication\n• Internationalization\n• AOP integration\n• Extends BeanFactory\n\nAlways use ApplicationContext.",
      "explanation": "BeanFactory = basic. ApplicationContext = advanced (events, i18n, AOP). ApplicationContext used in all modern apps. BeanFactory legacy.",
      "difficulty": "Medium",
      "code": "// BeanFactory (rarely used)\nBeanFactory factory = new XmlBeanFactory(\n    new ClassPathResource(\"beans.xml\"));\nUser user = factory.getBean(User.class);\n\n// ApplicationContext (preferred)\nApplicationContext context = \n    new ClassPathXmlApplicationContext(\"beans.xml\");\nUser user = context.getBean(User.class);\n\n// Spring Boot\n@SpringBootApplication\npublic class App {\n    public static void main(String[] args) {\n        ApplicationContext context = \n            SpringApplication.run(App.class, args);\n    }\n}"
    },
    {
      "id": 65,
      "question": "What is  Spring FactoryBean?",
      "answer": "FactoryBean creates complex beans:\n\n Interface:\n• getObject(): Returns bean\n• getObjectType(): Bean type  \n• isSingleton(): Scope\n\nUse cases:\n• Complex instantiation\n• Third-party integration\n• Proxy creation\n\n& prefix gets FactoryBean itself.",
      "explanation": "FactoryBean = factory for creating beans. Useful for complex object creation. getBean('name') returns product. getBean('&name') returns factory.",
      "difficulty": "Hard",
      "code": "@Component\npublic class ConnectionFactoryBean implements FactoryBean<Connection> {\n    \n    @Override\n    public Connection getObject() throws Exception {\n        return DriverManager.getConnection(\n            \"jdbc:postgresql://localhost/db\", \"user\", \"pass\");\n    }\n    \n    @Override\n    public Class<?> getObjectType() {\n        return Connection.class;\n    }\n    \n    @Override\n    public boolean isSingleton() {\n        return true;\n    }\n}\n\n@Service\npublic class Service {\n    @Autowired\n    private Connection connection;  // Gets Connection, not FactoryBean\n}"
    },
    {
      "id": 66,
      "question": "What is Spring Method Injection and Lookup?",
      "answer": "Method injection solves singleton-prototype problem:\n\n@Lookup:\n• Method returns new prototype\n• Spring implements method\n• Abstract/interface method\n\nObjectProvider:\n• Get prototype programmatically\n• Lazy retrieval\n\nProblem: Singleton needs new prototype each time.",
      "explanation": "Singleton autowires prototype once. @Lookup generates method returning new prototype. ObjectProvider alternative. Both solve prototype-in-singleton.",
      "difficulty": "Hard",
      "code": "@Component\n@Scope(\"prototype\")\npublic class Command {}\n\n@Service\npublic abstract class CommandManager {\n    \n    public void process() {\n        Command cmd = createCommand();  // New each time\n        cmd.execute();\n    }\n    \n    @Lookup\n    protected abstract Command createCommand();\n}\n\n// Alternative: ObjectProvider\n@Service\npublic class Manager {\n    @Autowired\n    private ObjectProvider<Command> commandProvider;\n    \n    public void process() {\n        Command cmd = commandProvider.getObject();\n    }\n}"
    },
    {
      "id": 67,
      "question": "What is Spring PropertySource and Environment?",
      "answer": "PropertySource loads external properties:\n\n@PropertySource:\n• Load specific files\n• Multiple sources\n• Profiles\n\nEnvironment:\n• Access properties\n• Check profiles\n• System properties\n\nReplaced by @ConfigurationProperties in Boot.",
      "explanation": "@PropertySource loads property files. Environment accesses properties. Spring Boot auto-loads application.properties. @ConfigurationProperties better for complex config.",
      "difficulty": "Medium",
      "code": "@Configuration\n@PropertySource(\"classpath:custom.properties\")\npublic class Config {\n    \n    @Autowired\n    private Environment env;\n    \n    @Bean\n    public DataSource dataSource() {\n        String url = env.getProperty(\"db.url\");\n        String user = env.getProperty(\"db.user\");\n        // Create DataSource\n    }\n}\n\n// Multiple sources\n@PropertySource({\n    \"classpath:app.properties\",\n    \"classpath:db.properties\"\n})\npublic class Config {}\n\n// With profile\n@PropertySource(\n    value = \"classpath:dev.properties\",\n    ignoreResourceNotFound = true\n)\n@Profile(\"dev\")\npublic class DevConfig {}"
    },
    {
      "id": 68,
      "question": "What is Spring Import and ImportResource?",
      "answer": "Import configuration from other classes:\n\n@Import:\n• Import @Configuration classes\n• Modular configuration\n• Conditional imports\n\n@ImportResource:\n• Import XML config\n• Legacy integration\n• Mixed Java/XML\n\nBoth organize large configurations.",
      "explanation": "@Import combines @Configuration classes. @ImportResource loads XML beans. Useful for modular config and legacy code.",
      "difficulty": "Medium",
      "code": "@Configuration\npublic class DataSourceConfig {\n    @Bean\n    public DataSource dataSource() {}\n}\n\n@Configuration\npublic class ServiceConfig {\n    @Bean\n    public UserService userService() {}\n}\n\n@Configuration\n@Import({DataSourceConfig.class, ServiceConfig.class})\npublic class AppConfig {\n    // Combines all configs\n}\n\n// Import XML\n@Configuration\n@ImportResource(\"classpath:legacy-beans.xml\")\npublic class MixedConfig {\n    // Java + XML beans\n}"
    },
    {
      "id": 69,
      "question": "What is Spring DependsOn?",
      "answer": "@DependsOn ensures initialization order:\n\nUse cases:\n• Implicit dependencies\n• Initialization order\n• External resources\n\nNot for explicit dependencies (use constructor).\n\nForces specified bean creation first.",
      "explanation": "@DependsOn controls bean creation order. Use when need bean A before B but no direct dependency. Explicit @Autowired better than @DependsOn.",
      "difficulty": "Easy",
      "code": "@Component\npublic class DatabaseInitializer {\n    @PostConstruct\n    public void init() {\n        System.out.println(\"DB initialized\");\n    }\n}\n\n@Component\n@DependsOn(\"databaseInitializer\")\npublic class DataLoader {\n    @PostConstruct\n    public void load() {\n        System.out.println(\"Data loaded\");\n        // Runs after DB initialized\n    }\n}\n\n// Multiple dependencies\n@Component\n@DependsOn({\"beanA\", \"beanB\", \"beanC\"})\npublic class BeanD {}"
    },
    {
      "id": 70,
      "question": "What is Spring PostProcessor (BeanPostProcessor)?",
      "answer": "BeanPostProcessor modifies beans during initialization:\n\nMethods:\n• postProcessBeforeInitialization\n• postProcessAfterInitialization\n\nUse cases:\n• AOP proxies\n• Custom processing\n• Validation\n• Logging\n\nSpring uses internally for @Autowired, @Transactional.",
      "explanation": "BeanPostProcessor intercepts bean creation. Modify all beans before/after init. Spring AOP uses this. Custom processors for cross-cutting concerns.",
      "difficulty": "Hard",
      "code": "@Component\npublic class LoggingBeanPostProcessor implements BeanPostProcessor {\n    \n    @Override\n    public Object postProcessBeforeInitialization(\n            Object bean, String beanName) throws BeansException {\n        System.out.println(\"Before init: \" + beanName);\n        return bean;\n    }\n    \n    @Override\n    public Object postProcessAfterInitialization(\n            Object bean, String beanName) throws BeansException {\n        System.out.println(\"After init: \" + beanName);\n        return bean;  // Can return proxy\n    }\n}\n\n// Example: Validation processor\n@Component\npublic class ValidationPostProcessor implements BeanPostProcessor {\n    \n    @Override\n    public Object postProcessAfterInitialization(\n            Object bean, String beanName) throws BeansException {\n        \n        if (bean instanceof Validator) {\n            ((Validator) bean).validate();\n        }\n        return bean;\n    }\n}"
    },
    {
      "id": 71,
      "question": "What is Spring @Lazy annotation?",
      "answer": "@Lazy delays bean initialization:\n\nDefault: Eager (startup)\n@Lazy: On-demand (first use)\n\nBenefits:\n• Faster startup\n• Reduced memory\n• Conditional usage\n\nDrawbacks:\n• Errors delayed\n• First request slower\n\nUse for optional features.",
      "explanation": "@Lazy creates bean on first use, not startup. Speeds app start but delays errors. Good for rarely-used beans. Trade startup time for first-use time.",
      "difficulty": "Easy",
      "code": "@Component\n@Lazy\npublic class HeavyComponent {\n    public HeavyComponent() {\n        System.out.println(\"Heavy init\");\n        // Not created at startup\n    }\n}\n\n@Service\npublic class MyService {\n    @Autowired\n    @Lazy  // Injected lazily\n    private HeavyComponent heavy;\n    \n    public void use() {\n        heavy.doWork();  // Created here\n    }\n}\n\n// Global lazy\n@Configuration\n@Lazy\npublic class LazyConfig {\n    @Bean\n    public BeanA beanA() {}  // Lazy\n    \n    @Bean\n    public BeanB beanB() {}  // Lazy\n}\n\n// Override lazy\n@Bean\n@Lazy(false)  // Eager\npublic class Important {}"
    },
    {
      "id": 72,
      "question": "What is Spring Resource abstraction?",
      "answer": "Resource unified access to resources:\n\nTypes:\n• ClassPathResource\n• FileSystemResource\n• UrlResource\n• ServletContextResource\n\nPrefixes:\n• classpath: Classpath\n• file: File system\n• http: URL\n\n@Value loads resources easily.",
      "explanation": "Resource = abstraction over files, URLs, classpath. Unified API. Use @Value(\"classpath:file.txt\"). Spring handles loading.",
      "difficulty": "Medium",
      "code": "@Service\npublic class FileService {\n    \n    @Value(\"classpath:data/users.json\")\n    private Resource usersFile;\n    \n    @Value(\"file:/config/app.properties\")\n    private Resource configFile;\n    \n    public String readUsers() throws IOException {\n        InputStream is = usersFile.getInputStream();\n        return new String(is.readAllBytes());\n    }\n}\n\n// ResourceLoader\n@Service\npublic class LoaderService {\n    @Autowired\n    private ResourceLoader resourceLoader;\n    \n    public void loadFile() {\n        Resource resource = resourceLoader.getResource(\n            \"classpath:data.txt\");\n        File file = resource.getFile();\n    }\n}\n\n// Multiple resources\n@Value(\"classpath*:config/*.properties\")\nprivate Resource[] configs;"
    },
    {
      "id": 73,
      "question": "What is Spring MessageSource for internationalization?",
      "answer": "MessageSource enables i18n:\n\nFiles:\n• messages.properties (default)\n• messages_en.properties\n• messages_fr.properties\n\nUsage:\n• getMessage(code, args, locale)\n• Auto-configured in Boot\n\nLocaleResolver determines language.",
      "explanation": "MessageSource = i18n support. Create messages_xx.properties. getMessage(key, locale) returns translated text. Spring Boot auto-configures.",
      "difficulty": "Medium",
      "code": "# messages.properties\ngreeting=Hello\nwelcome=Welcome, {0}!\n\n# messages_fr.properties  \ngreeting=Bonjour\nwelcome=Bienvenue, {0}!\n\n@Service\npublic class I18nService {\n    @Autowired\n    private MessageSource messageSource;\n    \n    public String getGreeting(Locale locale) {\n        return messageSource.getMessage(\n            \"greeting\", null, locale);\n    }\n    \n    public String getWelcome(String name, Locale locale) {\n        return messageSource.getMessage(\n            \"welcome\", new Object[]{name}, locale);\n    }\n}\n\n@RestController\npublic class Controller {\n    @GetMapping(\"/greeting\")\n    public String greeting(Locale locale) {\n        return i18nService.getGreeting(locale);\n    }\n}"
    },
    {
      "id": 74,
      "question": "What is Spring Converter and Formatter?",
      "answer": "Convert between types:\n\nConverter:\n• Object to object\n• Type-safe\n• Bidirectional\n\nFormatter:\n• String to object\n• Locale-aware\n• Display formatting\n\nBoth used in data binding, validation.",
      "explanation": "Converter = type conversion (String→Date). Formatter = locale formatting. Spring uses for @RequestParam, @PathVariable. Register custom converters/formatters.",
      "difficulty": "Hard",
      "code": "// Converter\n@Component\npublic class StringToUserConverter implements Converter<String, User> {\n    @Override\n    public User convert(String id) {\n        return userRepository.findById(Long.parseLong(id))\n            .orElse(null);\n    }\n}\n\n@RestController\npublic class Controller {\n    @GetMapping(\"/users/{user}\")\n    public User getUser(@PathVariable User user) {\n        return user;  // Converted from String\n    }\n}\n\n// Formatter\npublic class DateFormatter implements Formatter<LocalDate> {\n    \n    @Override\n    public LocalDate parse(String text, Locale locale) {\n        return LocalDate.parse(text);\n    }\n    \n    @Override\n    public String print(LocalDate date, Locale locale) {\n        return date.format(DateTimeFormatter.ISO_DATE);\n    }\n}\n\n// Register\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    @Override\n    public void addFormatters(FormatterRegistry registry) {\n        registry.addConverter(new StringToUserConverter());\n        registry.addFormatter(new DateFormatter());\n    }\n}"
    },
    {
      "id": 75,
      "question": "What is Spring Validation with JSR-380?",
      "answer": "Bean Validation (JSR-380):\n\nAnnotations:\n• @NotNull, @NotEmpty, @NotBlank\n• @Size, @Min, @Max\n• @Email, @Pattern\n• @Valid (nested)\n\nUsage:\n• @Valid @RequestBody\n• Method validation\n• Custom validators\n\nSpring Boot auto-configures.",
      "explanation": "JSR-380 = validation standard. @Valid triggers validation. MethodArgumentNotValidException on error. Custom @Constraint for complex validation.",
      "difficulty": "Medium",
      "code": "public class UserDto {\n    @NotBlank\n    @Size(min=3, max=50)\n    private String name;\n    \n    @Email\n    private String email;\n    \n    @Min(18)\n    private Integer age;\n    \n    @Valid\n    private Address address;\n}\n\n@RestController\npublic class Controller {\n    @PostMapping(\"/users\")\n    public User create(@Valid @RequestBody UserDto dto) {\n        return userService.create(dto);\n    }\n}\n\n// Custom validator\n@Constraint(validatedBy = AgeValidator.class)\npublic @interface Adult {\n    String message() default \"Must be adult\";\n}\n\npublic class AgeValidator \n        implements ConstraintValidator<Adult, Integer> {\n    @Override\n    public boolean isValid(Integer age, ConstraintValidatorContext ctx) {\n        return age != null && age >= 18;\n    }\n}"
    },
    {
      "id": 76,
      "question": "What is Spring Task Execution and Scheduling?",
      "answer": "Execute tasks asynchronously and schedule:\n\n@Async:\n• Async execution\n• Thread pool\n• Future/CompletableFuture\n\n@Scheduled:\n• Fixed rate/delay\n• Cron expressions\n• Timezone support\n\nEnable with @EnableAsync, @EnableScheduling.",
      "explanation": "@Async runs in background thread. @Scheduled runs periodically. Configure thread pool. @Async returns Future. @Scheduled void or result ignored.",
      "difficulty": "Medium",
      "code": "@Configuration\n@EnableAsync\n@EnableScheduling\npublic class TaskConfig {\n    @Bean\n    public TaskExecutor taskExecutor() {\n        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n        executor.setCorePoolSize(5);\n        executor.setMaxPoolSize(10);\n        executor.setQueueCapacity(25);\n        executor.initialize();\n        return executor;\n    }\n}\n\n@Service\npublic class AsyncService {\n    @Async\n    public CompletableFuture<String> process() {\n        // Runs in thread pool\n        return CompletableFuture.completedFuture(\"Done\");\n    }\n}\n\n@Component\npublic class ScheduledTasks {\n    @Scheduled(fixedRate = 5000)\n    public void task1() {\n        // Every 5 seconds\n    }\n    \n    @Scheduled(cron = \"0 0 2 * * ?\")\n    public void task2() {\n        // Daily at 2 AM\n    }\n}"
    },
    {
      "id": 77,
      "question": "What is Spring Boot DevTools?",
      "answer": "DevTools improves development experience:\n\nFeatures:\n• Auto-restart on changes\n• LiveReload\n• Disable caching\n• Remote debugging\n\nDevelopment only (auto-disabled in production).\n\nSpeeds development cycle.",
      "explanation": "DevTools = faster development. Auto-restart when code changes. Disable template caching. LiveReload browser. Add dependency, works automatically.",
      "difficulty": "Easy",
      "code": "// build.gradle\ndevelopmentOnly 'org.springframework.boot:spring-boot-devtools'\n\n// pom.xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-devtools</artifactId>\n    <optional>true</optional>\n</dependency>\n\n// Features enabled automatically:\n// - Auto-restart\n// - LiveReload\n// - Template cache disabled\n// - H2 console enabled\n\n// Exclude patterns\nspring.devtools.restart.exclude=static/**,public/**\n\n// Trigger files\nspring.devtools.restart.trigger-file=.reloadtrigger"
    },
    {
      "id": 78,
      "question": "What is Spring Boot CommandLineRunner and ApplicationRunner?",
      "answer": "Run code after startup:\n\nCommandLineRunner:\n• String[] args\n• Raw arguments\n\nApplicationRunner:\n• ApplicationArguments\n• Parsed options\n\nBoth @Component or @Bean.\n\nUse for initialization tasks.",
      "explanation": "CommandLineRunner/ApplicationRunner = execute after app starts. Load data, check config, print info. ApplicationRunner better API (parsed args).",
      "difficulty": "Easy",
      "code": "@Component\npublic class DataLoader implements CommandLineRunner {\n    @Override\n    public void run(String... args) {\n        System.out.println(\"Loading data...\");\n        // Load initial data\n    }\n}\n\n@Component\npublic class StartupTask implements ApplicationRunner {\n    @Override\n    public void run(ApplicationArguments args) {\n        if (args.containsOption(\"debug\")) {\n            System.out.println(\"Debug mode\");\n        }\n        List<String> nonOptions = args.getNonOptionArgs();\n    }\n}\n\n// Or as @Bean\n@SpringBootApplication\npublic class App {\n    @Bean\n    public CommandLineRunner run() {\n        return args -> {\n            System.out.println(\"App started!\");\n        };\n    }\n}\n\n// Order multiple runners\n@Component\n@Order(1)\npublic class First implements CommandLineRunner {}\n\n@Component\n@Order(2)\npublic class Second implements CommandLineRunner {}"
    },
    {
      "id": 79,
      "question": "What is Spring Boot Logging?",
      "answer": "Spring Boot configures logging:\n\nDefault: Logback\nSupports: Log4j2, JUL\n\nLevels:\n• TRACE, DEBUG, INFO, WARN, ERROR\n\nConfiguration:\n• logging.level.{package}=DEBUG\n• logging.file.name\n• logging.pattern\n\nUse SLF4J API.",
      "explanation": "Logback default. Use SLF4J in code. Configure levels in application.properties. logging.level.root=INFO. Per-package levels. File/console output.",
      "difficulty": "Easy",
      "code": "// Use SLF4J\n@Service\npublic class UserService {\n    private static  final Logger log = LoggerFactory.getLogger(UserService.class);\n    \n    public void create(User user) {\n        log.debug(\"Creating user: {}\", user);\n        log.info(\"User created: {}\", user.getId());\n        log.warn(\"Duplicate email: {}\", user.getEmail());\n        log.error(\"Failed to create user\", exception);\n    }\n}\n\n// Or Lombok\n@Service\n@Slf4j\npublic class Service {\n    public void method() {\n        log.info(\"Message\");\n    }\n}\n\n# application.properties\nlogging.level.root=INFO\nlogging.level.com.example=DEBUG\nlogging.level.org.springframework.web=DEBUG\n\nlogging.file.name=app.log\nlogging.file.path=/var/log\n\nlogging.pattern.console=%d{HH:mm:ss} %-5level %logger{36} - %msg%n\n\n// logback-spring.xml\n<configuration>\n    <springProfile name=\"dev\">\n        <logger name=\"com.example\" level=\"DEBUG\"/>\n    </springProfile>\n    <springProfile name=\"prod\">\n        <logger name=\"com.example\" level=\"WARN\"/>\n    </springProfile>\n</configuration>"
    },
    {
      "id": 80,
      "question": "What is Spring Boot Banner?",
      "answer": "Banner displays at startup:\n\nCustomization:\n• banner.txt in src/main/resources\n• ASCII art\n• Variables ${application.version}\n• Programmatic\n• Disable with Mode.OFF\n\nPurely cosmetic feature.",
      "explanation": "Banner = startup logo. Create banner.txt with ASCII art. Variables for version info. spring.main.banner-mode=off to disable. Fun but optional.",
      "difficulty": "Easy",
      "code": "// src/main/resources/banner.txt\n  __  __                              \n |  \\/  |_   _     /\\   _ __  _ __  \n | |\\/| | | | |   /  \\ | '_ \\| '_ \\ \n | |  | | |_| |  / /\\ \\| |_) | |_) |\n |_|  |_|\\__, | /_/  \\_\\ .__/| .__/ \n         |___/         |_|   |_|    \n\nVersion: ${application.version}\nSpring Boot: ${spring-boot.version}\nRunning on: ${os.name}\n\n// Disable\n# application.properties\nspring.main.banner-mode=off\n\n// Programmatic\n@SpringBootApplication\npublic class App {\n    public static void main(String[] args) {\n        SpringApplication app = new SpringApplication(App.class);\n        app.setBannerMode(Banner.Mode.OFF);\n        app.run(args);\n    }\n}"
    },
    {
      "id": 81,
      "question": "What is Spring Boot Embedded Servers?",
      "answer": "Spring Boot embeds web servers:\n\nDefault: Tomcat\nAlternatives: Jetty, Undertow\n\nBenefits:\n• No external server\n• JAR packaging\n• Easy deployment\n• Configuration in properties\n\nSwitch servers by dependencies.",
      "explanation": "Embedded server = server inside JAR. No Tomcat installation needed. java -jar runs app with embedded Tomcat. Switch to Jetty by changing dependency.",
      "difficulty": "Easy",
      "code": "// Default Tomcat\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n}\n\n// Switch to Jetty\ndependencies {\n    implementation('org.springframework.boot:spring-boot-starter-web') {\n        exclude group: 'org.springframework.boot', \n                module: 'spring-boot-starter-tomcat'\n    }\n    implementation 'org.springframework.boot:spring-boot-starter-jetty'\n}\n\n// Switch to Undertow\ndependencies {\n    implementation('org.springframework.boot:spring-boot-starter-web') {\n        exclude group: 'org.springframework.boot', \n                module: 'spring-boot-starter-tomcat'\n    }\n    implementation 'org.springframework.boot:spring-boot-starter-undertow'\n}\n\n# Configuration\nserver.port=8080\nserver.servlet.context-path=/api\nserver.compression.enabled=true\nserver.tomcat.max-threads=200"
    },
    {
      "id": 82,
      "question": "What is Spring Boot Fat JAR?",
      "answer": "Fat JAR contains everything:\n\nContents:\n• Application code\n• All dependencies\n• Embedded server\n• Configuration\n\nOne JAR to run.\n\nBuilt by spring-boot-maven-plugin.",
      "explanation": "Fat JAR = executable JAR with all dependencies. java -jar app.jar runs everything. No classpath needed. Simplified deployment.",
      "difficulty": "Easy",
      "code": "// build.gradle\nplugins {\n    id 'org.springframework.boot' version '3.2.0'\n}\n\n// pom.xml\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n    </plugins>\n</build>\n\n// Build\n./mvnw clean package\n./gradlew bootJar\n\n// Run\njava -jar target/app-1.0.0.jar\n\n// JAR structure\napp.jar\n├── BOOT-INF/\n│   ├── classes/  (your code)\n│   └── lib/  (dependencies)\n├── META-INF/\n└── org/springframework/boot/loader/"
    },
    {
      "id": 83,
      "question": "What is Spring Boot Externalized Configuration?",
      "answer": "Configuration from external sources:\n\nSources (precedence):\n1. Command line\n2. Java system properties\n3. OS environment variables\n4. application-{profile}.properties\n5. application.properties\n\nFlexible deployment without rebuild.",
      "explanation": "Externalized config = configure without recompiling. Override properties via environment, command line. 12-factor app principle. Deploy same JAR to dev/prod.",
      "difficulty": "Medium",
      "code": "# application.properties\nserver.port=8080\ndb.url=jdbc:h2:mem:db\n\n# application-prod.properties\nserver.port=80\ndb.url=jdbc:postgresql://prod-db/mydb\n\n// Environment variable\nexport SERVER_PORT=9090\nexport DB_URL=jdbc:postgresql://localhost/db\n\n// Command line\njava -jar app.jar --server.port=7070 --db.url=jdbc:...\n\n// System property\njava -Dserver.port=6060 -jar app.jar\n\n// Access in code\n@Value(\"${server.port}\")\nprivate int port;\n\n@Value(\"${db.url}\")\nprivate String dbUrl;\n\n// Precedence example\n# application.properties: port=8080\n# ENV: SERVER_PORT=9090\n# CMD: --server.port=7070\n// Result: 7070 (command line wins)"
    },
    {
      "id": 84,
      "question": "What is Spring Boot @ConditionalOnProperty?",
      "answer": "@ConditionalOnProperty creates bean based on property:\n\nAttributes:\n• name: Property name\n• havingValue: Expected value\n• matchIfMissing: Default if absent\n\nFeature flags, conditional configuration.",
      "explanation": "@ConditionalOnProperty = create bean if property matches. Great for feature flags. Enable/disable features via properties.",
      "difficulty": "Medium",
      "code": "@Configuration\npublic class FeatureConfig {\n    \n    @Bean\n    @ConditionalOnProperty(\n        name = \"feature.analytics.enabled\",\n        havingValue = \"true\"\n    )\n    public AnalyticsService analyticsService() {\n        return new AnalyticsService();\n    }\n    \n    @Bean\n    @ConditionalOnProperty(\n        name = \"feature.cache.enabled\",\n        havingValue = \"true\",\n        matchIfMissing = true  // Default true if missing\n    )\n    public CacheManager cacheManager() {\n        return new ConcurrentMapCacheManager();\n    }\n}\n\n# application.properties\nfeature.analytics.enabled=true\nfeature.cache.enabled=false"
    },
    {
      "id": 85,
      "question": "What is Spring Boot Relaxed Binding?",
      "answer": "Relaxed binding maps property variations:\n\nFormats:\n• camelCase: myProperty\n• kebab-case: my-property\n• snake_case: my_property\n• UPPER_SNAKE: MY_PROPERTY\n\nAll map to same field.\n\nEnvironment variables use UPPER_SNAKE.",
      "explanation": "Relaxed binding = flexible property names. my-property, myProperty, MY_PROPERTY all same. Environment variables auto-convert. Convenient deployment.",
      "difficulty": "Easy",
      "code": "@ConfigurationProperties(prefix = \"app\")\npublic class AppProperties {\n    private String myProperty;\n    // All these work:\n    // app.my-property=value\n    // app.myProperty=value\n    // app.my_property=value\n    // APP_MY_PROPERTY=value (env)\n}\n\n# All equivalent\napp.my-property=value\napp.myProperty=value\napp.my_property=value\n\n// Environment variable\nexport APP_MY_PROPERTY=value\n\n// List relaxed binding\napp.servers[0]=server1\napp.servers[1]=server2\n\nAPP_SERVERS_0=server1\nAPP_SERVERS_1=server2"
    },
    {
      "id": 86,
      "question": "What is Spring Boot Configuration Metadata?",
      "answer": "Metadata provides IDE autocomplete:\n\nGenerated:\n• spring-configuration-metadata.json\n• From @ConfigurationProperties\n• Property descriptions\n• Default values\n• Deprecation info\n\nEnhances IDE experience.",
      "explanation": "Configuration metadata = IDE autocomplete for properties. Generated from @ConfigurationProperties. Shows available properties, types, descriptions in IDE.",
      "difficulty": "Easy",
      "code": "// Add processor\ndependencies {\n    annotationProcessor \n        'org.springframework.boot:spring-boot-configuration-processor'\n}\n\n@ConfigurationProperties(prefix = \"app\")\npublic class AppProperties {\n    /**\n     * Application name\n     */\n    private String name = \"MyApp\";\n    \n    /**\n     * Connection timeout in milliseconds\n     */\n    private int timeout = 5000;\n}\n\n// Generated metadata\n// target/classes/META-INF/spring-configuration-metadata.json\n{\n  \"properties\": [\n    {\n      \"name\": \"app.name\",\n      \"type\": \"java.lang.String\",\n      \"description\": \"Application name\",\n      \"defaultValue\": \"MyApp\"\n    }\n  ]\n}"
    },
    {
      "id": 87,
      "question": "What is Spring Boot Custom Starter?",
      "answer": "Create custom starter for reusable configuration:\n\nComponents:\n• Autoconfiguration class\n• @ConfigurationProperties\n• spring.factories\n• Starter POM\n\nPackage reusable functionality.",
      "explanation": "Custom starter = reusable auto-configuration. Package library + config. Add dependency, auto-configures. Great for company-wide standards.",
      "difficulty": "Hard",
      "code": "// my-spring-boot-starter\n// MyAutoConfiguration.java\n@Configuration\n@ConditionalOnClass(MyService.class)\n@EnableConfigurationProperties(MyProperties.class)\npublic class MyAutoConfiguration {\n    \n    @Bean\n    @ConditionalOnMissingBean\n    public MyService myService(MyProperties properties) {\n        return new MyServiceImpl(properties);\n    }\n}\n\n// MyProperties.java\n@ConfigurationProperties(prefix = \"my.service\")\npublic class MyProperties {\n    private String apiKey;\n    private int timeout = 5000;\n    // getters/setters\n}\n\n// src/main/resources/META-INF/spring.factories\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\ncom.example.MyAutoConfiguration\n\n// pom.xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>com.example</groupId>\n        <artifactId>my-library</artifactId>\n    </dependency>\n</dependencies>\n\n// Usage\ndependencies {\n    implementation 'com.example:my-spring-boot-starter:1.0.0'\n}\n\n# application.properties\nmy.service.api-key=abc123\nmy.service.timeout=10000"
    },
    {
      "id": 88,
      "question": "What is Spring Boot Testing Slices?",
      "answer": "Test slices load minimal context:\n\n@WebMvcTest:\n• Controllers only\n• MockMvc\n\n@DataJpaTest:\n• JPA repositories\n• In-memory DB\n\n@JsonTest:\n• JSON serialization\n\nFaster than @SpringBootTest.",
      "explanation": "Test slices = focused tests. Load only needed beans. @WebMvcTest for controllers, @DataJpaTest for repos. Much faster than full context.",
      "difficulty": "Medium",
      "code": "@WebMvcTest(UserController.class)\nclass UserControllerTest {\n    @Autowired\n    private MockMvc mockMvc;\n    \n    @MockBean\n    private UserService userService;\n    \n    @Test\n    void testGetUser() throws Exception {\n        mockMvc.perform(get(\"/users/1\"))\n            .andExpect(status().isOk());\n    }\n}\n\n@DataJpaTest\nclass UserRepositoryTest {\n    @Autowired\n    private UserRepository repository;\n    \n    @Autowired\n    private TestEntityManager entityManager;\n    \n    @Test\n    void testFindByEmail() {\n        User user = new User(\"test@example.com\");\n        entityManager.persist(user);\n        \n        User found = repository.findByEmail(\"test@example.com\");\n        assertNotNull(found);\n    }\n}\n\n@JsonTest\nclass UserJsonTest {\n    @Autowired\n    private JacksonTester<User> json;\n    \n    @Test\n    void testSerialize() throws Exception {\n        User user = new User(\"John\");\n        assertThat(json.write(user))\n            .extractingJsonPathStringValue(\"$.name\")\n            .isEqualTo(\"John\");\n    }\n}"
    },
    {
      "id": 89,
      "question": "What is Spring Boot @TestConfiguration?",
      "answer": "@TestConfiguration provides test-specific beans:\n\nFeatures:\n• Test-only configuration\n• Override production beans\n• Mock services\n• Test data\n\n@Import or auto-detected.",
      "explanation": "@TestConfiguration = config for tests only. Override production beans with mocks. Provide test data. Not loaded in production.",
      "difficulty": "Easy",
      "code": "@TestConfiguration\npublic class TestConfig {\n    \n    @Bean\n    @Primary  // Override production bean\n    public EmailService mockEmailService() {\n        return Mockito.mock(EmailService.class);\n    }\n    \n    @Bean\n    public TestDataLoader testDataLoader() {\n        return new TestDataLoader();\n    }\n}\n\n@SpringBootTest\n@Import(TestConfig.class)\nclass ServiceTest {\n    @Autowired\n    private EmailService emailService;  // Gets mock\n    \n    @Autowired\n    private TestDataLoader dataLoader;\n}\n\n// Auto-detected (same package)\n@SpringBootTest\nclass UserServiceTest {\n    // TestConfig auto-detected\n}"
    },
    {
      "id": 90,
      "question": "What is Spring Boot @MockBean vs @SpyBean?",
      "answer": "Both modify beans in tests:\n\n@MockBean:\n• Complete mock\n• All methods stubbed\n• Replaces real bean\n\n@SpyBean:\n• Partial mock\n• Real methods unless stubbed\n• Wraps real bean\n\nUse @MockBean usually, @SpyBean rarely.",
      "explanation": "@MockBean = full mock (all methods mocked). @SpyBean = real bean, mock some methods. @MockBean more common. @SpyBean when need real behavior mostly.",
      "difficulty": "Medium",
      "code": "@SpringBootTest\nclass UserServiceTest {\n    \n    @MockBean\n    private UserRepository repository;\n    \n    @Autowired\n    private UserService service;\n    \n    @Test\n    void test() {\n        // All repository methods mocked\n        when(repository.findById(1L))\n            .thenReturn(Optional.of(new User()));\n    }\n}\n\n@SpringBootTest\nclass EmailServiceTest {\n    \n    @SpyBean\n    private EmailService emailService;\n    \n    @Test\n    void test() {\n        // Real methods execute\n        emailService.send(\"test@example.com\", \"Hi\");\n        \n        // Mock specific method\n        doReturn(true).when(emailService).isValid(any());\n        \n        // isValid() mocked, other methods real\n    }\n}"
    },
    {
      "id": 91,
      "question": "What are Spring Best Practices?",
      "answer": "Spring best practices:\n\n• Constructor injection\n• Avoid field injection\n• Use interfaces\n• Keep beans stateless\n• Avoid @Autowired on fields\n• Use @RequiredArgsConstructor\n• Proper layering\n• Test-driven development\n• Profile-specific configs\n• Externalize configuration",
      "explanation": "Constructor injection better than field. Immutable, testable. Use interfaces for loose coupling. Stateless beans thread-safe. Profile per environment.",
      "difficulty": "Easy",
      "code": "// Good: Constructor injection\n@Service\npublic class UserService {\n    private final UserRepository repository;\n    private final EmailService emailService;\n    \n    public UserService(UserRepository repository, \n                      EmailService emailService) {\n        this.repository = repository;\n        this.emailService = emailService;\n    }\n}\n\n// Better with Lombok\n@Service\n@RequiredArgsConstructor\npublic class UserService {\n    private final UserRepository repository;\n    private final EmailService emailService;\n}\n\n// Bad: Field injection\n@Service\npublic class UserService {\n    @Autowired  // Avoid\n    private UserRepository repository;\n}\n\n// Good: Interface-based\npublic interface EmailService {\n    void send(String to, String msg);\n}\n\n@Service\npublic class SmtpEmailService implements EmailService {}\n\n// Good: Stateless\n@Service\npublic class Service {\n   // NO instance variables!\n    public void process(Data data) {}\n}\n\n// Bad: Stateful\n@Service\npublic class Service {\n    private int counter;  // NOT thread-safe!\n}"
    },
    {
      "id": 92,
      "question": "What are common Spring pitfalls?",
      "answer": "Common Spring mistakes:\n\n• Circular dependencies\n• N+1 query problem\n• Stateful beans\n• Forgetting @Transactional\n• Wrong scope (prototype in singleton)\n• Self-invocation (@Transactional)\n• Lazy loading outside transaction\n• Too many beans in test\n• Not closing resources",
      "explanation": "Circular deps = design issue. N+1 = fetch joins needed. Stateful beans = concurrency bugs. Self-call bypasses proxy. Test slices faster.",
      "difficulty": "Medium",
      "code": "// Circular dependency\n@Service\npublic class A {\n    @Autowired\n    private B b;\n}\n\n@Service  \npublic class B {\n    @Autowired\n    private A a;  // Circular!\n}\n// Fix: Constructor injection, redesign\n\n// N+1 problem\n@Entity\npublic class User {\n    @OneToMany\n    private List<Order> orders;  // Lazy\n}\n\nList<User> users = userRepo.findAll();\nusers.forEach(u -> u.getOrders().size());  // N+1!\n// Fix: @EntityGraph, JOIN FETCH\n\n// Self-invocation\n@Service\npublic class Service {\n    @Transactional\n    public void method1() {}\n    \n    public void method2() {\n        this.method1();  // NO transaction!\n    }\n}\n// Fix: Inject self, separate service\n\n// Stateful bean\n@Service\npublic class Service {\n    private List<String> data = new ArrayList<>();  // Shared!\n    \n    public void add(String item) {\n        data.add(item);  // NOT thread-safe!\n    }\n}\n// Fix: Method parameters, ThreadLocal, prototype scope"
    },
    {
      "id": 93,
      "question": "What is Spring Framework vs Spring Boot?",
      "answer": "Spring Framework vs Spring Boot:\n\nSpring Framework:\n• Core IoC, DI, AOP\n• Manual configuration\n• XML/Java config\n• Choose dependencies\n• More control\n\nSpring Boot:\n• Built on Spring\n• Auto-configuration\n• Starters\n• Embedded servers\n• Production-ready\n• Opinionated defaults\n\nBoot simplifies Spring.",
      "explanation": "Spring Framework = foundation (IoC, AOP). Spring Boot = simplified Spring (auto-config, starters, embedded server). Boot for new projects.",
      "difficulty": "Easy",
      "code": "// Spring Framework\n@Configuration\n@EnableWebMvc\n@ComponentScan\npublic class WebConfig implements WebMvcConfigurer {\n    @Bean\n    public DataSource dataSource() {\n        HikariDataSource ds = new HikariDataSource();\n        ds.setJdbcUrl(\"...\");\n        ds.setUsername(\"...\");\n        // Manual configuration\n        return ds;\n    }\n    \n    @Bean\n    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {\n        // Configure Entity Manager\n    }\n}\n\n// Spring Boot\n@SpringBootApplication\npublic class App {\n    public static void main(String[] args) {\n        SpringApplication.run(App.class, args);\n    }\n}\n\n# application.properties\nspring.datasource.url=jdbc:postgresql://localhost/db\nspring.datasource.username=user\nspring.datasource.password=pass\n// Auto-configured!"
    },
    {
      "id": 94,
      "question": "What is Spring Cloud?",
      "answer": "Spring Cloud for microservices:\n\nComponents:\n• Config Server: Centralized config\n• Eureka: Service discovery\n• Gateway: API gateway\n• Circuit Breaker: Fault tolerance\n• Load Balancer\n• Distributed tracing\n\nBuilt on Spring Boot.\n\nMicroservices patterns implementation.",
      "explanation": "Spring Cloud = microservices toolkit. Config server, service discovery, API gateway, circuit breaker. Patterns like Config, Discovery, Gateway.",
      "difficulty": "Easy",
      "code": "// Config Server\n@SpringBootApplication\n@EnableConfigServer\npublic class ConfigServerApp {}\n\n// Service Discovery\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class ServiceApp {}\n\n// API Gateway\n@SpringBootApplication\npublic class GatewayApp {}\n\nspring:\n  cloud:\n    gateway:\n      routes:\n        - id: user-service\n          uri: lb://USER-SERVICE\n          predicates:\n            - Path=/users/**\n\n// Circuit Breaker\n@RestController\npublic class Controller {\n    @GetMapping(\"/users\")\n    @CircuitBreaker(name = \"user-service\", \n                   fallbackMethod = \"fallback\")\n    public List<User> getUsers() {\n        return restTemplate.getForObject(\n            \"http://user-service/users\", List.class);\n    }\n    \n    public List<User> fallback(Exception e) {\n        return Collections.emptyList();\n    }\n}"
    },
    {
      "id": 95,
      "question": "What are Spring Annotations categories?",
      "answer": "Spring annotations by category:\n\nStereotype:\n• @Component, @Service, @Repository\n• @Controller, @RestController\n\nConfiguration:\n• @Configuration, @Bean\n• @Import, @ComponentScan\n\nDependency Injection:\n• @Autowired, @Qualifier\n• @Value, @Primary\n\nWeb:\n• @RequestMapping, @GetMapping\n• @RequestBody, @PathVariable\n\nData:\n• @Entity, @Table\n• @Transactional\n\nTesting:\n• @SpringBootTest\n• @MockBean, @WebMvcTest",
      "explanation": "Stereotypes create beans. Configuration defines beans. Injection wires dependencies. Web handle requests. Data manage persistence. Testing test components.",
      "difficulty": "Easy",
      "code": "// Stereotype\n@Component\n@Service  \n@Repository\n@Controller\n@RestController\n\n// Configuration\n@Configuration\n@Bean\n@ComponentScan\n@Import\n\n// Dependency Injection\n@Autowired\n@Qualifier\n@Value\n@Primary\n@Lazy\n\n// Web\n@RequestMapping\n@GetMapping\n@PostMapping\n@RequestBody\n@PathVariable\n@RequestParam\n\n// Data\n@Entity\n@Table\n@Transactional\n@Query\n\n// AOP\n@Aspect\n@Before\n@After\n@Around\n\n// Testing\n@SpringBootTest\n@WebMvcTest\n@DataJpaTest\n@MockBean\n@SpyBean"
    },
    {
      "id": 96,
      "question": "What is Spring Security basics?",
      "answer": "Spring Security secures applications:\n\nFeatures:\n• Authentication\n• Authorization\n• CSRF protection\n• Session management\n• Password encoding\n• Remember-me\n• OAuth2/JWT\n\nFilter-based architecture.\n\nHighly customizable.",
      "explanation": "Spring Security = authentication + authorization. Filter chain intercepts requests. Configure via SecurityFilterChain. BCrypt passwords. Role-based access.",
      "difficulty": "Medium",
      "code": "// Basic setup\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-security'\n}\n\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) \n            throws Exception {\n        http\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/public/**\").permitAll()\n                .requestMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n                .anyRequest().authenticated()\n            )\n            .formLogin(Customizer.withDefaults())\n            .httpBasic(Customizer.withDefaults());\n        return http.build();\n    }\n    \n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n    \n    @Bean\n    public UserDetailsService userDetailsService() {\n        UserDetails user = User.builder()\n            .username(\"user\")\n            .password(passwordEncoder().encode(\"password\"))\n            .roles(\"USER\")\n            .build();\n        \n        UserDetails admin = User.builder()\n            .username(\"admin\")\n            .password(passwordEncoder().encode(\"admin\"))\n            .roles(\"ADMIN\")\n            .build();\n        \n        return new InMemoryUserDetailsManager(user, admin);\n    }\n}\n\n// Method security\n@EnableMethodSecurity\n@Configuration\npublic class MethodSecurityConfig {}\n\n@Service\npublic class Service {\n    @PreAuthorize(\"hasRole('ADMIN')\")\n    public void adminOnly() {}\n    \n    @PreAuthorize(\"#username == authentication.name\")\n    public void ownerOnly(String username) {}\n}"
    },
    {
      "id": 97,
      "question": "What are Spring Boot Production Features?",
      "answer": "Spring Boot production features:\n\n• Actuator: Monitoring\n• Metrics: Prometheus, Micrometer\n• Health checks\n• Graceful shutdown\n• External configuration\n• Logging\n• Distributed tracing\n• Security\n• Docker support\n• Cloud-native\n\nProduction-ready out of box.",
      "explanation": "Actuator = monitoring endpoints. Metrics for dashboards. Health for load balancers. Graceful shutdown. All essential for production. Enable and secure.",
      "difficulty": "Medium",
      "code": "// Actuator\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-actuator'\n}\n\n# application.properties\nmanagement.endpoints.web.exposure.include=health,info,metrics\nmanagement.endpoint.health.show-details=always\n\n// Graceful shutdown\nserver.shutdown=graceful\nspring.lifecycle.timeout-per-shutdown-phase=30s\n\n// Metrics\n@Service\npublic class Service {\n    private final Counter counter;\n    \n    public Service(MeterRegistry registry) {\n        this.counter = registry.counter(\"my.metric\");\n    }\n    \n    public void process() {\n        counter.increment();\n    }\n}\n\n// Docker\nFROM openjdk:17-slim\nCOPY target/app.jar app.jar\nEXPOSE 8080\nENTRYPOINT [\"java\", \"-jar\", \"/app.jar\"]\n\n// Health check\n@Component\npublic class CustomHealthIndicator implements HealthIndicator {\n    @Override\n    public Health health() {\n        return Health.up()\n            .withDetail(\"status\", \"OK\")\n            .build();\n    }\n}"
    },
    {
      "id": 98,
      "question": "What is Spring Boot vs Spring MVC?",
      "answer": "Spring Boot vs Spring MVC:\n\nSpring MVC:\n• Web framework\n• Part of Spring Framework\n• Controllers, views\n• Manual configuration\n\nSpring Boot:\n• Application framework\n• Includes Spring MVC\n• Auto-configuration\n• Embedded server\n• Complete stack\n\nBoot contains MVC.",
      "explanation": "Spring MVC = web layer (controllers, REST). Spring Boot = full application framework (includes MVC + more). Boot auto-configures MVC.",
      "difficulty": "Easy",
      "code": "// Spring MVC (without Boot)\n@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n    // Manual configuration\n}\n\n@Controller\npublic class MyController {\n    @RequestMapping(\"/hello\")\n    public String hello() {\n        return \"hello\";\n    }\n}\n\n// Spring Boot with MVC\n@SpringBootApplication\npublic class App {}\n\n@RestController\npublic class MyController {\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello\";\n    }\n}\n// MVC auto-configured!"
    },
    {
      "id": 99,
      "question": "What are Spring Framework Design Patterns?",
      "answer": "Spring uses design patterns:\n\n• Dependency Injection: IoC\n• Factory: BeanFactory\n• Singleton: Default scope\n• Prototype: Bean scope\n• Proxy: AOP, @Transactional\n• Template: JdbcTemplate, RestTemplate\n• Front Controller: DispatcherServlet\n• MVC: Web framework\n• Observer: Event listeners\n• Strategy: Multiple implementations",
      "explanation": "Spring built on patterns. IoC = DI pattern. BeanFactory = Factory. AOP = Proxy. DispatcherServlet = Front Controller. JdbcTemplate = Template Method.",
      "difficulty": "Medium",
      "code": "// Singleton (default)\n@Service\npublic class SingletonService {}  // One instance\n\n// Prototype\n@Service\n@Scope(\"prototype\")\npublic class PrototypeService {}  // New each time\n\n// Factory\nApplicationContext context = ...;\nUserService service = context.getBean(UserService.class);\n\n// Template\nJdbcTemplate template = new JdbcTemplate(dataSource);\ntemplate.query(sql, rowMapper);\n\n// Proxy\n@Service\npublic class Service {\n    @Transactional  // Creates proxy\n    public void method() {}\n}\n\n// Strategy\npublic interface PaymentStrategy {}\n\n@Service\npublic class CreditCardPayment implements PaymentStrategy {}\n\n@Service\npublic class PayPalPayment implements PaymentStrategy {}\n\n@Service\npublic class PaymentService {\n    @Autowired\n    private List<PaymentStrategy> strategies;\n}\n\n// Observer\n@Component\npublic class Listener {\n    @EventListener\n    public void handle(UserCreatedEvent event) {}\n}"
    },
    {
      "id": 100,
      "question": "What is future of Spring Framework?",
      "answer": "Spring Framework evolving:\n\nTrends:\n• Native compilation (GraalVM)\n• Reactive programming\n• Cloud-native\n• Kubernetes integration\n• Serverless support\n• Improved startup time\n• Reduced memory footprint\n• AOT compilation\n• Virtual threads (Java 21)\n• Observability\n\nSpring continues leading Java.",
      "explanation": "Spring embracing cloud-native, reactive, GraalVM. Native images for faster startup. Virtual threads for scalability. Kubernetes first-class. Modern Java features.",
      "difficulty": "Easy",
      "code": "// Native image\n./mvnw -Pnative native:compile\n// Fast startup, low memory\n\n// Reactive\n@RestController\npublic class ReactiveController {\n    @GetMapping(\"/users\")\n    public Flux<User> getUsers() {\n        return userService.findAll();\n    }\n}\n\n// Virtual threads (Java 21+)\nspring.threads.virtual.enabled=true\n\n// Observability\nmanagement.tracing.enabled=true\nmanagement.metrics.export.prometheus.enabled=true\n\n// Kubernetes\nspring.cloud.kubernetes.discovery.enabled=true\nspring.cloud.kubernetes.config.enabled=true\n\n// AOT (Ahead-of-Time)\n./mvnw spring-boot:process-aot\n// Faster startup in production"
    }
  ]
}
