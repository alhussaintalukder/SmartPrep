{
  "topic": "Spring Security",
  "questions": [
    {
      "id": 1,
      "question": "What is Spring Security and why is it used?",
      "answer": "Spring Security is a powerful and highly customizable authentication and access-control framework for Java applications.\n\nKey features:\n• Authentication - Verifying user identity\n• Authorization - Controlling access to resources\n• Protection against common attacks (CSRF, XSS, Session Fixation)\n• Integration with various authentication mechanisms\n• Method-level security\n• Password encryption\n• Remember-me services\n• Session management",
      "explanation": "Spring Security is the de-facto standard for securing Spring applications. It provides comprehensive security services and is highly extensible.",
      "difficulty": "Easy"
    },
    {
      "id": 2,
      "question": "What is the difference between Authentication and Authorization?",
      "answer": "Authentication: 'Who are you?'\n• Verifying the identity of a user\n• Checking credentials (username/password, tokens, certificates)\n• Happens first in the security flow\n\nAuthorization: 'What can you do?'\n• Determining what an authenticated user can access\n• Checking permissions and roles\n• Happens after authentication",
      "explanation": "Authentication proves identity, authorization grants permissions. You can't authorize someone until they're authenticated.",
      "difficulty": "Easy",
      "code": "@PreAuthorize(\"hasRole('ADMIN')\")\npublic void deleteUser(Long id) {\n    userRepository.deleteById(id);\n}"
    },
    {
      "id": 3,
      "question": "Explain the Spring Security Architecture and its core components.",
      "answer": "Core components:\n\n1. SecurityContext: Holds security information\n2. SecurityContextHolder: Provides access to SecurityContext\n3. Authentication: Represents authenticated user\n4. GrantedAuthority: Permissions granted to user\n5. UserDetails: User information\n6. UserDetailsService: Loads user-specific data\n7. AuthenticationManager: Processes authentication\n8. AuthenticationProvider: Performs authentication\n9. FilterChainProxy: Security filter chain",
      "explanation": "Spring Security uses filters to intercept requests and apply security rules. The architecture is modular and extensible.",
      "difficulty": "Medium",
      "code": "Authentication auth = SecurityContextHolder.getContext().getAuthentication();\nString username = auth.getName();"
    },
    {
      "id": 4,
      "question": "How do you configure Spring Security in Spring Boot?",
      "answer": "Configuration steps:\n\n1. Add dependency: spring-boot-starter-security\n2. Create SecurityConfig class\n3. Define SecurityFilterChain bean\n4. Configure authentication and authorization\n\nDefault behavior:\n• Secures all endpoints\n• Creates login page\n• Generates random password\n• Username: user",
      "explanation": "Modern Spring Security uses SecurityFilterChain bean instead of deprecated WebSecurityConfigurerAdapter.",
      "difficulty": "Easy",
      "code": "@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http.authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/public/**\").permitAll()\n                .anyRequest().authenticated()\n            ).formLogin(Customizer.withDefaults());\n        return http.build();\n    }\n}"
    },
    {
      "id": 5,
      "question": "What authentication mechanisms does Spring Security support?",
      "answer": "Common mechanisms:\n\n1. Form-based: Traditional login form\n2. HTTP Basic: Base64 credentials in header\n3. JWT: Stateless token-based\n4. OAuth2: Third-party (Google, Facebook)\n5. LDAP: Enterprise directory\n6. Remember-me: Persistent login\n7. Certificate-based: X.509 certificates\n8. SAML: Enterprise SSO\n9. Custom: AuthenticationProvider",
      "explanation": "Each mechanism suits different use cases. Form for web apps, JWT for APIs, OAuth2 for social login.",
      "difficulty": "Medium",
      "code": "http.formLogin(form -> form.loginPage(\"/login\"));\nhttp.httpBasic(Customizer.withDefaults());\nhttp.rememberMe(remember -> remember.key(\"secret\"));"
    },
    {
      "id": 6,
      "question": "What is the Spring Security Filter Chain?",
      "answer": "Filter Chain processes security for each request:\n\nKey filters:\n1. SecurityContextPersistenceFilter\n2. LogoutFilter\n3. UsernamePasswordAuthenticationFilter\n4. BasicAuthenticationFilter\n5. AnonymousAuthenticationFilter\n6. SessionManagementFilter\n7. ExceptionTranslationFilter\n8. FilterSecurityInterceptor",
      "explanation": "Filters execute in order. Each has specific responsibility. Requests pass through chain until response sent.",
      "difficulty": "Hard",
      "code": "public class CustomFilter extends OncePerRequestFilter {\n    protected void doFilterInternal(HttpServletRequest request, \n                                   HttpServletResponse response,\n                                   FilterChain filterChain) {\n        // Custom logic\n        filterChain.doFilter(request, response);\n    }\n}"
    },
    {
      "id": 7,
      "question": "How do you implement UserDetailsService?",
      "answer": "UserDetailsService loads user data:\n\nMethod:\n• loadUserByUsername(String username): Returns UserDetails\n\nApproaches:\n1. In-memory: InMemoryUserDetailsManager\n2. JDBC: JdbcUserDetailsManager\n3. Custom: Database lookup\n\nUserDetails contains:\n• Username, password\n• Authorities\n• Account status",
      "explanation": "Spring Security calls this during authentication to fetch user from database.",
      "difficulty": "Medium",
      "code": "@Service\npublic class CustomUserDetailsService implements UserDetailsService {\n    @Autowired\n    private UserRepository userRepository;\n    \n    @Override\n    public UserDetails loadUserByUsername(String username) {\n        User user = userRepository.findByUsername(username)\n            .orElseThrow(() -> new UsernameNotFoundException(username));\n        return org.springframework.security.core.userdetails.User\n            .withUsername(user.getUsername())\n            .password(user.getPassword())\n            .authorities(user.getRoles())\n            .build();\n    }\n}"
    },
    {
      "id": 8,
      "question": "Explain password encoding in Spring Security.",
      "answer": "Password encoding for security:\n\nPasswordEncoder methods:\n• encode(): Hash password\n• matches(): Verify password\n\nEncoders:\n• BCryptPasswordEncoder (RECOMMENDED)\n• Argon2PasswordEncoder\n• Pbkdf2PasswordEncoder\n• SCryptPasswordEncoder\n• NoOpPasswordEncoder (NEVER in production)",
      "explanation": "BCrypt is most popular - adaptive, built-in salt, brute-force resistant. Never store plain text passwords!",
      "difficulty": "Medium",
      "code": "@Bean\npublic PasswordEncoder passwordEncoder() {\n    return new BCryptPasswordEncoder();\n}\n\n// Usage\nString encoded = passwordEncoder.encode(rawPassword);\nboolean matches = passwordEncoder.matches(raw, encoded);"
    },
    {
      "id": 9,
      "question": "What are URL-based authorization rules in Spring Security?",
      "answer": "HTTP Security authorization:\n\nMatchers:\n• requestMatchers(): Match URLs\n• hasRole(): Check role\n• hasAuthority(): Check authority\n• hasAnyRole(): Multiple roles\n• authenticated(): Require auth\n• permitAll(): Allow all\n• denyAll(): Deny all",
      "explanation": "URL-based is simple for protecting endpoints. Configure from most specific to least specific.",
      "difficulty": "Medium",
      "code": "http.authorizeHttpRequests(auth -> auth\n    .requestMatchers(\"/public/**\").permitAll()\n    .requestMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n    .requestMatchers(\"/api/**\").hasAnyRole(\"USER\", \"ADMIN\")\n    .requestMatchers(HttpMethod.DELETE).hasRole(\"ADMIN\")\n    .anyRequest().authenticated()\n);"
    },
    {
      "id": 10,
      "question": "Explain method-level security annotations.",
      "answer": "@PreAuthorize: Before execution, supports SpEL\n@PostAuthorize: After execution, access return value\n@Secured: Simple role check, no SpEL\n@RolesAllowed: JSR-250 standard\n\nEnable with:\n@EnableMethodSecurity(prePostEnabled = true)",
      "explanation": "@PreAuthorize most flexible due to SpEL. @PostAuthorize useful when authorization depends on result.",
      "difficulty": "Medium",
      "code": "@Configuration\n@EnableMethodSecurity(prePostEnabled = true)\npublic class MethodSecurityConfig { }\n\n@Service\npublic class DocumentService {\n    @PreAuthorize(\"hasRole('ADMIN')\")\n    public void deleteDocument(Long id) { }\n    \n    @PostAuthorize(\"returnObject.owner == authentication.name\")\n    public Document getDocument(Long id) { }\n}"
    },    {
      "id": 11,
      "question": "What is CSRF protection and how does Spring Security handle it?",
      "answer": "CSRF (Cross-Site Request Forgery): Attack where malicious site tricks user into unwanted actions.\n\nProtection:\n• Generates unique token per session\n• Validates token on POST/PUT/DELETE\n• Enabled by default\n• GET/HEAD/OPTIONS don't need token\n\nWhen to disable:\n• Stateless REST APIs with JWT/OAuth2",
      "explanation": "CSRF exploits browser's automatic cookie inclusion. Token ensures request came from your app, not malicious site.",
      "difficulty": "Medium",
      "code": "// Enable (default)\nhttp.csrf(Customizer.withDefaults());\n\n// Disable for REST APIs\nhttp.csrf(csrf -> csrf.disable());\n\n// Custom configuration\nhttp.csrf(csrf -> csrf\n    .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())\n    .ignoringRequestMatchers(\"/api/public/**\")\n);\n\n// In form\n<input type=\"hidden\" th:name=\"${_csrf.parameterName}\" \n       th:value=\"${_csrf.token}\"/>"
    },
    {
      "id": 12,
      "question": "How do you configure CORS in Spring Security?",
      "answer": "CORS (Cross-Origin Resource Sharing): Allows controlled access from different domains.\n\nHeaders:\n• Access-Control-Allow-Origin\n• Access-Control-Allow-Methods\n• Access-Control-Allow-Headers\n• Access-Control-Allow-Credentials\n\nConfiguration:\n1. Global: WebMvcConfigurer\n2. Controller: @CrossOrigin\n3. Security: CorsConfigurationSource",
      "explanation": "Without CORS, browsers block JavaScript requests to different domains. CORS relaxes same-origin policy securely.",
      "difficulty": "Medium",
      "code": "@Bean\npublic CorsConfigurationSource corsConfigurationSource() {\n    CorsConfiguration config = new CorsConfiguration();\n    config.setAllowedOrigins(Arrays.asList(\"http://localhost:3000\"));\n    config.setAllowedMethods(Arrays.asList(\"GET\", \"POST\", \"PUT\", \"DELETE\"));\n    config.setAllowedHeaders(Arrays.asList(\"*\"));\n    config.setAllowCredentials(true);\n    \n    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n    source.registerCorsConfiguration(\"/**\", config);\n    return source;\n}\n\nhttp.cors(Customizer.withDefaults());"
    },
    {
      "id": 13,
      "question": "What is JWT and its structure?",
      "answer": "JWT (JSON Web Token): Compact, URL-safe token for secure information transmission.\n\nStructure: header.payload.signature\n\n• Header: Token type and algorithm\n• Payload: Claims (user data)\n• Signature: Verifies integrity\n\nAdvantages:\n• Stateless\n• Scalable\n• Cross-domain\n• Mobile-friendly\n\nFlow:\n1. User logs in\n2. Server generates JWT\n3. Client stores JWT\n4. Client includes in requests\n5. Server validates JWT",
      "explanation": "JWT is ideal for REST APIs. Token contains user info, so no database lookup needed per request.",
      "difficulty": "Hard",
      "code": "// JWT structure\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.  // Header\neyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4ifQ.  // Payload\nSflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c  // Signature\n\n// Decoded header\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n\n// Decoded payload\n{\n  \"sub\": \"1234567890\",\n  \"name\": \"John\",\n  \"iat\": 1516239022\n}"
    },
    {
      "id": 14,
      "question": "How do you implement JWT utility class?",
      "answer": "JWT Utility methods:\n\n• generateToken(): Create JWT\n• extractUsername(): Get user from token\n• extractExpiration(): Get expiry\n• validateToken(): Verify token\n• isTokenExpired(): Check expiry",
      "explanation": "Utility class centralizes JWT operations. Uses secret key for signing and verification.",
      "difficulty": "Hard",
      "code": "@Component\npublic class JwtUtil {\n    @Value(\"${jwt.secret}\")\n    private String secret;\n    \n    @Value(\"${jwt.expiration}\")\n    private Long expiration;\n    \n    public String generateToken(UserDetails userDetails) {\n        return Jwts.builder()\n            .setSubject(userDetails.getUsername())\n            .setIssuedAt(new Date())\n            .setExpiration(new Date(System.currentTimeMillis() + expiration))\n            .signWith(SignatureAlgorithm.HS512, secret)\n            .compact();\n    }\n    \n    public String extractUsername(String token) {\n        return extractClaim(token, Claims::getSubject);\n    }\n    \n    public Boolean validateToken(String token, UserDetails userDetails) {\n        String username = extractUsername(token);\n        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));\n    }\n}"
    },
    {
      "id": 15,
      "question": "How do you implement JWT authentication filter?",
      "answer": "JWT filter validates tokens:\n\nSteps:\n1. Extract JWT from header\n2. Validate token\n3. Extract username\n4. Load user details\n5. Create authentication\n6. Set in SecurityContext\n7. Continue chain",
      "explanation": "Filter runs per request. Valid JWT authenticates user without database hit (stateless).",
      "difficulty": "Hard",
      "code": "@Component\npublic class JwtAuthFilter extends OncePerRequestFilter {\n    @Autowired\n    private JwtUtil jwtUtil;\n    @Autowired\n    private UserDetailsService userDetailsService;\n    \n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                   HttpServletResponse response,\n                                   FilterChain filterChain) {\n        String authHeader = request.getHeader(\"Authorization\");\n        String jwt = null;\n        String username = null;\n        \n        if (authHeader != null && authHeader.startsWith(\"Bearer \")) {\n            jwt = authHeader.substring(7);\n            username = jwtUtil.extractUsername(jwt);\n        }\n        \n        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {\n            UserDetails userDetails = userDetailsService.loadUserByUsername(username);\n            if (jwtUtil.validateToken(jwt, userDetails)) {\n                UsernamePasswordAuthenticationToken authToken = \n                    new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());\n                SecurityContextHolder.getContext().setAuthentication(authToken);\n            }\n        }\n        filterChain.doFilter(request, response);\n    }\n}"
    },
    {
      "id": 16,
      "question": "How do you create JWT login endpoint?",
      "answer": "Login endpoint:\n\n1. Receive credentials\n2. Authenticate with AuthenticationManager\n3. Generate JWT\n4. Return token\n\nRegister endpoint:\n1. Validate input\n2. Check duplicates\n3. Encode password\n4. Save user\n5. Optionally return JWT",
      "explanation": "These endpoints are typically unsecured (permitAll) for user registration and authentication.",
      "difficulty": "Medium",
      "code": "@RestController\n@RequestMapping(\"/api/auth\")\npublic class AuthController {\n    @Autowired\n    private AuthenticationManager authenticationManager;\n    @Autowired\n    private JwtUtil jwtUtil;\n    @Autowired\n    private UserDetailsService userDetailsService;\n    \n    @PostMapping(\"/login\")\n    public ResponseEntity<?> login(@RequestBody LoginRequest request) {\n        try {\n            authenticationManager.authenticate(\n                new UsernamePasswordAuthenticationToken(\n                    request.getUsername(), request.getPassword()\n                )\n            );\n            UserDetails userDetails = userDetailsService.loadUserByUsername(request.getUsername());\n            String jwt = jwtUtil.generateToken(userDetails);\n            return ResponseEntity.ok(new JwtResponse(jwt));\n        } catch (BadCredentialsException e) {\n            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)\n                .body(\"Invalid credentials\");\n        }\n    }\n}"
    },
    {
      "id": 17,
      "question": "What is OAuth2 and its grant types?",
      "answer": "OAuth2: Authorization framework for third-party access.\n\nConcepts:\n• Resource Owner: User\n• Client: Application\n• Resource Server: Hosts data\n• Authorization Server: Issues tokens\n\nGrant types:\n1. Authorization Code: Most secure\n2. Implicit: Deprecated\n3. Password: Trusted apps\n4. Client Credentials: Machine-to-machine\n5. Refresh Token: Get new token",
      "explanation": "OAuth2 is for authorization. OpenID Connect (OIDC) extends it for authentication.",
      "difficulty": "Hard",
      "code": "spring:\n  security:\n    oauth2:\n      client:\n        registration:\n          google:\n            client-id: your-client-id\n            client-secret: your-secret\n            scope:\n              - email\n              - profile\n          github:\n            client-id: github-client-id\n            client-secret: github-secret"
    },
    {
      "id": 18,
      "question": "How do you implement OAuth2 Login in Spring Security?",
      "answer": "OAuth2 Login (Social Login):\n\n1. Add dependency: oauth2-client\n2. Configure client registration\n3. Set redirect URI\n4. Configure security\n\nProviders:\n• Google\n• GitHub\n• Facebook\n• Okta",
      "explanation": "Spring Security handles OAuth2 flow automatically. Users log in via third-party provider.",
      "difficulty": "Medium",
      "code": "@Configuration\n@EnableWebSecurity\npublic class OAuth2Config {\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) {\n        http\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/\", \"/login\").permitAll()\n                .anyRequest().authenticated()\n            )\n            .oauth2Login(oauth2 -> oauth2\n                .loginPage(\"/login\")\n                .defaultSuccessUrl(\"/dashboard\")\n            );\n        return http.build();\n    }\n}\n\n// Get user info\n@GetMapping(\"/user\")\npublic String getUser(@AuthenticationPrincipal OAuth2User principal) {\n    return principal.getAttribute(\"name\");\n}"
    },
    {
      "id": 19,
      "question": "How do you implement OAuth2 Resource Server?",
      "answer": "Resource Server: Protects APIs with OAuth2 tokens.\n\nToken types:\n• JWT: Self-contained, local validation\n• Opaque: Validated with auth server\n\nConfiguration:\n1. Add dependency: oauth2-resource-server\n2. Configure token validation\n3. Set issuer URI\n4. Define authorization",
      "explanation": "Resource Server validates access tokens. Client includes Bearer token in Authorization header.",
      "difficulty": "Hard",
      "code": "spring:\n  security:\n    oauth2:\n      resourceserver:\n        jwt:\n          issuer-uri: https://auth-server.com\n\n@Configuration\npublic class ResourceServerConfig {\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) {\n        http\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/api/public/**\").permitAll()\n                .anyRequest().authenticated()\n            )\n            .oauth2ResourceServer(oauth2 -> oauth2\n                .jwt(Customizer.withDefaults())\n            );\n        return http.build();\n    }\n}"
    },
    {
      "id": 20,
      "question": "What is session management in Spring Security?",
      "answer": "Session management controls user sessions:\n\nPolicies:\n• ALWAYS: Always create\n• IF_REQUIRED: Create if needed (default)\n• NEVER: Never create, use if exists\n• STATELESS: No session (REST APIs)\n\nFeatures:\n• Session fixation protection\n• Concurrent session control\n• Session timeout\n• Remember-me",
      "explanation": "Use IF_REQUIRED for web apps. Use STATELESS for REST APIs with JWT/OAuth2.",
      "difficulty": "Medium",
      "code": "http.sessionManagement(session -> session\n    .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n    .sessionFixation().migrateSession()\n    .maximumSessions(1)\n        .maxSessionsPreventsLogin(true)\n        .expiredUrl(\"/session-expired\")\n);\n\n// Timeout\nserver.servlet.session.timeout=30m"
    },    {
      "id": 21,
      "question": "How do you implement Remember-Me functionality?",
      "answer": "Remember-Me: Stay logged in across sessions.\n\nApproaches:\n1. Hash-Based Token: MD5 hash, less secure\n2. Persistent Token: Database stored, more secure\n\nCookie contains:\n• Username\n• Expiration\n• Token signature\n\nSecurity:\n• Use HTTPS\n• Set httpOnly flag\n• Token rotation",
      "explanation": "Remember-Me trades security for convenience. Use persistent tokens for better security.",
      "difficulty": "Medium",
      "code": "http.rememberMe(remember -> remember\n    .key(\"uniqueAndSecret\")\n    .tokenValiditySeconds(86400 * 30)\n    .userDetailsService(userDetailsService)\n    .rememberMeParameter(\"remember-me\")\n);\n\n// Persistent token\n@Bean\npublic PersistentTokenRepository tokenRepository(DataSource dataSource) {\n    JdbcTokenRepositoryImpl tokenRepository = new JdbcTokenRepositoryImpl();\n    tokenRepository.setDataSource(dataSource);\n    return tokenRepository;\n}\n\n// Form\n<input type=\"checkbox\" name=\"remember-me\" /> Remember Me"
    },
    {
      "id": 22,
      "question": "How do you handle logout in Spring Security?",
      "answer": "Logout process:\n1. Invalidate session\n2. Clear SecurityContext\n3. Delete cookies\n4. Redirect\n\nConfiguration:\n• Logout URL (/logout)\n• Success URL\n• Success handler\n• Delete cookies\n• Invalidate session",
      "explanation": "Spring Security handles logout automatically. Customize with LogoutHandler and LogoutSuccessHandler.",
      "difficulty": "Easy",
      "code": "http.logout(logout -> logout\n    .logoutUrl(\"/logout\")\n    .logoutSuccessUrl(\"/login?logout\")\n    .deleteCookies(\"JSESSIONID\", \"remember-me\")\n    .invalidateHttpSession(true)\n    .clearAuthentication(true)\n    .permitAll()\n);\n\n// Custom handler\n@Component\npublic class CustomLogoutHandler implements LogoutSuccessHandler {\n    @Override\n    public void onLogoutSuccess(HttpServletRequest request,\n                               HttpServletResponse response,\n                               Authentication auth) {\n        // Custom cleanup\n        response.sendRedirect(\"/login?logout=success\");\n    }\n}"
    },
    {
      "id": 23,
      "question": "What are roles and authorities in Spring Security?",
      "answer": "Roles vs Authorities:\n\n• Role: High-level permission (ADMIN, USER)\n• Authority: Fine-grained permission (READ_USER, WRITE_USER)\n\nConvention:\n• Roles prefixed with \"ROLE_\"\n• hasRole(\"ADMIN\") checks \"ROLE_ADMIN\"\n• hasAuthority(\"ROLE_ADMIN\") requires exact match\n\nGrantedAuthority:\n• Interface representing permission\n• SimpleGrantedAuthority: Basic implementation",
      "explanation": "Roles are authorities with ROLE_ prefix. Use roles for broad access, authorities for specific permissions.",
      "difficulty": "Medium",
      "code": "// Using roles\n@PreAuthorize(\"hasRole('ADMIN')\")\npublic void deleteUser() { }\n\nhttp.authorizeHttpRequests(auth -> auth\n    .requestMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n);\n\n// Using authorities\n@PreAuthorize(\"hasAuthority('WRITE_USER')\")\npublic void updateUser() { }\n\nhttp.authorizeHttpRequests(auth -> auth\n    .requestMatchers(\"/api/**\").hasAuthority(\"API_ACCESS\")\n);\n\n// Multiple\n@PreAuthorize(\"hasAnyRole('ADMIN', 'MANAGER')\")\npublic void approveOrder() { }\n\n// Creating authorities\nList<GrantedAuthority> authorities = new ArrayList<>();\nauthorities.add(new SimpleGrantedAuthority(\"ROLE_ADMIN\"));\nauthorities.add(new SimpleGrantedAuthority(\"WRITE_USER\"));"
    },
    {
      "id": 24,
      "question": "How do you implement role hierarchy in Spring Security?",
      "answer": "Role Hierarchy: Define role inheritance.\n\nExample:\nADMIN > MANAGER > USER\n\nADMIN inherits:\n• MANAGER permissions\n• USER permissions\n\nBenefits:\n• Reduces code duplication\n• Simplifies authorization\n• Easier maintenance",
      "explanation": "Higher roles automatically get lower role permissions. Configure with RoleHierarchy bean.",
      "difficulty": "Medium",
      "code": "@Bean\npublic RoleHierarchy roleHierarchy() {\n    RoleHierarchyImpl roleHierarchy = new RoleHierarchyImpl();\n    String hierarchy = \"ROLE_ADMIN > ROLE_MANAGER \\n ROLE_MANAGER > ROLE_USER\";\n    roleHierarchy.setHierarchy(hierarchy);\n    return roleHierarchy;\n}\n\n@Bean\npublic DefaultWebSecurityExpressionHandler webSecurityExpressionHandler() {\n    DefaultWebSecurityExpressionHandler handler = new DefaultWebSecurityExpressionHandler();\n    handler.setRoleHierarchy(roleHierarchy());\n    return handler;\n}\n\n// Now ADMIN can access USER endpoints\n@PreAuthorize(\"hasRole('USER')\")\npublic void viewProfile() { }\n// ADMIN, MANAGER, and USER can access"
    },
    {
      "id": 25,
      "question": "What is method-level security with SpEL expressions?",
      "answer": "SpEL (Spring Expression Language) in security:\n\nCommon expressions:\n• authentication.principal: Current user\n• authentication.name: Username\n• hasRole('ADMIN'): Check role\n• hasPermission(): Custom permission\n• #paramName: Method parameter\n• returnObject: Return value (PostAuthorize)\n\nPowerful for:\n• Dynamic authorization\n• Parameter-based checks\n• Complex conditions",
      "explanation": "SpEL enables dynamic, flexible authorization based on runtime data and method parameters.",
      "difficulty": "Hard",
      "code": "@Service\npublic class DocumentService {\n    \n    // Check if user owns document\n    @PreAuthorize(\"#document.owner == authentication.name\")\n    public void updateDocument(Document document) { }\n    \n    // Return value check\n    @PostAuthorize(\"returnObject.owner == authentication.name\")\n    public Document getDocument(Long id) { }\n    \n    // Multiple conditions\n    @PreAuthorize(\"hasRole('ADMIN') or #userId == authentication.principal.id\")\n    public User getUser(Long userId) { }\n    \n    // Collection filtering\n    @PostFilter(\"filterObject.owner == authentication.name\")\n    public List<Document> getAllDocuments() { }\n    \n    // Custom permission evaluator\n    @PreAuthorize(\"@permissionEvaluator.canAccess(authentication, #id)\")\n    public Document getSecureDocument(Long id) { }\n    \n    // Complex expression\n    @PreAuthorize(\"hasRole('ADMIN') or (hasRole('USER') and #order.total < 1000)\")\n    public void processOrder(Order order) { }\n}"
    },
    {
      "id": 26,
      "question": "How do you implement custom PermissionEvaluator?",
      "answer": "PermissionEvaluator: Custom permission logic.\n\nInterface methods:\n• hasPermission(Authentication, Object, Object): Check permission on object\n• hasPermission(Authentication, Serializable, String, Object): Check by ID\n\nUse cases:\n• Domain object security\n• Complex business rules\n• Custom permission logic",
      "explanation": "PermissionEvaluator allows complex authorization beyond simple role checks.",
      "difficulty": "Hard",
      "code": "@Component(\"customPermissionEvaluator\")\npublic class CustomPermissionEvaluator implements PermissionEvaluator {\n    \n    @Override\n    public boolean hasPermission(Authentication authentication,\n                                Object targetDomainObject,\n                                Object permission) {\n        if (authentication == null || targetDomainObject == null) {\n            return false;\n        }\n        \n        if (targetDomainObject instanceof Document) {\n            Document document = (Document) targetDomainObject;\n            return checkDocumentPermission(authentication, document, permission.toString());\n        }\n        \n        return false;\n    }\n    \n    @Override\n    public boolean hasPermission(Authentication authentication,\n                                Serializable targetId,\n                                String targetType,\n                                Object permission) {\n        if (\"Document\".equals(targetType)) {\n            Document document = documentRepository.findById((Long) targetId).orElse(null);\n            return hasPermission(authentication, document, permission);\n        }\n        return false;\n    }\n    \n    private boolean checkDocumentPermission(Authentication auth, Document doc, String permission) {\n        String username = auth.getName();\n        \n        if (\"READ\".equals(permission)) {\n            return doc.isPublic() || doc.getOwner().equals(username);\n        }\n        if (\"WRITE\".equals(permission)) {\n            return doc.getOwner().equals(username);\n        }\n        \n        return false;\n    }\n}\n\n// Usage\n@PreAuthorize(\"hasPermission(#document, 'WRITE')\")\npublic void updateDocument(Document document) { }\n\n@PreAuthorize(\"hasPermission(#id, 'Document', 'READ')\")\npublic Document getDocument(Long id) { }"
    },
    {
      "id": 27,
      "question": "What is @Secured vs @PreAuthorize?",
      "answer": "@Secured:\n• Legacy annotation\n• Simple role checking\n• No SpEL support\n• Array of roles\n• Requires exact authority name\n\n@PreAuthorize:\n• Modern approach\n• SpEL support\n• More flexible\n• Complex expressions\n• Parameter access",
      "explanation": "@PreAuthorize is preferred for flexibility. @Secured kept for backward compatibility.",
      "difficulty": "Easy",
      "code": "// @Secured - no SpEL\n@Secured({\"ROLE_ADMIN\", \"ROLE_MANAGER\"})\npublic void approveOrder() { }\n\n@Secured(\"ROLE_USER\")\npublic void viewProfile() { }\n\n// @PreAuthorize - with SpEL\n@PreAuthorize(\"hasRole('ADMIN')\")\npublic void deleteUser() { }\n\n@PreAuthorize(\"hasRole('ADMIN') or hasRole('MANAGER')\")\npublic void approveOrder() { }\n\n@PreAuthorize(\"#userId == authentication.principal.id\")\npublic void updateProfile(Long userId) { }\n\n// Enable\n@EnableMethodSecurity(\n    securedEnabled = true,  // @Secured\n    prePostEnabled = true   // @PreAuthorize/@PostAuthorize\n)"
    },
    {
      "id": 28,
      "question": "How do you implement custom authentication provider?",
      "answer": "AuthenticationProvider: Custom authentication logic.\n\nInterface methods:\n• authenticate(Authentication): Perform authentication\n• supports(Class<?>): Check if provider supports authentication type\n\nUse cases:\n• Custom authentication source\n• Third-party integration\n• Special validation logic",
      "explanation": "Custom provider allows authentication against any data source or with custom rules.",
      "difficulty": "Hard",
      "code": "@Component\npublic class CustomAuthenticationProvider implements AuthenticationProvider {\n    \n    @Autowired\n    private UserService userService;\n    \n    @Autowired\n    private PasswordEncoder passwordEncoder;\n    \n    @Override\n    public Authentication authenticate(Authentication authentication) \n            throws AuthenticationException {\n        \n        String username = authentication.getName();\n        String password = authentication.getCredentials().toString();\n        \n        User user = userService.findByUsername(username);\n        \n        if (user == null) {\n            throw new BadCredentialsException(\"User not found\");\n        }\n        \n        if (!passwordEncoder.matches(password, user.getPassword())) {\n            throw new BadCredentialsException(\"Invalid password\");\n        }\n        \n        // Custom validation\n        if (!user.isAccountActive()) {\n            throw new DisabledException(\"Account is disabled\");\n        }\n        \n        List<GrantedAuthority> authorities = user.getRoles().stream()\n            .map(role -> new SimpleGrantedAuthority(role.getName()))\n            .collect(Collectors.toList());\n        \n        return new UsernamePasswordAuthenticationToken(\n            username, password, authorities);\n    }\n    \n    @Override\n    public boolean supports(Class<?> authentication) {\n        return UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication);\n    }\n}\n\n// Register provider\n@Bean\npublic AuthenticationManager authenticationManager(\n        AuthenticationConfiguration config) throws Exception {\n    return config.getAuthenticationManager();\n}"
    },
    {
      "id": 29,
      "question": "What is SecurityContext and SecurityContextHolder?",
      "answer": "SecurityContext:\n• Holds authentication information\n• Contains Authentication object\n• Thread-scoped\n\nSecurityContextHolder:\n• Provides access to SecurityContext\n• Storage strategies:\n  - MODE_THREADLOCAL (default)\n  - MODE_INHERITABLETHREADLOCAL\n  - MODE_GLOBAL\n\nUsage:\n• Get current user\n• Check authentication\n• Manual authentication",
      "explanation": "SecurityContextHolder stores authentication for current thread. Accessible anywhere in application.",
      "difficulty": "Medium",
      "code": "// Get current authentication\nAuthentication auth = SecurityContextHolder.getContext().getAuthentication();\n\n// Get username\nString username = auth.getName();\n\n// Get authorities\nCollection<? extends GrantedAuthority> authorities = auth.getAuthorities();\n\n// Get user details\nUserDetails userDetails = (UserDetails) auth.getPrincipal();\n\n// Check if authenticated\nboolean isAuthenticated = auth.isAuthenticated();\n\n// Manual authentication\nUsernamePasswordAuthenticationToken authToken = \n    new UsernamePasswordAuthenticationToken(user, null, authorities);\nSecurityContextHolder.getContext().setAuthentication(authToken);\n\n// Clear authentication\nSecurityContextHolder.clearContext();\n\n// In controller\n@GetMapping(\"/profile\")\npublic String getProfile() {\n    Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n    String username = auth.getName();\n    return \"Profile of \" + username;\n}"
    },
    {
      "id": 30,
      "question": "How do you get current authenticated user in Spring Security?",
      "answer": "Multiple approaches:\n\n1. SecurityContextHolder\n2. @AuthenticationPrincipal\n3. Principal parameter\n4. Authentication parameter\n\nBest practice:\n• Controller: @AuthenticationPrincipal\n• Service: SecurityContextHolder\n• Custom objects: Implement UserDetails",
      "explanation": "@AuthenticationPrincipal is cleanest in controllers. SecurityContextHolder works anywhere.",
      "difficulty": "Easy",
      "code": "// 1. SecurityContextHolder (anywhere)\nAuthentication auth = SecurityContextHolder.getContext().getAuthentication();\nString username = auth.getName();\n\n// 2. @AuthenticationPrincipal (controller)\n@GetMapping(\"/profile\")\npublic String profile(@AuthenticationPrincipal UserDetails user) {\n    return user.getUsername();\n}\n\n// With custom UserDetails\n@GetMapping(\"/profile\")\npublic String profile(@AuthenticationPrincipal CustomUser user) {\n    return user.getEmail();\n}\n\n// 3. Principal parameter\n@GetMapping(\"/profile\")\npublic String profile(Principal principal) {\n    return principal.getName();\n}\n\n// 4. Authentication parameter\n@GetMapping(\"/profile\")\npublic String profile(Authentication authentication) {\n    return authentication.getName();\n}\n\n// In service\n@Service\npublic class UserService {\n    public void doSomething() {\n        String username = SecurityContextHolder.getContext()\n            .getAuthentication().getName();\n    }\n}"
    },    {
      "id": 31,
      "question": "What are Spring Security test annotations?",
      "answer": "Testing annotations:\n\n• @WithMockUser: Mock authenticated user\n• @WithUserDetails: Load from UserDetailsService\n• @WithAnonymousUser: Anonymous user\n• @WithSecurityContext: Custom security context\n\nTest support:\n• Spring Security Test dependency\n• MockMvc integration\n• Security context setup",
      "explanation": "These annotations simplify testing secured methods and endpoints without actual authentication.",
      "difficulty": "Medium",
      "code": "<!-- Dependency -->\n<dependency>\n    <groupId>org.springframework.security</groupId>\n    <artifactId>spring-security-test</artifactId>\n    <scope>test</scope>\n</dependency>\n\n@WebMvcTest(UserController.class)\nclass UserControllerTest {\n    @Autowired\n    private MockMvc mockMvc;\n    \n    @Test\n    @WithMockUser(username = \"john\", roles = {\"USER\"})\n    void testGetProfile() throws Exception {\n        mockMvc.perform(get(\"/profile\"))\n            .andExpect(status().isOk());\n    }\n    \n    @Test\n    @WithMockUser(roles = {\"ADMIN\"})\n    void testDeleteUser() throws Exception {\n        mockMvc.perform(delete(\"/users/1\"))\n            .andExpect(status().isOk());\n    }\n    \n    @Test\n    @WithAnonymousUser\n    void testPublicEndpoint() throws Exception {\n        mockMvc.perform(get(\"/public\"))\n            .andExpect(status().isOk());\n    }\n    \n    @Test\n    @WithUserDetails(\"john@example.com\")\n    void testWithUserDetails() throws Exception {\n        mockMvc.perform(get(\"/dashboard\"))\n            .andExpect(status().isOk());\n    }\n}"
    },
    {
      "id": 32,
      "question": "How do you test secured methods with Spring Security?",
      "answer": "Testing secured methods:\n\n1. Unit tests: @WithMockUser\n2. Integration tests: Real authentication\n3. Service tests: SecurityContext setup\n4. MockMvc: Security setup\n\nApproaches:\n• Annotation-based\n• Programmatic setup\n• Custom security context",
      "explanation": "Use @WithMockUser for unit tests. Use real authentication for integration tests.",
      "difficulty": "Medium",
      "code": "@ExtendWith(SpringExtension.class)\n@ContextConfiguration\nclass UserServiceTest {\n    @Autowired\n    private UserService userService;\n    \n    @Test\n    @WithMockUser(username = \"admin\", roles = {\"ADMIN\"})\n    void adminCanDeleteUser() {\n        assertDoesNotThrow(() -> userService.deleteUser(1L));\n    }\n    \n    @Test\n    @WithMockUser(username = \"user\", roles = {\"USER\"})\n    void userCannotDeleteUser() {\n        assertThrows(AccessDeniedException.class, \n            () -> userService.deleteUser(1L));\n    }\n    \n    @Test\n    void testWithProgrammaticAuth() {\n        // Setup authentication\n        UserDetails user = User.withUsername(\"john\")\n            .password(\"password\")\n            .roles(\"USER\")\n            .build();\n        \n        Authentication auth = new UsernamePasswordAuthenticationToken(\n            user, null, user.getAuthorities());\n        \n        SecurityContextHolder.getContext().setAuthentication(auth);\n        \n        // Test\n        User result = userService.getCurrentUser();\n        assertEquals(\"john\", result.getUsername());\n        \n        // Cleanup\n        SecurityContextHolder.clearContext();\n    }\n}"
    },
    {
      "id": 33,
      "question": "What is Access Control List (ACL) in Spring Security?",
      "answer": "ACL: Instance-level security.\n\nFeatures:\n• Per-object permissions\n• Fine-grained access control\n• Who can do what on specific instances\n\nComponents:\n• ACL: Access control list\n• ACE: Access control entry\n• SID: Security identity\n• OID: Object identity\n\nPermissions:\n• READ, WRITE, CREATE, DELETE\n• ADMINISTRATION",
      "explanation": "ACL provides domain object security. Different from role-based - controls access to specific instances.",
      "difficulty": "Hard",
      "code": "<!-- Dependency -->\n<dependency>\n    <groupId>org.springframework.security</groupId>\n    <artifactId>spring-security-acl</artifactId>\n</dependency>\n\n// Configuration\n@Configuration\n@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)\npublic class AclConfig {\n    \n    @Bean\n    public AclService aclService(DataSource dataSource, \n                                 LookupStrategy lookupStrategy) {\n        JdbcMutableAclService aclService = \n            new JdbcMutableAclService(dataSource, lookupStrategy, aclCache());\n        return aclService;\n    }\n}\n\n// Usage\n@Service\npublic class DocumentService {\n    \n    @PreAuthorize(\"hasPermission(#id, 'com.example.Document', 'READ')\")\n    public Document getDocument(Long id) {\n        return documentRepository.findById(id).orElse(null);\n    }\n    \n    @PreAuthorize(\"hasPermission(#document, 'WRITE')\")\n    public void updateDocument(Document document) {\n        documentRepository.save(document);\n    }\n}"
    },
    {
      "id": 34,
      "question": "How do you handle authentication failures?",
      "answer": "Authentication failure handling:\n\n1. AuthenticationFailureHandler: Custom logic\n2. ExceptionTranslationFilter: Catches exceptions\n3. Failure URL: Redirect on failure\n4. Custom error messages\n\nCommon exceptions:\n• BadCredentialsException\n• UsernameNotFoundException\n• DisabledException\n• LockedException\n• AccountExpiredException",
      "explanation": "Custom failure handler provides better user experience with specific error messages.",
      "difficulty": "Medium",
      "code": "@Component\npublic class CustomAuthenticationFailureHandler \n        implements AuthenticationFailureHandler {\n    \n    @Override\n    public void onAuthenticationFailure(HttpServletRequest request,\n                                       HttpServletResponse response,\n                                       AuthenticationException exception) {\n        \n        String errorMessage;\n        \n        if (exception instanceof BadCredentialsException) {\n            errorMessage = \"Invalid username or password\";\n        } else if (exception instanceof DisabledException) {\n            errorMessage = \"Account is disabled\";\n        } else if (exception instanceof LockedException) {\n            errorMessage = \"Account is locked\";\n        } else if (exception instanceof AccountExpiredException) {\n            errorMessage = \"Account has expired\";\n        } else {\n            errorMessage = \"Authentication failed\";\n        }\n        \n        request.getSession().setAttribute(\"error\", errorMessage);\n        response.sendRedirect(\"/login?error=true\");\n    }\n}\n\n// Configure\nhttp.formLogin(form -> form\n    .loginPage(\"/login\")\n    .failureHandler(customAuthenticationFailureHandler)\n);"
    },
    {
      "id": 35,
      "question": "How do you implement custom login page in Spring Security?",
      "answer": "Custom login page steps:\n\n1. Create login HTML/JSP\n2. Configure Spring Security\n3. Set login URL\n4. Set success/failure URLs\n5. Include CSRF token\n\nForm requirements:\n• POST to login URL\n• Username parameter\n• Password parameter\n• CSRF token",
      "explanation": "Custom login provides branded user experience. Must include CSRF token for security.",
      "difficulty": "Easy",
      "code": "// Security configuration\nhttp.formLogin(form -> form\n    .loginPage(\"/login\")              // GET login page\n    .loginProcessingUrl(\"/perform-login\")  // POST login\n    .defaultSuccessUrl(\"/dashboard\", true)\n    .failureUrl(\"/login?error=true\")\n    .usernameParameter(\"email\")       // Default: username\n    .passwordParameter(\"pass\")        // Default: password\n    .permitAll()\n);\n\n// Controller\n@Controller\npublic class LoginController {\n    @GetMapping(\"/login\")\n    public String loginPage() {\n        return \"login\";\n    }\n}\n\n<!-- login.html (Thymeleaf) -->\n<form th:action=\"@{/perform-login}\" method=\"post\">\n    <input type=\"email\" name=\"email\" required/>\n    <input type=\"password\" name=\"pass\" required/>\n    <input type=\"hidden\" th:name=\"${_csrf.parameterName}\" \n           th:value=\"${_csrf.token}\"/>\n    <button type=\"submit\">Login</button>\n</form>\n\n<div th:if=\"${param.error}\">\n    Invalid credentials\n</div>\n<div th:if=\"${param.logout}\">\n    Logged out successfully\n</div>"
    },
    {
      "id": 36,
      "question": "What is authentication success handler?",
      "answer": "AuthenticationSuccessHandler: Custom logic after successful login.\n\nUse cases:\n• Redirect based on role\n• Log login events\n• Update last login time\n• Set session attributes\n• Custom response for APIs\n\nMethods:\n• onAuthenticationSuccess()",
      "explanation": "Success handler provides post-login customization like role-based redirects and audit logging.",
      "difficulty": "Medium",
      "code": "@Component\npublic class CustomAuthenticationSuccessHandler \n        implements AuthenticationSuccessHandler {\n    \n    @Autowired\n    private UserService userService;\n    \n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request,\n                                       HttpServletResponse response,\n                                       Authentication authentication) {\n        \n        String username = authentication.getName();\n        \n        // Update last login\n        userService.updateLastLogin(username);\n        \n        // Log event\n        logger.info(\"User {} logged in successfully\", username);\n        \n        // Role-based redirect\n        String redirectUrl = determineTargetUrl(authentication);\n        response.sendRedirect(redirectUrl);\n    }\n    \n    private String determineTargetUrl(Authentication authentication) {\n        boolean isAdmin = authentication.getAuthorities().stream()\n            .anyMatch(auth -> auth.getAuthority().equals(\"ROLE_ADMIN\"));\n        \n        if (isAdmin) {\n            return \"/admin/dashboard\";\n        } else {\n            return \"/user/dashboard\";\n        }\n    }\n}\n\n// Configure\nhttp.formLogin(form -> form\n    .successHandler(customAuthenticationSuccessHandler)\n);"
    },
    {
      "id": 37,
      "question": "How do you implement multi-factor authentication (MFA)?",
      "answer": "MFA implementation:\n\n1. First factor: Username/password\n2. Second factor:\n   • TOTP (Time-based OTP)\n   • SMS code\n   • Email code\n   • Authenticator app\n\nSteps:\n1. Validate credentials\n2. Generate/send code\n3. Store pending authentication\n4. Verify code\n5. Complete authentication",
      "explanation": "MFA adds security layer. Implement as custom authentication filter or in success handler.",
      "difficulty": "Hard",
      "code": "@Component\npublic class MfaAuthenticationFilter extends OncePerRequestFilter {\n    \n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                   HttpServletResponse response,\n                                   FilterChain chain) {\n        \n        Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n        \n        if (auth != null && auth.isAuthenticated() && requiresMfa(auth)) {\n            String mfaCode = request.getParameter(\"mfaCode\");\n            \n            if (mfaCode == null) {\n                // Redirect to MFA page\n                response.sendRedirect(\"/mfa\");\n                return;\n            }\n            \n            if (!mfaService.verifyCode(auth.getName(), mfaCode)) {\n                SecurityContextHolder.clearContext();\n                response.sendRedirect(\"/login?error=mfa\");\n                return;\n            }\n            \n            // Mark MFA as completed\n            markMfaCompleted(auth);\n        }\n        \n        chain.doFilter(request, response);\n    }\n}\n\n@Service\npublic class MfaService {\n    public String generateTotpCode(String secret) {\n        // Generate TOTP code\n    }\n    \n    public boolean verifyCode(String username, String code) {\n        User user = userRepository.findByUsername(username);\n        String expectedCode = generateTotpCode(user.getMfaSecret());\n        return code.equals(expectedCode);\n    }\n    \n    public String generateQrCode(String username) {\n        // Generate QR code for authenticator app\n    }\n}"
    },
    {
      "id": 38,
      "question": "What is Spring Security's authentication event system?",
      "answer": "Authentication events:\n\nSuccess events:\n• AuthenticationSuccessEvent\n• InteractiveAuthenticationSuccessEvent\n\nFailure events:\n• AuthenticationFailureBadCredentialsEvent\n• AuthenticationFailureDisabledEvent\n• AuthenticationFailureLockedEvent\n• AuthenticationFailureExpiredEvent\n\nUse cases:\n• Audit logging\n• Failed login tracking\n• Account locking\n• Notifications",
      "explanation": "Events decouple authentication from business logic. Listen to events for audit, monitoring, security.",
      "difficulty": "Medium",
      "code": "@Component\npublic class AuthenticationEventListener {\n    \n    private Map<String, Integer> failedAttempts = new ConcurrentHashMap<>();\n    \n    @EventListener\n    public void onAuthenticationSuccess(AuthenticationSuccessEvent event) {\n        String username = event.getAuthentication().getName();\n        logger.info(\"User {} logged in successfully\", username);\n        \n        // Clear failed attempts\n        failedAttempts.remove(username);\n    }\n    \n    @EventListener\n    public void onAuthenticationFailure(AuthenticationFailureBadCredentialsEvent event) {\n        String username = event.getAuthentication().getName();\n        logger.warn(\"Failed login attempt for user: {}\", username);\n        \n        // Track failed attempts\n        int attempts = failedAttempts.getOrDefault(username, 0) + 1;\n        failedAttempts.put(username, attempts);\n        \n        // Lock account after 5 attempts\n        if (attempts >= 5) {\n            userService.lockAccount(username);\n            logger.warn(\"Account locked: {}\", username);\n        }\n    }\n    \n    @EventListener\n    public void onLogoutSuccess(LogoutSuccessEvent event) {\n        String username = event.getAuthentication().getName();\n        logger.info(\"User {} logged out\", username);\n    }\n}"
    },
    {
      "id": 39,
      "question": "How do you implement account locking after failed login attempts?",
      "answer": "Account locking strategy:\n\n1. Track failed attempts\n2. Lock after threshold\n3. Set lock duration\n4. Clear on success\n5. Unlock after timeout\n\nImplementation:\n• Database: Store attempts, lock status\n• Events: Listen to failures\n• UserDetails: Check lock status\n• Scheduled task: Auto-unlock",
      "explanation": "Account locking prevents brute force attacks. Implement with authentication event listeners.",
      "difficulty": "Medium",
      "code": "@Entity\npublic class User {\n    private String username;\n    private String password;\n    private boolean accountLocked;\n    private int failedAttempts;\n    private LocalDateTime lockTime;\n}\n\n@Service\npublic class LoginAttemptService {\n    \n    private static final int MAX_ATTEMPTS = 5;\n    private static final long LOCK_DURATION_MS = 3600000; // 1 hour\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    public void loginSucceeded(String username) {\n        User user = userRepository.findByUsername(username);\n        if (user != null) {\n            user.setFailedAttempts(0);\n            user.setAccountLocked(false);\n            user.setLockTime(null);\n            userRepository.save(user);\n        }\n    }\n    \n    public void loginFailed(String username) {\n        User user = userRepository.findByUsername(username);\n        if (user != null) {\n            int attempts = user.getFailedAttempts() + 1;\n            user.setFailedAttempts(attempts);\n            \n            if (attempts >= MAX_ATTEMPTS) {\n                user.setAccountLocked(true);\n                user.setLockTime(LocalDateTime.now());\n            }\n            \n            userRepository.save(user);\n        }\n    }\n    \n    public boolean isLocked(String username) {\n        User user = userRepository.findByUsername(username);\n        if (user == null || !user.isAccountLocked()) {\n            return false;\n        }\n        \n        // Check if lock expired\n        long lockDuration = ChronoUnit.MILLIS.between(\n            user.getLockTime(), LocalDateTime.now());\n            \n        if (lockDuration > LOCK_DURATION_MS) {\n            user.setAccountLocked(false);\n            user.setFailedAttempts(0);\n            user.setLockTime(null);\n            userRepository.save(user);\n            return false;\n        }\n        \n        return true;\n    }\n}\n\n@Component\npublic class AuthenticationListener {\n    @Autowired\n    private LoginAttemptService loginAttemptService;\n    \n    @EventListener\n    public void onSuccess(AuthenticationSuccessEvent event) {\n        loginAttemptService.loginSucceeded(event.getAuthentication().getName());\n    }\n    \n    @EventListener\n    public void onFailure(AuthenticationFailureBadCredentialsEvent event) {\n        loginAttemptService.loginFailed(event.getAuthentication().getName());\n    }\n}\n\n// In UserDetailsService\nif (loginAttemptService.isLocked(username)) {\n    throw new LockedException(\"Account is locked due to multiple failed attempts\");\n}"
    },
    {
      "id": 40,
      "question": "What is SecurityContextPersistenceFilter?",
      "answer": "SecurityContextPersistenceFilter:\n• First filter in chain\n• Loads SecurityContext at start\n• Saves SecurityContext at end\n• Uses SecurityContextRepository\n\nDefault repository:\n• HttpSessionSecurityContextRepository\n• Stores context in HTTP session\n\nFor stateless:\n• NullSecurityContextRepository\n• No persistence",
      "explanation": "This filter manages SecurityContext lifecycle - loading from session and saving back.",
      "difficulty": "Hard",
      "code": "// Default behavior (session-based)\nhttp.securityContext(context -> context\n    .securityContextRepository(new HttpSessionSecurityContextRepository())\n);\n\n// Stateless (no persistence)\nhttp.securityContext(context -> context\n    .securityContextRepository(new NullSecurityContextRepository())\n);\n\n// Custom repository\npublic class CustomSecurityContextRepository implements SecurityContextRepository {\n    \n    @Override\n    public SecurityContext loadContext(HttpRequestResponseHolder requestResponseHolder) {\n        HttpServletRequest request = requestResponseHolder.getRequest();\n        \n        // Load from custom source (e.g., Redis)\n        String sessionId = request.getHeader(\"X-Session-Id\");\n        SecurityContext context = redisTemplate.opsForValue().get(sessionId);\n        \n        return context != null ? context : SecurityContextHolder.createEmptyContext();\n    }\n    \n    @Override\n    public void saveContext(SecurityContext context, \n                           HttpServletRequest request, \n                           HttpServletResponse response) {\n        // Save to custom source\n        String sessionId = request.getHeader(\"X-Session-Id\");\n        redisTemplate.opsForValue().set(sessionId, context, 30, TimeUnit.MINUTES);\n    }\n}"
    },    {
      "id": 41,
      "question": "How do you implement basic authentication in Spring Security?",
      "answer": "HTTP Basic Authentication:\n• Credentials in Authorization header\n• Base64 encoded: username:password\n• Sent with every request\n• No login page needed\n\nUse cases:\n• APIs\n• Service-to-service\n• Simple authentication\n\nFormat: Authorization: Basic dXNlcjpwYXNzd29yZA==",
      "explanation": "Basic auth is simple but less secure. Use with HTTPS. Better for APIs than web apps.",
      "difficulty": "Easy",
      "code": "// Enable basic authentication\nhttp.httpBasic(Customizer.withDefaults());\n\n// Custom configuration\nhttp.httpBasic(basic -> basic\n    .realmName(\"My App\")\n    .authenticationEntryPoint(customAuthenticationEntryPoint)\n);\n\n// Both form and basic\nhttp\n    .formLogin(Customizer.withDefaults())\n    .httpBasic(Customizer.withDefaults());\n\n// Test with curl\ncurl -u username:password http://localhost:8080/api/users\n\n// Or with header\ncurl -H \"Authorization: Basic dXNlcjpwYXNzd29yZA==\" \\\n     http://localhost:8080/api/users\n\n// In Java client\nString auth = username + \":\" + password;\nString encodedAuth = Base64.getEncoder().encodeToString(auth.getBytes());\nHttpHeaders headers = new HttpHeaders();\nheaders.set(\"Authorization\", \"Basic \" + encodedAuth);"
    },
    {
      "id": 42,
      "question": "What is the difference between hasRole and hasAuthority?",
      "answer": "hasRole:\n• Automatically adds \"ROLE_\" prefix\n• hasRole(\"ADMIN\") checks \"ROLE_ADMIN\"\n• Convention-based\n• For roles\n\nhasAuthority:\n• Exact match\n• hasAuthority(\"ROLE_ADMIN\") checks \"ROLE_ADMIN\"\n• hasAuthority(\"READ_PERMISSION\") checks exact string\n• For any authority",
      "explanation": "Use hasRole for role-based security. Use hasAuthority for fine-grained permissions without prefix.",
      "difficulty": "Easy",
      "code": "// hasRole - auto-prefixes with ROLE_\nhttp.authorizeHttpRequests(auth -> auth\n    .requestMatchers(\"/admin/**\").hasRole(\"ADMIN\")  // Checks ROLE_ADMIN\n    .requestMatchers(\"/user/**\").hasRole(\"USER\")    // Checks ROLE_USER\n);\n\n@PreAuthorize(\"hasRole('ADMIN')\")\npublic void deleteUser() { }  // Checks ROLE_ADMIN\n\n// hasAuthority - exact match\nhttp.authorizeHttpRequests(auth -> auth\n    .requestMatchers(\"/api/**\").hasAuthority(\"API_ACCESS\")\n    .requestMatchers(\"/write/**\").hasAuthority(\"WRITE_PERMISSION\")\n);\n\n@PreAuthorize(\"hasAuthority('DELETE_USER')\")\npublic void deleteUser() { }  // Checks DELETE_USER exactly\n\n// Creating authorities\nList<GrantedAuthority> authorities = Arrays.asList(\n    new SimpleGrantedAuthority(\"ROLE_ADMIN\"),   // For hasRole\n    new SimpleGrantedAuthority(\"READ_USER\"),    // For hasAuthority\n    new SimpleGrantedAuthority(\"WRITE_USER\")    // For hasAuthority\n);\n\n// Multiple\n@PreAuthorize(\"hasAnyRole('ADMIN', 'MANAGER')\")\npublic void approve() { }\n\n@PreAuthorize(\"hasAnyAuthority('READ', 'WRITE')\")\npublic void access() { }"
    },
    {
      "id": 43,
      "question": "How do you configure in-memory authentication?",
      "answer": "In-memory authentication: Users stored in application memory.\n\nUse cases:\n• Development/testing\n• POC projects\n• Small applications\n• Quick setup\n\nNot for production:\n• No persistence\n• Lost on restart\n• Not scalable",
      "explanation": "In-memory is simplest authentication, good for learning and testing. Never use in production.",
      "difficulty": "Easy",
      "code": "@Bean\npublic UserDetailsService userDetailsService() {\n    UserDetails user = User.builder()\n        .username(\"user\")\n        .password(passwordEncoder().encode(\"password\"))\n        .roles(\"USER\")\n        .build();\n    \n    UserDetails admin = User.builder()\n        .username(\"admin\")\n        .password(passwordEncoder().encode(\"admin123\"))\n        .roles(\"ADMIN\", \"USER\")\n        .build();\n    \n    return new InMemoryUserDetailsManager(user, admin);\n}\n\n// With authorities\nUserDetails manager = User.builder()\n    .username(\"manager\")\n    .password(passwordEncoder().encode(\"manager123\"))\n    .authorities(\"READ_USER\", \"WRITE_USER\", \"ROLE_MANAGER\")\n    .build();\n\n// Account status\nUserDetails locked = User.builder()\n    .username(\"locked\")\n    .password(passwordEncoder().encode(\"pass\"))\n    .roles(\"USER\")\n    .accountLocked(true)\n    .build();\n\nUserDetails disabled = User.builder()\n    .username(\"disabled\")\n    .password(passwordEncoder().encode(\"pass\"))\n    .roles(\"USER\")\n    .disabled(true)\n    .build();"
    },
    {
      "id": 44,
      "question": "How do you configure JDBC authentication?",
      "answer": "JDBC authentication: Users stored in database.\n\nDefault schema:\n• users table: username, password, enabled\n• authorities table: username, authority\n\nBenefits:\n• Persistent storage\n• Production-ready\n• Standard queries\n• Customizable",
      "explanation": "JDBC authentication uses database. Spring provides default schema or use custom queries.",
      "difficulty": "Medium",
      "code": "@Bean\npublic UserDetailsService userDetailsService(DataSource dataSource) {\n    JdbcUserDetailsManager users = new JdbcUserDetailsManager(dataSource);\n    \n    // Custom queries (optional)\n    users.setUsersByUsernameQuery(\n        \"SELECT username, password, enabled FROM users WHERE username = ?\"\n    );\n    users.setAuthoritiesByUsernameQuery(\n        \"SELECT username, authority FROM authorities WHERE username = ?\"\n    );\n    users.setGroupAuthoritiesByUsernameQuery(\n        \"SELECT g.id, g.group_name, ga.authority \" +\n        \"FROM groups g, group_members gm, group_authorities ga \" +\n        \"WHERE gm.username = ? AND g.id = ga.group_id AND g.id = gm.group_id\"\n    );\n    \n    return users;\n}\n\n// Default schema\nCREATE TABLE users (\n    username VARCHAR(50) NOT NULL PRIMARY KEY,\n    password VARCHAR(100) NOT NULL,\n    enabled BOOLEAN NOT NULL\n);\n\nCREATE TABLE authorities (\n    username VARCHAR(50) NOT NULL,\n    authority VARCHAR(50) NOT NULL,\n    FOREIGN KEY (username) REFERENCES users(username)\n);\n\nCREATE UNIQUE INDEX ix_auth_username ON authorities (username, authority);\n\n// Create user programmatically\nUserDetails user = User.withUsername(\"john\")\n    .password(passwordEncoder.encode(\"password\"))\n    .roles(\"USER\")\n    .build();\n\nusers.createUser(user);"
    },
    {
      "id": 45,
      "question": "How do you implement custom UserDetails?",
      "answer": "Custom UserDetails: Add custom user fields.\n\nInterface methods:\n• getUsername()\n• getPassword()\n• getAuthorities()\n• isAccountNonExpired()\n• isAccountNonLocked()\n• isCredentialsNonExpired()\n• isEnabled()\n\nBenefits:\n• Additional fields (email, phone)\n• Custom logic\n• Business-specific data",
      "explanation": "Implement UserDetails to include custom fields like email, firstName. Keep domain model separate.",
      "difficulty": "Medium",
      "code": "// Custom UserDetails implementation\npublic class CustomUserDetails implements UserDetails {\n    \n    private String username;\n    private String password;\n    private String email;\n    private String firstName;\n    private String lastName;\n    private boolean enabled;\n    private boolean accountNonLocked;\n    private Set<GrantedAuthority> authorities;\n    \n    // Constructor from User entity\n    public CustomUserDetails(User user) {\n        this.username = user.getUsername();\n        this.password = user.getPassword();\n        this.email = user.getEmail();\n        this.firstName = user.getFirstName();\n        this.lastName = user.getLastName();\n        this.enabled = user.isEnabled();\n        this.accountNonLocked = !user.isLocked();\n        this.authorities = user.getRoles().stream()\n            .map(role -> new SimpleGrantedAuthority(role.getName()))\n            .collect(Collectors.toSet());\n    }\n    \n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        return authorities;\n    }\n    \n    @Override\n    public String getPassword() {\n        return password;\n    }\n    \n    @Override\n    public String getUsername() {\n        return username;\n    }\n    \n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n    \n    @Override\n    public boolean isAccountNonLocked() {\n        return accountNonLocked;\n    }\n    \n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n    \n    @Override\n    public boolean isEnabled() {\n        return enabled;\n    }\n    \n    // Custom getters\n    public String getEmail() {\n        return email;\n    }\n    \n    public String getFullName() {\n        return firstName + \" \" + lastName;\n    }\n}\n\n// Usage in controller\n@GetMapping(\"/profile\")\npublic String profile(@AuthenticationPrincipal CustomUserDetails user) {\n    return \"Welcome \" + user.getFullName() + \" (\" + user.getEmail() + \")\";\n}"
    },
    {
      "id": 46,
      "question": "How do you implement security with WebFlux (Reactive)?",
      "answer": "Spring Security WebFlux: For reactive applications.\n\nDifferences:\n• ServerHttpSecurity (not HttpSecurity)\n• Reactive types (Mono, Flux)\n• Non-blocking\n• Different filters\n\nSame concepts:\n• Authentication\n• Authorization\n• CSRF, CORS",
      "explanation": "WebFlux security is reactive version. Use with Spring WebFlux for non-blocking applications.",
      "difficulty": "Hard",
      "code": "<!-- Dependency -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-webflux</artifactId>\n</dependency>\n\n@Configuration\n@EnableWebFluxSecurity\npublic class SecurityConfig {\n    \n    @Bean\n    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n        return http\n            .authorizeExchange(exchanges -> exchanges\n                .pathMatchers(\"/public/**\").permitAll()\n                .pathMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n                .anyExchange().authenticated()\n            )\n            .httpBasic(Customizer.withDefaults())\n            .formLogin(Customizer.withDefaults())\n            .csrf(ServerHttpSecurity.CsrfSpec::disable)\n            .build();\n    }\n    \n    @Bean\n    public MapReactiveUserDetailsService userDetailsService() {\n        UserDetails user = User.builder()\n            .username(\"user\")\n            .password(passwordEncoder().encode(\"password\"))\n            .roles(\"USER\")\n            .build();\n        \n        return new MapReactiveUserDetailsService(user);\n    }\n    \n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n}\n\n// Reactive controller\n@RestController\npublic class UserController {\n    \n    @GetMapping(\"/user\")\n    public Mono<String> getUser(@AuthenticationPrincipal Mono<UserDetails> principal) {\n        return principal.map(UserDetails::getUsername);\n    }\n    \n    @GetMapping(\"/users\")\n    @PreAuthorize(\"hasRole('ADMIN')\")\n    public Flux<User> getAllUsers() {\n        return userRepository.findAll();\n    }\n}"
    },
    {
      "id": 47,
      "question": "What is @EnableGlobalMethodSecurity vs @EnableMethodSecurity?",
      "answer": "@EnableGlobalMethodSecurity:\n• Legacy annotation (deprecated)\n• Before Spring Security 5.6\n• Uses AOP proxies\n\n@EnableMethodSecurity:\n• Modern approach (5.6+)\n• Native Spring AOP\n• Better performance\n• Simplified configuration\n\nReplace:\n@EnableGlobalMethodSecurity â†’ @EnableMethodSecurity",
      "explanation": "@EnableMethodSecurity is replacement. Use it in new projects, migrate from @EnableGlobalMethodSecurity.",
      "difficulty": "Easy",
      "code": "// OLD (deprecated)\n@Configuration\n@EnableGlobalMethodSecurity(\n    prePostEnabled = true,\n    securedEnabled = true,\n    jsr250Enabled = true\n)\npublic class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {\n}\n\n// NEW (recommended)\n@Configuration\n@EnableMethodSecurity(  // Simplified!\n    prePostEnabled = true,     // @PreAuthorize, @PostAuthorize (default: true)\n    securedEnabled = true,     // @Secured (default: false)\n    jsr250Enabled = true       // @RolesAllowed (default: false)\n)\npublic class MethodSecurityConfig {\n}\n\n// Minimal (just @PreAuthorize/@PostAuthorize)\n@Configuration\n@EnableMethodSecurity\npublic class MethodSecurityConfig {\n}\n\n// Usage remains same\n@Service\npublic class UserService {\n    @PreAuthorize(\"hasRole('ADMIN')\")\n    public void deleteUser(Long id) { }\n    \n    @Secured(\"ROLE_USER\")\n    public void viewProfile() { }\n    \n    @RolesAllowed(\"ADMIN\")\n    public void configureSystem() { }\n}"
    },
    {
      "id": 48,
      "question": "How do you handle concurrent session control?",
      "answer": "Concurrent session control: Limit active sessions per user.\n\nStrategies:\n1. Prevent new login: Block if max reached\n2. Expire old session: Force logout old sessions\n\nUse cases:\n• License enforcement\n• Security (prevent sharing)\n• Resource management\n\nConfiguration:\n• Maximum sessions\n• Prevention strategy\n• Expired URL",
      "explanation": "Concurrent control prevents multiple logins. Useful for preventing account sharing.",
      "difficulty": "Medium",
      "code": "@Bean\npublic HttpSessionEventPublisher httpSessionEventPublisher() {\n    return new HttpSessionEventPublisher();\n}\n\nhttp.sessionManagement(session -> session\n    .maximumSessions(1)\n        .maxSessionsPreventsLogin(true)  // Prevent new login\n        .expiredUrl(\"/session-expired\")\n        .sessionRegistry(sessionRegistry())\n);\n\n// Or expire old sessions (default)\nhttp.sessionManagement(session -> session\n    .maximumSessions(1)\n        .maxSessionsPreventsLogin(false)  // Expire old\n);\n\n@Bean\npublic SessionRegistry sessionRegistry() {\n    return new SessionRegistryImpl();\n}\n\n// View active sessions\n@Service\npublic class SessionService {\n    @Autowired\n    private SessionRegistry sessionRegistry;\n    \n    public List<String> getActiveSessions(String username) {\n        return sessionRegistry.getAllPrincipals().stream()\n            .filter(principal -> ((UserDetails) principal).getUsername().equals(username))\n            .flatMap(principal -> \n                sessionRegistry.getAllSessions(principal, false).stream())\n            .map(SessionInformation::getSessionId)\n            .collect(Collectors.toList());\n    }\n    \n    public void expireUserSessions(String username) {\n        sessionRegistry.getAllPrincipals().stream()\n            .filter(principal -> ((UserDetails) principal).getUsername().equals(username))\n            .flatMap(principal -> \n                sessionRegistry.getAllSessions(principal, false).stream())\n            .forEach(SessionInformation::expireNow);\n    }\n}"
    },
    {
      "id": 49,
      "question": "What is SecurityExpressionRoot and SecurityExpressionOperations?",
      "answer": "SecurityExpressionRoot: Base class for security expressions.\n\nProvides methods:\n• hasRole(), hasAnyRole()\n• hasAuthority(), hasAnyAuthority()\n• hasPermission()\n• isAnonymous(), isAuthenticated()\n• isFullyAuthenticated()\n• principal, authentication\n\nExtensions:\n• WebSecurityExpressionRoot: Web security\n• MethodSecurityExpressionRoot: Method security",
      "explanation": "These classes provide SpEL methods for security expressions in @PreAuthorize and HttpSecurity.",
      "difficulty": "Hard",
      "code": "// Built-in expressions from SecurityExpressionRoot\n\n// Role checks\n@PreAuthorize(\"hasRole('ADMIN')\")\n@PreAuthorize(\"hasAnyRole('ADMIN', 'MANAGER')\")\n\n// Authority checks\n@PreAuthorize(\"hasAuthority('WRITE_USER')\")\n@PreAuthorize(\"hasAnyAuthority('READ', 'WRITE')\")\n\n// Authentication state\n@PreAuthorize(\"isAnonymous()\")           // Not authenticated\n@PreAuthorize(\"isAuthenticated()\")      // Authenticated (including remember-me)\n@PreAuthorize(\"isFullyAuthenticated()\") // Authenticated (excluding remember-me)\n\n// Access principal\n@PreAuthorize(\"principal.username == #username\")\n@PreAuthorize(\"authentication.name == 'admin'\")\n\n// Permission\n@PreAuthorize(\"hasPermission(#document, 'WRITE')\")\n@PreAuthorize(\"hasPermission(#id, 'Document', 'READ')\")\n\n// Custom security expression\n@Component(\"customSecurity\")\npublic class CustomSecurityExpression {\n    \n    public boolean isOwner(Authentication authentication, Long userId) {\n        if (authentication == null) return false;\n        UserDetails user = (UserDetails) authentication.getPrincipal();\n        return user.getUsername().equals(getUsernameById(userId));\n    }\n    \n    public boolean canAccessDocument(Authentication authentication, Long docId) {\n        // Custom logic\n        return true;\n    }\n}\n\n// Usage\n@PreAuthorize(\"@customSecurity.isOwner(authentication, #userId)\")\npublic void updateUser(Long userId) { }\n\n@PreAuthorize(\"@customSecurity.canAccessDocument(authentication, #id)\")\npublic Document getDocument(Long id) { }"
    },
    {
      "id": 50,
      "question": "How do you debug Spring Security configuration?",
      "answer": "Debugging techniques:\n\n1. Enable debug logging\n2. View filter chain\n3. Check authentication\n4. Verify authorities\n5. Test with @WithMockUser\n6. Use actuator endpoints\n\nCommon issues:\n• Wrong authority name\n• Missing ROLE_ prefix\n• Filter order\n• CSRF token missing",
      "explanation": "Debug logging shows filter chain execution. Essential for troubleshooting security issues.",
      "difficulty": "Medium",
      "code": "# Enable debug logging\nlogging.level.org.springframework.security=DEBUG\nlogging.level.org.springframework.security.web.FilterChainProxy=DEBUG\n\n// Programmatic debugging\n@RestController\npublic class DebugController {\n    \n    @GetMapping(\"/debug/auth\")\n    public Map<String, Object> getAuthInfo() {\n        Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n        \n        Map<String, Object> info = new HashMap<>();\n        info.put(\"username\", auth.getName());\n        info.put(\"authenticated\", auth.isAuthenticated());\n        info.put(\"authorities\", auth.getAuthorities().stream()\n            .map(GrantedAuthority::getAuthority)\n            .collect(Collectors.toList()));\n        info.put(\"principal\", auth.getPrincipal());\n        \n        return info;\n    }\n    \n    @GetMapping(\"/debug/roles\")\n    public boolean hasRole(@RequestParam String role) {\n        Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n        return auth.getAuthorities().stream()\n            .anyMatch(a -> a.getAuthority().equals(\"ROLE_\" + role));\n    }\n}\n\n// Custom filter for logging\npublic class LoggingFilter extends OncePerRequestFilter {\n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                   HttpServletResponse response,\n                                   FilterChain chain) {\n        logger.debug(\"Request: {} {}\", request.getMethod(), request.getRequestURI());\n        \n        Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n        if (auth != null) {\n            logger.debug(\"User: {}, Authorities: {}\", \n                auth.getName(), auth.getAuthorities());\n        }\n        \n        chain.doFilter(request, response);\n    }\n}\n\n// View security filter chain\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n    http.authorizeHttpRequests(auth -> auth.anyRequest().authenticated());\n    SecurityFilterChain chain = http.build();\n    \n    // Log filters\n    logger.info(\"Security filters: {}\", chain.getFilters());\n    \n    return chain;\n}"
    },    {
      "id": 51,
      "question": "How do you implement API key authentication?",
      "answer": "API key authentication: Custom token-based auth.\n\nSteps:\n1. Generate API keys\n2. Store securely (hashed)\n3. Create custom filter\n4. Validate key from header\n5. Set authentication\n\nHeaders:\n• X-API-Key\n• Authorization: ApiKey xxx",
      "explanation": "API keys are simpler than JWT for machine-to-machine. Implement as custom authentication filter.",
      "difficulty": "Hard",
      "code": "@Entity\npublic class ApiKey {\n    @Id\n    private String key;  // Hashed\n    private String name;\n    private LocalDateTime expiresAt;\n    private boolean active;\n}\n\n@Component\npublic class ApiKeyAuthFilter extends OncePerRequestFilter {\n    \n    @Autowired\n    private ApiKeyService apiKeyService;\n    \n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                   HttpServletResponse response,\n                                   FilterChain chain) {\n        \n        String apiKey = request.getHeader(\"X-API-Key\");\n        \n        if (apiKey != null && apiKeyService.isValid(apiKey)) {\n            Authentication auth = new ApiKeyAuthentication(apiKey, true);\n            SecurityContextHolder.getContext().setAuthentication(auth);\n        }\n        \n        chain.doFilter(request, response);\n    }\n}\n\npublic class ApiKeyAuthentication extends AbstractAuthenticationToken {\n    private final String apiKey;\n    \n    public ApiKeyAuthentication(String apiKey, boolean authenticated) {\n        super(authenticated ? \n            Collections.singletonList(new SimpleGrantedAuthority(\"ROLE_API\")) : \n            Collections.emptyList());\n        this.apiKey = apiKey;\n        setAuthenticated(authenticated);\n    }\n    \n    @Override\n    public Object getCredentials() {\n        return apiKey;\n    }\n    \n    @Override\n    public Object getPrincipal() {\n        return apiKey;\n    }\n}\n\nhttp.addFilterBefore(apiKeyAuthFilter, UsernamePasswordAuthenticationFilter.class);"
    },
    {
      "id": 52,
      "question": "How do you implement IP-based access control?",
      "answer": "IP-based access control: Restrict by IP address.\n\nApproaches:\n1. hasIpAddress(): Single IP\n2. IP range matching\n3. Custom IP filter\n4. Blacklist/whitelist\n\nUse cases:\n• Admin access from office only\n• Block suspicious IPs\n• Internal APIs",
      "explanation": "IP filtering adds extra security layer. Combine with authentication for better security.",
      "difficulty": "Medium",
      "code": "// Simple IP restriction\nhttp.authorizeHttpRequests(auth -> auth\n    .requestMatchers(\"/admin/**\")\n        .hasIpAddress(\"192.168.1.100\")\n    .requestMatchers(\"/internal/**\")\n        .access(\"hasIpAddress('192.168.1.0/24') or hasIpAddress('10.0.0.0/8')\")\n);\n\n// Custom IP filter\n@Component\npublic class IpWhitelistFilter extends OncePerRequestFilter {\n    \n    private Set<String> whitelist = Set.of(\n        \"192.168.1.100\",\n        \"192.168.1.101\",\n        \"10.0.0.50\"\n    );\n    \n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                   HttpServletResponse response,\n                                   FilterChain chain) {\n        \n        String clientIp = getClientIp(request);\n        \n        if (!whitelist.contains(clientIp)) {\n            response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n            response.getWriter().write(\"Access denied from IP: \" + clientIp);\n            return;\n        }\n        \n        chain.doFilter(request, response);\n    }\n    \n    private String getClientIp(HttpServletRequest request) {\n        String ip = request.getHeader(\"X-Forwarded-For\");\n        if (ip == null || ip.isEmpty()) {\n            ip = request.getRemoteAddr();\n        }\n        return ip;\n    }\n}\n\n// IP range checker\n@Component(\"ipChecker\")\npublic class IpAddressChecker {\n    \n    public boolean isInRange(String ip, String cidr) {\n        // Parse CIDR and check if IP is in range\n        return checkIpInCidr(ip, cidr);\n    }\n}\n\n@PreAuthorize(\"@ipChecker.isInRange(request.remoteAddr, '192.168.1.0/24')\")\npublic void sensitiveOperation() { }"
    },
    {
      "id": 53,
      "question": "What is AntMatcher vs MvcMatcher vs RegexMatcher?",
      "answer": "URL Matchers:\n\nAntMatcher:\n• Ant-style patterns\n• ** matches zero or more directories\n• * matches zero or more characters\n• ? matches one character\n\nMvcMatcher (deprecated):\n• Uses Spring MVC mappings\n• More accurate for MVC apps\n\nRegexMatcher:\n• Regular expressions\n• Most flexible\n• Case-sensitive by default",
      "explanation": "Use requestMatchers() in modern Spring Security. It auto-detects best matcher.",
      "difficulty": "Medium",
      "code": "// Modern approach (Spring Security 5.8+)\nhttp.authorizeHttpRequests(auth -> auth\n    .requestMatchers(\"/public/**\").permitAll()  // Auto-selects matcher\n    .requestMatchers(\"/api/**\").authenticated()\n);\n\n// Ant patterns\nhttp.authorizeHttpRequests(auth -> auth\n    .requestMatchers(\"/users/*\").permitAll()      // /users/123\n    .requestMatchers(\"/users/**\").permitAll()     // /users/123/profile\n    .requestMatchers(\"/files/*.pdf\").permitAll()  // /files/doc.pdf\n    .requestMatchers(\"/api/*/items\").permitAll()  // /api/v1/items\n);\n\n// HTTP method specific\nhttp.authorizeHttpRequests(auth -> auth\n    .requestMatchers(HttpMethod.GET, \"/api/**\").permitAll()\n    .requestMatchers(HttpMethod.POST, \"/api/**\").hasRole(\"ADMIN\")\n    .requestMatchers(HttpMethod.DELETE, \"/api/**\").hasRole(\"ADMIN\")\n);\n\n// Regex patterns\nhttp.authorizeHttpRequests(auth -> auth\n    .requestMatchers(RegexRequestMatcher.regexMatcher(\"/users/[0-9]+\")).permitAll()\n);\n\n// Multiple patterns\nhttp.authorizeHttpRequests(auth -> auth\n    .requestMatchers(\"/public/**\", \"/login\", \"/register\").permitAll()\n    .requestMatchers(\"/admin/**\", \"/management/**\").hasRole(\"ADMIN\")\n);\n\n// Common patterns\n// /api/users     -> /api/*\n// /api/users/123 -> /api/**\n// /api/v1/users  -> /api/*/users\n// /files/a.pdf   -> /files/*.pdf"
    },
    {
      "id": 54,
      "question": "How do you implement rate limiting in Spring Security?",
      "answer": "Rate limiting: Prevent abuse by limiting requests.\n\nApproaches:\n1. Custom filter with counter\n2. Bucket4j library\n3. Redis-based tracking\n4. Spring Cloud Gateway\n\nStrategies:\n• Fixed window\n• Sliding window\n• Token bucket\n• Leaky bucket",
      "explanation": "Rate limiting prevents DDoS and brute force. Implement as filter before authentication.",
      "difficulty": "Hard",
      "code": "<!-- Bucket4j dependency -->\n<dependency>\n    <groupId>com.github.vladimir-bukhtoyarov</groupId>\n    <artifactId>bucket4j-core</artifactId>\n</dependency>\n\n@Component\npublic class RateLimitingFilter extends OncePerRequestFilter {\n    \n    private final Map<String, Bucket> cache = new ConcurrentHashMap<>();\n    \n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                   HttpServletResponse response,\n                                   FilterChain chain) {\n        \n        String key = getClientKey(request);\n        Bucket bucket = cache.computeIfAbsent(key, k -> createBucket());\n        \n        if (bucket.tryConsume(1)) {\n            chain.doFilter(request, response);\n        } else {\n            response.setStatus(429); // Too Many Requests\n            response.getWriter().write(\"Rate limit exceeded\");\n        }\n    }\n    \n    private Bucket createBucket() {\n        // 10 requests per minute\n        Bandwidth limit = Bandwidth.classic(10, \n            Refill.intervally(10, Duration.ofMinutes(1)));\n        return Bucket.builder()\n            .addLimit(limit)\n            .build();\n    }\n    \n    private String getClientKey(HttpServletRequest request) {\n        // Use IP address or user ID\n        Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n        if (auth != null && auth.isAuthenticated()) {\n            return auth.getName();\n        }\n        return request.getRemoteAddr();\n    }\n}\n\n// Redis-based (distributed)\n@Component\npublic class RedisRateLimiter {\n    @Autowired\n    private StringRedisTemplate redisTemplate;\n    \n    public boolean allowRequest(String key, int maxRequests, Duration window) {\n        String redisKey = \"rate_limit:\" + key;\n        Long count = redisTemplate.opsForValue().increment(redisKey);\n        \n        if (count == 1) {\n            redisTemplate.expire(redisKey, window);\n        }\n        \n        return count <= maxRequests;\n    }\n}"
    },
    {
      "id": 55,
      "question": "How do you implement password policies?",
      "answer": "Password policies: Enforce strong passwords.\n\nRules:\n• Minimum length\n• Character requirements (uppercase, lowercase, digit, special)\n• No common passwords\n• Password history\n• Expiration\n\nImplementation:\n• Custom validator\n• Bean validation\n• UserDetailsService check",
      "explanation": "Password policies improve security. Validate on registration and password change.",
      "difficulty": "Medium",
      "code": "// Custom password validator\n@Component\npublic class PasswordPolicyValidator {\n    \n    private static final int MIN_LENGTH = 8;\n    private static final String SPECIAL_CHARS = \"!@#$%^&*()\";\n    \n    public boolean isValid(String password) {\n        if (password == null || password.length() < MIN_LENGTH) {\n            return false;\n        }\n        \n        boolean hasUppercase = password.chars().anyMatch(Character::isUpperCase);\n        boolean hasLowercase = password.chars().anyMatch(Character::isLowerCase);\n        boolean hasDigit = password.chars().anyMatch(Character::isDigit);\n        boolean hasSpecial = password.chars()\n            .anyMatch(c -> SPECIAL_CHARS.indexOf(c) >= 0);\n        \n        return hasUppercase && hasLowercase && hasDigit && hasSpecial;\n    }\n    \n    public String getValidationMessage() {\n        return \"Password must be at least \" + MIN_LENGTH + \" characters and contain \" +\n               \"uppercase, lowercase, digit, and special character\";\n    }\n}\n\n// Bean validation annotation\n@Target({ElementType.FIELD})\n@Retention(RetentionPolicy.RUNTIME)\n@Constraint(validatedBy = StrongPasswordValidator.class)\npublic @interface StrongPassword {\n    String message() default \"Password does not meet requirements\";\n    Class<?>[] groups() default {};\n    Class<? extends Payload>[] payload() default {};\n}\n\npublic class StrongPasswordValidator \n        implements ConstraintValidator<StrongPassword, String> {\n    \n    @Override\n    public boolean isValid(String password, ConstraintValidatorContext context) {\n        if (password == null) return false;\n        \n        return password.length() >= 8 &&\n               password.chars().anyMatch(Character::isUpperCase) &&\n               password.chars().anyMatch(Character::isLowerCase) &&\n               password.chars().anyMatch(Character::isDigit) &&\n               password.matches(\".*[!@#$%^&*()].*\");\n    }\n}\n\n// Usage in DTO\npublic class RegisterRequest {\n    @NotBlank\n    private String username;\n    \n    @NotBlank\n    @StrongPassword\n    private String password;\n}\n\n// Password history check\n@Service\npublic class PasswordHistoryService {\n    private static final int HISTORY_SIZE = 5;\n    \n    public boolean isPasswordReused(String username, String newPassword) {\n        List<String> history = getPasswordHistory(username);\n        return history.stream()\n            .anyMatch(oldHash -> passwordEncoder.matches(newPassword, oldHash));\n    }\n}"
    },
    {
      "id": 56,
      "question": "What is DelegatingPasswordEncoder and why use it?",
      "answer": "DelegatingPasswordEncoder: Supports multiple encoding algorithms.\n\nFeatures:\n• Prefix identifies algorithm: {bcrypt}hash\n• Allow migration between encoders\n• Default encoder for new passwords\n• Validate old passwords with old encoder\n\nFormat: {id}encodedPassword\n\nBenefits:\n• Algorithm agility\n• Zero-downtime migration\n• Future-proof",
      "explanation": "DelegatingPasswordEncoder allows upgrading password algorithm without mass password reset.",
      "difficulty": "Medium",
      "code": "// Default DelegatingPasswordEncoder\n@Bean\npublic PasswordEncoder passwordEncoder() {\n    return PasswordEncoderFactories.createDelegatingPasswordEncoder();\n}\n\n// Custom configuration\n@Bean\npublic PasswordEncoder passwordEncoder() {\n    String idForEncode = \"bcrypt\";\n    Map<String, PasswordEncoder> encoders = new HashMap<>();\n    encoders.put(idForEncode, new BCryptPasswordEncoder());\n    encoders.put(\"pbkdf2\", new Pbkdf2PasswordEncoder());\n    encoders.put(\"scrypt\", new SCryptPasswordEncoder());\n    encoders.put(\"argon2\", new Argon2PasswordEncoder());\n    encoders.put(\"sha256\", new StandardPasswordEncoder());\n    \n    return new DelegatingPasswordEncoder(idForEncode, encoders);\n}\n\n// Password format in database\n// Old MD5:     {MD5}5f4dcc3b5aa765d61d8327deb882cf99\n// BCrypt:      {bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG\n// PBKDF2:      {pbkdf2}5d923b44a6d129f3ddf3e3c8d29412723dcbde72445e8ef6bf3b508fbf17fa4ed4d6b99ca763d8dc\n// Argon2:      {argon2}$argon2id$v=19$m=4096,t=3,p=1$...\n\n// Migration strategy\n@Service\npublic class PasswordUpgradeService {\n    @Autowired\n    private PasswordEncoder passwordEncoder;\n    @Autowired\n    private UserRepository userRepository;\n    \n    public void upgradePasswordIfNeeded(String username, String rawPassword) {\n        User user = userRepository.findByUsername(username);\n        String currentHash = user.getPassword();\n        \n        // Check if using old encoding\n        if (!currentHash.startsWith(\"{bcrypt}\")) {\n            // Re-encode with BCrypt\n            String newHash = passwordEncoder.encode(rawPassword);\n            user.setPassword(newHash);\n            userRepository.save(user);\n        }\n    }\n}\n\n// Automatic upgrade on login\n@Component\npublic class PasswordUpgradeSuccessHandler \n        implements AuthenticationSuccessHandler {\n    \n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request,\n                                       HttpServletResponse response,\n                                       Authentication authentication) {\n        String rawPassword = request.getParameter(\"password\");\n        passwordUpgradeService.upgradePasswordIfNeeded(\n            authentication.getName(), rawPassword);\n    }\n}"
    },
    {
      "id": 57,
      "question": "How do you implement audit logging in Spring Security?",
      "answer": "Audit logging: Track security events.\n\nWhat to log:\n• Login/logout events\n• Failed authentication\n• Authorization failures\n• Password changes\n• Account changes\n• Sensitive operations\n\nApproaches:\n• Authentication events\n• Custom auditing\n• Spring Data auditing\n• AOP",
      "explanation": "Audit logging is crucial for security compliance and incident investigation.",
      "difficulty": "Medium",
      "code": "@Entity\npublic class AuditLog {\n    @Id @GeneratedValue\n    private Long id;\n    private String username;\n    private String action;\n    private String ipAddress;\n    private LocalDateTime timestamp;\n    private boolean success;\n    private String details;\n}\n\n@Component\npublic class SecurityAuditListener {\n    @Autowired\n    private AuditLogRepository auditLogRepository;\n    \n    @EventListener\n    public void onAuthenticationSuccess(AuthenticationSuccessEvent event) {\n        String username = event.getAuthentication().getName();\n        AuditLog log = new AuditLog();\n        log.setUsername(username);\n        log.setAction(\"LOGIN\");\n        log.setSuccess(true);\n        log.setTimestamp(LocalDateTime.now());\n        auditLogRepository.save(log);\n    }\n    \n    @EventListener\n    public void onAuthenticationFailure(AuthenticationFailureBadCredentialsEvent event) {\n        String username = event.getAuthentication().getName();\n        AuditLog log = new AuditLog();\n        log.setUsername(username);\n        log.setAction(\"LOGIN_FAILED\");\n        log.setSuccess(false);\n        log.setDetails(event.getException().getMessage());\n        log.setTimestamp(LocalDateTime.now());\n        auditLogRepository.save(log);\n    }\n    \n    @EventListener\n    public void onLogout(LogoutSuccessEvent event) {\n        String username = event.getAuthentication().getName();\n        AuditLog log = new AuditLog();\n        log.setUsername(username);\n        log.setAction(\"LOGOUT\");\n        log.setSuccess(true);\n        log.setTimestamp(LocalDateTime.now());\n        auditLogRepository.save(log);\n    }\n}\n\n// AOP for method auditing\n@Aspect\n@Component\npublic class AuditAspect {\n    \n    @AfterReturning(\"@annotation(audited)\")\n    public void auditMethod(JoinPoint joinPoint, Audited audited) {\n        Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n        String username = auth != null ? auth.getName() : \"anonymous\";\n        \n        AuditLog log = new AuditLog();\n        log.setUsername(username);\n        log.setAction(joinPoint.getSignature().getName());\n        log.setSuccess(true);\n        auditLogRepository.save(log);\n    }\n}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Audited {\n}\n\n// Usage\n@Audited\n@PreAuthorize(\"hasRole('ADMIN')\")\npublic void deleteUser(Long id) {\n    userRepository.deleteById(id);\n}"
    },
    {
      "id": 58,
      "question": "How do you implement security headers in Spring Security?",
      "answer": "Security headers: Protect against common attacks.\n\nHeaders:\n• X-Content-Type-Options: nosniff\n• X-Frame-Options: DENY\n• X-XSS-Protection: 1; mode=block\n• Strict-Transport-Security (HSTS)\n• Content-Security-Policy (CSP)\n• Referrer-Policy\n\nSpring Security enables most by default.",
      "explanation": "Security headers add defense-in-depth. Configure to balance security and functionality.",
      "difficulty": "Easy",
      "code": "http.headers(headers -> headers\n    // Content Type Options\n    .contentTypeOptions(Customizer.withDefaults())\n    \n    // Frame Options\n    .frameOptions(frame -> frame\n        .sameOrigin()  // or .deny()\n    )\n    \n    // XSS Protection\n    .xssProtection(xss -> xss\n        .headerValue(XXssProtectionHeaderWriter.HeaderValue.ENABLED_MODE_BLOCK)\n    )\n    \n    // HSTS\n    .httpStrictTransportSecurity(hsts -> hsts\n        .includeSubDomains(true)\n        .maxAgeInSeconds(31536000)  // 1 year\n    )\n    \n    // CSP\n    .contentSecurityPolicy(csp -> csp\n        .policyDirectives(\"default-src 'self'; script-src 'self' 'unsafe-inline'\")\n    )\n    \n    // Referrer Policy\n    .referrerPolicy(referrer -> referrer\n        .policy(ReferrerPolicyHeaderWriter.ReferrerPolicy.STRICT_ORIGIN_WHEN_CROSS_ORIGIN)\n    )\n    \n    // Permissions Policy\n    .permissionsPolicy(permissions -> permissions\n        .policy(\"camera=(), microphone=(), geolocation=()\")\n    )\n);\n\n// Disable specific header\nhttp.headers(headers -> headers\n    .frameOptions(frame -> frame.disable())\n);\n\n// Disable all headers\nhttp.headers(AbstractHttpConfigurer::disable);\n\n// Custom header\nhttp.headers(headers -> headers\n    .addHeaderWriter(new StaticHeadersWriter(\"X-Custom-Header\", \"value\"))\n);"
    },
    {
      "id": 59,
      "question": "What is GrantedAuthority vs Role?",
      "answer": "GrantedAuthority:\n• Interface representing permission\n• Any string authority\n• Fine-grained permissions\n• Examples: READ_USER, WRITE_USER, DELETE_USER\n\nRole:\n• Special type of GrantedAuthority\n• Prefixed with \"ROLE_\"\n• Coarse-grained permissions\n• Examples: ROLE_ADMIN, ROLE_USER\n\nRelationship:\n• Roles ARE GrantedAuthorities\n• Not all authorities are roles",
      "explanation": "Use roles for general access levels. Use authorities for specific permissions. Combine both for flexible security.",
      "difficulty": "Easy",
      "code": "// Creating authorities\nList<GrantedAuthority> authorities = new ArrayList<>();\n\n// Roles (with ROLE_ prefix)\nauthorities.add(new SimpleGrantedAuthority(\"ROLE_ADMIN\"));\nauthorities.add(new SimpleGrantedAuthority(\"ROLE_USER\"));\n\n// Fine-grained authorities\nauthorities.add(new SimpleGrantedAuthority(\"READ_USER\"));\nauthorities.add(new SimpleGrantedAuthority(\"WRITE_USER\"));\nauthorities.add(new SimpleGrantedAuthority(\"DELETE_USER\"));\n\n// Check role (adds ROLE_ prefix)\n@PreAuthorize(\"hasRole('ADMIN')\")  // Checks ROLE_ADMIN\npublic void adminMethod() { }\n\n// Check authority (exact match)\n@PreAuthorize(\"hasAuthority('READ_USER')\")  // Checks READ_USER\npublic void readMethod() { }\n\n// Combine both\n@PreAuthorize(\"hasRole('ADMIN') or hasAuthority('DELETE_USER')\")\npublic void deleteUser() { }\n\n// In UserDetails\npublic class CustomUserDetails implements UserDetails {\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        Set<GrantedAuthority> authorities = new HashSet<>();\n        \n        // Add roles\n        user.getRoles().forEach(role -> \n            authorities.add(new SimpleGrantedAuthority(\"ROLE_\" + role.getName()))\n        );\n        \n        // Add permissions\n        user.getPermissions().forEach(permission -> \n            authorities.add(new SimpleGrantedAuthority(permission.getName()))\n        );\n        \n        return authorities;\n    }\n}\n\n// Best practice: Combine for flexibility\n// Roles: ROLE_ADMIN, ROLE_USER, ROLE_MANAGER\n// Permissions: READ_USER, WRITE_USER, DELETE_USER, APPROVE_ORDER"
    },
    {
      "id": 60,
      "question": "How do you implement custom AccessDecisionVoter?",
      "answer": "AccessDecisionVoter: Custom authorization logic.\n\nInterface methods:\n• vote(Authentication, Object, Collection<ConfigAttribute>)\n• supports(ConfigAttribute)\n• supports(Class)\n\nVote results:\n• ACCESS_GRANTED (1)\n• ACCESS_ABSTAIN (0)\n• ACCESS_DENIED (-1)\n\nUse cases:\n• Custom business rules\n• Time-based access\n• Location-based access",
      "explanation": "AccessDecisionVoter allows complex authorization beyond role/authority checks.",
      "difficulty": "Hard",
      "code": "// Custom voter\npublic class TimeBasedVoter implements AccessDecisionVoter<Object> {\n    \n    @Override\n    public int vote(Authentication authentication, \n                    Object object,\n                    Collection<ConfigAttribute> attributes) {\n        \n        // Check if any attribute is time-based\n        for (ConfigAttribute attribute : attributes) {\n            if (\"TIME_RESTRICTED\".equals(attribute.getAttribute())) {\n                LocalTime now = LocalTime.now();\n                LocalTime start = LocalTime.of(9, 0);  // 9 AM\n                LocalTime end = LocalTime.of(17, 0);   // 5 PM\n                \n                if (now.isAfter(start) && now.isBefore(end)) {\n                    return ACCESS_GRANTED;\n                } else {\n                    return ACCESS_DENIED;\n                }\n            }\n        }\n        \n        return ACCESS_ABSTAIN;\n    }\n    \n    @Override\n    public boolean supports(ConfigAttribute attribute) {\n        return \"TIME_RESTRICTED\".equals(attribute.getAttribute());\n    }\n    \n    @Override\n    public boolean supports(Class<?> clazz) {\n        return true;\n    }\n}\n\n// IP-based voter\npublic class IpAddressVoter implements AccessDecisionVoter<Object> {\n    \n    private Set<String> allowedIps = Set.of(\"192.168.1.100\", \"192.168.1.101\");\n    \n    @Override\n    public int vote(Authentication authentication, \n                    Object object,\n                    Collection<ConfigAttribute> attributes) {\n        \n        if (object instanceof FilterInvocation) {\n            FilterInvocation fi = (FilterInvocation) object;\n            String ip = fi.getRequest().getRemoteAddr();\n            \n            if (allowedIps.contains(ip)) {\n                return ACCESS_GRANTED;\n            }\n        }\n        \n        return ACCESS_ABSTAIN;\n    }\n}\n\n// Configure voters\n@Bean\npublic AccessDecisionManager accessDecisionManager() {\n    List<AccessDecisionVoter<?>> voters = Arrays.asList(\n        new RoleVoter(),\n        new AuthenticatedVoter(),\n        new TimeBasedVoter(),\n        new IpAddressVoter()\n    );\n    return new UnanimousBased(voters);  // All must grant\n    // Or: new AffirmativeBased(voters); // One must grant\n    // Or: new ConsensusBased(voters);   // Majority must grant\n}"
    },    {
      "id": 61,
      "question": "How do you implement SSO (Single Sign-On) with Spring Security?",
      "answer": "SSO: One authentication for multiple applications.\n\nApproaches:\n1. OAuth2/OIDC: Modern, REST-based\n2. SAML: Enterprise standard\n3. CAS: Central Authentication Service\n4. Custom JWT: Shared token\n\nComponents:\n• Identity Provider (IdP): Central auth\n• Service Provider (SP): Individual apps\n• Trust relationship",
      "explanation": "SSO improves user experience and centralizes authentication. OAuth2/OIDC most common for modern apps.",
      "difficulty": "Hard",
      "code": "<!-- OAuth2 Client for SSO -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-oauth2-client</artifactId>\n</dependency>\n\n# application.yml - SSO with OAuth2\nspring:\n  security:\n    oauth2:\n      client:\n        registration:\n          keycloak:\n            client-id: my-app\n            client-secret: secret\n            scope: openid,profile,email\n            authorization-grant-type: authorization_code\n            redirect-uri: \"{baseUrl}/login/oauth2/code/{registrationId}\"\n        provider:\n          keycloak:\n            issuer-uri: https://keycloak.example.com/realms/my-realm\n            authorization-uri: https://keycloak.example.com/realms/my-realm/protocol/openid-connect/auth\n            token-uri: https://keycloak.example.com/realms/my-realm/protocol/openid-connect/token\n            user-info-uri: https://keycloak.example.com/realms/my-realm/protocol/openid-connect/userinfo\n            jwk-set-uri: https://keycloak.example.com/realms/my-realm/protocol/openid-connect/certs\n\n@Configuration\npublic class SsoSecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) {\n        http\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/\", \"/public/**\").permitAll()\n                .anyRequest().authenticated()\n            )\n            .oauth2Login(oauth2 -> oauth2\n                .defaultSuccessUrl(\"/dashboard\")\n            );\n        return http.build();\n    }\n}\n\n// Access user info\n@GetMapping(\"/user-info\")\npublic Map<String, Object> getUserInfo(@AuthenticationPrincipal OAuth2User principal) {\n    return principal.getAttributes();\n}"
    },
    {
      "id": 62,
      "question": "What is LDAP authentication and how to implement it?",
      "answer": "LDAP (Lightweight Directory Access Protocol): Enterprise directory service.\n\nFeatures:\n• Centralized user management\n• Hierarchical structure\n• Group-based authorization\n• Active Directory integration\n\nCommon servers:\n• Active Directory (Microsoft)\n• OpenLDAP\n• ApacheDS",
      "explanation": "LDAP common in enterprise for centralized authentication. Integrates with corporate directories.",
      "difficulty": "Medium",
      "code": "<!-- Dependencies -->\n<dependency>\n    <groupId>org.springframework.security</groupId>\n    <artifactId>spring-security-ldap</artifactId>\n</dependency>\n<dependency>\n    <groupId>com.unboundid</groupId>\n    <artifactId>unboundid-ldapsdk</artifactId>\n</dependency>\n\n# application.yml\nspring:\n  ldap:\n    urls: ldap://localhost:389\n    base: dc=example,dc=com\n    username: cn=admin,dc=example,dc=com\n    password: admin\n\n@Configuration\npublic class LdapSecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) {\n        http\n            .authorizeHttpRequests(auth -> auth\n                .anyRequest().authenticated()\n            )\n            .formLogin(Customizer.withDefaults());\n        return http.build();\n    }\n    \n    @Bean\n    public LdapAuthenticationProvider ldapAuthenticationProvider() {\n        BindAuthenticator authenticator = new BindAuthenticator(\n            contextSource());\n        authenticator.setUserDnPatterns(\n            new String[] { \"uid={0},ou=people\" });\n        \n        LdapAuthenticationProvider provider = \n            new LdapAuthenticationProvider(authenticator);\n        provider.setUserDetailsContextMapper(\n            new InetOrgPersonContextMapper());\n        \n        return provider;\n    }\n    \n    @Bean\n    public LdapContextSource contextSource() {\n        LdapContextSource contextSource = new LdapContextSource();\n        contextSource.setUrl(\"ldap://localhost:389\");\n        contextSource.setBase(\"dc=example,dc=com\");\n        contextSource.setUserDn(\"cn=admin,dc=example,dc=com\");\n        contextSource.setPassword(\"admin\");\n        return contextSource;\n    }\n}\n\n// Embedded LDAP for testing\n@Bean\npublic EmbeddedLdapServerContextSourceFactoryBean embeddedLdapServer() {\n    return EmbeddedLdapServerContextSourceFactoryBean.fromEmbeddedLdapServer();\n}"
    },
    {
      "id": 63,
      "question": "How do you implement SAML authentication?",
      "answer": "SAML (Security Assertion Markup Language): XML-based SSO standard.\n\nComponents:\n• Identity Provider (IdP): Authenticates users\n• Service Provider (SP): Your application\n• SAML Assertion: Authentication statement\n\nFlow:\n1. User accesses SP\n2. SP redirects to IdP\n3. User authenticates at IdP\n4. IdP sends SAML assertion\n5. SP validates and grants access",
      "explanation": "SAML common in enterprise SSO. More complex than OAuth2 but widely supported in corporate environments.",
      "difficulty": "Hard",
      "code": "<!-- Dependency -->\n<dependency>\n    <groupId>org.springframework.security</groupId>\n    <artifactId>spring-security-saml2-service-provider</artifactId>\n</dependency>\n\n# application.yml\nspring:\n  security:\n    saml2:\n      relyingparty:\n        registration:\n          okta:\n            entity-id: \"{baseUrl}/saml2/service-provider-metadata/okta\"\n            signing:\n              credentials:\n                - private-key-location: classpath:credentials/private.key\n                  certificate-location: classpath:credentials/certificate.crt\n            assertingparty:\n              entity-id: http://www.okta.com/exk...\n              single-sign-on:\n                url: https://dev-123456.okta.com/app/dev-123456_myapp_1/exk.../sso/saml\n                sign-request: false\n              verification:\n                credentials:\n                  - certificate-location: classpath:credentials/okta.cert\n\n@Configuration\npublic class SamlSecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) {\n        http\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/\", \"/error\").permitAll()\n                .anyRequest().authenticated()\n            )\n            .saml2Login(Customizer.withDefaults())\n            .saml2Logout(Customizer.withDefaults());\n        return http.build();\n    }\n}\n\n// Custom user details from SAML\n@Component\npublic class CustomSaml2UserDetailsService implements Saml2AuthenticatedPrincipalUserDetailsService {\n    \n    @Override\n    public UserDetails loadUser(Saml2AuthenticationToken token) {\n        String username = token.getName();\n        List<String> attributes = token.getSaml2Authentication()\n            .getFirstAttribute(\"groups\");\n        \n        return User.withUsername(username)\n            .password(\"\")\n            .authorities(attributes.stream()\n                .map(SimpleGrantedAuthority::new)\n                .collect(Collectors.toList()))\n            .build();\n    }\n}"
    },
    {
      "id": 64,
      "question": "How do you implement social login (Google, Facebook, GitHub)?",
      "answer": "Social login: OAuth2-based third-party authentication.\n\nProviders:\n• Google\n• Facebook  \n• GitHub\n• LinkedIn\n• Twitter\n\nBenefits:\n• No password management\n• Quick registration\n• Trusted authentication\n• User data access",
      "explanation": "Social login improves user experience. Spring Security provides built-in support for common providers.",
      "difficulty": "Medium",
      "code": "<!-- Dependency -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-oauth2-client</artifactId>\n</dependency>\n\n# application.yml - Multiple providers\nspring:\n  security:\n    oauth2:\n      client:\n        registration:\n          google:\n            client-id: your-google-client-id\n            client-secret: your-google-secret\n            scope:\n              - email\n              - profile\n          \n          github:\n            client-id: your-github-client-id\n            client-secret: your-github-secret\n            scope:\n              - user:email\n              - read:user\n          \n          facebook:\n            client-id: your-facebook-app-id\n            client-secret: your-facebook-secret\n            scope:\n              - email\n              - public_profile\n\n@Configuration\npublic class OAuth2LoginConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) {\n        http\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/\", \"/login\", \"/error\").permitAll()\n                .anyRequest().authenticated()\n            )\n            .oauth2Login(oauth2 -> oauth2\n                .loginPage(\"/login\")\n                .userInfoEndpoint(userInfo -> userInfo\n                    .userService(oAuth2UserService())\n                )\n                .successHandler(oAuth2LoginSuccessHandler())\n            );\n        return http.build();\n    }\n    \n    @Bean\n    public OAuth2UserService<OAuth2UserRequest, OAuth2User> oAuth2UserService() {\n        DefaultOAuth2UserService delegate = new DefaultOAuth2UserService();\n        \n        return request -> {\n            OAuth2User oAuth2User = delegate.loadUser(request);\n            \n            // Extract and save user info\n            String email = oAuth2User.getAttribute(\"email\");\n            String name = oAuth2User.getAttribute(\"name\");\n            String provider = request.getClientRegistration().getRegistrationId();\n            \n            // Create or update local user\n            User user = userService.findOrCreateUser(email, name, provider);\n            \n            return new DefaultOAuth2User(\n                oAuth2User.getAuthorities(),\n                oAuth2User.getAttributes(),\n                \"email\"\n            );\n        };\n    }\n}\n\n// Login page\n<a href=\"/oauth2/authorization/google\">Login with Google</a>\n<a href=\"/oauth2/authorization/github\">Login with GitHub</a>\n<a href=\"/oauth2/authorization/facebook\">Login with Facebook</a>"
    },
    {
      "id": 65,
      "question": "How do you implement refresh token functionality?",
      "answer": "Refresh token: Long-lived token to get new access token.\n\nTokens:\n• Access token: Short-lived (15 min)\n• Refresh token: Long-lived (7 days)\n\nFlow:\n1. Login returns both tokens\n2. Use access token for requests\n3. When expired, use refresh token\n4. Get new access token\n5. Optional: Rotate refresh token",
      "explanation": "Refresh tokens improve security by limiting access token lifetime while maintaining user session.",
      "difficulty": "Hard",
      "code": "@Entity\npublic class RefreshToken {\n    @Id @GeneratedValue\n    private Long id;\n    private String token;\n    private String username;\n    private LocalDateTime expiryDate;\n}\n\n@Service\npublic class RefreshTokenService {\n    \n    @Value(\"${jwt.refresh.expiration}\")\n    private Long refreshExpiration;\n    \n    @Autowired\n    private RefreshTokenRepository refreshTokenRepository;\n    \n    public RefreshToken createRefreshToken(String username) {\n        RefreshToken refreshToken = new RefreshToken();\n        refreshToken.setUsername(username);\n        refreshToken.setToken(UUID.randomUUID().toString());\n        refreshToken.setExpiryDate(\n            LocalDateTime.now().plusSeconds(refreshExpiration));\n        \n        return refreshTokenRepository.save(refreshToken);\n    }\n    \n    public Optional<RefreshToken> findByToken(String token) {\n        return refreshTokenRepository.findByToken(token);\n    }\n    \n    public RefreshToken verifyExpiration(RefreshToken token) {\n        if (token.getExpiryDate().isBefore(LocalDateTime.now())) {\n            refreshTokenRepository.delete(token);\n            throw new TokenRefreshException(\"Refresh token expired\");\n        }\n        return token;\n    }\n    \n    public void deleteByUsername(String username) {\n        refreshTokenRepository.deleteByUsername(username);\n    }\n}\n\n@RestController\n@RequestMapping(\"/api/auth\")\npublic class AuthController {\n    \n    @PostMapping(\"/login\")\n    public ResponseEntity<?> login(@RequestBody LoginRequest request) {\n        // Authenticate\n        Authentication auth = authenticationManager.authenticate(\n            new UsernamePasswordAuthenticationToken(\n                request.getUsername(), request.getPassword()));\n        \n        // Generate tokens\n        String accessToken = jwtUtil.generateAccessToken(auth.getName());\n        RefreshToken refreshToken = refreshTokenService.createRefreshToken(auth.getName());\n        \n        return ResponseEntity.ok(new TokenResponse(\n            accessToken, \n            refreshToken.getToken()\n        ));\n    }\n    \n    @PostMapping(\"/refresh\")\n    public ResponseEntity<?> refreshToken(@RequestBody TokenRefreshRequest request) {\n        String refreshToken = request.getRefreshToken();\n        \n        return refreshTokenService.findByToken(refreshToken)\n            .map(refreshTokenService::verifyExpiration)\n            .map(RefreshToken::getUsername)\n            .map(username -> {\n                String newAccessToken = jwtUtil.generateAccessToken(username);\n                return ResponseEntity.ok(new TokenRefreshResponse(newAccessToken));\n            })\n            .orElseThrow(() -> new TokenRefreshException(\"Invalid refresh token\"));\n    }\n    \n    @PostMapping(\"/logout\")\n    public ResponseEntity<?> logout() {\n        String username = SecurityContextHolder.getContext()\n            .getAuthentication().getName();\n        refreshTokenService.deleteByUsername(username);\n        return ResponseEntity.ok(\"Logged out\");\n    }\n}"
    },
    {
      "id": 66,
      "question": "How do you implement token blacklisting for JWT?",
      "answer": "Token blacklisting: Invalidate JWT before expiration.\n\nNeeded for:\n• Logout\n• Password change\n• Account compromise\n• Permission revocation\n\nApproaches:\n1. Database blacklist\n2. Redis cache\n3. Token versioning\n4. Short expiration + refresh",
      "explanation": "JWT is stateless, so blacklisting requires storage. Use Redis for performance, or avoid with short expiration.",
      "difficulty": "Hard",
      "code": "// Redis-based blacklist\n@Service\npublic class TokenBlacklistService {\n    \n    @Autowired\n    private StringRedisTemplate redisTemplate;\n    \n    @Autowired\n    private JwtUtil jwtUtil;\n    \n    public void blacklistToken(String token) {\n        Date expiration = jwtUtil.extractExpiration(token);\n        long ttl = expiration.getTime() - System.currentTimeMillis();\n        \n        if (ttl > 0) {\n            redisTemplate.opsForValue().set(\n                \"blacklist:\" + token, \n                \"true\", \n                ttl, \n                TimeUnit.MILLISECONDS\n            );\n        }\n    }\n    \n    public boolean isBlacklisted(String token) {\n        return Boolean.TRUE.equals(\n            redisTemplate.hasKey(\"blacklist:\" + token));\n    }\n    \n    public void blacklistAllUserTokens(String username) {\n        // Increment user's token version\n        redisTemplate.opsForValue().increment(\"token_version:\" + username);\n    }\n}\n\n// Filter to check blacklist\n@Component\npublic class JwtAuthenticationFilter extends OncePerRequestFilter {\n    \n    @Autowired\n    private TokenBlacklistService blacklistService;\n    \n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                   HttpServletResponse response,\n                                   FilterChain chain) {\n        \n        String jwt = extractJwtFromRequest(request);\n        \n        if (jwt != null) {\n            // Check blacklist\n            if (blacklistService.isBlacklisted(jwt)) {\n                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n                response.getWriter().write(\"Token has been revoked\");\n                return;\n            }\n            \n            // Validate and authenticate\n            if (jwtUtil.validateToken(jwt)) {\n                // Set authentication\n            }\n        }\n        \n        chain.doFilter(request, response);\n    }\n}\n\n// Logout with blacklisting\n@PostMapping(\"/logout\")\npublic ResponseEntity<?> logout(HttpServletRequest request) {\n    String jwt = extractJwtFromRequest(request);\n    \n    if (jwt != null) {\n        blacklistService.blacklistToken(jwt);\n    }\n    \n    return ResponseEntity.ok(\"Logged out successfully\");\n}\n\n// Blacklist all tokens on password change\n@PostMapping(\"/change-password\")\npublic ResponseEntity<?> changePassword(@RequestBody PasswordChangeRequest request) {\n    String username = SecurityContextHolder.getContext()\n        .getAuthentication().getName();\n    \n    userService.changePassword(username, request.getNewPassword());\n    blacklistService.blacklistAllUserTokens(username);\n    \n    return ResponseEntity.ok(\"Password changed. Please login again.\");\n}"
    },
    {
      "id": 67,
      "question": "How do you implement custom authentication entry point?",
      "answer": "AuthenticationEntryPoint: Handles unauthenticated requests.\n\nUse cases:\n• Custom login redirect\n• API error responses\n• Different behavior per endpoint\n\nDefault:\n• Form login: Redirect to login page\n• HTTP Basic: WWW-Authenticate header\n• REST API: 401 JSON response",
      "explanation": "Custom entry point provides consistent error handling for unauthenticated requests, especially for APIs.",
      "difficulty": "Medium",
      "code": "@Component\npublic class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint {\n    \n    @Override\n    public void commence(HttpServletRequest request,\n                        HttpServletResponse response,\n                        AuthenticationException authException) \n            throws IOException {\n        \n        response.setContentType(\"application/json\");\n        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n        \n        Map<String, Object> errorDetails = new HashMap<>();\n        errorDetails.put(\"timestamp\", LocalDateTime.now().toString());\n        errorDetails.put(\"status\", 401);\n        errorDetails.put(\"error\", \"Unauthorized\");\n        errorDetails.put(\"message\", authException.getMessage());\n        errorDetails.put(\"path\", request.getRequestURI());\n        \n        ObjectMapper mapper = new ObjectMapper();\n        response.getWriter().write(\n            mapper.writeValueAsString(errorDetails));\n    }\n}\n\n// Configure\nhttp\n    .exceptionHandling(ex -> ex\n        .authenticationEntryPoint(customAuthenticationEntryPoint)\n    )\n    .authorizeHttpRequests(auth -> auth\n        .anyRequest().authenticated()\n    );\n\n// Different entry points for different paths\nhttp\n    .securityMatcher(\"/api/**\")\n    .exceptionHandling(ex -> ex\n        .authenticationEntryPoint(apiAuthenticationEntryPoint)  // JSON response\n    )\n    .authorizeHttpRequests(auth -> auth.anyRequest().authenticated());\n\nhttp\n    .securityMatcher(\"/web/**\")\n    .exceptionHandling(ex -> ex\n        .authenticationEntryPoint(\n            new LoginUrlAuthenticationEntryPoint(\"/login\"))  // Redirect\n    )\n    .authorizeHttpRequests(auth -> auth.anyRequest().authenticated());\n\n// Conditional entry point\n@Component\npublic class DelegatingAuthenticationEntryPoint implements AuthenticationEntryPoint {\n    \n    @Override\n    public void commence(HttpServletRequest request,\n                        HttpServletResponse response,\n                        AuthenticationException authException) {\n        \n        if (request.getRequestURI().startsWith(\"/api/\")) {\n            // API: JSON response\n            response.setContentType(\"application/json\");\n            response.setStatus(401);\n            response.getWriter().write(\"{\\\"error\\\":\\\"Unauthorized\\\"}\");\n        } else {\n            // Web: Redirect to login\n            response.sendRedirect(\"/login\");\n        }\n    }\n}"
    },
    {
      "id": 68,
      "question": "How do you implement custom access denied handler?",
      "answer": "AccessDeniedHandler: Handles authorization failures.\n\nWhen triggered:\n• Authenticated but insufficient permissions\n• Role/authority check fails\n• @PreAuthorize denies access\n\nDefault:\n• Form login: Redirect to /error\n• REST API: 403 Forbidden",
      "explanation": "Custom access denied handler provides better user feedback and logging for authorization failures.",
      "difficulty": "Medium",
      "code": "@Component\npublic class CustomAccessDeniedHandler implements AccessDeniedHandler {\n    \n    @Override\n    public void handle(HttpServletRequest request,\n                      HttpServletResponse response,\n                      AccessDeniedException accessDeniedException) \n            throws IOException {\n        \n        Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n        \n        // Log attempt\n        logger.warn(\"User {} attempted to access {} without permission\",\n            auth.getName(), request.getRequestURI());\n        \n        response.setContentType(\"application/json\");\n        response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n        \n        Map<String, Object> errorDetails = new HashMap<>();\n        errorDetails.put(\"timestamp\", LocalDateTime.now().toString());\n        errorDetails.put(\"status\", 403);\n        errorDetails.put(\"error\", \"Forbidden\");\n        errorDetails.put(\"message\", \"You don't have permission to access this resource\");\n        errorDetails.put(\"path\", request.getRequestURI());\n        errorDetails.put(\"user\", auth.getName());\n        errorDetails.put(\"requiredAuthority\", extractRequiredAuthority(request));\n        \n        ObjectMapper mapper = new ObjectMapper();\n        response.getWriter().write(\n            mapper.writeValueAsString(errorDetails));\n    }\n    \n    private String extractRequiredAuthority(HttpServletRequest request) {\n        // Extract from request attributes if available\n        return \"See documentation for required permissions\";\n    }\n}\n\n// Configure\nhttp\n    .exceptionHandling(ex -> ex\n        .accessDeniedHandler(customAccessDeniedHandler)\n    )\n    .authorizeHttpRequests(auth -> auth\n        .requestMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n        .anyRequest().authenticated()\n    );\n\n// Custom page for web apps\n@Component\npublic class WebAccessDeniedHandler implements AccessDeniedHandler {\n    \n    @Override\n    public void handle(HttpServletRequest request,\n                      HttpServletResponse response,\n                      AccessDeniedException exception) {\n        response.sendRedirect(\"/access-denied\");\n    }\n}\n\n@Controller\npublic class ErrorController {\n    @GetMapping(\"/access-denied\")\n    public String accessDenied(Model model) {\n        Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n        model.addAttribute(\"username\", auth.getName());\n        model.addAttribute(\"message\", \"You don't have permission to access this page\");\n        return \"access-denied\";\n    }\n}"
    },
    {
      "id": 69,
      "question": "How do you implement custom logout handler?",
      "answer": "LogoutHandler: Perform cleanup during logout.\n\nInterface:\n• logout(HttpServletRequest, HttpServletResponse, Authentication)\n\nUse cases:\n• Clear caches\n• Blacklist tokens\n• Audit logging\n• Cleanup resources\n• Notify systems\n\nBuilt-in handlers:\n• SecurityContextLogoutHandler\n• CookieClearingLogoutHandler\n• CsrfLogoutHandler",
      "explanation": "Custom logout handler ensures proper cleanup and logging during logout process.",
      "difficulty": "Easy",
      "code": "@Component\npublic class CustomLogoutHandler implements LogoutHandler {\n    \n    @Autowired\n    private TokenBlacklistService tokenBlacklistService;\n    \n    @Autowired\n    private AuditLogService auditLogService;\n    \n    @Autowired\n    private CacheService cacheService;\n    \n    @Override\n    public void logout(HttpServletRequest request,\n                      HttpServletResponse response,\n                      Authentication authentication) {\n        \n        if (authentication == null) {\n            return;\n        }\n        \n        String username = authentication.getName();\n        \n        // Blacklist JWT token\n        String jwt = extractJwtFromRequest(request);\n        if (jwt != null) {\n            tokenBlacklistService.blacklistToken(jwt);\n        }\n        \n        // Clear user cache\n        cacheService.evictUserCache(username);\n        \n        // Audit log\n        auditLogService.logLogout(username, request.getRemoteAddr());\n        \n        // Additional cleanup\n        cleanupUserResources(username);\n        \n        logger.info(\"User {} logged out successfully\", username);\n    }\n    \n    private void cleanupUserResources(String username) {\n        // Custom cleanup logic\n    }\n}\n\n// Configure\nhttp.logout(logout -> logout\n    .logoutUrl(\"/logout\")\n    .addLogoutHandler(customLogoutHandler)\n    .addLogoutHandler(new SecurityContextLogoutHandler())\n    .addLogoutHandler(new CookieClearingLogoutHandler(\"JSESSIONID\", \"remember-me\"))\n    .logoutSuccessHandler(customLogoutSuccessHandler)\n    .permitAll()\n);\n\n// Multiple handlers execute in order\nhttp.logout(logout -> logout\n    .logoutUrl(\"/logout\")\n    .addLogoutHandler((request, response, auth) -> {\n        logger.info(\"Logout handler 1\");\n    })\n    .addLogoutHandler((request, response, auth) -> {\n        logger.info(\"Logout handler 2\");\n    })\n    .addLogoutHandler((request, response, auth) -> {\n        logger.info(\"Logout handler 3\");\n    })\n);"
    },
    {
      "id": 70,
      "question": "What are common Spring Security vulnerabilities and how to prevent them?",
      "answer": "Common vulnerabilities:\n\n1. CSRF: Use CSRF tokens\n2. XSS: Encode output, CSP headers\n3. SQL Injection: Use parameterized queries\n4. Session Fixation: Migrate session on auth\n5. Clickjacking: X-Frame-Options header\n6. Insecure Direct Object Reference: Authorization checks\n7. Weak passwords: Enforce policy\n8. No HTTPS: Use HSTS\n9. Verbose errors: Hide stack traces\n10. Missing authorization: Use @PreAuthorize",
      "explanation": "Spring Security protects against many vulnerabilities by default. Follow best practices for comprehensive security.",
      "difficulty": "Medium",
      "code": "// 1. CSRF Protection (enabled by default)\nhttp.csrf(Customizer.withDefaults());\n\n// 2. Security Headers\nhttp.headers(headers -> headers\n    .frameOptions(frame -> frame.deny())  // Clickjacking\n    .xssProtection(Customizer.withDefaults())  // XSS\n    .contentTypeOptions(Customizer.withDefaults())  // MIME sniffing\n    .httpStrictTransportSecurity(hsts -> hsts\n        .includeSubDomains(true)\n        .maxAgeInSeconds(31536000)\n    )\n    .contentSecurityPolicy(csp -> csp\n        .policyDirectives(\"default-src 'self'; script-src 'self'\")\n    )\n);\n\n// 3. Session Fixation Protection\nhttp.sessionManagement(session -> session\n    .sessionFixation().migrateSession()  // or newSession()\n);\n\n// 4. Password Policy\n@Component\npublic class PasswordValidator {\n    public boolean isStrong(String password) {\n        return password.length() >= 12 &&\n               password.matches(\".*[A-Z].*\") &&\n               password.matches(\".*[a-z].*\") &&\n               password.matches(\".*\\\\d.*\") &&\n               password.matches(\".*[!@#$%^&*].*\");\n    }\n}\n\n// 5. Authorization checks\n@PreAuthorize(\"#id == authentication.principal.id or hasRole('ADMIN')\")\npublic User getUser(Long id) {\n    return userRepository.findById(id).orElseThrow();\n}\n\n// 6. Error handling (don't leak info)\n@ExceptionHandler(Exception.class)\npublic ResponseEntity<ErrorResponse> handleException(Exception ex) {\n    // Don't expose stack trace in production\n    return ResponseEntity.status(500)\n        .body(new ErrorResponse(\"An error occurred\"));\n}\n\n// 7. Rate limiting\nhttp.addFilterBefore(rateLimitingFilter, \n    UsernamePasswordAuthenticationFilter.class);\n\n// 8. Input validation\npublic class UserRequest {\n    @NotBlank\n    @Size(min = 3, max = 50)\n    @Pattern(regexp = \"^[a-zA-Z0-9_-]+$\")\n    private String username;\n    \n    @NotBlank\n    @Email\n    private String email;\n}\n\n// 9. SQL Injection Prevention\n@Query(\"SELECT u FROM User u WHERE u.email = :email\")  // Parameterized\nUser findByEmail(@Param(\"email\") String email);\n\n// 10. Secure defaults\n// - All endpoints authenticated by default\n// - HTTPS required in production\n// - Strong password encoding (BCrypt)\n// - Secure session cookies (httpOnly, secure)"
    },    {
      "id": 71,
      "question": "How do you implement database-based session management?",
      "answer": "Database session management: Store sessions in database instead of memory.\n\nBenefits:\n• Session persistence across restarts\n• Support for multiple servers\n• Session analytics\n• Manual session management\n\nOptions:\n• JDBC Session\n• Redis Session\n• MongoDB Session\n• Hazelcast Session",
      "explanation": "Database sessions enable horizontal scaling and session persistence. Use Redis for performance.",
      "difficulty": "Medium",
      "code": "<!-- Spring Session JDBC -->\n<dependency>\n    <groupId>org.springframework.session</groupId>\n    <artifactId>spring-session-jdbc</artifactId>\n</dependency>\n\n# application.yml\nspring:\n  session:\n    store-type: jdbc\n    jdbc:\n      initialize-schema: always\n    timeout: 30m\n\n@Configuration\n@EnableJdbcHttpSession\npublic class SessionConfig {\n}\n\n// Schema created automatically\nCREATE TABLE SPRING_SESSION (\n    PRIMARY_ID CHAR(36) NOT NULL,\n    SESSION_ID CHAR(36) NOT NULL,\n    CREATION_TIME BIGINT NOT NULL,\n    LAST_ACCESS_TIME BIGINT NOT NULL,\n    MAX_INACTIVE_INTERVAL INT NOT NULL,\n    EXPIRY_TIME BIGINT NOT NULL,\n    PRINCIPAL_NAME VARCHAR(100),\n    PRIMARY KEY (PRIMARY_ID)\n);\n\n<!-- Redis Session (Recommended) -->\n<dependency>\n    <groupId>org.springframework.session</groupId>\n    <artifactId>spring-session-data-redis</artifactId>\n</dependency>\n\nspring:\n  session:\n    store-type: redis\n  redis:\n    host: localhost\n    port: 6379\n\n@Configuration\n@EnableRedisHttpSession\npublic class RedisSessionConfig {\n}\n\n// Access session\n@GetMapping(\"/session-info\")\npublic Map<String, Object> getSessionInfo(HttpSession session) {\n    Map<String, Object> info = new HashMap<>();\n    info.put(\"id\", session.getId());\n    info.put(\"creationTime\", session.getCreationTime());\n    info.put(\"lastAccessedTime\", session.getLastAccessedTime());\n    info.put(\"maxInactiveInterval\", session.getMaxInactiveInterval());\n    return info;\n}"
    },
    {
      "id": 72,
      "question": "How do you implement microservices security with Spring Cloud?",
      "answer": "Microservices security challenges:\n\n• Service-to-service auth\n• API Gateway security\n• Distributed sessions\n• Token propagation\n• Service discovery\n\nSolutions:\n• API Gateway: Centralized auth\n• JWT: Stateless tokens\n• OAuth2: Authorization\n• Service mesh: mTLS",
      "explanation": "Microservices need distributed security. API Gateway handles external auth, JWT for internal.",
      "difficulty": "Hard",
      "code": "<!-- API Gateway Security -->\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-gateway</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>\n</dependency>\n\n// API Gateway Config\n@Configuration\npublic class GatewaySecurityConfig {\n    \n    @Bean\n    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n        http\n            .csrf(csrf -> csrf.disable())\n            .authorizeExchange(exchange -> exchange\n                .pathMatchers(\"/api/public/**\").permitAll()\n                .pathMatchers(\"/api/users/**\").hasRole(\"USER\")\n                .pathMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\n                .anyExchange().authenticated()\n            )\n            .oauth2ResourceServer(oauth2 -> oauth2.jwt(Customizer.withDefaults()));\n        return http.build();\n    }\n}\n\n// Token Relay (forward JWT to downstream)\nspring:\n  cloud:\n    gateway:\n      routes:\n        - id: user-service\n          uri: lb://USER-SERVICE\n          predicates:\n            - Path=/api/users/**\n          filters:\n            - TokenRelay\n\n// Service-to-service with Feign\n@FeignClient(name = \"user-service\")\npublic interface UserServiceClient {\n    @GetMapping(\"/users/{id}\")\n    User getUser(@PathVariable Long id);\n}\n\n@Configuration\npublic class FeignConfig {\n    @Bean\n    public RequestInterceptor requestInterceptor() {\n        return template -> {\n            Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n            if (auth != null && auth.getCredentials() instanceof String) {\n                String token = (String) auth.getCredentials();\n                template.header(\"Authorization\", \"Bearer \" + token);\n            }\n        };\n    }\n}\n\n// Resource Server (Microservice)\n@Configuration\npublic class ResourceServerConfig {\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) {\n        http\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/actuator/health\").permitAll()\n                .anyRequest().authenticated()\n            )\n            .oauth2ResourceServer(oauth2 -> oauth2.jwt(Customizer.withDefaults()));\n        return http.build();\n    }\n}"
    },
    {
      "id": 73,
      "question": "How do you implement custom security filter ordering?",
      "answer": "Filter ordering: Control filter execution sequence.\n\nMethods:\n• addFilterBefore(): Before existing filter\n• addFilterAfter(): After existing filter\n• addFilterAt(): Replace filter position\n\nCommon positions:\n• Before authentication filters\n• After authentication filters\n• Before authorization filter\n\nStandard filter order managed by FilterComparator.",
      "explanation": "Custom filters must be positioned correctly in chain. Order matters for security logic execution.",
      "difficulty": "Medium",
      "code": "// Add filter before\nhttp.addFilterBefore(customFilter, \n    UsernamePasswordAuthenticationFilter.class);\n\n// Add filter after\nhttp.addFilterAfter(customFilter, \n    BasicAuthenticationFilter.class);\n\n// Add filter at position (replaces)\nhttp.addFilterAt(customFilter, \n    UsernamePasswordAuthenticationFilter.class);\n\n// Multiple custom filters\nhttp\n    .addFilterBefore(requestLoggingFilter, \n        UsernamePasswordAuthenticationFilter.class)\n    .addFilterBefore(apiKeyAuthFilter, \n        UsernamePasswordAuthenticationFilter.class)\n    .addFilterAfter(auditFilter, \n        FilterSecurityInterceptor.class);\n\n// Custom filter with @Order\n@Component\n@Order(Ordered.HIGHEST_PRECEDENCE)\npublic class HighPriorityFilter extends OncePerRequestFilter {\n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                   HttpServletResponse response,\n                                   FilterChain chain) {\n        // Executes first\n        chain.doFilter(request, response);\n    }\n}\n\n// Standard filter order (for reference)\n// 1. ChannelProcessingFilter\n// 2. SecurityContextPersistenceFilter\n// 3. ConcurrentSessionFilter\n// 4. Authentication filters (UsernamePassword, Basic, etc.)\n// 5. SecurityContextHolderAwareRequestFilter\n// 6. JaasApiIntegrationFilter\n// 7. RememberMeAuthenticationFilter\n// 8. AnonymousAuthenticationFilter\n// 9. SessionManagementFilter\n// 10. ExceptionTranslationFilter\n// 11. FilterSecurityInterceptor\n\n// Example: Request ID filter (before all)\nhttp.addFilterBefore(\n    new RequestIdFilter(), \n    ChannelProcessingFilter.class\n);\n\n// Example: Audit filter (after all)\nhttp.addFilterAfter(\n    new AuditFilter(), \n    FilterSecurityInterceptor.class\n);"
    },
    {
      "id": 74,
      "question": "How do you implement custom AccessDecisionManager?",
      "answer": "AccessDecisionManager: Makes final authorization decision.\n\nStrategies:\n• AffirmativeBased: One voter grants (default)\n• ConsensusBased: Majority grants\n• UnanimousBased: All voters grant\n\nInterface:\n• decide(): Makes decision\n• supports(): Check if supported\n\nCustom logic:\n• Complex voting\n• Custom strategies\n• Business rules",
      "explanation": "AccessDecisionManager coordinates multiple voters for authorization decision.",
      "difficulty": "Hard",
      "code": "public class CustomAccessDecisionManager implements AccessDecisionManager {\n    \n    private List<AccessDecisionVoter<?>> voters;\n    \n    public CustomAccessDecisionManager(List<AccessDecisionVoter<?>> voters) {\n        this.voters = voters;\n    }\n    \n    @Override\n    public void decide(Authentication authentication, \n                      Object object,\n                      Collection<ConfigAttribute> configAttributes) {\n        \n        int grant = 0;\n        int deny = 0;\n        int abstain = 0;\n        \n        for (AccessDecisionVoter voter : voters) {\n            int result = voter.vote(authentication, object, configAttributes);\n            \n            switch (result) {\n                case AccessDecisionVoter.ACCESS_GRANTED:\n                    grant++;\n                    break;\n                case AccessDecisionVoter.ACCESS_DENIED:\n                    deny++;\n                    break;\n                default:\n                    abstain++;\n            }\n        }\n        \n        // Custom logic: Require 2 grants and no denies\n        if (grant >= 2 && deny == 0) {\n            return;  // Access granted\n        }\n        \n        throw new AccessDeniedException(\"Access denied by custom decision manager\");\n    }\n    \n    @Override\n    public boolean supports(ConfigAttribute attribute) {\n        return voters.stream()\n            .anyMatch(voter -> voter.supports(attribute));\n    }\n    \n    @Override\n    public boolean supports(Class<?> clazz) {\n        return voters.stream()\n            .anyMatch(voter -> voter.supports(clazz));\n    }\n}\n\n// Configure\n@Bean\npublic AccessDecisionManager accessDecisionManager() {\n    List<AccessDecisionVoter<?>> voters = Arrays.asList(\n        new RoleVoter(),\n        new AuthenticatedVoter(),\n        new CustomBusinessRuleVoter()\n    );\n    \n    // Built-in strategies\n    // return new AffirmativeBased(voters);  // One grant = access\n    // return new ConsensusBased(voters);    // Majority = access\n    // return new UnanimousBased(voters);    // All grant = access\n    \n    // Custom strategy\n    return new CustomAccessDecisionManager(voters);\n}\n\n// Use in security config (legacy approach)\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n    http\n        .authorizeHttpRequests()\n        .anyRequest().authenticated()\n        .accessDecisionManager(accessDecisionManager());\n    return http.build();\n}"
    },
    {
      "id": 75,
      "question": "How do you implement geolocation-based access control?",
      "answer": "Geolocation access control: Restrict by user location.\n\nData sources:\n• IP geolocation APIs\n• GPS coordinates\n• Device location\n\nUse cases:\n• Compliance (GDPR, data residency)\n• Fraud prevention\n• Regional restrictions\n• Office-only access\n\nImplementation:\n• Custom filter\n• IP lookup service\n• AccessDecisionVoter",
      "explanation": "Geolocation adds context-based security. Useful for compliance and fraud prevention.",
      "difficulty": "Hard",
      "code": "// Geolocation service\n@Service\npublic class GeolocationService {\n    \n    public String getCountryCode(String ipAddress) {\n        // Use IP geolocation API (MaxMind, IPInfo, etc.)\n        // This is a simplified example\n        if (ipAddress.startsWith(\"192.168\")) {\n            return \"US\";  // Example\n        }\n        return apiClient.getCountryCode(ipAddress);\n    }\n    \n    public boolean isAllowedCountry(String countryCode) {\n        Set<String> allowed = Set.of(\"US\", \"CA\", \"UK\", \"DE\", \"FR\");\n        return allowed.contains(countryCode);\n    }\n    \n    public boolean isBlockedCountry(String countryCode) {\n        Set<String> blocked = Set.of(\"XX\", \"YY\");  // Blocked countries\n        return blocked.contains(countryCode);\n    }\n}\n\n// Geolocation filter\n@Component\npublic class GeolocationFilter extends OncePerRequestFilter {\n    \n    @Autowired\n    private GeolocationService geolocationService;\n    \n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                   HttpServletResponse response,\n                                   FilterChain chain) {\n        \n        String clientIp = getClientIp(request);\n        String countryCode = geolocationService.getCountryCode(clientIp);\n        \n        // Store in request for later use\n        request.setAttribute(\"countryCode\", countryCode);\n        \n        // Block if from blocked country\n        if (geolocationService.isBlockedCountry(countryCode)) {\n            response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n            response.getWriter().write(\n                \"Access denied from country: \" + countryCode);\n            return;\n        }\n        \n        chain.doFilter(request, response);\n    }\n    \n    private String getClientIp(HttpServletRequest request) {\n        String ip = request.getHeader(\"X-Forwarded-For\");\n        if (ip == null || ip.isEmpty()) {\n            ip = request.getRemoteAddr();\n        }\n        return ip.split(\",\")[0].trim();\n    }\n}\n\n// Geolocation voter\npublic class GeolocationVoter implements AccessDecisionVoter<FilterInvocation> {\n    \n    @Autowired\n    private GeolocationService geolocationService;\n    \n    @Override\n    public int vote(Authentication authentication, \n                    FilterInvocation fi,\n                    Collection<ConfigAttribute> attributes) {\n        \n        HttpServletRequest request = fi.getRequest();\n        String clientIp = getClientIp(request);\n        String countryCode = geolocationService.getCountryCode(clientIp);\n        \n        if (geolocationService.isAllowedCountry(countryCode)) {\n            return ACCESS_GRANTED;\n        }\n        \n        return ACCESS_DENIED;\n    }\n}\n\n// Method-level with SpEL\n@Component(\"geoChecker\")\npublic class GeolocationChecker {\n    @Autowired\n    private GeolocationService geolocationService;\n    \n    public boolean isAllowedLocation(HttpServletRequest request) {\n        String ip = getClientIp(request);\n        String country = geolocationService.getCountryCode(ip);\n        return geolocationService.isAllowedCountry(country);\n    }\n}\n\n@PreAuthorize(\"@geoChecker.isAllowedLocation(#request)\")\npublic void sensitiveOperation(HttpServletRequest request) {\n    // Only accessible from allowed countries\n}"
    },
    {
      "id": 76,
      "question": "How do you implement API versioning with security?",
      "answer": "API versioning with security:\n\nVersioning strategies:\n• URI versioning: /api/v1/users\n• Header versioning: Accept: application/vnd.api.v1+json\n• Query parameter: /api/users?version=1\n\nSecurity considerations:\n• Different auth per version\n• Deprecation policies\n• Version-specific permissions\n• Migration period",
      "explanation": "Versioned APIs may have different security requirements. Configure security per version.",
      "difficulty": "Medium",
      "code": "// URI-based versioning security\n@Configuration\npublic class VersionedSecurityConfig {\n    \n    @Bean\n    @Order(1)\n    public SecurityFilterChain apiV1SecurityFilterChain(HttpSecurity http) throws Exception {\n        http\n            .securityMatcher(\"/api/v1/**\")\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/api/v1/public/**\").permitAll()\n                .requestMatchers(\"/api/v1/**\").hasRole(\"USER_V1\")\n            )\n            .httpBasic(Customizer.withDefaults());  // V1 uses Basic Auth\n        return http.build();\n    }\n    \n    @Bean\n    @Order(2)\n    public SecurityFilterChain apiV2SecurityFilterChain(HttpSecurity http) throws Exception {\n        http\n            .securityMatcher(\"/api/v2/**\")\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/api/v2/public/**\").permitAll()\n                .requestMatchers(\"/api/v2/**\").authenticated()\n            )\n            .oauth2ResourceServer(oauth2 -> oauth2.jwt(Customizer.withDefaults()));  // V2 uses JWT\n        return http.build();\n    }\n}\n\n// Controller versioning\n@RestController\n@RequestMapping(\"/api/v1\")\npublic class UserControllerV1 {\n    @GetMapping(\"/users\")\n    @PreAuthorize(\"hasRole('USER')\")\n    public List<UserV1> getUsers() {\n        return userService.getAllUsersV1();\n    }\n}\n\n@RestController\n@RequestMapping(\"/api/v2\")\npublic class UserControllerV2 {\n    @GetMapping(\"/users\")\n    @PreAuthorize(\"hasAuthority('READ_USER') and hasRole('USER_V2')\")\n    public Page<UserV2> getUsers(Pageable pageable) {\n        return userService.getAllUsersV2(pageable);\n    }\n}\n\n// Header-based versioning\n@Component\npublic class ApiVersionFilter extends OncePerRequestFilter {\n    \n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                   HttpServletResponse response,\n                                   FilterChain chain) {\n        \n        String acceptHeader = request.getHeader(\"Accept\");\n        String version = extractVersion(acceptHeader);  // v1, v2, etc.\n        \n        request.setAttribute(\"apiVersion\", version);\n        \n        // Apply version-specific security\n        if (\"v1\".equals(version) && isDeprecated()) {\n            response.setHeader(\"X-API-Deprecated\", \"true\");\n            response.setHeader(\"X-API-Sunset\", \"2024-12-31\");\n        }\n        \n        chain.doFilter(request, response);\n    }\n}\n\n// Deprecation with security\n@GetMapping(\"/api/v1/legacy\")\n@Deprecated\n@PreAuthorize(\"hasRole('LEGACY_USER')\")\npublic Response legacyEndpoint() {\n    return Response.withWarning(\"This endpoint is deprecated\");\n}"
    },
    {
      "id": 77,
      "question": "How do you implement security for GraphQL APIs?",
      "answer": "GraphQL security challenges:\n\n• Field-level authorization\n• Query depth/complexity limits\n• Introspection control\n• Mutation security\n• N+1 query problem\n\nSecurity layers:\n• HTTP layer: Standard Spring Security\n• Field layer: Custom annotations\n• Data loader: Batch authorization",
      "explanation": "GraphQL needs field-level security. Unlike REST, single endpoint requires fine-grained control.",
      "difficulty": "Hard",
      "code": "<!-- Dependencies -->\n<dependency>\n    <groupId>com.graphql-java-kickstart</groupId>\n    <artifactId>graphql-spring-boot-starter</artifactId>\n</dependency>\n<dependency>\n    <groupId>com.graphql-java-kickstart</groupId>\n    <artifactId>graphql-java-tools</artifactId>\n</dependency>\n\n// HTTP-level security\n@Configuration\npublic class GraphQLSecurityConfig {\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) {\n        http\n            .csrf(csrf -> csrf.disable())\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/graphql\").authenticated()\n                .requestMatchers(\"/graphiql\").hasRole(\"ADMIN\")\n            )\n            .oauth2ResourceServer(oauth2 -> oauth2.jwt(Customizer.withDefaults()));\n        return http.build();\n    }\n}\n\n// Field-level security annotation\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Secured {\n    String[] value();\n}\n\n// GraphQL resolver with security\n@Component\npublic class UserResolver implements GraphQLQueryResolver {\n    \n    @Secured(\"ROLE_USER\")\n    public List<User> users() {\n        return userService.findAll();\n    }\n    \n    @Secured(\"ROLE_ADMIN\")\n    public User user(Long id) {\n        return userService.findById(id);\n    }\n}\n\n// Security interceptor\n@Component\npublic class GraphQLSecurityInstrumentation extends SimpleInstrumentation {\n    \n    @Override\n    public DataFetcher<?> instrumentDataFetcher(\n            DataFetcher<?> dataFetcher,\n            InstrumentationFieldFetchParameters parameters) {\n        \n        return environment -> {\n            GraphQLFieldDefinition field = environment.getFieldDefinition();\n            Secured secured = field.getDefinition().getDirective(\"secured\");\n            \n            if (secured != null) {\n                Authentication auth = SecurityContextHolder.getContext()\n                    .getAuthentication();\n                \n                if (auth == null || !hasRequiredRoles(auth, secured.value())) {\n                    throw new AccessDeniedException(\"Insufficient permissions\");\n                }\n            }\n            \n            return dataFetcher.get(environment);\n        };\n    }\n}\n\n// GraphQL schema with security directive\ntype Query {\n    users: [User!]! @secured(roles: [\"ROLE_USER\"])\n    user(id: ID!): User @secured(roles: [\"ROLE_ADMIN\"])\n}\n\ntype Mutation {\n    createUser(input: CreateUserInput!): User @secured(roles: [\"ROLE_ADMIN\"])\n    updateUser(id: ID!, input: UpdateUserInput!): User @secured(roles: [\"ROLE_ADMIN\"])\n}\n\n// Complexity limit\n@Bean\npublic GraphQLQueryComplexityInstrumentation complexityInstrumentation() {\n    return new GraphQLQueryComplexityInstrumentation(100);\n}\n\n// Disable introspection in production\ngraphql:\n  servlet:\n    exception-handlers-enabled: true\n  tools:\n    introspection-enabled: false"
    },
    {
      "id": 78,
      "question": "How do you implement custom UserDetails with additional fields?",
      "answer": "Custom UserDetails: Extend with app-specific fields.\n\nAdditional fields:\n• Email, phone\n• Profile data\n• Business attributes\n• Custom authorities structure\n\nApproaches:\n1. Implement UserDetails\n2. Extend User class\n3. Composition pattern\n\nAccess:\n• @AuthenticationPrincipal\n• SecurityContextHolder",
      "explanation": "Custom UserDetails includes business data beyond username/password. Accessible throughout application.",
      "difficulty": "Easy",
      "code": "// Custom UserDetails implementation\npublic class CustomUserDetails implements UserDetails {\n    \n    private final Long id;\n    private final String username;\n    private final String password;\n    private final String email;\n    private final String firstName;\n    private final String lastName;\n    private final String phoneNumber;\n    private final String department;\n    private final boolean enabled;\n    private final boolean accountNonLocked;\n    private final LocalDateTime lastLoginDate;\n    private final Set<GrantedAuthority> authorities;\n    \n    // Constructor from entity\n    public CustomUserDetails(User user) {\n        this.id = user.getId();\n        this.username = user.getUsername();\n        this.password = user.getPassword();\n        this.email = user.getEmail();\n        this.firstName = user.getFirstName();\n        this.lastName = user.getLastName();\n        this.phoneNumber = user.getPhoneNumber();\n        this.department = user.getDepartment();\n        this.enabled = user.isEnabled();\n        this.accountNonLocked = !user.isLocked();\n        this.lastLoginDate = user.getLastLoginDate();\n        this.authorities = user.getRoles().stream()\n            .map(role -> new SimpleGrantedAuthority(role.getName()))\n            .collect(Collectors.toSet());\n    }\n    \n    // UserDetails methods\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        return authorities;\n    }\n    \n    @Override\n    public String getPassword() {\n        return password;\n    }\n    \n    @Override\n    public String getUsername() {\n        return username;\n    }\n    \n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n    \n    @Override\n    public boolean isAccountNonLocked() {\n        return accountNonLocked;\n    }\n    \n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n    \n    @Override\n    public boolean isEnabled() {\n        return enabled;\n    }\n    \n    // Custom getters\n    public Long getId() {\n        return id;\n    }\n    \n    public String getEmail() {\n        return email;\n    }\n    \n    public String getFullName() {\n        return firstName + \" \" + lastName;\n    }\n    \n    public String getDepartment() {\n        return department;\n    }\n}\n\n// Usage in controller\n@GetMapping(\"/profile\")\npublic UserProfile getProfile(@AuthenticationPrincipal CustomUserDetails user) {\n    return UserProfile.builder()\n        .id(user.getId())\n        .username(user.getUsername())\n        .email(user.getEmail())\n        .fullName(user.getFullName())\n        .department(user.getDepartment())\n        .build();\n}\n\n// In service\n@Service\npublic class ProfileService {\n    public void updateProfile(ProfileUpdateRequest request) {\n        CustomUserDetails user = (CustomUserDetails) SecurityContextHolder\n            .getContext().getAuthentication().getPrincipal();\n        \n        Long userId = user.getId();\n        String email = user.getEmail();\n        \n        // Business logic\n    }\n}"
    },
    {
      "id": 79,
      "question": "How do you implement security for server-sent events (SSE)?",
      "answer": "SSE security: Authenticate streaming connections.\n\nChallenges:\n• Long-lived connections\n• Token in query param (can't set header)\n• Connection authentication\n• Event authorization\n\nSolutions:\n• JWT in query parameter\n• Session-based auth\n• Custom authentication\n• Per-event filtering",
      "explanation": "SSE needs special handling - browsers can't set headers. Use token in query or session-based auth.",
      "difficulty": "Hard",
      "code": "// SSE Controller\n@RestController\n@RequestMapping(\"/api/events\")\npublic class EventController {\n    \n    @GetMapping(\"/stream\")\n    public SseEmitter streamEvents(\n            @RequestParam(\"token\") String token) {\n        \n        // Validate token\n        if (!jwtUtil.validateToken(token)) {\n            throw new UnauthorizedException(\"Invalid token\");\n        }\n        \n        String username = jwtUtil.extractUsername(token);\n        \n        SseEmitter emitter = new SseEmitter(Long.MAX_VALUE);\n        \n        // Register emitter\n        sseService.addEmitter(username, emitter);\n        \n        emitter.onCompletion(() -> sseService.removeEmitter(username, emitter));\n        emitter.onTimeout(() -> sseService.removeEmitter(username, emitter));\n        \n        return emitter;\n    }\n}\n\n// SSE Service\n@Service\npublic class SseService {\n    \n    private final Map<String, Set<SseEmitter>> emitters = new ConcurrentHashMap<>();\n    \n    public void addEmitter(String username, SseEmitter emitter) {\n        emitters.computeIfAbsent(username, k -> ConcurrentHashMap.newKeySet())\n            .add(emitter);\n    }\n    \n    public void removeEmitter(String username, SseEmitter emitter) {\n        Set<SseEmitter> userEmitters = emitters.get(username);\n        if (userEmitters != null) {\n            userEmitters.remove(emitter);\n        }\n    }\n    \n    public void sendEventToUser(String username, Object data) {\n        Set<SseEmitter> userEmitters = emitters.get(username);\n        if (userEmitters != null) {\n            userEmitters.forEach(emitter -> {\n                try {\n                    emitter.send(SseEmitter.event()\n                        .name(\"message\")\n                        .data(data));\n                } catch (IOException e) {\n                    emitter.completeWithError(e);\n                }\n            });\n        }\n    }\n    \n    public void broadcastEvent(Object data, Predicate<String> userFilter) {\n        emitters.forEach((username, userEmitters) -> {\n            if (userFilter.test(username)) {\n                userEmitters.forEach(emitter -> {\n                    try {\n                        emitter.send(data);\n                    } catch (IOException e) {\n                        emitter.completeWithError(e);\n                    }\n                });\n            }\n        });\n    }\n}\n\n// Security config\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) {\n    http\n        .authorizeHttpRequests(auth -> auth\n            .requestMatchers(\"/api/events/stream\").permitAll()  // Auth in controller\n            .anyRequest().authenticated()\n        );\n    return http.build();\n}\n\n// Client-side\nconst token = localStorage.getItem('jwt');\nconst eventSource = new EventSource(`/api/events/stream?token=${token}`);\n\neventSource.addEventListener('message', (event) => {\n    console.log('Received:', event.data);\n});\n\neventSource.onerror = (error) => {\n    console.error('SSE error:', error);\n    eventSource.close();\n};"
    },
    {
      "id": 80,
      "question": "What are Spring Security best practices?",
      "answer": "Security best practices:\n\n1. Use HTTPS everywhere\n2. Strong password encoding (BCrypt)\n3. Enable CSRF for form-based\n4. Disable CSRF for stateless APIs\n5. Use @PreAuthorize over URL patterns\n6. Least privilege principle\n7. Short-lived access tokens\n8. Refresh tokens for long sessions\n9. Rate limiting on login\n10. Audit logging\n11. Security headers enabled\n12. Input validation\n13. Parameterized queries\n14. Hide error details in production\n15. Regular security updates",
      "explanation": "Follow defense-in-depth approach. Layer multiple security controls for comprehensive protection.",
      "difficulty": "Easy",
      "code": "// 1. Comprehensive security configuration\n@Configuration\n@EnableWebSecurity\n@EnableMethodSecurity(prePostEnabled = true)\npublic class SecurityBestPractices {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            // CSRF (enable for form-based, disable for stateless APIs)\n            .csrf(csrf -> csrf\n                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())\n            )\n            \n            // Security headers\n            .headers(headers -> headers\n                .frameOptions(frame -> frame.deny())\n                .xssProtection(Customizer.withDefaults())\n                .contentSecurityPolicy(csp -> csp\n                    .policyDirectives(\"default-src 'self'\")\n                )\n                .httpStrictTransportSecurity(hsts -> hsts\n                    .includeSubDomains(true)\n                    .maxAgeInSeconds(31536000)\n                )\n            )\n            \n            // Session management\n            .sessionManagement(session -> session\n                .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)\n                .sessionFixation().migrateSession()\n                .maximumSessions(1)\n                    .maxSessionsPreventsLogin(false)\n            )\n            \n            // Authorization\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/public/**\", \"/error\").permitAll()\n                .anyRequest().authenticated()\n            )\n            \n            .formLogin(Customizer.withDefaults());\n        \n        return http.build();\n    }\n    \n    // 2. Strong password encoder\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder(12);  // Higher strength in production\n    }\n    \n    // 3. Password policy\n    @Bean\n    public PasswordValidator passwordValidator() {\n        return new PasswordValidator(\n            12,  // Min length\n            true,  // Require uppercase\n            true,  // Require lowercase\n            true,  // Require digit\n            true   // Require special char\n        );\n    }\n}\n\n// 4. Use method security\n@Service\npublic class UserService {\n    \n    @PreAuthorize(\"hasRole('ADMIN') or #userId == authentication.principal.id\")\n    public User getUser(Long userId) {\n        return userRepository.findById(userId).orElseThrow();\n    }\n    \n    @PreAuthorize(\"hasRole('ADMIN')\")\n    public void deleteUser(Long userId) {\n        userRepository.deleteById(userId);\n    }\n}\n\n// 5. Input validation\npublic class CreateUserRequest {\n    @NotBlank\n    @Size(min = 3, max = 50)\n    @Pattern(regexp = \"^[a-zA-Z0-9_-]+$\")\n    private String username;\n    \n    @NotBlank\n    @Email\n    private String email;\n    \n    @NotBlank\n    @StrongPassword\n    private String password;\n}\n\n// 6. Audit logging\n@Aspect\n@Component\npublic class SecurityAuditAspect {\n    @AfterReturning(\"@annotation(PreAuthorize)\")\n    public void auditSecuredMethod(JoinPoint joinPoint) {\n        String username = SecurityContextHolder.getContext()\n            .getAuthentication().getName();\n        logger.info(\"User {} accessed {}\", \n            username, joinPoint.getSignature().getName());\n    }\n}\n\n// 7. Error handling (don't leak info)\n@RestControllerAdvice\npublic class SecurityExceptionHandler {\n    @ExceptionHandler(AccessDeniedException.class)\n    public ResponseEntity<ErrorResponse> handleAccessDenied(Exception ex) {\n        return ResponseEntity.status(403)\n            .body(new ErrorResponse(\"Access denied\"));  // No details\n    }\n}"
    },    {
      "id": 81,
      "question": "How do you implement multi-tenancy security?",
      "answer": "Multi-tenancy security patterns:\n\n1. Tenant isolation:\n   • Separate databases (most secure)\n   • Separate schemas (balanced)\n   • Shared schema with tenant ID (least secure)\n\n2. Security concerns:\n   • Tenant identification\n   • Cross-tenant access prevention\n   • Tenant-specific configurations\n   • Data isolation\n\n3. Implementation:\n   • Tenant context\n   • Request filters\n   • Data access controls",
      "explanation": "Multi-tenancy requires strict data isolation. Tenant ID must be validated on every request.",
      "difficulty": "Hard",
      "code": "// Tenant context\n@Component\npublic class TenantContext {\n    private static final ThreadLocal<String> currentTenant = new ThreadLocal<>();\n    \n    public static void setTenantId(String tenantId) {\n        currentTenant.set(tenantId);\n    }\n    \n    public static String getTenantId() {\n        return currentTenant.get();\n    }\n    \n    public static void clear() {\n        currentTenant.remove();\n    }\n}\n\n// Tenant resolution filter\n@Component\n@Order(Ordered.HIGHEST_PRECEDENCE)\npublic class TenantFilter extends OncePerRequestFilter {\n    \n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                   HttpServletResponse response,\n                                   FilterChain chain) {\n        try {\n            // Extract tenant from different sources\n            String tenantId = resolveTenantId(request);\n            \n            if (tenantId == null) {\n                response.sendError(400, \"Tenant ID required\");\n                return;\n            }\n            \n            // Validate tenant exists\n            if (!tenantService.tenantExists(tenantId)) {\n                response.sendError(404, \"Tenant not found\");\n                return;\n            }\n            \n            TenantContext.setTenantId(tenantId);\n            chain.doFilter(request, response);\n        } finally {\n            TenantContext.clear();\n        }\n    }\n    \n    private String resolveTenantId(HttpServletRequest request) {\n        // Option 1: Subdomain (tenant1.app.com)\n        String host = request.getServerName();\n        if (host.contains(\".\")) {\n            return host.split(\"\\\\.\")[0];\n        }\n        \n        // Option 2: Header\n        String header = request.getHeader(\"X-Tenant-ID\");\n        if (header != null) {\n            return header;\n        }\n        \n        // Option 3: JWT claim\n        Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n        if (auth instanceof JwtAuthenticationToken) {\n            Jwt jwt = ((JwtAuthenticationToken) auth).getToken();\n            return jwt.getClaimAsString(\"tenant_id\");\n        }\n        \n        // Option 4: Path parameter\n        return request.getParameter(\"tenant\");\n    }\n}\n\n// Entity with tenant\n@Entity\n@FilterDef(name = \"tenantFilter\", parameters = @ParamDef(name = \"tenantId\", type = \"string\"))\n@Filter(name = \"tenantFilter\", condition = \"tenant_id = :tenantId\")\npublic class Order {\n    @Id\n    private Long id;\n    \n    @Column(name = \"tenant_id\")\n    private String tenantId;\n    \n    private String description;\n}\n\n// Repository with tenant filter\n@Component\npublic class TenantInterceptor implements Interceptor {\n    @Override\n    public String onPrepareStatement(String sql) {\n        String tenantId = TenantContext.getTenantId();\n        if (tenantId != null) {\n            // Add tenant filter to all queries\n            return addTenantFilter(sql, tenantId);\n        }\n        return sql;\n    }\n}\n\n// Method security with tenant check\n@PreAuthorize(\"@tenantChecker.isValidTenant(#tenantId)\")\npublic Order getOrder(String tenantId, Long orderId) {\n    return orderRepository.findById(orderId).orElseThrow();\n}\n\n@Component(\"tenantChecker\")\npublic class TenantChecker {\n    public boolean isValidTenant(String tenantId) {\n        String currentTenant = TenantContext.getTenantId();\n        return currentTenant != null && currentTenant.equals(tenantId);\n    }\n}"
    },
    {
      "id": 82,
      "question": "How do you implement security for file uploads?",
      "answer": "File upload security:\n\nVulnerabilities:\n• Malicious files\n• Path traversal\n• Large files (DoS)\n• Executable uploads\n• MIME type spoofing\n\nProtection:\n• File type validation\n• Size limits\n• Virus scanning\n• Secure storage\n• Access control",
      "explanation": "File uploads are high-risk. Validate everything: type, size, content, and storage location.",
      "difficulty": "Medium",
      "code": "// File upload config\n@Configuration\npublic class FileUploadConfig {\n    \n    @Bean\n    public MultipartConfigElement multipartConfigElement() {\n        MultipartConfigFactory factory = new MultipartConfigFactory();\n        factory.setMaxFileSize(DataSize.ofMegabytes(10));\n        factory.setMaxRequestSize(DataSize.ofMegabytes(20));\n        return factory.createMultipartConfig();\n    }\n}\n\n// Secure file upload controller\n@RestController\n@RequestMapping(\"/api/files\")\npublic class FileUploadController {\n    \n    private static final Set<String> ALLOWED_EXTENSIONS = \n        Set.of(\"jpg\", \"jpeg\", \"png\", \"pdf\", \"docx\");\n    \n    private static final Set<String> ALLOWED_MIME_TYPES = \n        Set.of(\"image/jpeg\", \"image/png\", \"application/pdf\");\n    \n    @Autowired\n    private FileStorageService fileStorageService;\n    \n    @PostMapping(\"/upload\")\n    @PreAuthorize(\"hasRole('USER')\")\n    public ResponseEntity<FileResponse> uploadFile(\n            @RequestParam(\"file\") MultipartFile file) {\n        \n        // 1. Validate file is not empty\n        if (file.isEmpty()) {\n            throw new BadRequestException(\"File is empty\");\n        }\n        \n        // 2. Validate file size\n        if (file.getSize() > 10_000_000) {  // 10MB\n            throw new BadRequestException(\"File too large\");\n        }\n        \n        // 3. Validate filename (prevent path traversal)\n        String filename = file.getOriginalFilename();\n        if (filename == null || filename.contains(\"..\") || \n            filename.contains(\"/\") || filename.contains(\"\\\\\")) {\n            throw new BadRequestException(\"Invalid filename\");\n        }\n        \n        // 4. Validate file extension\n        String extension = getFileExtension(filename).toLowerCase();\n        if (!ALLOWED_EXTENSIONS.contains(extension)) {\n            throw new BadRequestException(\"File type not allowed\");\n        }\n        \n        // 5. Validate MIME type\n        String mimeType = file.getContentType();\n        if (!ALLOWED_MIME_TYPES.contains(mimeType)) {\n            throw new BadRequestException(\"Invalid content type\");\n        }\n        \n        // 6. Validate actual content (not just extension)\n        try {\n            if (!validateFileContent(file, extension)) {\n                throw new BadRequestException(\"File content mismatch\");\n            }\n        } catch (IOException e) {\n            throw new BadRequestException(\"Failed to validate file\");\n        }\n        \n        // 7. Virus scan (optional but recommended)\n        if (virusScanner.isInfected(file)) {\n            throw new BadRequestException(\"Virus detected\");\n        }\n        \n        // 8. Generate secure filename\n        String secureFilename = generateSecureFilename(filename);\n        \n        // 9. Store file securely\n        String storedPath = fileStorageService.store(file, secureFilename);\n        \n        // 10. Save metadata to database\n        FileMetadata metadata = new FileMetadata();\n        metadata.setOriginalName(filename);\n        metadata.setStoredName(secureFilename);\n        metadata.setSize(file.getSize());\n        metadata.setMimeType(mimeType);\n        metadata.setUploadedBy(getCurrentUsername());\n        metadata.setUploadDate(LocalDateTime.now());\n        fileMetadataRepository.save(metadata);\n        \n        return ResponseEntity.ok(new FileResponse(metadata.getId(), secureFilename));\n    }\n    \n    private boolean validateFileContent(MultipartFile file, String extension) \n            throws IOException {\n        \n        byte[] bytes = file.getBytes();\n        \n        // Check magic numbers\n        switch (extension) {\n            case \"jpg\":\n            case \"jpeg\":\n                return bytes[0] == (byte) 0xFF && bytes[1] == (byte) 0xD8;\n            case \"png\":\n                return bytes[0] == (byte) 0x89 && bytes[1] == 'P';\n            case \"pdf\":\n                return bytes[0] == '%' && bytes[1] == 'P' && \n                       bytes[2] == 'D' && bytes[3] == 'F';\n            default:\n                return true;\n        }\n    }\n    \n    private String generateSecureFilename(String originalFilename) {\n        String extension = getFileExtension(originalFilename);\n        return UUID.randomUUID().toString() + \".\" + extension;\n    }\n}\n\n// Secure file serving\n@GetMapping(\"/files/{id}\")\n@PreAuthorize(\"hasRole('USER')\")\npublic ResponseEntity<Resource> downloadFile(@PathVariable Long id) {\n    \n    FileMetadata metadata = fileMetadataRepository.findById(id)\n        .orElseThrow(() -> new NotFoundException(\"File not found\"));\n    \n    // Check ownership\n    if (!metadata.getUploadedBy().equals(getCurrentUsername()) && \n        !hasRole(\"ADMIN\")) {\n        throw new AccessDeniedException(\"Not authorized\");\n    }\n    \n    Resource resource = fileStorageService.loadAsResource(metadata.getStoredName());\n    \n    return ResponseEntity.ok()\n        .contentType(MediaType.parseMediaType(metadata.getMimeType()))\n        .header(HttpHeaders.CONTENT_DISPOSITION, \n                \"attachment; filename=\\\"\" + metadata.getOriginalName() + \"\\\"\")\n        .body(resource);\n}"
    },
    {
      "id": 83,
      "question": "How do you implement remember-me with secure token approach?",
      "answer": "Remember-me persistent token approach:\n\nSecurity improvements over simple hash:\n• Token stored in database\n• Series identifier\n• Token changed on each use\n• Detects token theft\n\nComponents:\n• Token repository\n• Series and token values\n• Token rotation\n• Theft detection",
      "explanation": "Persistent token is more secure than cookie hash. Detects stolen tokens and invalidates automatically.",
      "difficulty": "Medium",
      "code": "// Database schema\nCREATE TABLE persistent_logins (\n    username VARCHAR(64) NOT NULL,\n    series VARCHAR(64) PRIMARY KEY,\n    token VARCHAR(64) NOT NULL,\n    last_used TIMESTAMP NOT NULL\n);\n\n// Security configuration\n@Configuration\npublic class RememberMeSecurityConfig {\n    \n    @Autowired\n    private DataSource dataSource;\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .rememberMe(remember -> remember\n                .tokenRepository(persistentTokenRepository())\n                .tokenValiditySeconds(604800)  // 7 days\n                .userDetailsService(userDetailsService())\n                .rememberMeParameter(\"remember-me\")\n                .rememberMeCookieName(\"my-remember-me\")\n                .key(\"uniqueAndSecret\")\n                // Security options\n                .useSecureCookie(true)      // HTTPS only\n                .alwaysRemember(false)      // Require explicit checkbox\n            );\n        return http.build();\n    }\n    \n    @Bean\n    public PersistentTokenRepository persistentTokenRepository() {\n        JdbcTokenRepositoryImpl tokenRepository = new JdbcTokenRepositoryImpl();\n        tokenRepository.setDataSource(dataSource);\n        // tokenRepository.setCreateTableOnStartup(true);  // Only for dev\n        return tokenRepository;\n    }\n}\n\n// Custom token repository (Redis example)\n@Component\npublic class RedisPersistentTokenRepository implements PersistentTokenRepository {\n    \n    @Autowired\n    private RedisTemplate<String, PersistentRememberMeToken> redisTemplate;\n    \n    @Override\n    public void createNewToken(PersistentRememberMeToken token) {\n        String key = \"remember-me:\" + token.getSeries();\n        redisTemplate.opsForValue().set(key, token, 7, TimeUnit.DAYS);\n    }\n    \n    @Override\n    public void updateToken(String series, String tokenValue, Date lastUsed) {\n        String key = \"remember-me:\" + series;\n        PersistentRememberMeToken token = redisTemplate.opsForValue().get(key);\n        if (token != null) {\n            PersistentRememberMeToken updated = new PersistentRememberMeToken(\n                token.getUsername(), series, tokenValue, lastUsed);\n            redisTemplate.opsForValue().set(key, updated, 7, TimeUnit.DAYS);\n        }\n    }\n    \n    @Override\n    public PersistentRememberMeToken getTokenForSeries(String seriesId) {\n        String key = \"remember-me:\" + seriesId;\n        return redisTemplate.opsForValue().get(key);\n    }\n    \n    @Override\n    public void removeUserTokens(String username) {\n        Set<String> keys = redisTemplate.keys(\"remember-me:*\");\n        if (keys != null) {\n            keys.forEach(key -> {\n                PersistentRememberMeToken token = redisTemplate.opsForValue().get(key);\n                if (token != null && token.getUsername().equals(username)) {\n                    redisTemplate.delete(key);\n                }\n            });\n        }\n    }\n}\n\n// Login form\n<form method=\"post\" action=\"/login\">\n    <input type=\"text\" name=\"username\" />\n    <input type=\"password\" name=\"password\" />\n    <label>\n        <input type=\"checkbox\" name=\"remember-me\" /> Remember me\n    </label>\n    <button type=\"submit\">Login</button>\n</form>\n\n// Logout removes remember-me\n@PostMapping(\"/logout\")\npublic String logout(HttpServletRequest request, HttpServletResponse response) {\n    Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n    if (auth != null) {\n        persistentTokenRepository.removeUserTokens(auth.getName());\n        new SecurityContextLogoutHandler().logout(request, response, auth);\n    }\n    return \"redirect:/login?logout\";\n}\n\n// How it works:\n// 1. User logs in with \"remember me\" checked\n// 2. Server generates series and token (both random)\n// 3. Cookie stored: series:token\n// 4. DB stores: username, series, token, last_used\n// 5. On next visit:\n//    - Extract series from cookie\n//    - Lookup token in DB by series\n//    - If token matches: authenticate, generate new token\n//    - If token differs: stolen! Delete all user tokens\n// 6. Token rotates on each use for security"
    },
    {
      "id": 84,
      "question": "How do you implement password reset securely?",
      "answer": "Secure password reset flow:\n\n1. Generate unique token\n2. Store with expiration\n3. Send via email (never URL param on GET)\n4. Validate token\n5. Allow password change\n6. Invalidate token\n\nSecurity considerations:\n• Short expiration (15-30 min)\n• One-time use\n• Secure token generation\n• Rate limiting\n• No user enumeration",
      "explanation": "Password reset is sensitive. Use time-limited, one-time tokens. Avoid leaking user existence.",
      "difficulty": "Medium",
      "code": "// Password reset token entity\n@Entity\npublic class PasswordResetToken {\n    @Id\n    @GeneratedValue\n    private Long id;\n    \n    @Column(unique = true)\n    private String token;\n    \n    @ManyToOne\n    private User user;\n    \n    private LocalDateTime expiryDate;\n    \n    private boolean used;\n    \n    public boolean isExpired() {\n        return LocalDateTime.now().isAfter(expiryDate);\n    }\n}\n\n// Password reset service\n@Service\npublic class PasswordResetService {\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    @Autowired\n    private PasswordResetTokenRepository tokenRepository;\n    \n    @Autowired\n    private EmailService emailService;\n    \n    @Autowired\n    private PasswordEncoder passwordEncoder;\n    \n    private static final int EXPIRATION_MINUTES = 30;\n    \n    public void requestPasswordReset(String email) {\n        // Don't reveal if user exists (prevent enumeration)\n        Optional<User> userOpt = userRepository.findByEmail(email);\n        \n        if (userOpt.isPresent()) {\n            User user = userOpt.get();\n            \n            // Invalidate existing tokens\n            tokenRepository.deleteByUser(user);\n            \n            // Generate secure token\n            String token = generateSecureToken();\n            \n            // Save token\n            PasswordResetToken resetToken = new PasswordResetToken();\n            resetToken.setToken(token);\n            resetToken.setUser(user);\n            resetToken.setExpiryDate(LocalDateTime.now().plusMinutes(EXPIRATION_MINUTES));\n            resetToken.setUsed(false);\n            tokenRepository.save(resetToken);\n            \n            // Send email\n            String resetUrl = \"https://yourdomain.com/reset-password?token=\" + token;\n            emailService.sendPasswordResetEmail(user.getEmail(), resetUrl);\n        }\n        \n        // Always return success (don't reveal if email exists)\n        // Response is same whether user exists or not\n    }\n    \n    public void resetPassword(String token, String newPassword) {\n        PasswordResetToken resetToken = tokenRepository.findByToken(token)\n            .orElseThrow(() -> new InvalidTokenException(\"Invalid reset token\"));\n        \n        // Validate token\n        if (resetToken.isUsed()) {\n            throw new InvalidTokenException(\"Token already used\");\n        }\n        \n        if (resetToken.isExpired()) {\n            throw new InvalidTokenException(\"Token expired\");\n        }\n        \n        // Update password\n        User user = resetToken.getUser();\n        user.setPassword(passwordEncoder.encode(newPassword));\n        userRepository.save(user);\n        \n        // Mark token as used\n        resetToken.setUsed(true);\n        tokenRepository.save(resetToken);\n        \n        // Invalidate all sessions\n        sessionRegistry.getAllSessions(user, false)\n            .forEach(SessionInformation::expireNow);\n        \n        // Send confirmation email\n        emailService.sendPasswordChangedEmail(user.getEmail());\n    }\n    \n    private String generateSecureToken() {\n        SecureRandom random = new SecureRandom();\n        byte[] bytes = new byte[32];\n        random.nextBytes(bytes);\n        return Base64.getUrlEncoder().withoutPadding().encodeToString(bytes);\n    }\n}\n\n// Controller\n@RestController\n@RequestMapping(\"/api/password\")\npublic class PasswordResetController {\n    \n    @Autowired\n    private PasswordResetService passwordResetService;\n    \n    // Rate limited\n    @PostMapping(\"/forgot\")\n    @RateLimited(maxRequests = 3, timeWindow = 3600)  // 3 per hour\n    public ResponseEntity<String> forgotPassword(@RequestBody ForgotPasswordRequest request) {\n        passwordResetService.requestPasswordReset(request.getEmail());\n        return ResponseEntity.ok(\n            \"If the email exists, a reset link has been sent\");\n    }\n    \n    // Validate token (before showing reset form)\n    @GetMapping(\"/reset/validate\")\n    public ResponseEntity<Boolean> validateToken(@RequestParam String token) {\n        try {\n            PasswordResetToken resetToken = tokenRepository.findByToken(token)\n                .orElseThrow();\n            return ResponseEntity.ok(!resetToken.isUsed() && !resetToken.isExpired());\n        } catch (Exception e) {\n            return ResponseEntity.ok(false);\n        }\n    }\n    \n    // Reset password (POST, not GET)\n    @PostMapping(\"/reset\")\n    public ResponseEntity<String> resetPassword(@RequestBody ResetPasswordRequest request) {\n        // Validate password strength\n        if (!isStrongPassword(request.getNewPassword())) {\n            throw new WeakPasswordException(\"Password does not meet requirements\");\n        }\n        \n        passwordResetService.resetPassword(request.getToken(), request.getNewPassword());\n        return ResponseEntity.ok(\"Password reset successful\");\n    }\n}\n\n// Email template\nDear User,\n\nYou recently requested to reset your password. Click the link below:\n\n{{resetUrl}}\n\nThis link expires in 30 minutes.\n\nIf you didn't request this, ignore this email.\n\nThanks,\nYour App Team"
    },
    {
      "id": 85,
      "question": "How do you implement account lockout after failed login attempts?",
      "answer": "Account lockout mechanism:\n\nPurpose:\n• Prevent brute force attacks\n• Limit password guessing\n• Detect automated attacks\n\nImplementation:\n• Track failed attempts\n• Lock after threshold (e.g., 5 attempts)\n• Time-based unlock (e.g., 30 minutes)\n• Admin unlock option\n\nStorage:\n• Database field\n• Cache (Redis)",
      "explanation": "Account lockout mitigates brute force. Balance security with user experience (not too aggressive).",
      "difficulty": "Medium",
      "code": "// User entity with lockout fields\n@Entity\npublic class User {\n    @Id\n    private Long id;\n    private String username;\n    private String password;\n    private boolean enabled;\n    \n    // Lockout fields\n    private int failedAttempts = 0;\n    private LocalDateTime lockTime;\n    private boolean accountNonLocked = true;\n    \n    public void incrementFailedAttempts() {\n        this.failedAttempts++;\n    }\n    \n    public void resetFailedAttempts() {\n        this.failedAttempts = 0;\n    }\n    \n    public void lock() {\n        this.accountNonLocked = false;\n        this.lockTime = LocalDateTime.now();\n    }\n    \n    public void unlock() {\n        this.accountNonLocked = true;\n        this.lockTime = null;\n        this.failedAttempts = 0;\n    }\n    \n    public boolean isLockExpired(int lockDurationMinutes) {\n        if (lockTime == null) return false;\n        return LocalDateTime.now()\n            .isAfter(lockTime.plusMinutes(lockDurationMinutes));\n    }\n}\n\n// Lockout service\n@Service\npublic class LoginAttemptService {\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    private static final int MAX_ATTEMPTS = 5;\n    private static final int LOCK_DURATION_MINUTES = 30;\n    \n    @Transactional\n    public void loginFailed(String username) {\n        User user = userRepository.findByUsername(username)\n            .orElse(null);\n        \n        if (user != null) {\n            user.incrementFailedAttempts();\n            \n            if (user.getFailedAttempts() >= MAX_ATTEMPTS) {\n                user.lock();\n                // Send alert email\n                emailService.sendAccountLockedEmail(user.getEmail());\n            }\n            \n            userRepository.save(user);\n        }\n    }\n    \n    @Transactional\n    public void loginSucceeded(String username) {\n        User user = userRepository.findByUsername(username)\n            .orElse(null);\n        \n        if (user != null) {\n            user.resetFailedAttempts();\n            userRepository.save(user);\n        }\n    }\n    \n    public boolean isLocked(String username) {\n        User user = userRepository.findByUsername(username)\n            .orElseThrow();\n        \n        // Check if lock expired\n        if (!user.isAccountNonLocked() && user.isLockExpired(LOCK_DURATION_MINUTES)) {\n            user.unlock();\n            userRepository.save(user);\n            return false;\n        }\n        \n        return !user.isAccountNonLocked();\n    }\n    \n    public int getRemainingAttempts(String username) {\n        User user = userRepository.findByUsername(username)\n            .orElseThrow();\n        return Math.max(0, MAX_ATTEMPTS - user.getFailedAttempts());\n    }\n}\n\n// Authentication failure handler\n@Component\npublic class CustomAuthenticationFailureHandler \n        implements AuthenticationFailureHandler {\n    \n    @Autowired\n    private LoginAttemptService loginAttemptService;\n    \n    @Override\n    public void onAuthenticationFailure(HttpServletRequest request,\n                                       HttpServletResponse response,\n                                       AuthenticationException exception) {\n        \n        String username = request.getParameter(\"username\");\n        \n        if (username != null) {\n            loginAttemptService.loginFailed(username);\n            \n            int remaining = loginAttemptService.getRemainingAttempts(username);\n            \n            if (remaining > 0) {\n                request.setAttribute(\"error\", \n                    \"Invalid credentials. \" + remaining + \" attempts remaining.\");\n            } else {\n                request.setAttribute(\"error\", \n                    \"Account locked due to multiple failed attempts. Try again in 30 minutes.\");\n            }\n        }\n        \n        // Redirect to login with error\n        response.sendRedirect(\"/login?error\");\n    }\n}\n\n// Authentication success handler\n@Component\npublic class CustomAuthenticationSuccessHandler \n        implements AuthenticationSuccessHandler {\n    \n    @Autowired\n    private LoginAttemptService loginAttemptService;\n    \n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request,\n                                       HttpServletResponse response,\n                                       Authentication authentication) {\n        loginAttemptService.loginSucceeded(authentication.getName());\n        response.sendRedirect(\"/dashboard\");\n    }\n}\n\n// Custom UserDetailsService checks lock\n@Service\npublic class CustomUserDetailsService implements UserDetailsService {\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    @Autowired\n    private LoginAttemptService loginAttemptService;\n    \n    @Override\n    public UserDetails loadUserByUsername(String username) {\n        User user = userRepository.findByUsername(username)\n            .orElseThrow(() -> new UsernameNotFoundException(\"User not found\"));\n        \n        // Check if account is locked\n        if (loginAttemptService.isLocked(username)) {\n            throw new LockedException(\"Account is locked due to multiple failed attempts\");\n        }\n        \n        return new CustomUserDetails(user);\n    }\n}\n\n// Security configuration\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n    http\n        .formLogin(form -> form\n            .successHandler(authenticationSuccessHandler)\n            .failureHandler(authenticationFailureHandler)\n        );\n    return http.build();\n}\n\n// Admin unlock endpoint\n@PostMapping(\"/admin/unlock/{userId}\")\n@PreAuthorize(\"hasRole('ADMIN')\")\npublic ResponseEntity<String> unlockAccount(@PathVariable Long userId) {\n    User user = userRepository.findById(userId).orElseThrow();\n    user.unlock();\n    userRepository.save(user);\n    return ResponseEntity.ok(\"Account unlocked\");\n}"
    },
    {
      "id": 86,
      "question": "How do you implement security auditing and logging?",
      "answer": "Security audit logging:\n\nWhat to log:\n• Authentication attempts (success/failure)\n• Authorization failures\n• Privilege escalation attempts\n• Data access (sensitive)\n• Configuration changes\n• Admin actions\n\nLog fields:\n• Timestamp\n• User identity\n• Action\n• Resource\n• Result\n• IP address\n• User agent",
      "explanation": "Audit logs are crucial for compliance and incident response. Log security events, not business data.",
      "difficulty": "Medium",
      "code": "// Audit event entity\n@Entity\npublic class AuditEvent {\n    @Id\n    @GeneratedValue\n    private Long id;\n    \n    private LocalDateTime timestamp;\n    private String username;\n    private String action;\n    private String resource;\n    private String result;  // SUCCESS, FAILURE, DENIED\n    private String ipAddress;\n    private String userAgent;\n    private String details;\n    \n    @Enumerated(EnumType.STRING)\n    private EventType eventType;\n}\n\npublic enum EventType {\n    AUTHENTICATION_SUCCESS,\n    AUTHENTICATION_FAILURE,\n    AUTHORIZATION_FAILURE,\n    LOGOUT,\n    PASSWORD_CHANGE,\n    ACCOUNT_LOCKED,\n    ACCOUNT_UNLOCKED,\n    PRIVILEGE_ESCALATION,\n    SENSITIVE_DATA_ACCESS,\n    CONFIGURATION_CHANGE,\n    ADMIN_ACTION\n}\n\n// Audit service\n@Service\npublic class AuditService {\n    \n    @Autowired\n    private AuditEventRepository auditRepository;\n    \n    @Async\n    public void logEvent(EventType type, String action, String resource, \n                        String result, HttpServletRequest request) {\n        \n        AuditEvent event = new AuditEvent();\n        event.setTimestamp(LocalDateTime.now());\n        event.setEventType(type);\n        event.setAction(action);\n        event.setResource(resource);\n        event.setResult(result);\n        \n        // Get user\n        Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n        if (auth != null && auth.isAuthenticated()) {\n            event.setUsername(auth.getName());\n        }\n        \n        // Get request details\n        if (request != null) {\n            event.setIpAddress(getClientIp(request));\n            event.setUserAgent(request.getHeader(\"User-Agent\"));\n        }\n        \n        auditRepository.save(event);\n    }\n    \n    private String getClientIp(HttpServletRequest request) {\n        String ip = request.getHeader(\"X-Forwarded-For\");\n        if (ip == null || ip.isEmpty()) {\n            ip = request.getRemoteAddr();\n        }\n        return ip;\n    }\n}\n\n// Authentication event listener\n@Component\npublic class AuthenticationEventListener {\n    \n    @Autowired\n    private AuditService auditService;\n    \n    @EventListener\n    public void onSuccess(AuthenticationSuccessEvent event) {\n        String username = event.getAuthentication().getName();\n        auditService.logEvent(\n            EventType.AUTHENTICATION_SUCCESS,\n            \"LOGIN\",\n            null,\n            \"SUCCESS\",\n            getCurrentRequest()\n        );\n        \n        logger.info(\"User {} logged in successfully\", username);\n    }\n    \n    @EventListener\n    public void onFailure(AbstractAuthenticationFailureEvent event) {\n        String username = event.getAuthentication().getName();\n        auditService.logEvent(\n            EventType.AUTHENTICATION_FAILURE,\n            \"LOGIN\",\n            null,\n            \"FAILURE\",\n            getCurrentRequest()\n        );\n        \n        logger.warn(\"Failed login attempt for user {}\", username);\n    }\n}\n\n// Authorization failure listener\n@Component\npublic class AuthorizationEventListener {\n    \n    @Autowired\n    private AuditService auditService;\n    \n    @EventListener\n    public void onAccessDenied(AuthorizationDeniedEvent<?> event) {\n        Authentication auth = event.getAuthentication().get();\n        auditService.logEvent(\n            EventType.AUTHORIZATION_FAILURE,\n            \"ACCESS_DENIED\",\n            event.getAuthorizationDecision().toString(),\n            \"DENIED\",\n            getCurrentRequest()\n        );\n        \n        logger.warn(\"Access denied for user {} to resource {}\",\n            auth.getName(), event.getAuthorizationDecision());\n    }\n}\n\n// Aspect for sensitive operations\n@Aspect\n@Component\npublic class SensitiveDataAuditAspect {\n    \n    @Autowired\n    private AuditService auditService;\n    \n    @Around(\"@annotation(auditable)\")\n    public Object auditSensitiveAccess(ProceedingJoinPoint joinPoint, \n                                       Auditable auditable) throws Throwable {\n        \n        String methodName = joinPoint.getSignature().getName();\n        Object[] args = joinPoint.getArgs();\n        \n        try {\n            Object result = joinPoint.proceed();\n            \n            auditService.logEvent(\n                EventType.SENSITIVE_DATA_ACCESS,\n                methodName,\n                auditable.resource(),\n                \"SUCCESS\",\n                getCurrentRequest()\n            );\n            \n            return result;\n        } catch (Exception e) {\n            auditService.logEvent(\n                EventType.SENSITIVE_DATA_ACCESS,\n                methodName,\n                auditable.resource(),\n                \"FAILURE: \" + e.getMessage(),\n                getCurrentRequest()\n            );\n            throw e;\n        }\n    }\n}\n\n// Custom annotation\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Auditable {\n    String resource();\n}\n\n// Usage\n@GetMapping(\"/users/{id}\")\n@PreAuthorize(\"hasRole('ADMIN')\")\n@Auditable(resource = \"USER_DETAILS\")\npublic User getUser(@PathVariable Long id) {\n    return userService.findById(id);\n}\n\n// Query audit logs\n@GetMapping(\"/admin/audit-logs\")\n@PreAuthorize(\"hasRole('ADMIN')\")\npublic Page<AuditEvent> getAuditLogs(\n        @RequestParam(required = false) String username,\n        @RequestParam(required = false) EventType eventType,\n        @RequestParam(required = false) LocalDateTime startDate,\n        @RequestParam(required = false) LocalDateTime endDate,\n        Pageable pageable) {\n    \n    return auditRepository.findByFilters(\n        username, eventType, startDate, endDate, pageable);\n}"
    },
    {
      "id": 87,
      "question": "How do you implement Cross-Origin Resource Sharing (CORS) securely?",
      "answer": "CORS security configuration:\n\nCORS headers:\n• Access-Control-Allow-Origin\n• Access-Control-Allow-Methods\n• Access-Control-Allow-Headers\n• Access-Control-Allow-Credentials\n• Access-Control-Max-Age\n\nSecurity rules:\n• Never use wildcard (*) with credentials\n• Whitelist specific origins\n• Limit allowed methods\n• Validate preflight requests",
      "explanation": "CORS controls browser access from other origins. Configure restrictively - whitelist known domains only.",
      "difficulty": "Easy",
      "code": "// Global CORS configuration\n@Configuration\npublic class CorsConfig {\n    \n    @Bean\n    public CorsConfigurationSource corsConfigurationSource() {\n        CorsConfiguration config = new CorsConfiguration();\n        \n        // Allowed origins (NEVER use \"*\" with credentials)\n        config.setAllowedOrigins(Arrays.asList(\n            \"https://app.example.com\",\n            \"https://admin.example.com\"\n        ));\n        \n        // OR use patterns\n        // config.setAllowedOriginPatterns(Arrays.asList(\"https://*.example.com\"));\n        \n        // Allowed methods\n        config.setAllowedMethods(Arrays.asList(\n            \"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"\n        ));\n        \n        // Allowed headers\n        config.setAllowedHeaders(Arrays.asList(\n            \"Authorization\",\n            \"Content-Type\",\n            \"X-Requested-With\"\n        ));\n        \n        // Expose headers (visible to JS)\n        config.setExposedHeaders(Arrays.asList(\n            \"Authorization\",\n            \"X-Total-Count\"\n        ));\n        \n        // Allow credentials (cookies, auth headers)\n        config.setAllowCredentials(true);\n        \n        // Preflight cache duration (seconds)\n        config.setMaxAge(3600L);\n        \n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration(\"/**\", config);\n        return source;\n    }\n}\n\n// Apply CORS in security config\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n    http\n        .cors(cors -> cors.configurationSource(corsConfigurationSource()))\n        .csrf(csrf -> csrf.disable())  // Usually disabled for CORS APIs\n        .authorizeHttpRequests(auth -> auth\n            .anyRequest().authenticated()\n        );\n    return http.build();\n}\n\n// Controller-level CORS (more specific)\n@RestController\n@RequestMapping(\"/api\")\n@CrossOrigin(\n    origins = \"https://app.example.com\",\n    methods = {RequestMethod.GET, RequestMethod.POST},\n    allowedHeaders = {\"Authorization\", \"Content-Type\"},\n    exposedHeaders = {\"X-Total-Count\"},\n    allowCredentials = \"true\",\n    maxAge = 3600\n)\npublic class ApiController {\n    \n    @GetMapping(\"/data\")\n    public Data getData() {\n        return dataService.getData();\n    }\n}\n\n// Method-level CORS (most specific)\n@GetMapping(\"/public-data\")\n@CrossOrigin(origins = \"*\")  // Public endpoint, no credentials\npublic Data getPublicData() {\n    return dataService.getPublicData();\n}\n\n// Dynamic origin validation\n@Bean\npublic CorsConfigurationSource dynamicCorsConfigurationSource() {\n    return request -> {\n        String origin = request.getHeader(\"Origin\");\n        \n        CorsConfiguration config = new CorsConfiguration();\n        \n        // Validate origin dynamically\n        if (isAllowedOrigin(origin)) {\n            config.setAllowedOrigins(Collections.singletonList(origin));\n            config.setAllowedMethods(Arrays.asList(\"GET\", \"POST\"));\n            config.setAllowedHeaders(Arrays.asList(\"*\"));\n            config.setAllowCredentials(true);\n        }\n        \n        return config;\n    };\n    \n    private boolean isAllowedOrigin(String origin) {\n        return origin != null && \n               (origin.endsWith(\".example.com\") || \n                origin.equals(\"https://app.example.com\"));\n    }\n}\n\n// Environment-specific CORS\nspring:\n  profiles:\n    active: production\n\n---\nspring:\n  config:\n    activate:\n      on-profile: development\n      \ncors:\n  allowed-origins: http://localhost:3000,http://localhost:4200\n\n---\nspring:\n  config:\n    activate:\n      on-profile: production\n      \ncors:\n  allowed-origins: https://app.example.com,https://admin.example.com\n\n// Security best practices:\n// 1. NEVER use \"*\" with allowCredentials = true\n// 2. Whitelist specific origins, not wildcards\n// 3. Limit allowed methods (don't allow DELETE if not needed)\n// 4. Validate Origin header server-side\n// 5. Use HTTPS in production\n// 6. Set appropriate maxAge for preflight caching\n// 7. Only expose necessary headers"
    },
    {
      "id": 88,
      "question": "How do you implement security for WebSocket connections?",
      "answer": "WebSocket security:\n\nChallenges:\n• Bi-directional communication\n• Long-lived connections\n• Authentication\n• Authorization per message\n• CSRF protection\n\nSolutions:\n• Token-based auth\n• Session-based auth\n• Interceptor authorization\n• Message-level security\n• Origin validation",
      "explanation": "WebSocket needs special security - authenticate connection, authorize each message, validate origins.",
      "difficulty": "Hard",
      "code": "<!-- Dependencies -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-websocket</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.security</groupId>\n    <artifactId>spring-security-messaging</artifactId>\n</dependency>\n\n// WebSocket configuration\n@Configuration\n@EnableWebSocketMessageBroker\npublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer {\n    \n    @Override\n    public void configureMessageBroker(MessageBrokerRegistry config) {\n        config.enableSimpleBroker(\"/topic\", \"/queue\");\n        config.setApplicationDestinationPrefixes(\"/app\");\n        config.setUserDestinationPrefix(\"/user\");\n    }\n    \n    @Override\n    public void registerStompEndpoints(StompEndpointRegistry registry) {\n        registry.addEndpoint(\"/ws\")\n            .setAllowedOrigins(\"https://app.example.com\")  // CORS for WS\n            .withSockJS();\n    }\n}\n\n// WebSocket security configuration\n@Configuration\npublic class WebSocketSecurityConfig {\n    \n    @Bean\n    public AuthorizationManager<Message<?>> messageAuthorizationManager(\n            MessageMatcherDelegatingAuthorizationManager.Builder messages) {\n        \n        messages\n            // Allow connection\n            .simpDestMatchers(\"/app/**\").authenticated()\n            .simpSubscribeDestMatchers(\"/user/queue/**\").authenticated()\n            .simpSubscribeDestMatchers(\"/topic/public/**\").permitAll()\n            \n            // Message-level authorization\n            .simpDestMatchers(\"/app/chat/**\").hasRole(\"USER\")\n            .simpDestMatchers(\"/app/admin/**\").hasRole(\"ADMIN\")\n            \n            // Subscribe authorization\n            .simpSubscribeDestMatchers(\"/topic/admin/**\").hasRole(\"ADMIN\")\n            .simpSubscribeDestMatchers(\"/user/**\").authenticated()\n            \n            .anyMessage().denyAll();\n        \n        return messages.build();\n    }\n}\n\n// Token-based authentication (preferred for WebSocket)\n@Component\npublic class WebSocketAuthInterceptor implements ChannelInterceptor {\n    \n    @Autowired\n    private JwtUtil jwtUtil;\n    \n    @Override\n    public Message<?> preSend(Message<?> message, MessageChannel channel) {\n        StompHeaderAccessor accessor = \n            MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);\n        \n        if (StompCommand.CONNECT.equals(accessor.getCommand())) {\n            // Extract JWT from header\n            String token = accessor.getFirstNativeHeader(\"Authorization\");\n            \n            if (token != null && token.startsWith(\"Bearer \")) {\n                token = token.substring(7);\n                \n                if (jwtUtil.validateToken(token)) {\n                    String username = jwtUtil.extractUsername(token);\n                    UserDetails userDetails = userDetailsService.loadUserByUsername(username);\n                    \n                    UsernamePasswordAuthenticationToken auth = \n                        new UsernamePasswordAuthenticationToken(\n                            userDetails, null, userDetails.getAuthorities());\n                    \n                    accessor.setUser(auth);\n                } else {\n                    throw new IllegalArgumentException(\"Invalid JWT token\");\n                }\n            } else {\n                throw new IllegalArgumentException(\"Missing JWT token\");\n            }\n        }\n        \n        return message;\n    }\n}\n\n// Register interceptor\n@Configuration\npublic class WebSocketAuthConfig implements WebSocketMessageBrokerConfigurer {\n    \n    @Autowired\n    private WebSocketAuthInterceptor authInterceptor;\n    \n    @Override\n    public void configureClientInboundChannel(ChannelRegistration registration) {\n        registration.interceptors(authInterceptor);\n    }\n}\n\n// Controller with authorization\n@Controller\npublic class ChatController {\n    \n    @MessageMapping(\"/chat.send\")\n    @SendTo(\"/topic/public\")\n    @PreAuthorize(\"hasRole('USER')\")\n    public ChatMessage sendMessage(ChatMessage message, \n                                   @AuthenticationPrincipal UserDetails user) {\n        message.setSender(user.getUsername());\n        message.setTimestamp(LocalDateTime.now());\n        return message;\n    }\n    \n    // Private message\n    @MessageMapping(\"/chat.private\")\n    @SendToUser(\"/queue/messages\")\n    @PreAuthorize(\"hasRole('USER')\")\n    public ChatMessage sendPrivateMessage(ChatMessage message,\n                                         @AuthenticationPrincipal UserDetails user) {\n        return message;\n    }\n    \n    // Admin broadcast\n    @MessageMapping(\"/admin.broadcast\")\n    @SendTo(\"/topic/admin\")\n    @PreAuthorize(\"hasRole('ADMIN')\")\n    public AdminMessage broadcastAdmin(AdminMessage message) {\n        return message;\n    }\n}\n\n// Client-side (JavaScript)\nconst token = localStorage.getItem('jwt');\nconst socket = new SockJS('/ws');\nconst stompClient = Stomp.over(socket);\n\n// Connect with JWT\nstompClient.connect(\n    {'Authorization': 'Bearer ' + token},\n    (frame) => {\n        console.log('Connected:', frame);\n        \n        // Subscribe to topics\n        stompClient.subscribe('/topic/public', (message) => {\n            console.log('Received:', JSON.parse(message.body));\n        });\n        \n        // Subscribe to private queue\n        stompClient.subscribe('/user/queue/messages', (message) => {\n            console.log('Private message:', JSON.parse(message.body));\n        });\n    },\n    (error) => {\n        console.error('Connection error:', error);\n    }\n);\n\n// Send message\nfunction sendMessage(text) {\n    stompClient.send('/app/chat.send', {}, JSON.stringify({\n        content: text\n    }));\n}"
    },
    {
      "id": 89,
      "question": "How do you implement Content Security Policy (CSP)?",
      "answer": "Content Security Policy (CSP):\n\nPurpose:\n• Prevent XSS attacks\n• Control resource loading\n• Restrict inline scripts\n• Define trusted sources\n\nDirectives:\n• default-src: Default policy\n• script-src: JavaScript sources\n• style-src: CSS sources\n• img-src: Image sources\n• connect-src: AJAX/WebSocket\n• frame-ancestors: Embedding\n\nModes:\n• Enforce mode\n• Report-only mode",
      "explanation": "CSP is a powerful XSS defense. Define trusted sources for all content types. Start with report-only.",
      "difficulty": "Medium",
      "code": "// CSP configuration in Spring Security\n@Configuration\npublic class SecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .headers(headers -> headers\n                .contentSecurityPolicy(csp -> csp\n                    .policyDirectives(\n                        \"default-src 'self'; \" +\n                        \"script-src 'self' https://cdn.example.com; \" +\n                        \"style-src 'self' 'unsafe-inline' https://cdn.example.com; \" +\n                        \"img-src 'self' data: https:; \" +\n                        \"font-src 'self' https://fonts.gstatic.com; \" +\n                        \"connect-src 'self' https://api.example.com; \" +\n                        \"frame-ancestors 'none'; \" +\n                        \"base-uri 'self'; \" +\n                        \"form-action 'self'\"\n                    )\n                )\n            );\n        return http.build();\n    }\n}\n\n// Report-only mode (testing)\nhttp.headers(headers -> headers\n    .contentSecurityPolicy(csp -> csp\n        .policyDirectives(\"...\")\n        .reportOnly()  // Doesn't enforce, only reports violations\n    )\n);\n\n// With reporting endpoint\nhttp.headers(headers -> headers\n    .contentSecurityPolicy(csp -> csp\n        .policyDirectives(\n            \"default-src 'self'; \" +\n            \"report-uri /csp-report; \" +  // Deprecated\n            \"report-to csp-endpoint\"       // New standard\n        )\n    )\n);\n\n// CSP violation report handler\n@RestController\npublic class CspReportController {\n    \n    @PostMapping(\"/csp-report\")\n    public ResponseEntity<Void> handleCspReport(@RequestBody CspReport report) {\n        logger.warn(\"CSP Violation: {}\", report);\n        \n        // Store in database for analysis\n        cspViolationService.save(report);\n        \n        // Alert on repeated violations\n        if (cspViolationService.countRecent(report.getBlockedUri()) > 10) {\n            alertService.notify(\"Repeated CSP violations for: \" + report.getBlockedUri());\n        }\n        \n        return ResponseEntity.ok().build();\n    }\n}\n\npublic class CspReport {\n    private String documentUri;\n    private String referrer;\n    private String blockedUri;\n    private String violatedDirective;\n    private String effectiveDirective;\n    private String originalPolicy;\n    private String disposition;  // \"enforce\" or \"report\"\n    private String statusCode;\n}\n\n// Nonce-based CSP (most secure)\n@Controller\npublic class PageController {\n    \n    @GetMapping(\"/\")\n    public String index(Model model, HttpServletRequest request) {\n        // Generate nonce\n        String nonce = generateNonce();\n        request.setAttribute(\"cspNonce\", nonce);\n        model.addAttribute(\"nonce\", nonce);\n        return \"index\";\n    }\n    \n    private String generateNonce() {\n        byte[] nonceBytes = new byte[16];\n        new SecureRandom().nextBytes(nonceBytes);\n        return Base64.getEncoder().encodeToString(nonceBytes);\n    }\n}\n\n// Nonce filter\n@Component\npublic class CspNonceFilter extends OncePerRequestFilter {\n    \n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                   HttpServletResponse response,\n                                   FilterChain chain) {\n        String nonce = generateNonce();\n        request.setAttribute(\"cspNonce\", nonce);\n        \n        // Add CSP header with nonce\n        response.setHeader(\"Content-Security-Policy\",\n            \"default-src 'self'; \" +\n            \"script-src 'self' 'nonce-\" + nonce + \"'; \" +\n            \"style-src 'self' 'nonce-\" + nonce + \"'\");\n        \n        chain.doFilter(request, response);\n    }\n}\n\n// HTML template with nonce\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Secure Page</title>\n    <!-- Inline style with nonce -->\n    <style nonce=\"${nonce}\">\n        body { font-family: Arial; }\n    </style>\n</head>\n<body>\n    <h1>Hello World</h1>\n    \n    <!-- Inline script with nonce -->\n    <script nonce=\"${nonce}\">\n        console.log('This script is allowed');\n    </script>\n    \n    <!-- External script (allowed by CSP) -->\n    <script src=\"/js/app.js\"></script>\n</body>\n</html>\n\n// Strict CSP (best practice)\n\"default-src 'none'; \" +\n\"script-src 'self' 'nonce-{random}'; \" +\n\"style-src 'self' 'nonce-{random}'; \" +\n\"img-src 'self' https:; \" +\n\"font-src 'self'; \" +\n\"connect-src 'self'; \" +\n\"frame-ancestors 'none'; \" +\n\"base-uri 'self'; \" +\n\"form-action 'self'\"\n\n// Migration strategy:\n// 1. Start with report-only mode\n// 2. Analyze violation reports\n// 3. Adjust policy\n// 4. Enable enforcement\n// 5. Use nonces for inline scripts\n// 6. Remove 'unsafe-inline' and 'unsafe-eval'"
    },
    {
      "id": 90,
      "question": "How do you implement security for scheduled tasks?",
      "answer": "Scheduled task security:\n\nChallenges:\n• No user context\n• System-level operations\n• Background execution\n• Audit tracking\n\nSolutions:\n• System authentication\n• Security context setup\n• Audit logging\n• Error handling\n• Rate limiting\n• Idempotency",
      "explanation": "Scheduled tasks run without user context. Create system authentication for proper authorization and auditing.",
      "difficulty": "Medium",
      "code": "// System user for scheduled tasks\n@Service\npublic class SystemAuthenticationService {\n    \n    public Authentication createSystemAuthentication() {\n        List<GrantedAuthority> authorities = Arrays.asList(\n            new SimpleGrantedAuthority(\"ROLE_SYSTEM\"),\n            new SimpleGrantedAuthority(\"ROLE_ADMIN\")\n        );\n        \n        UserDetails systemUser = User.builder()\n            .username(\"SYSTEM\")\n            .password(\"\")  // No password\n            .authorities(authorities)\n            .build();\n        \n        return new UsernamePasswordAuthenticationToken(\n            systemUser, null, authorities);\n    }\n    \n    public void runAsSystem(Runnable task) {\n        Authentication original = SecurityContextHolder.getContext()\n            .getAuthentication();\n        \n        try {\n            SecurityContextHolder.getContext()\n                .setAuthentication(createSystemAuthentication());\n            task.run();\n        } finally {\n            SecurityContextHolder.getContext()\n                .setAuthentication(original);\n        }\n    }\n}\n\n// Secured scheduled task\n@Component\npublic class ScheduledTasks {\n    \n    @Autowired\n    private SystemAuthenticationService systemAuthService;\n    \n    @Autowired\n    private AuditService auditService;\n    \n    // Basic scheduled task\n    @Scheduled(cron = \"0 0 2 * * *\")  // 2 AM daily\n    public void dailyCleanup() {\n        systemAuthService.runAsSystem(() -> {\n            try {\n                logger.info(\"Starting daily cleanup task\");\n                auditService.logEvent(\n                    EventType.ADMIN_ACTION,\n                    \"SCHEDULED_CLEANUP\",\n                    \"system\",\n                    \"STARTED\",\n                    null\n                );\n                \n                // Task logic\n                cleanupOldData();\n                \n                auditService.logEvent(\n                    EventType.ADMIN_ACTION,\n                    \"SCHEDULED_CLEANUP\",\n                    \"system\",\n                    \"COMPLETED\",\n                    null\n                );\n            } catch (Exception e) {\n                logger.error(\"Cleanup task failed\", e);\n                auditService.logEvent(\n                    EventType.ADMIN_ACTION,\n                    \"SCHEDULED_CLEANUP\",\n                    \"system\",\n                    \"FAILED: \" + e.getMessage(),\n                    null\n                );\n            }\n        });\n    }\n    \n    // Scheduled task with method security\n    @Scheduled(fixedRate = 3600000)  // Every hour\n    public void hourlyReport() {\n        systemAuthService.runAsSystem(() -> {\n            generateReport();  // Calls @PreAuthorize methods\n        });\n    }\n    \n    @PreAuthorize(\"hasRole('ADMIN')\")\n    private void generateReport() {\n        // This needs ADMIN role, provided by system auth\n    }\n}\n\n// Async scheduled task with security\n@Configuration\n@EnableAsync\n@EnableScheduling\npublic class AsyncSchedulingConfig implements AsyncConfigurer {\n    \n    @Override\n    public Executor getAsyncExecutor() {\n        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n        executor.setCorePoolSize(5);\n        executor.setMaxPoolSize(10);\n        executor.setQueueCapacity(100);\n        executor.setThreadNamePrefix(\"async-task-\");\n        \n        // Propagate security context to async threads\n        executor.setTaskDecorator(new SecurityContextPropagatingDecorator());\n        \n        executor.initialize();\n        return executor;\n    }\n}\n\npublic class SecurityContextPropagatingDecorator implements TaskDecorator {\n    @Override\n    public Runnable decorate(Runnable runnable) {\n        SecurityContext context = SecurityContextHolder.getContext();\n        return () -> {\n            try {\n                SecurityContextHolder.setContext(context);\n                runnable.run();\n            } finally {\n                SecurityContextHolder.clearContext();\n            }\n        };\n    }\n}\n\n// Scheduled task with distributed locking\n@Component\npublic class DistributedScheduledTasks {\n    \n    @Autowired\n    private RedissonClient redissonClient;\n    \n    @Scheduled(cron = \"0 0 * * * *\")\n    public void hourlyTaskWithLock() {\n        RLock lock = redissonClient.getLock(\"scheduled-task-lock\");\n        \n        try {\n            // Try to acquire lock (prevents duplicate execution)\n            if (lock.tryLock(1, 50, TimeUnit.SECONDS)) {\n                systemAuthService.runAsSystem(() -> {\n                    performTask();\n                });\n            } else {\n                logger.info(\"Task already running on another instance\");\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        } finally {\n            if (lock.isHeldByCurrentThread()) {\n                lock.unlock();\n            }\n        }\n    }\n}\n\n// Configuration\n@Configuration\npublic class SchedulingSecurityConfig {\n    \n    // Enable method security for scheduled tasks\n    @Bean\n    public MethodSecurityExpressionHandler methodSecurityExpressionHandler() {\n        DefaultMethodSecurityExpressionHandler handler = \n            new DefaultMethodSecurityExpressionHandler();\n        // Custom configuration\n        return handler;\n    }\n}\n\n// Manual task execution (admin endpoint)\n@RestController\n@RequestMapping(\"/admin/tasks\")\npublic class TaskController {\n    \n    @Autowired\n    private ScheduledTasks scheduledTasks;\n    \n    @PostMapping(\"/cleanup\")\n    @PreAuthorize(\"hasRole('ADMIN')\")\n    public ResponseEntity<String> triggerCleanup() {\n        scheduledTasks.dailyCleanup();\n        return ResponseEntity.ok(\"Cleanup task triggered\");\n    }\n}"
    },    {
      "id": 91,
      "question": "How do you implement security context propagation in async methods?",
      "answer": "Async security context propagation:\n\nProblem:\n• SecurityContext is ThreadLocal\n• Async methods run on different threads\n• Context not automatically propagated\n\nSolutions:\n1. SecurityContextPropagating Executor\n2. DelegatingSecurityContext variants\n3. @Async with security mode\n4. Manual context transfer\n\nModes:\n• MODE_THREADLOCAL (default)\n• MODE_INHERITABLETHREADLOCAL\n• MODE_GLOBAL",
      "explanation": "SecurityContext doesn't automatically transfer to async threads. Use propagating executors or inheritable mode.",
      "difficulty": "Medium",
      "code": "// Enable inheritable thread local (simplest)\n@EnableGlobalMethodSecurity(\n    prePostEnabled = true,\n    securedEnabled = true,\n    mode = AdviceMode.PROXY,\n    proxyTargetClass = false\n)\npublic class SecurityConfig {\n    @Bean\n    public SecurityContextHolderStrategy securityContextHolderStrategy() {\n        return new InheritableThreadLocalSecurityContextHolderStrategy();\n    }\n}\n\n// Or set globally\nSecurityContextHolder.setStrategyName(\n    SecurityContextHolder.MODE_INHERITABLETHREADLOCAL);\n\n// Custom async executor with security\n@Configuration\n@EnableAsync\npublic class AsyncConfig implements AsyncConfigurer {\n    \n    @Override\n    public Executor getAsyncExecutor() {\n        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n        executor.setCorePoolSize(5);\n        executor.setMaxPoolSize(10);\n        executor.setQueueCapacity(25);\n        executor.setThreadNamePrefix(\"async-\");\n        \n        // Wrap with DelegatingSecurityContext\n        executor.setTaskDecorator(new SecurityContextTaskDecorator());\n        \n        executor.initialize();\n        return executor;\n    }\n    \n    @Override\n    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {\n        return (throwable, method, params) -> {\n            logger.error(\"Async method {} threw exception\", \n                method.getName(), throwable);\n        };\n    }\n}\n\n// Security context task decorator\npublic class SecurityContextTaskDecorator implements TaskDecorator {\n    @Override\n    public Runnable decorate(Runnable runnable) {\n        // Capture context from calling thread\n        SecurityContext context = SecurityContextHolder.getContext();\n        \n        return () -> {\n            try {\n                // Set context in async thread\n                SecurityContextHolder.setContext(context);\n                runnable.run();\n            } finally {\n                // Clean up\n                SecurityContextHolder.clearContext();\n            }\n        };\n    }\n}\n\n// Usage in service\n@Service\npublic class AsyncService {\n    \n    @Async\n    @PreAuthorize(\"hasRole('USER')\")\n    public CompletableFuture<String> asyncMethodWithSecurity() {\n        // Security context is available here\n        String username = SecurityContextHolder.getContext()\n            .getAuthentication().getName();\n        \n        // Do async work\n        String result = performLongOperation();\n        \n        return CompletableFuture.completedFuture(result);\n    }\n    \n    // Without @Async - manual context propagation\n    public CompletableFuture<String> manualAsyncMethod() {\n        SecurityContext context = SecurityContextHolder.getContext();\n        \n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                SecurityContextHolder.setContext(context);\n                return performSecureOperation();\n            } finally {\n                SecurityContextHolder.clearContext();\n            }\n        });\n    }\n}\n\n// DelegatingSecurityContextExecutorService\n@Bean\npublic Executor securityAwareExecutor() {\n    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n    executor.initialize();\n    \n    // Wrap with DelegatingSecurityContextExecutorService\n    return new DelegatingSecurityContextExecutorService(\n        executor.getThreadPoolExecutor());\n}\n\n// Callable with security context\nCallable<String> task = new Callable<>() {\n    @Override\n    public String call() throws Exception {\n        return \"Result: \" + SecurityContextHolder.getContext()\n            .getAuthentication().getName();\n    }\n};\n\n// Wrap and submit\nCallable<String> wrappedTask = \n    new DelegatingSecurityContextCallable<>(task);\nFuture<String> future = executorService.submit(wrappedTask);\n\n// Runnable with security context\nRunnable task = () -> {\n    String user = SecurityContextHolder.getContext()\n        .getAuthentication().getName();\n    logger.info(\"Running as: {}\", user);\n};\n\nRunnable wrappedTask = new DelegatingSecurityContextRunnable(task);\nexecutor.execute(wrappedTask);\n\n// Reactor (WebFlux) context propagation\n@Bean\npublic SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n    http\n        .authorizeExchange(auth -> auth.anyExchange().authenticated())\n        // Automatically available in reactive chain\n        .oauth2ResourceServer(ServerHttpSecurity.OAuth2ResourceServerSpec::jwt);\n    return http.build();\n}\n\n// Access in reactive chain\npublic Mono<User> getUser(Long id) {\n    return ReactiveSecurityContextHolder.getContext()\n        .map(SecurityContext::getAuthentication)\n        .map(auth -> auth.getName())\n        .flatMap(username -> {\n            logger.info(\"User: {}\", username);\n            return userRepository.findById(id);\n        });\n}"
    },
    {
      "id": 92,
      "question": "What are common Spring Security vulnerabilities and how to prevent them?",
      "answer": "Common vulnerabilities:\n\n1. Insecure Direct Object References (IDOR)\n   • Fix: Validate ownership\n\n2. Missing function-level access control\n   • Fix: Use @PreAuthorize\n\n3. Session fixation\n   • Fix: migrateSession\n\n4. Weak password hashing\n   • Fix: BCrypt with high strength\n\n5. CSRF disabled unnecessarily\n   • Fix: Enable for form-based\n\n6. Missing security headers\n   • Fix: Enable all headers\n\n7. Hardcoded credentials\n   • Fix: Use environment variables",
      "explanation": "Security is multi-layered. Each vulnerability needs specific prevention strategy. Defense in depth.",
      "difficulty": "Hard",
      "code": "// 1. IDOR Prevention\n@GetMapping(\"/users/{id}\")\n@PreAuthorize(\"hasRole('ADMIN') or #id == authentication.principal.id\")\npublic User getUser(@PathVariable Long id) {\n    return userService.findById(id);\n}\n\n// Or in service\n@Service\npublic class UserService {\n    public User getUser(Long id) {\n        User user = userRepository.findById(id).orElseThrow();\n        \n        // Check ownership\n        String currentUser = SecurityContextHolder.getContext()\n            .getAuthentication().getName();\n        \n        if (!user.getUsername().equals(currentUser) && !isAdmin()) {\n            throw new AccessDeniedException(\"Not authorized\");\n        }\n        \n        return user;\n    }\n}\n\n// 2. Function-level access control\n// BAD - Only URL-based\nhttp.authorizeHttpRequests(auth -> auth\n    .requestMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n);\n\n// GOOD - Method-level (can't bypass)\n@PreAuthorize(\"hasRole('ADMIN')\")\npublic void deleteUser(Long id) {\n    userRepository.deleteById(id);\n}\n\n// 3. Session fixation prevention\nhttp.sessionManagement(session -> session\n    .sessionFixation().migrateSession()  // Create new session on login\n    .maximumSessions(1)\n    .maxSessionsPreventsLogin(false)\n);\n\n// 4. Strong password hashing\n@Bean\npublic PasswordEncoder passwordEncoder() {\n    return new BCryptPasswordEncoder(12);  // High strength\n}\n\n// Never do this:\n// new MessageDigestPasswordEncoder(\"MD5\")  // VULNERABLE!\n// new NoOpPasswordEncoder()  // VULNERABLE!\n\n// 5. CSRF protection\n// Enable for form-based\nhttp.csrf(Customizer.withDefaults());\n\n// Only disable for stateless APIs\nhttp\n    .csrf(csrf -> csrf.disable())\n    .sessionManagement(session -> session\n        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n    );\n\n// 6. Security headers\nhttp.headers(headers -> headers\n    .frameOptions(frame -> frame.deny())\n    .xssProtection(Customizer.withDefaults())\n    .contentSecurityPolicy(csp -> csp\n        .policyDirectives(\"default-src 'self'\")\n    )\n    .httpStrictTransportSecurity(hsts -> hsts\n        .includeSubDomains(true)\n        .maxAgeInSeconds(31536000)\n    )\n    .referrerPolicy(referrer -> referrer\n        .policy(ReferrerPolicy.STRICT_ORIGIN_WHEN_CROSS_ORIGIN)\n    )\n);\n\n// 7. No hardcoded credentials\n// BAD\npublic class SecurityConfig {\n    @Bean\n    public UserDetailsService users() {\n        UserDetails user = User.builder()\n            .username(\"admin\")\n            .password(\"{bcrypt}$2a$10$...\")  // HARDCODED!\n            .roles(\"ADMIN\")\n            .build();\n        return new InMemoryUserDetailsManager(user);\n    }\n}\n\n// GOOD\n@Value(\"${app.admin.username}\")\nprivate String adminUsername;\n\n@Value(\"${app.admin.password}\")\nprivate String adminPassword;\n\n// Or use database/LDAP\n\n// 8. SQL Injection prevention\n// BAD\nString query = \"SELECT * FROM users WHERE username = '\" + username + \"'\";\n\n// GOOD - Use parameters\n@Query(\"SELECT u FROM User u WHERE u.username = :username\")\nUser findByUsername(@Param(\"username\") String username);\n\n// 9. XSS prevention\n// Escape user input\n@GetMapping(\"/search\")\npublic String search(@RequestParam String query, Model model) {\n    // Spring auto-escapes in Thymeleaf\n    model.addAttribute(\"query\", query);\n    return \"search\";\n}\n\n// Thymeleaf: th:text escapes automatically\n<p th:text=\"${query}\"></p>  <!-- Safe -->\n<p th:utext=\"${query}\"></p> <!-- UNSAFE - renders HTML -->\n\n// 10. Path traversal prevention\n@GetMapping(\"/files/{filename}\")\npublic ResponseEntity<Resource> downloadFile(@PathVariable String filename) {\n    // Validate filename\n    if (filename.contains(\"..\") || filename.contains(\"/\")) {\n        throw new BadRequestException(\"Invalid filename\");\n    }\n    \n    // Use whitelist\n    if (!filename.matches(\"^[a-zA-Z0-9._-]+$\")) {\n        throw new BadRequestException(\"Invalid filename\");\n    }\n    \n    Resource resource = storageService.load(filename);\n    return ResponseEntity.ok(resource);\n}\n\n// 11. Information disclosure prevention\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    @ExceptionHandler(Exception.class)\n    public ResponseEntity<ErrorResponse> handleException(Exception e) {\n        // Don't expose stack traces in production\n        if (isProduction()) {\n            return ResponseEntity.status(500)\n                .body(new ErrorResponse(\"Internal server error\"));\n        } else {\n            return ResponseEntity.status(500)\n                .body(new ErrorResponse(e.getMessage()));\n        }\n    }\n}\n\n// 12. Rate limiting\n@RateLimited(maxRequests = 5, timeWindow = 60)\n@PostMapping(\"/login\")\npublic ResponseEntity<String> login(@RequestBody LoginRequest request) {\n    // Login logic\n}"
    },
    {
      "id": 93,
      "question": "How do you implement security for a multi-module Spring Boot application?",
      "answer": "Multi-module security architecture:\n\nModules:\n• security-core: Common config\n• security-web: Web security\n• security-api: API security\n• security-service: Business logic\n\nShared components:\n• UserDetails\n• Authentication providers\n• Security utilities\n\nModule-specific:\n• Filter chains\n• Authorization rules\n• Endpoints",
      "explanation": "Multi-module apps need shared security config. Use separate modules for web, API, and core security.",
      "difficulty": "Hard",
      "code": "// Project structure\nmy-app/\nâ”œâ”€â”€ security-core/          # Common security\nâ”œâ”€â”€ security-web/           # Web UI security\nâ”œâ”€â”€ security-api/           # REST API security\nâ”œâ”€â”€ web-module/             # Web application\nâ””â”€â”€ api-module/             # REST API\n\n// security-core module: pom.xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-security</artifactId>\n    </dependency>\n</dependencies>\n\n// security-core: Common configuration\n@Configuration\npublic class SecurityCoreConfig {\n    \n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n    \n    @Bean\n    public UserDetailsService userDetailsService() {\n        return new CustomUserDetailsService();\n    }\n    \n    @Bean\n    public AuthenticationManager authenticationManager(\n            AuthenticationConfiguration config) throws Exception {\n        return config.getAuthenticationManager();\n    }\n}\n\n// security-core: Common user details\npublic class CustomUserDetails implements UserDetails {\n    private final User user;\n    \n    // Common implementation shared across modules\n}\n\n// security-web module: pom.xml\n<dependencies>\n    <dependency>\n        <groupId>com.example</groupId>\n        <artifactId>security-core</artifactId>\n    </dependency>\n</dependencies>\n\n// security-web: Web security configuration\n@Configuration\n@Order(1)\npublic class WebSecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain webSecurityFilterChain(HttpSecurity http) throws Exception {\n        http\n            .securityMatcher(\"/app/**\", \"/login\", \"/logout\")\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/app/public/**\").permitAll()\n                .requestMatchers(\"/app/admin/**\").hasRole(\"ADMIN\")\n                .requestMatchers(\"/app/**\").hasRole(\"USER\")\n            )\n            .formLogin(form -> form\n                .loginPage(\"/login\")\n                .defaultSuccessUrl(\"/app/dashboard\")\n            )\n            .logout(logout -> logout\n                .logoutUrl(\"/logout\")\n                .logoutSuccessUrl(\"/login?logout\")\n            )\n            .csrf(Customizer.withDefaults());\n        return http.build();\n    }\n}\n\n// security-api module: REST API security\n@Configuration\n@Order(2)\npublic class ApiSecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain apiSecurityFilterChain(HttpSecurity http) throws Exception {\n        http\n            .securityMatcher(\"/api/**\")\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/api/public/**\").permitAll()\n                .requestMatchers(\"/api/**\").authenticated()\n            )\n            .oauth2ResourceServer(oauth2 -> oauth2.jwt(Customizer.withDefaults()))\n            .csrf(csrf -> csrf.disable())\n            .sessionManagement(session -> session\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n            );\n        return http.build();\n    }\n}\n\n// web-module: pom.xml\n<dependencies>\n    <dependency>\n        <groupId>com.example</groupId>\n        <artifactId>security-web</artifactId>\n    </dependency>\n</dependencies>\n\n// web-module: Application\n@SpringBootApplication(\n    scanBasePackages = {\"com.example.web\", \"com.example.security.web\"}\n)\npublic class WebApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(WebApplication.class, args);\n    }\n}\n\n// web-module: Controller\n@Controller\n@RequestMapping(\"/app\")\npublic class DashboardController {\n    @GetMapping(\"/dashboard\")\n    public String dashboard(Model model,\n                          @AuthenticationPrincipal CustomUserDetails user) {\n        model.addAttribute(\"user\", user);\n        return \"dashboard\";\n    }\n}\n\n// api-module: pom.xml\n<dependencies>\n    <dependency>\n        <groupId>com.example</groupId>\n        <artifactId>security-api</artifactId>\n    </dependency>\n</dependencies>\n\n// api-module: Application\n@SpringBootApplication(\n    scanBasePackages = {\"com.example.api\", \"com.example.security.api\"}\n)\npublic class ApiApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ApiApplication.class, args);\n    }\n}\n\n// api-module: Controller\n@RestController\n@RequestMapping(\"/api\")\npublic class UserApiController {\n    @GetMapping(\"/users\")\n    @PreAuthorize(\"hasRole('USER')\")\n    public List<User> getUsers(\n            @AuthenticationPrincipal CustomUserDetails user) {\n        return userService.findAll();\n    }\n}\n\n// security-core: Shared service\n@Service\npublic class SecurityService {\n    \n    public CustomUserDetails getCurrentUser() {\n        Authentication auth = SecurityContextHolder.getContext()\n            .getAuthentication();\n        return (CustomUserDetails) auth.getPrincipal();\n    }\n    \n    public boolean hasRole(String role) {\n        return SecurityContextHolder.getContext()\n            .getAuthentication()\n            .getAuthorities().stream()\n            .anyMatch(a -> a.getAuthority().equals(\"ROLE_\" + role));\n    }\n}\n\n// Combined application (single deployment)\n@SpringBootApplication(\n    scanBasePackages = \"com.example\"\n)\npublic class CombinedApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(CombinedApplication.class, args);\n    }\n}\n\n// Both filter chains active simultaneously:\n// /app/** -> Web security (form login, CSRF enabled)\n// /api/** -> API security (JWT, CSRF disabled)"
    },
    {
      "id": 94,
      "question": "How do you implement GDPR compliance with Spring Security?",
      "answer": "GDPR compliance requirements:\n\n1. Right to access\n   • User data export\n\n2. Right to erasure (\"right to be forgotten\")\n   • Data deletion\n\n3. Data portability\n   • Export in standard format\n\n4. Consent management\n   • Track consent\n\n5. Audit logging\n   • Who accessed what data\n\n6. Data minimization\n   • Store only necessary data\n\n7. Encryption\n   • At rest and in transit",
      "explanation": "GDPR requires data protection by design. Implement access, deletion, export, and audit for compliance.",
      "difficulty": "Hard",
      "code": "// User entity with GDPR fields\n@Entity\npublic class User {\n    @Id\n    private Long id;\n    \n    @Column(nullable = false, unique = true)\n    private String username;\n    \n    @Column(nullable = false)\n    private String email;\n    \n    // GDPR fields\n    private LocalDateTime consentDate;\n    private boolean marketingConsent;\n    private boolean dataProcessingConsent;\n    private LocalDateTime dataExportRequestDate;\n    private LocalDateTime deletionRequestDate;\n    private boolean anonymized;\n}\n\n// Consent management\n@Service\npublic class ConsentService {\n    \n    @Transactional\n    public void updateConsent(Long userId, ConsentRequest request) {\n        User user = userRepository.findById(userId).orElseThrow();\n        \n        user.setMarketingConsent(request.isMarketingConsent());\n        user.setDataProcessingConsent(request.isDataProcessingConsent());\n        user.setConsentDate(LocalDateTime.now());\n        \n        userRepository.save(user);\n        \n        // Audit log\n        auditService.logConsentChange(userId, request);\n    }\n    \n    public boolean hasActiveConsent(Long userId) {\n        User user = userRepository.findById(userId).orElseThrow();\n        return user.isDataProcessingConsent() && \n               user.getConsentDate() != null &&\n               user.getConsentDate().isAfter(LocalDateTime.now().minusYears(1));\n    }\n}\n\n// Right to access - data export\n@RestController\n@RequestMapping(\"/api/gdpr\")\npublic class GdprController {\n    \n    @GetMapping(\"/export\")\n    @PreAuthorize(\"isAuthenticated()\")\n    public ResponseEntity<Resource> exportUserData(\n            @AuthenticationPrincipal CustomUserDetails currentUser) {\n        \n        // Collect all user data\n        UserDataExport export = new UserDataExport();\n        export.setUser(userService.getUserData(currentUser.getId()));\n        export.setOrders(orderService.getUserOrders(currentUser.getId()));\n        export.setActivity(activityService.getUserActivity(currentUser.getId()));\n        export.setExportDate(LocalDateTime.now());\n        \n        // Convert to JSON\n        String json = objectMapper.writeValueAsString(export);\n        \n        // Log export request\n        auditService.logDataExport(currentUser.getId());\n        \n        ByteArrayResource resource = new ByteArrayResource(json.getBytes());\n        \n        return ResponseEntity.ok()\n            .header(HttpHeaders.CONTENT_DISPOSITION, \n                    \"attachment; filename=user-data-\" + \n                    currentUser.getId() + \".json\")\n            .contentType(MediaType.APPLICATION_JSON)\n            .body(resource);\n    }\n    \n    // Right to erasure\n    @PostMapping(\"/delete-account\")\n    @PreAuthorize(\"isAuthenticated()\")\n    public ResponseEntity<String> requestAccountDeletion(\n            @AuthenticationPrincipal CustomUserDetails currentUser) {\n        \n        User user = userRepository.findById(currentUser.getId())\n            .orElseThrow();\n        \n        // Mark for deletion (30-day grace period)\n        user.setDeletionRequestDate(LocalDateTime.now());\n        userRepository.save(user);\n        \n        // Send confirmation email\n        emailService.sendDeletionConfirmation(user.getEmail());\n        \n        // Log deletion request\n        auditService.logDeletionRequest(currentUser.getId());\n        \n        return ResponseEntity.ok(\n            \"Account deletion scheduled. You have 30 days to cancel.\");\n    }\n    \n    @PostMapping(\"/cancel-deletion\")\n    @PreAuthorize(\"isAuthenticated()\")\n    public ResponseEntity<String> cancelAccountDeletion(\n            @AuthenticationPrincipal CustomUserDetails currentUser) {\n        \n        User user = userRepository.findById(currentUser.getId())\n            .orElseThrow();\n        \n        user.setDeletionRequestDate(null);\n        userRepository.save(user);\n        \n        return ResponseEntity.ok(\"Account deletion cancelled.\");\n    }\n}\n\n// Scheduled deletion task\n@Component\npublic class GdprScheduledTasks {\n    \n    @Scheduled(cron = \"0 0 2 * * *\")  // Daily at 2 AM\n    public void processAccountDeletions() {\n        LocalDateTime cutoffDate = LocalDateTime.now().minusDays(30);\n        \n        List<User> usersToDelete = userRepository\n            .findByDeletionRequestDateBefore(cutoffDate);\n        \n        for (User user : usersToDelete) {\n            anonymizeUser(user);\n        }\n    }\n    \n    @Transactional\n    private void anonymizeUser(User user) {\n        // Replace with anonymized data\n        user.setUsername(\"deleted_user_\" + user.getId());\n        user.setEmail(\"deleted_\" + user.getId() + \"@example.com\");\n        user.setPassword(\"\");\n        user.setAnonymized(true);\n        \n        // Clear personal data\n        user.setFirstName(null);\n        user.setLastName(null);\n        user.setPhoneNumber(null);\n        user.setAddress(null);\n        \n        // Keep aggregated/anonymized data for analytics\n        \n        userRepository.save(user);\n        \n        // Delete related personal data\n        profileRepository.deleteByUserId(user.getId());\n        \n        // Audit log\n        auditService.logAccountDeletion(user.getId());\n    }\n}\n\n// Data access audit\n@Aspect\n@Component\npublic class DataAccessAuditAspect {\n    \n    @Around(\"@annotation(personalData)\")\n    public Object auditPersonalDataAccess(ProceedingJoinPoint joinPoint,\n                                         PersonalData personalData) {\n        \n        String accessor = SecurityContextHolder.getContext()\n            .getAuthentication().getName();\n        \n        // Log access\n        dataAccessLogRepository.save(new DataAccessLog(\n            accessor,\n            personalData.category(),\n            LocalDateTime.now(),\n            joinPoint.getSignature().getName()\n        ));\n        \n        return joinPoint.proceed();\n    }\n}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface PersonalData {\n    String category();\n}\n\n// Usage\n@GetMapping(\"/users/{id}\")\n@PersonalData(category = \"USER_PROFILE\")\npublic User getUser(@PathVariable Long id) {\n    return userService.findById(id);\n}\n\n// Encryption at rest\n@Entity\npublic class SensitiveUser {\n    @Id\n    private Long id;\n    \n    @Convert(converter = EncryptedStringConverter.class)\n    private String ssn;  // Encrypted in database\n    \n    @Convert(converter = EncryptedStringConverter.class)\n    private String creditCard;\n}\n\npublic class EncryptedStringConverter \n        implements AttributeConverter<String, String> {\n    \n    @Autowired\n    private EncryptionService encryptionService;\n    \n    @Override\n    public String convertToDatabaseColumn(String attribute) {\n        return encryptionService.encrypt(attribute);\n    }\n    \n    @Override\n    public String convertToEntityAttribute(String dbData) {\n        return encryptionService.decrypt(dbData);\n    }\n}"
    },
    {
      "id": 95,
      "question": "How do you implement security for gRPC services?",
      "answer": "gRPC security:\n\nAuthentication methods:\n• SSL/TLS (transport)\n• Token-based (metadata)\n• Mutual TLS (mTLS)\n\nAuthorization:\n• Interceptors\n• Method-level security\n• Role-based access\n\nConfiguration:\n• Server interceptors\n• Client interceptors\n• Security metadata",
      "explanation": "gRPC needs custom security - use interceptors for auth, metadata for tokens, TLS for encryption.",
      "difficulty": "Hard",
      "code": "<!-- Dependencies -->\n<dependency>\n    <groupId>net.devh</groupId>\n    <artifactId>grpc-spring-boot-starter</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.grpc</groupId>\n    <artifactId>grpc-netty-shaded</artifactId>\n</dependency>\n\n// gRPC security interceptor\n@GrpcGlobalServerInterceptor\npublic class AuthenticationInterceptor implements ServerInterceptor {\n    \n    @Autowired\n    private JwtUtil jwtUtil;\n    \n    @Autowired\n    private UserDetailsService userDetailsService;\n    \n    @Override\n    public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(\n            ServerCall<ReqT, RespT> call,\n            Metadata headers,\n            ServerCallHandler<ReqT, RespT> next) {\n        \n        // Extract token from metadata\n        String token = headers.get(\n            Metadata.Key.of(\"authorization\", Metadata.ASCII_STRING_MARSHALLER));\n        \n        if (token != null && token.startsWith(\"Bearer \")) {\n            token = token.substring(7);\n            \n            try {\n                if (jwtUtil.validateToken(token)) {\n                    String username = jwtUtil.extractUsername(token);\n                    UserDetails userDetails = \n                        userDetailsService.loadUserByUsername(username);\n                    \n                    UsernamePasswordAuthenticationToken authentication = \n                        new UsernamePasswordAuthenticationToken(\n                            userDetails, null, userDetails.getAuthorities());\n                    \n                    SecurityContextHolder.getContext()\n                        .setAuthentication(authentication);\n                    \n                    // Continue with authenticated context\n                    return next.startCall(call, headers);\n                }\n            } catch (Exception e) {\n                call.close(Status.UNAUTHENTICATED\n                    .withDescription(\"Invalid token\"), headers);\n                return new ServerCall.Listener<>() {};\n            }\n        }\n        \n        // Unauthenticated\n        call.close(Status.UNAUTHENTICATED\n            .withDescription(\"Missing or invalid token\"), headers);\n        return new ServerCall.Listener<>() {};\n    }\n}\n\n// Authorization interceptor\n@GrpcGlobalServerInterceptor\n@Order(1)\npublic class AuthorizationInterceptor implements ServerInterceptor {\n    \n    @Override\n    public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(\n            ServerCall<ReqT, RespT> call,\n            Metadata headers,\n            ServerCallHandler<ReqT, RespT> next) {\n        \n        String methodName = call.getMethodDescriptor().getFullMethodName();\n        \n        Authentication auth = SecurityContextHolder.getContext()\n            .getAuthentication();\n        \n        if (auth == null || !auth.isAuthenticated()) {\n            call.close(Status.UNAUTHENTICATED, headers);\n            return new ServerCall.Listener<>() {};\n        }\n        \n        // Check authorization\n        if (requiresAdminRole(methodName) && !hasRole(auth, \"ADMIN\")) {\n            call.close(Status.PERMISSION_DENIED\n                .withDescription(\"Admin role required\"), headers);\n            return new ServerCall.Listener<>() {};\n        }\n        \n        return next.startCall(call, headers);\n    }\n    \n    private boolean requiresAdminRole(String methodName) {\n        return methodName.contains(\"Admin\") || methodName.contains(\"Delete\");\n    }\n    \n    private boolean hasRole(Authentication auth, String role) {\n        return auth.getAuthorities().stream()\n            .anyMatch(a -> a.getAuthority().equals(\"ROLE_\" + role));\n    }\n}\n\n// gRPC service with security\n@GrpcService\npublic class UserServiceImpl extends UserServiceGrpc.UserServiceImplBase {\n    \n    @Override\n    public void getUser(GetUserRequest request,\n                       StreamObserver<UserResponse> responseObserver) {\n        \n        // Security context is available\n        Authentication auth = SecurityContextHolder.getContext()\n            .getAuthentication();\n        \n        String currentUsername = auth.getName();\n        \n        // Check authorization\n        if (!currentUsername.equals(request.getUsername()) && \n            !hasRole(auth, \"ADMIN\")) {\n            responseObserver.onError(Status.PERMISSION_DENIED\n                .withDescription(\"Not authorized\")\n                .asRuntimeException());\n            return;\n        }\n        \n        User user = userService.findByUsername(request.getUsername());\n        \n        UserResponse response = UserResponse.newBuilder()\n            .setId(user.getId())\n            .setUsername(user.getUsername())\n            .setEmail(user.getEmail())\n            .build();\n        \n        responseObserver.onNext(response);\n        responseObserver.onCompleted();\n    }\n}\n\n// TLS configuration\n# application.yml\ngrpc:\n  server:\n    port: 9090\n    security:\n      enabled: true\n      certificate-chain: classpath:server.crt\n      private-key: classpath:server.key\n      trust-cert-collection: classpath:ca.crt  # For mTLS\n      client-auth: REQUIRE  # Mutual TLS\n\n// Client configuration\n@Configuration\npublic class GrpcClientConfig {\n    \n    @Bean\n    public ManagedChannel userServiceChannel() {\n        return ManagedChannelBuilder\n            .forAddress(\"localhost\", 9090)\n            .useTransportSecurity()\n            .sslContext(buildSslContext())\n            .build();\n    }\n    \n    @Bean\n    public UserServiceGrpc.UserServiceBlockingStub userServiceStub(\n            ManagedChannel channel) {\n        return UserServiceGrpc.newBlockingStub(channel);\n    }\n}\n\n// Client call with token\npublic class GrpcClient {\n    \n    @Autowired\n    private UserServiceBlockingStub userServiceStub;\n    \n    public UserResponse getUser(String username, String token) {\n        Metadata metadata = new Metadata();\n        metadata.put(\n            Metadata.Key.of(\"authorization\", Metadata.ASCII_STRING_MARSHALLER),\n            \"Bearer \" + token\n        );\n        \n        UserServiceBlockingStub stubWithAuth = \n            MetadataUtils.attachHeaders(userServiceStub, metadata);\n        \n        GetUserRequest request = GetUserRequest.newBuilder()\n            .setUsername(username)\n            .build();\n        \n        return stubWithAuth.getUser(request);\n    }\n}\n\n// Custom annotation for method security\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface SecuredGrpc {\n    String[] roles() default {};\n}\n\n@GrpcService\npublic class SecuredServiceImpl extends SecuredServiceGrpc.SecuredServiceImplBase {\n    \n    @SecuredGrpc(roles = {\"ADMIN\"})\n    @Override\n    public void deleteUser(DeleteUserRequest request,\n                          StreamObserver<DeleteUserResponse> responseObserver) {\n        // Implementation\n    }\n}"
    },
    {
      "id": 96,
      "question": "How do you implement security monitoring and alerting?",
      "answer": "Security monitoring:\n\nKey metrics:\n• Failed login attempts\n• Authorization failures\n• Unusual access patterns\n• Token violations\n• Account lockouts\n\nAlerting on:\n• Brute force attacks\n• Privilege escalation\n• Data breaches\n• Configuration changes\n\nTools:\n• Micrometer metrics\n• Log aggregation\n• Real-time alerts",
      "explanation": "Security monitoring detects threats in real-time. Monitor authentication, authorization, and access patterns.",
      "difficulty": "Medium",
      "code": "<!-- Dependencies -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.micrometer</groupId>\n    <artifactId>micrometer-registry-prometheus</artifactId>\n</dependency>\n\n// Security metrics\n@Component\npublic class SecurityMetrics {\n    \n    private final Counter failedLoginAttempts;\n    private final Counter successfulLogins;\n    private final Counter authorizationFailures;\n    private final Counter tokenViolations;\n    private final Gauge activeUsers;\n    \n    public SecurityMetrics(MeterRegistry registry) {\n        this.failedLoginAttempts = Counter.builder(\"security.login.failed\")\n            .description(\"Failed login attempts\")\n            .tag(\"type\", \"authentication\")\n            .register(registry);\n        \n        this.successfulLogins = Counter.builder(\"security.login.success\")\n            .description(\"Successful logins\")\n            .register(registry);\n        \n        this.authorizationFailures = Counter.builder(\"security.authorization.denied\")\n            .description(\"Authorization failures\")\n            .register(registry);\n        \n        this.tokenViolations = Counter.builder(\"security.token.violations\")\n            .description(\"JWT token violations\")\n            .register(registry);\n        \n        this.activeUsers = Gauge.builder(\"security.users.active\", \n                this::getActiveUserCount)\n            .description(\"Currently active users\")\n            .register(registry);\n    }\n    \n    public void recordFailedLogin(String username, String reason) {\n        failedLoginAttempts.increment();\n    }\n    \n    public void recordSuccessfulLogin(String username) {\n        successfulLogins.increment();\n    }\n    \n    public void recordAuthorizationFailure(String username, String resource) {\n        authorizationFailures.increment();\n    }\n    \n    public void recordTokenViolation(String type) {\n        tokenViolations.increment();\n    }\n    \n    private int getActiveUserCount() {\n        return sessionRegistry.getAllPrincipals().size();\n    }\n}\n\n// Authentication event monitoring\n@Component\npublic class SecurityMonitoringListener {\n    \n    @Autowired\n    private SecurityMetrics metrics;\n    \n    @Autowired\n    private AlertService alertService;\n    \n    @Autowired\n    private ThreatDetectionService threatDetection;\n    \n    @EventListener\n    public void onAuthenticationSuccess(AuthenticationSuccessEvent event) {\n        String username = event.getAuthentication().getName();\n        metrics.recordSuccessfulLogin(username);\n        \n        // Check for suspicious activity\n        if (threatDetection.isSuspiciousLogin(username)) {\n            alertService.sendAlert(\n                AlertLevel.WARNING,\n                \"Suspicious login detected\",\n                \"User: \" + username\n            );\n        }\n    }\n    \n    @EventListener\n    public void onAuthenticationFailure(AbstractAuthenticationFailureEvent event) {\n        String username = event.getAuthentication().getName();\n        String reason = event.getException().getMessage();\n        \n        metrics.recordFailedLogin(username, reason);\n        \n        // Check for brute force\n        if (threatDetection.isBruteForceAttempt(username)) {\n            alertService.sendAlert(\n                AlertLevel.CRITICAL,\n                \"Potential brute force attack\",\n                \"User: \" + username + \", Failed attempts: \" + \n                threatDetection.getFailedAttempts(username)\n            );\n        }\n    }\n    \n    @EventListener\n    public void onAuthorizationDenied(AuthorizationDeniedEvent<?> event) {\n        Authentication auth = event.getAuthentication().get();\n        String resource = event.getAuthorizationDecision().toString();\n        \n        metrics.recordAuthorizationFailure(auth.getName(), resource);\n        \n        // Check for privilege escalation attempts\n        if (threatDetection.isPrivilegeEscalation(auth, resource)) {\n            alertService.sendAlert(\n                AlertLevel.HIGH,\n                \"Privilege escalation attempt detected\",\n                \"User: \" + auth.getName() + \", Resource: \" + resource\n            );\n        }\n    }\n}\n\n// Threat detection service\n@Service\npublic class ThreatDetectionService {\n    \n    @Autowired\n    private RedisTemplate<String, Integer> redisTemplate;\n    \n    public boolean isBruteForceAttempt(String username) {\n        String key = \"failed_logins:\" + username;\n        Integer attempts = redisTemplate.opsForValue().get(key);\n        return attempts != null && attempts >= 5;\n    }\n    \n    public boolean isSuspiciousLogin(String username) {\n        // Check for:\n        // - Login from new location\n        // - Login at unusual time\n        // - Multiple concurrent sessions\n        // - Login shortly after password change\n        \n        return checkNewLocation(username) || \n               checkUnusualTime(username) ||\n               checkConcurrentSessions(username);\n    }\n    \n    public boolean isPrivilegeEscalation(Authentication auth, String resource) {\n        // Check if user is attempting to access\n        // resources above their privilege level\n        return resource.contains(\"admin\") && \n               !auth.getAuthorities().stream()\n                   .anyMatch(a -> a.getAuthority().equals(\"ROLE_ADMIN\"));\n    }\n}\n\n// Alert service\n@Service\npublic class AlertService {\n    \n    @Autowired\n    private EmailService emailService;\n    \n    @Autowired\n    private SlackService slackService;\n    \n    public void sendAlert(AlertLevel level, String title, String message) {\n        SecurityAlert alert = new SecurityAlert();\n        alert.setLevel(level);\n        alert.setTitle(title);\n        alert.setMessage(message);\n        alert.setTimestamp(LocalDateTime.now());\n        \n        // Store in database\n        alertRepository.save(alert);\n        \n        // Send notifications based on severity\n        switch (level) {\n            case CRITICAL:\n                emailService.sendToSecurityTeam(alert);\n                slackService.sendToSecurityChannel(alert);\n                // SMS to on-call engineer\n                break;\n            case HIGH:\n                emailService.sendToSecurityTeam(alert);\n                slackService.sendToSecurityChannel(alert);\n                break;\n            case WARNING:\n                slackService.sendToSecurityChannel(alert);\n                break;\n            case INFO:\n                // Log only\n                break;\n        }\n    }\n}\n\n// Real-time security dashboard\n@RestController\n@RequestMapping(\"/api/security/dashboard\")\n@PreAuthorize(\"hasRole('SECURITY_ADMIN')\")\npublic class SecurityDashboardController {\n    \n    @GetMapping(\"/metrics\")\n    public SecurityMetrics getMetrics() {\n        return SecurityMetrics.builder()\n            .failedLogins(getFailedLoginCount())\n            .successfulLogins(getSuccessfulLoginCount())\n            .authorizationFailures(getAuthzFailureCount())\n            .activeUsers(getActiveUserCount())\n            .recentAlerts(getRecentAlerts())\n            .build();\n    }\n    \n    @GetMapping(\"/alerts\")\n    public Page<SecurityAlert> getAlerts(\n            @RequestParam(required = false) AlertLevel level,\n            Pageable pageable) {\n        return alertRepository.findByLevel(level, pageable);\n    }\n}\n\n// Prometheus metrics endpoint\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: health,info,metrics,prometheus\n  metrics:\n    export:\n      prometheus:\n        enabled: true\n\n// Grafana dashboard query examples:\n// Rate of failed logins:\nrate(security_login_failed_total[5m])\n\n// Authorization failure rate:\nrate(security_authorization_denied_total[5m])\n\n// Active users:\nsecurity_users_active"
    },
    {
      "id": 97,
      "question": "How do you implement security for batch jobs?",
      "answer": "Batch job security:\n\nChallenges:\n• No user context\n• Long-running processes\n• Large data access\n• Resource authorization\n\nSolutions:\n• Job-level authentication\n• Step-level authorization\n• Data access control\n• Audit logging\n• Secure configuration",
      "explanation": "Batch jobs need system-level security. Authenticate job, authorize steps, audit data access.",
      "difficulty": "Medium",
      "code": "<!-- Spring Batch with Security -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-batch</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n\n// Batch security configuration\n@Configuration\n@EnableBatchProcessing\npublic class BatchSecurityConfig {\n    \n    @Bean\n    public JobRepository jobRepository(\n            DataSource dataSource,\n            PlatformTransactionManager transactionManager) throws Exception {\n        \n        JobRepositoryFactoryBean factory = new JobRepositoryFactoryBean();\n        factory.setDataSource(dataSource);\n        factory.setTransactionManager(transactionManager);\n        factory.afterPropertiesSet();\n        return factory.getObject();\n    }\n}\n\n// Secure job configuration\n@Configuration\npublic class UserProcessingJobConfig {\n    \n    @Autowired\n    private SystemAuthenticationService systemAuthService;\n    \n    @Bean\n    public Job userProcessingJob(JobRepository jobRepository,\n                                Step processUsersStep) {\n        return new JobBuilder(\"userProcessingJob\", jobRepository)\n            .start(processUsersStep)\n            .listener(new SecurityJobListener())\n            .build();\n    }\n    \n    @Bean\n    public Step processUsersStep(JobRepository jobRepository,\n                                PlatformTransactionManager transactionManager) {\n        return new StepBuilder(\"processUsersStep\", jobRepository)\n            .<User, User>chunk(100, transactionManager)\n            .reader(userReader())\n            .processor(secureUserProcessor())\n            .writer(userWriter())\n            .listener(new SecurityStepListener())\n            .build();\n    }\n}\n\n// Security job listener\npublic class SecurityJobListener implements JobExecutionListener {\n    \n    @Autowired\n    private SystemAuthenticationService systemAuthService;\n    \n    @Autowired\n    private AuditService auditService;\n    \n    @Override\n    public void beforeJob(JobExecution jobExecution) {\n        // Set up security context\n        Authentication auth = systemAuthService.createSystemAuthentication();\n        SecurityContextHolder.getContext().setAuthentication(auth);\n        \n        // Audit log\n        auditService.logEvent(\n            EventType.ADMIN_ACTION,\n            \"BATCH_JOB_START\",\n            jobExecution.getJobInstance().getJobName(),\n            \"STARTED\",\n            null\n        );\n        \n        logger.info(\"Starting job: {}\", \n            jobExecution.getJobInstance().getJobName());\n    }\n    \n    @Override\n    public void afterJob(JobExecution jobExecution) {\n        // Audit log\n        auditService.logEvent(\n            EventType.ADMIN_ACTION,\n            \"BATCH_JOB_END\",\n            jobExecution.getJobInstance().getJobName(),\n            jobExecution.getStatus().toString(),\n            null\n        );\n        \n        // Clear security context\n        SecurityContextHolder.clearContext();\n        \n        logger.info(\"Job finished: {} with status: {}\",\n            jobExecution.getJobInstance().getJobName(),\n            jobExecution.getStatus());\n    }\n}\n\n// Secure item processor\npublic class SecureUserProcessor implements ItemProcessor<User, User> {\n    \n    @Autowired\n    private DataMaskingService maskingService;\n    \n    @Autowired\n    private AuditService auditService;\n    \n    @Override\n    public User process(User user) throws Exception {\n        // Check if current authentication has permission\n        Authentication auth = SecurityContextHolder.getContext()\n            .getAuthentication();\n        \n        if (!hasPermission(auth, \"PROCESS_USER_DATA\")) {\n            throw new AccessDeniedException(\n                \"Insufficient permissions to process user data\");\n        }\n        \n        // Audit sensitive data access\n        auditService.logEvent(\n            EventType.SENSITIVE_DATA_ACCESS,\n            \"BATCH_PROCESS_USER\",\n            String.valueOf(user.getId()),\n            \"SUCCESS\",\n            null\n        );\n        \n        // Process user (with data masking if needed)\n        if (containsSensitiveData(user)) {\n            user = maskingService.maskSensitiveFields(user);\n        }\n        \n        return user;\n    }\n}\n\n// Secure item reader with data filtering\npublic class SecureUserReader implements ItemReader<User> {\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    private Iterator<User> userIterator;\n    \n    @BeforeStep\n    public void beforeStep(StepExecution stepExecution) {\n        // Get users based on security context\n        Authentication auth = SecurityContextHolder.getContext()\n            .getAuthentication();\n        \n        List<User> users;\n        if (hasRole(auth, \"ADMIN\")) {\n            // Admin can process all users\n            users = userRepository.findAll();\n        } else if (hasRole(auth, \"MANAGER\")) {\n            // Manager can only process their department\n            String department = getDepartment(auth);\n            users = userRepository.findByDepartment(department);\n        } else {\n            throw new AccessDeniedException(\n                \"Insufficient permissions to read user data\");\n        }\n        \n        this.userIterator = users.iterator();\n    }\n    \n    @Override\n    public User read() {\n        if (userIterator != null && userIterator.hasNext()) {\n            return userIterator.next();\n        }\n        return null;\n    }\n}\n\n// Secure job launcher\n@RestController\n@RequestMapping(\"/api/batch\")\npublic class BatchJobController {\n    \n    @Autowired\n    private JobLauncher jobLauncher;\n    \n    @Autowired\n    private Job userProcessingJob;\n    \n    @Autowired\n    private AuditService auditService;\n    \n    @PostMapping(\"/launch/user-processing\")\n    @PreAuthorize(\"hasRole('ADMIN')\")\n    public ResponseEntity<String> launchUserProcessing(\n            @AuthenticationPrincipal CustomUserDetails user) {\n        \n        try {\n            // Audit who launched the job\n            auditService.logEvent(\n                EventType.ADMIN_ACTION,\n                \"BATCH_JOB_LAUNCH\",\n                \"userProcessingJob\",\n                \"LAUNCHED_BY: \" + user.getUsername(),\n                null\n            );\n            \n            JobParameters params = new JobParametersBuilder()\n                .addLong(\"startTime\", System.currentTimeMillis())\n                .addString(\"launchedBy\", user.getUsername())\n                .toJobParameters();\n            \n            JobExecution execution = jobLauncher.run(userProcessingJob, params);\n            \n            return ResponseEntity.ok(\n                \"Job launched with execution id: \" + execution.getId());\n        } catch (Exception e) {\n            return ResponseEntity.status(500)\n                .body(\"Failed to launch job: \" + e.getMessage());\n        }\n    }\n}\n\n// Scheduled batch job with security\n@Component\npublic class ScheduledBatchJobs {\n    \n    @Autowired\n    private JobLauncher jobLauncher;\n    \n    @Autowired\n    private Job userProcessingJob;\n    \n    @Autowired\n    private SystemAuthenticationService systemAuthService;\n    \n    @Scheduled(cron = \"0 0 2 * * *\")  // Daily at 2 AM\n    public void runDailyUserProcessing() {\n        systemAuthService.runAsSystem(() -> {\n            try {\n                JobParameters params = new JobParametersBuilder()\n                    .addLong(\"startTime\", System.currentTimeMillis())\n                    .addString(\"launchedBy\", \"SYSTEM\")\n                    .toJobParameters();\n                \n                jobLauncher.run(userProcessingJob, params);\n            } catch (Exception e) {\n                logger.error(\"Failed to run scheduled batch job\", e);\n            }\n        });\n    }\n}"
    },
    {
      "id": 98,
      "question": "How do you implement security for event-driven architecture?",
      "answer": "Event-driven security:\n\nChallenges:\n• Async communication\n• Multiple producers/consumers\n• Event authenticity\n• Authorization per event\n• Data privacy in events\n\nSolutions:\n• Event signing\n• Message encryption\n• Consumer authorization\n• Audit logging\n• Schema validation",
      "explanation": "Events need authenticity and authorization. Sign events, encrypt sensitive data, authorize consumers.",
      "difficulty": "Hard",
      "code": "// Event with security metadata\npublic class SecureEvent<T> {\n    private String eventId;\n    private String eventType;\n    private T payload;\n    \n    // Security fields\n    private String publisher;\n    private LocalDateTime timestamp;\n    private String signature;  // Digital signature\n    private Set<String> allowedConsumers;\n    private boolean encrypted;\n}\n\n// Event publisher with security\n@Service\npublic class SecureEventPublisher {\n    \n    @Autowired\n    private ApplicationEventPublisher eventPublisher;\n    \n    @Autowired\n    private DigitalSignatureService signatureService;\n    \n    @Autowired\n    private EncryptionService encryptionService;\n    \n    public <T> void publishSecureEvent(String eventType, T payload, \n                                      Set<String> allowedConsumers) {\n        \n        // Get current user\n        Authentication auth = SecurityContextHolder.getContext()\n            .getAuthentication();\n        String publisher = auth.getName();\n        \n        // Create secure event\n        SecureEvent<T> event = new SecureEvent<>();\n        event.setEventId(UUID.randomUUID().toString());\n        event.setEventType(eventType);\n        event.setPayload(payload);\n        event.setPublisher(publisher);\n        event.setTimestamp(LocalDateTime.now());\n        event.setAllowedConsumers(allowedConsumers);\n        \n        // Encrypt sensitive data\n        if (containsSensitiveData(payload)) {\n            event.setPayload(encryptionService.encrypt(payload));\n            event.setEncrypted(true);\n        }\n        \n        // Sign event\n        String signature = signatureService.sign(event);\n        event.setSignature(signature);\n        \n        // Publish\n        eventPublisher.publishEvent(event);\n        \n        // Audit log\n        auditService.logEventPublished(event);\n    }\n}\n\n// Secure event listener\n@Component\npublic class SecureEventListener {\n    \n    @Autowired\n    private DigitalSignatureService signatureService;\n    \n    @Autowired\n    private EncryptionService encryptionService;\n    \n    @Autowired\n    private AuditService auditService;\n    \n    @EventListener\n    @Async\n    public void handleUserCreatedEvent(SecureEvent<UserCreatedPayload> event) {\n        \n        try {\n            // 1. Verify signature\n            if (!signatureService.verify(event)) {\n                logger.error(\"Invalid event signature: {}\", event.getEventId());\n                auditService.logSecurityViolation(\"INVALID_SIGNATURE\", event);\n                return;\n            }\n            \n            // 2. Check authorization\n            Authentication auth = SecurityContextHolder.getContext()\n                .getAuthentication();\n            String consumer = auth.getName();\n            \n            if (!event.getAllowedConsumers().contains(consumer) && \n                !event.getAllowedConsumers().contains(\"*\")) {\n                logger.error(\"Unauthorized consumer: {} for event: {}\",\n                    consumer, event.getEventId());\n                auditService.logSecurityViolation(\"UNAUTHORIZED_CONSUMER\", event);\n                return;\n            }\n            \n            // 3. Decrypt if needed\n            UserCreatedPayload payload = event.getPayload();\n            if (event.isEncrypted()) {\n                payload = encryptionService.decrypt(payload);\n            }\n            \n            // 4. Process event\n            handleUserCreated(payload);\n            \n            // 5. Audit log\n            auditService.logEventConsumed(event, consumer);\n            \n        } catch (Exception e) {\n            logger.error(\"Error processing event\", e);\n            auditService.logEventProcessingError(event, e);\n        }\n    }\n}\n\n// Kafka with security\n@Configuration\npublic class KafkaSecurityConfig {\n    \n    @Bean\n    public ProducerFactory<String, SecureEvent<?>> producerFactory() {\n        Map<String, Object> config = new HashMap<>();\n        config.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, \"localhost:9092\");\n        \n        // SSL/TLS\n        config.put(\"security.protocol\", \"SSL\");\n        config.put(\"ssl.truststore.location\", \"/path/to/truststore.jks\");\n        config.put(\"ssl.truststore.password\", \"password\");\n        config.put(\"ssl.keystore.location\", \"/path/to/keystore.jks\");\n        config.put(\"ssl.keystore.password\", \"password\");\n        \n        // SASL authentication\n        config.put(\"sasl.mechanism\", \"PLAIN\");\n        config.put(\"sasl.jaas.config\", \n            \"org.apache.kafka.common.security.plain.PlainLoginModule required \" +\n            \"username='user' password='password';\");\n        \n        return new DefaultKafkaProducerFactory<>(config);\n    }\n}\n\n// Message signing service\n@Service\npublic class DigitalSignatureService {\n    \n    @Value(\"${security.signing.private-key}\")\n    private String privateKey;\n    \n    @Value(\"${security.signing.public-key}\")\n    private String publicKey;\n    \n    public <T> String sign(SecureEvent<T> event) {\n        try {\n            // Create signature from event data\n            String data = event.getEventId() + \n                         event.getEventType() + \n                         event.getPublisher() + \n                         event.getTimestamp() + \n                         serializePayload(event.getPayload());\n            \n            Signature signature = Signature.getInstance(\"SHA256withRSA\");\n            signature.initSign(loadPrivateKey(privateKey));\n            signature.update(data.getBytes(StandardCharsets.UTF_8));\n            \n            return Base64.getEncoder().encodeToString(signature.sign());\n        } catch (Exception e) {\n            throw new SecurityException(\"Failed to sign event\", e);\n        }\n    }\n    \n    public <T> boolean verify(SecureEvent<T> event) {\n        try {\n            String data = event.getEventId() + \n                         event.getEventType() + \n                         event.getPublisher() + \n                         event.getTimestamp() + \n                         serializePayload(event.getPayload());\n            \n            Signature signature = Signature.getInstance(\"SHA256withRSA\");\n            signature.initVerify(loadPublicKey(publicKey));\n            signature.update(data.getBytes(StandardCharsets.UTF_8));\n            \n            return signature.verify(\n                Base64.getDecoder().decode(event.getSignature()));\n        } catch (Exception e) {\n            logger.error(\"Signature verification failed\", e);\n            return false;\n        }\n    }\n}\n\n// Event audit logging\n@Service\npublic class EventAuditService {\n    \n    public void logEventPublished(SecureEvent<?> event) {\n        EventAuditLog log = new EventAuditLog();\n        log.setEventId(event.getEventId());\n        log.setEventType(event.getEventType());\n        log.setPublisher(event.getPublisher());\n        log.setTimestamp(event.getTimestamp());\n        log.setAction(\"PUBLISHED\");\n        auditLogRepository.save(log);\n    }\n    \n    public void logEventConsumed(SecureEvent<?> event, String consumer) {\n        EventAuditLog log = new EventAuditLog();\n        log.setEventId(event.getEventId());\n        log.setEventType(event.getEventType());\n        log.setConsumer(consumer);\n        log.setTimestamp(LocalDateTime.now());\n        log.setAction(\"CONSUMED\");\n        auditLogRepository.save(log);\n    }\n}"
    },
    {
      "id": 99,
      "question": "How do you implement zero-trust security architecture?",
      "answer": "Zero Trust principles:\n\n1. Never trust, always verify\n2. Assume breach\n3. Verify explicitly\n4. Least privilege access\n5. Micro-segmentation\n\nImplementation:\n• Authenticate every request\n• Authorize every action\n• Encrypt all traffic\n• Log everything\n• Monitor continuously\n• Context-aware access",
      "explanation": "Zero Trust assumes no implicit trust. Verify identity and device on every request, regardless of location.",
      "difficulty": "Hard",
      "code": "// Zero Trust Security Configuration\n@Configuration\npublic class ZeroTrustSecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain zeroTrustFilterChain(HttpSecurity http) {\n        http\n            // 1. No requests bypass security\n            .authorizeHttpRequests(auth -> auth\n                .anyRequest().authenticated()\n            )\n            \n            // 2. Stateless (no session trust)\n            .sessionManagement(session -> session\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n            )\n            \n            // 3. Multiple authentication factors\n            .oauth2ResourceServer(oauth2 -> oauth2\n                .jwt(jwt -> jwt\n                    .jwtAuthenticationConverter(contextAwareJwtConverter())\n                )\n            )\n            \n            // 4. Always use HTTPS\n            .requiresChannel(channel -> channel\n                .anyRequest().requiresSecure()\n            )\n            \n            // 5. Security headers\n            .headers(headers -> headers\n                .httpStrictTransportSecurity(hsts -> hsts\n                    .includeSubDomains(true)\n                    .maxAgeInSeconds(31536000)\n                )\n            );\n        \n        // 6. Context verification filters\n        http.addFilterBefore(\n            deviceVerificationFilter(),\n            UsernamePasswordAuthenticationFilter.class\n        );\n        \n        http.addFilterBefore(\n            riskAssessmentFilter(),\n            UsernamePasswordAuthenticationFilter.class\n        );\n        \n        return http.build();\n    }\n}\n\n// Device verification filter\n@Component\npublic class DeviceVerificationFilter extends OncePerRequestFilter {\n    \n    @Autowired\n    private DeviceService deviceService;\n    \n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                   HttpServletResponse response,\n                                   FilterChain chain) {\n        \n        // Extract device fingerprint\n        String deviceId = request.getHeader(\"X-Device-ID\");\n        String deviceFingerprint = calculateDeviceFingerprint(request);\n        \n        if (deviceId == null || !deviceService.isKnownDevice(deviceId)) {\n            // Unknown device - require additional verification\n            response.setStatus(403);\n            response.setHeader(\"X-Verification-Required\", \"true\");\n            return;\n        }\n        \n        // Verify device hasn't been compromised\n        if (deviceService.isCompromised(deviceId)) {\n            response.setStatus(403);\n            response.getWriter().write(\"Device security compromised\");\n            return;\n        }\n        \n        // Store device context\n        request.setAttribute(\"deviceId\", deviceId);\n        request.setAttribute(\"deviceFingerprint\", deviceFingerprint);\n        \n        chain.doFilter(request, response);\n    }\n}\n\n// Risk assessment filter\n@Component\npublic class RiskAssessmentFilter extends OncePerRequestFilter {\n    \n    @Autowired\n    private RiskAssessmentService riskService;\n    \n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                   HttpServletResponse response,\n                                   FilterChain chain) {\n        \n        // Assess risk based on context\n        RiskScore risk = riskService.assessRisk(\n            getClientIp(request),\n            request.getHeader(\"User-Agent\"),\n            request.getAttribute(\"deviceId\"),\n            SecurityContextHolder.getContext().getAuthentication()\n        );\n        \n        // High risk requires step-up authentication\n        if (risk.isHigh()) {\n            response.setStatus(401);\n            response.setHeader(\"X-Step-Up-Required\", \"true\");\n            response.setHeader(\"X-Risk-Score\", String.valueOf(risk.getScore()));\n            return;\n        }\n        \n        // Store risk score for authorization decisions\n        request.setAttribute(\"riskScore\", risk);\n        \n        chain.doFilter(request, response);\n    }\n}\n\n// Context-aware JWT converter\npublic class ContextAwareJwtConverter implements Converter<Jwt, AbstractAuthenticationToken> {\n    \n    @Override\n    public AbstractAuthenticationToken convert(Jwt jwt) {\n        // Extract user and roles\n        Collection<GrantedAuthority> authorities = extractAuthorities(jwt);\n        \n        // Create authentication with context\n        ZeroTrustAuthenticationToken authentication = \n            new ZeroTrustAuthenticationToken(jwt, authorities);\n        \n        // Verify token freshness\n        Instant issuedAt = jwt.getIssuedAt();\n        if (issuedAt.isBefore(Instant.now().minus(Duration.ofMinutes(5)))) {\n            throw new TokenExpiredException(\"Token too old for zero trust\");\n        }\n        \n        // Verify device claim\n        String deviceId = jwt.getClaimAsString(\"device_id\");\n        if (!deviceService.isKnownDevice(deviceId)) {\n            throw new UnknownDeviceException(\"Unknown device\");\n        }\n        \n        return authentication;\n    }\n}\n\n// Risk assessment service\n@Service\npublic class RiskAssessmentService {\n    \n    public RiskScore assessRisk(String ip, String userAgent, \n                               Object deviceId, Authentication auth) {\n        \n        int score = 0;\n        \n        // Check IP reputation\n        if (isKnownBadIp(ip)) {\n            score += 50;\n        }\n        \n        // Check location\n        String location = geoLocationService.getLocation(ip);\n        if (!isUsualLocation(auth.getName(), location)) {\n            score += 30;\n        }\n        \n        // Check time\n        if (isUnusualTime(auth.getName())) {\n            score += 20;\n        }\n        \n        // Check device\n        if (deviceId == null || !deviceService.isKnownDevice(deviceId)) {\n            score += 40;\n        }\n        \n        // Check recent authentication failures\n        if (hasRecentFailures(auth.getName())) {\n            score += 25;\n        }\n        \n        return new RiskScore(score);\n    }\n}\n\n// Dynamic authorization with context\n@PreAuthorize(\"@zeroTrustChecker.checkAccess(#resource, authentication, #request)\")\npublic Resource getResource(String resourceId, HttpServletRequest request) {\n    return resourceService.getById(resourceId);\n}\n\n@Component(\"zeroTrustChecker\")\npublic class ZeroTrustAccessChecker {\n    \n    public boolean checkAccess(String resource, \n                              Authentication auth,\n                              HttpServletRequest request) {\n        \n        // 1. Verify authentication is fresh\n        if (!isAuthenticationFresh(auth)) {\n            return false;\n        }\n        \n        // 2. Check risk score\n        RiskScore risk = (RiskScore) request.getAttribute(\"riskScore\");\n        if (risk != null && risk.isHigh()) {\n            return false;\n        }\n        \n        // 3. Verify device\n        String deviceId = (String) request.getAttribute(\"deviceId\");\n        if (!deviceService.isAuthorized(deviceId, resource)) {\n            return false;\n        }\n        \n        // 4. Check resource-specific permissions\n        return hasPermission(auth, resource);\n    }\n}\n\n// Continuous monitoring\n@Component\npublic class ContinuousMonitoring {\n    \n    @Scheduled(fixedRate = 60000)  // Every minute\n    public void monitorActiveSessions() {\n        // Re-evaluate all active sessions\n        List<ActiveSession> sessions = sessionService.getActiveSessions();\n        \n        for (ActiveSession session : sessions) {\n            RiskScore risk = riskService.assessRisk(session);\n            \n            if (risk.isHigh()) {\n                // Terminate high-risk sessions\n                sessionService.terminateSession(session.getId());\n                alertService.sendAlert(\n                    \"High-risk session terminated: \" + session.getUserId());\n            }\n        }\n    }\n}"
    },
    {
      "id": 100,
      "question": "What are the latest Spring Security features and best practices for 2024?",
      "answer": "Spring Security 6+ (2024):\n\nNew features:\n• Lambda DSL (required)\n• SecurityFilterChain (bean-based)\n• Observability with Micrometer\n• Authorization events\n• @AuthenticationPrincipal improvements\n\nDeprecated:\n• WebSecurityConfigurerAdapter\n• authorizeRequests()\n• antMatchers()\n\nBest practices:\n• Use SecurityFilterChain beans\n• Lambda configuration\n• AuthorizationManager\n• Method security with @PreAuthorize",
      "explanation": "Spring Security 6 modernizes config with lambda DSL and bean-based approach. Migrate from deprecated patterns.",
      "difficulty": "Medium",
      "code": "// âŒ OLD (Spring Security 5, deprecated)\n@Configuration\npublic class OldSecurityConfig extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n            .authorizeRequests()\n                .antMatchers(\"/public/**\").permitAll()\n                .antMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n                .anyRequest().authenticated()\n            .and()\n            .formLogin()\n            .and()\n            .httpBasic();\n    }\n}\n\n// âœ… NEW (Spring Security 6+, recommended)\n@Configuration\n@EnableWebSecurity\n@EnableMethodSecurity  // Replaces @EnableGlobalMethodSecurity\npublic class ModernSecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/public/**\").permitAll()\n                .requestMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n                .anyRequest().authenticated()\n            )\n            .formLogin(Customizer.withDefaults())\n            .httpBasic(Customizer.withDefaults());\n        \n        return http.build();\n    }\n}\n\n// Multiple security configurations\n@Configuration\npublic class MultipleSecurityConfig {\n    \n    @Bean\n    @Order(1)\n    public SecurityFilterChain apiSecurityFilterChain(HttpSecurity http) {\n        http\n            .securityMatcher(\"/api/**\")\n            .authorizeHttpRequests(auth -> auth\n                .anyRequest().authenticated()\n            )\n            .oauth2ResourceServer(oauth2 -> oauth2.jwt(Customizer.withDefaults()))\n            .csrf(csrf -> csrf.disable())\n            .sessionManagement(session -> session\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n            );\n        \n        return http.build();\n    }\n    \n    @Bean\n    @Order(2)\n    public SecurityFilterChain webSecurityFilterChain(HttpSecurity http) {\n        http\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/\", \"/login\").permitAll()\n                .anyRequest().authenticated()\n            )\n            .formLogin(form -> form\n                .loginPage(\"/login\")\n                .defaultSuccessUrl(\"/dashboard\")\n            );\n        \n        return http.build();\n    }\n}\n\n// Modern method security\n@Service\npublic class ModernUserService {\n    \n    // SpEL expressions\n    @PreAuthorize(\"hasRole('ADMIN') or #userId == authentication.principal.id\")\n    public User getUser(Long userId) {\n        return userRepository.findById(userId).orElseThrow();\n    }\n    \n    // @PostAuthorize for return value checks\n    @PostAuthorize(\"returnObject.username == authentication.name\")\n    public User getUserByUsername(String username) {\n        return userRepository.findByUsername(username).orElseThrow();\n    }\n    \n    // @PreFilter and @PostFilter\n    @PreFilter(\"filterObject != authentication.principal.username\")\n    public void deleteUsers(List<String> usernames) {\n        usernames.forEach(username -> userRepository.deleteByUsername(username));\n    }\n    \n    @PostFilter(\"filterObject.username == authentication.name or hasRole('ADMIN')\")\n    public List<User> getAllUsers() {\n        return userRepository.findAll();\n    }\n}\n\n// Custom AuthorizationManager (modern approach)\n@Component\npublic class CustomAuthorizationManager \n        implements AuthorizationManager<RequestAuthorizationContext> {\n    \n    @Override\n    public AuthorizationDecision check(\n            Supplier<Authentication> authentication,\n            RequestAuthorizationContext context) {\n        \n        HttpServletRequest request = context.getRequest();\n        Authentication auth = authentication.get();\n        \n        // Custom authorization logic\n        boolean granted = checkCustomRules(auth, request);\n        \n        return new AuthorizationDecision(granted);\n    }\n}\n\n// Use custom AuthorizationManager\n@Bean\npublic SecurityFilterChain customAuthFilterChain(HttpSecurity http,\n                                                 CustomAuthorizationManager authManager) {\n    http\n        .authorizeHttpRequests(auth -> auth\n            .requestMatchers(\"/custom/**\").access(authManager)\n            .anyRequest().authenticated()\n        );\n    \n    return http.build();\n}\n\n// Observability with Micrometer (Spring Security 6.1+)\n@Configuration\npublic class SecurityObservabilityConfig {\n    \n    @Bean\n    public ObservationRegistry observationRegistry() {\n        return ObservationRegistry.create();\n    }\n    \n    // Automatically enabled:\n    // - Authentication observations\n    // - Authorization observations\n    // - Filter chain observations\n}\n\n// Authorization events (Spring Security 6.1+)\n@Component\npublic class AuthorizationEventListener {\n    \n    @EventListener\n    public void onAuthorizationDenied(AuthorizationDeniedEvent<?> event) {\n        Authentication auth = event.getAuthentication().get();\n        logger.warn(\"Access denied for user: {}\", auth.getName());\n    }\n    \n    @EventListener\n    public void onAuthorizationGranted(AuthorizationGrantedEvent<?> event) {\n        Authentication auth = event.getAuthentication().get();\n        logger.info(\"Access granted for user: {}\", auth.getName());\n    }\n}\n\n// Modern password encoding\n@Bean\npublic PasswordEncoder passwordEncoder() {\n    // Defaults to BCrypt with strength 10\n    return PasswordEncoderFactories.createDelegatingPasswordEncoder();\n}\n\n// Custom password encoder\n@Bean\npublic PasswordEncoder customPasswordEncoder() {\n    String encodingId = \"bcrypt\";\n    Map<String, PasswordEncoder> encoders = new HashMap<>();\n    encoders.put(encodingId, new BCryptPasswordEncoder(12));\n    encoders.put(\"pbkdf2\", Pbkdf2PasswordEncoder.defaultsForSpringSecurity_v5_8());\n    encoders.put(\"scrypt\", SCryptPasswordEncoder.defaultsForSpringSecurity_v5_8());\n    encoders.put(\"argon2\", Argon2PasswordEncoder.defaultsForSpringSecurity_v5_8());\n    \n    return new DelegatingPasswordEncoder(encodingId, encoders);\n}\n\n// Reactive security (WebFlux)\n@Configuration\npublic class ReactiveSecurityConfig {\n    \n    @Bean\n    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n        http\n            .authorizeExchange(auth -> auth\n                .pathMatchers(\"/public/**\").permitAll()\n                .anyExchange().authenticated()\n            )\n            .oauth2ResourceServer(oauth2 -> oauth2.jwt(Customizer.withDefaults()));\n        \n        return http.build();\n    }\n}\n\n// Best practices summary:\n// 1. Use SecurityFilterChain beans instead of WebSecurityConfigurerAdapter\n// 2. Use lambda DSL (required in Spring Security 6)\n// 3. Use requestMatchers() instead of antMatchers()\n// 4. Use authorizeHttpRequests() instead of authorizeRequests()\n// 5. Use @EnableMethodSecurity instead of @EnableGlobalMethodSecurity\n// 6. Implement observability for monitoring\n// 7. Use modern password encoders (Argon2, BCrypt with high strength)\n// 8. Enable and monitor authorization events"
    }
  ]
}