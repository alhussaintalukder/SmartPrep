{
  "topic": "TypeScript",
  "questions": [
    {
      "id": 1,
      "question": "What is TypeScript and how does it differ from JavaScript?",
      "answer": "TypeScript is a strongly typed superset of JavaScript that compiles to plain JavaScript.\n\nKey Differences:\n• Static typing with type annotations\n• Compile-time type checking\n• Enhanced IDE support with IntelliSense\n• Modern ECMAScript features with backward compatibility\n• Object-oriented programming features like interfaces and enums\n• Better code maintainability and refactoring\n\nBenefits:\n• Catches errors during development\n• Improves code documentation\n• Enables better tooling and autocompletion\n• Scales well for large applications",
      "explanation": "TypeScript adds static typing and compile-time error checking to JavaScript, making it more suitable for large-scale applications.",
      "difficulty": "Easy",
      "code": "// JavaScript\nfunction add(a, b) {\n  return a + b;\n}\nadd(5, '10'); // Returns '510' - unexpected\n\n// TypeScript\nfunction add(a: number, b: number): number {\n  return a + b;\n}\nadd(5, '10'); // Compile error: Argument of type 'string' not assignable to 'number'"
    },
    {
      "id": 2,
      "question": "What are the basic types in TypeScript?",
      "answer": "TypeScript provides several primitive and complex types for type annotations.\n\nPrimitive Types:\n• number - for numeric values\n• string - for text values\n• boolean - for true/false values\n• null and undefined - for absence of value\n• symbol - for unique identifiers\n• bigint - for large integers\n\nComplex Types:\n• array - collection of elements\n• tuple - fixed-length array with specific types\n• enum - named constants\n• any - disables type checking\n• unknown - type-safe alternative to any\n• void - absence of return value\n• never - represents values that never occur",
      "explanation": "TypeScript offers primitive types like number, string, boolean, and complex types like arrays, tuples, and enums for comprehensive type safety.",
      "difficulty": "Easy",
      "code": "// Primitive types\nlet age: number = 25;\nlet name: string = 'John';\nlet isActive: boolean = true;\nlet value: null = null;\n\n// Complex types\nlet numbers: number[] = [1, 2, 3];\nlet tuple: [string, number] = ['hello', 10];\nenum Color { Red, Green, Blue }\nlet color: Color = Color.Red;\n\n// Special types\nlet anything: any = 'can be anything';\nlet notSure: unknown = 4;\nfunction log(): void { console.log('test'); }\nfunction error(): never { throw new Error(); }"
    },
    {
      "id": 3,
      "question": "What is type inference in TypeScript?",
      "answer": "Type inference is TypeScript's ability to automatically determine the type of a variable without explicit annotation.\n\nHow It Works:\n• Infers types based on assigned values\n• Analyzes return statements in functions\n• Considers context in expressions\n• Uses best common type algorithm for arrays\n\nBenefits:\n• Less verbose code\n• Maintains type safety\n• Reduces redundant type annotations\n• Still provides compile-time checks\n\nBest Practices:\n• Let TypeScript infer when obvious\n• Use explicit types for function parameters\n• Annotate complex return types\n• Be explicit when inference might be unclear",
      "explanation": "Type inference allows TypeScript to automatically determine variable types based on their values, reducing the need for explicit type annotations while maintaining type safety.",
      "difficulty": "Easy",
      "code": "// Type inference\nlet message = 'Hello'; // inferred as string\nlet count = 42; // inferred as number\nlet isValid = true; // inferred as boolean\n\n// Function return type inference\nfunction multiply(a: number, b: number) {\n  return a * b; // return type inferred as number\n}\n\n// Array type inference\nlet numbers = [1, 2, 3]; // inferred as number[]\nlet mixed = [1, 'two', true]; // inferred as (string | number | boolean)[]\n\n// Context-based inference\nwindow.addEventListener('click', (event) => {\n  // event is inferred as MouseEvent\n  console.log(event.clientX);\n});"
    },
    {
      "id": 4,
      "question": "What are interfaces in TypeScript?",
      "answer": "Interfaces define contracts for object shapes, specifying the structure that objects must follow.\n\nKey Features:\n• Define object structure with properties and methods\n• Support optional properties with ?\n• Support readonly properties\n• Can be extended and merged\n• Enable polymorphism and abstraction\n\nUse Cases:\n• Define API response structures\n• Enforce class contracts\n• Type function parameters and return values\n• Create reusable type definitions\n\nBest Practices:\n• Use interfaces for object shapes\n• Prefix interface names with I (optional)\n• Keep interfaces focused and cohesive\n• Use type aliases for unions and primitives",
      "explanation": "Interfaces define the structure and contract that objects must adhere to, enabling strong typing and better code organization.",
      "difficulty": "Easy",
      "code": "// Basic interface\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  age?: number; // optional property\n  readonly createdAt: Date; // readonly property\n}\n\nconst user: User = {\n  id: 1,\n  name: 'John Doe',\n  email: 'john@example.com',\n  createdAt: new Date()\n};\n\n// Interface with methods\ninterface Calculator {\n  add(a: number, b: number): number;\n  subtract(a: number, b: number): number;\n}\n\n// Extending interfaces\ninterface Admin extends User {\n  role: string;\n  permissions: string[];\n}"
    },
    {
      "id": 5,
      "question": "What is the difference between interface and type in TypeScript?",
      "answer": "Both interfaces and type aliases can define object shapes, but they have different capabilities and use cases.\n\nInterfaces:\n• Can be extended using extends keyword\n• Support declaration merging\n• Better for object-oriented patterns\n• Can be implemented by classes\n• Better error messages in some cases\n\nType Aliases:\n• Can represent primitives, unions, and tuples\n• Cannot be reopened to add properties\n• Support computed properties\n• Can use union and intersection types\n• More flexible for complex types\n\nWhen to Use:\n• Use interfaces for object shapes and classes\n• Use type aliases for unions, tuples, and primitives\n• Prefer interfaces for public APIs\n• Use types for complex type compositions",
      "explanation": "Interfaces are best for defining object contracts and can be extended and merged, while type aliases are more flexible for unions, tuples, and complex type compositions.",
      "difficulty": "Easy",
      "code": "// Interface\ninterface Point {\n  x: number;\n  y: number;\n}\n\ninterface Point3D extends Point {\n  z: number;\n}\n\n// Type alias\ntype ID = string | number;\ntype Coordinates = [number, number];\n\ntype Shape = {\n  color: string;\n  area: number;\n};\n\n// Type unions (only with type)\ntype Status = 'pending' | 'approved' | 'rejected';\n\n// Declaration merging (only with interface)\ninterface Window {\n  customProperty: string;\n}\n\ninterface Window {\n  anotherProperty: number;\n}\n// Window now has both properties"
    },
    {
      "id": 6,
      "question": "What are generics in TypeScript?",
      "answer": "Generics allow creation of reusable components that work with multiple types while maintaining type safety.\n\nKey Concepts:\n• Type parameters represented with angle brackets\n• Enable code reusability without losing type information\n• Work with functions, classes, and interfaces\n• Support constraints to limit acceptable types\n• Allow default type parameters\n\nBenefits:\n• Write flexible, reusable code\n• Maintain type safety\n• Avoid code duplication\n• Better IntelliSense support\n• Compile-time type checking\n\nCommon Use Cases:\n• Collection classes and data structures\n• Utility functions\n• API response handlers\n• Repository patterns",
      "explanation": "Generics enable writing flexible, reusable components that work with any type while preserving type safety through parameterized types.",
      "difficulty": "Easy",
      "code": "// Generic function\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\nlet output1 = identity<string>('hello'); // type is string\nlet output2 = identity<number>(42); // type is number\n\n// Generic interface\ninterface Container<T> {\n  value: T;\n  getValue(): T;\n}\n\nconst numberContainer: Container<number> = {\n  value: 42,\n  getValue() { return this.value; }\n};\n\n// Generic class\nclass DataStore<T> {\n  private data: T[] = [];\n  \n  add(item: T): void {\n    this.data.push(item);\n  }\n  \n  get(index: number): T {\n    return this.data[index];\n  }\n}\n\nconst store = new DataStore<string>();\nstore.add('hello');"
    },
    {
      "id": 7,
      "question": "What are type assertions in TypeScript?",
      "answer": "Type assertions tell the compiler to treat a value as a specific type, overriding its inferred type.\n\nSyntax Options:\n• Angle bracket syntax: <Type>value\n• As syntax: value as Type (preferred in JSX)\n\nWhen to Use:\n• Working with DOM elements\n• Handling third-party libraries\n• Narrowing union types\n• Type casting from any or unknown\n\nCautions:\n• Does not perform runtime checks\n• Can bypass type safety if misused\n• Should be used sparingly\n• Consider type guards as safer alternative\n\nBest Practices:\n• Use as syntax for consistency\n• Avoid asserting to incompatible types\n• Prefer type narrowing when possible\n• Document why assertion is needed",
      "explanation": "Type assertions allow explicitly telling TypeScript to treat a value as a specific type, useful when you know more about the type than the compiler does.",
      "difficulty": "Easy",
      "code": "// DOM element assertion\nconst input = document.getElementById('myInput') as HTMLInputElement;\ninput.value = 'Hello';\n\n// Alternative syntax\nconst button = <HTMLButtonElement>document.getElementById('myButton');\n\n// Asserting from any\nlet value: any = 'this is a string';\nlet length: number = (value as string).length;\n\n// Double assertion (avoid when possible)\nlet num = 42;\nlet str = num as unknown as string; // Not recommended\n\n// Better: Type narrowing\nfunction process(value: string | number) {\n  if (typeof value === 'string') {\n    // TypeScript knows value is string here\n    console.log(value.toUpperCase());\n  }\n}"
    },
    {
      "id": 8,
      "question": "What are union and intersection types?",
      "answer": "Union and intersection types allow combining multiple types in different ways.\n\nUnion Types (|):\n• Value can be one of several types\n• Use | operator to combine types\n• Type narrowing required to access specific properties\n• Common for optional values and multiple input types\n\nIntersection Types (&):\n• Combines multiple types into one\n• Value must satisfy all types\n• Use & operator to combine types\n• Useful for mixins and composition\n\nType Narrowing:\n• typeof checks for primitives\n• instanceof checks for classes\n• in operator for property checks\n• Custom type guards for complex logic",
      "explanation": "Union types allow a value to be one of several types using |, while intersection types combine multiple types into one using &.",
      "difficulty": "Easy",
      "code": "// Union types\ntype ID = string | number;\n\nfunction printId(id: ID) {\n  // Type narrowing required\n  if (typeof id === 'string') {\n    console.log(id.toUpperCase());\n  } else {\n    console.log(id.toFixed(2));\n  }\n}\n\nprintId('abc123');\nprintId(42);\n\n// Intersection types\ninterface Named {\n  name: string;\n}\n\ninterface Aged {\n  age: number;\n}\n\ntype Person = Named & Aged;\n\nconst person: Person = {\n  name: 'John',\n  age: 30\n}; // Must have both properties\n\n// Complex example\ntype Draggable = { drag(): void };\ntype Resizable = { resize(): void };\ntype UIElement = Draggable & Resizable;\n\nconst widget: UIElement = {\n  drag() { console.log('dragging'); },\n  resize() { console.log('resizing'); }\n};"
    },
    {
      "id": 9,
      "question": "What is the any type and when should it be used?",
      "answer": "The any type disables type checking, allowing any value to be assigned and any operation to be performed.\n\nCharacteristics:\n• Opts out of type checking\n• Compatible with all types\n• Can call any property or method\n• No compile-time errors\n• Similar to plain JavaScript\n\nValid Use Cases:\n• Migrating JavaScript code gradually\n• Working with dynamic content from APIs\n• Interfacing with third-party libraries without types\n• Temporary placeholder during development\n\nWhy to Avoid:\n• Defeats purpose of TypeScript\n• No IntelliSense support\n• Runtime errors not caught\n• Reduces code maintainability\n\nBetter Alternatives:\n• Use unknown for safer type-unsafe values\n• Create proper interfaces\n• Use generics for flexibility\n• Employ type guards for narrowing",
      "explanation": "The any type disables TypeScript's type checking and should be avoided except when migrating code or dealing with truly dynamic content, preferring unknown for type-safe alternatives.",
      "difficulty": "Easy",
      "code": "// Using any (not recommended)\nlet value: any = 42;\nvalue = 'hello';\nvalue = true;\nvalue.nonExistent(); // No error, but fails at runtime\n\n// Better: Use unknown\nlet userInput: unknown = getUserInput();\n\nif (typeof userInput === 'string') {\n  console.log(userInput.toUpperCase()); // Safe\n}\n\n// Better: Use proper types\ninterface ApiResponse {\n  data: unknown;\n  status: number;\n}\n\nfunction handleResponse(response: ApiResponse) {\n  // Type guard before using data\n  if (isValidData(response.data)) {\n    processData(response.data);\n  }\n}\n\n// Better: Use generics\nfunction fetchData<T>(url: string): Promise<T> {\n  return fetch(url).then(res => res.json());\n}"
    },
    {
      "id": 10,
      "question": "What is the unknown type in TypeScript?",
      "answer": "The unknown type is a type-safe alternative to any that requires type checking before use.\n\nKey Features:\n• Represents any value like any\n• Requires type narrowing before operations\n• Enforces type checking at compile time\n• Cannot be assigned to other types without checks\n• Top type in TypeScript type system\n\nDifferences from any:\n• any disables type checking\n• unknown enforces type checking\n• any is unsafe, unknown is safe\n• unknown requires explicit type guards\n\nCommon Patterns:\n• API responses with uncertain structure\n• User input validation\n• Error handling\n• Type-safe parsing operations\n\nType Narrowing Methods:\n• typeof checks\n• instanceof checks\n• Custom type guards\n• Type assertions after validation",
      "explanation": "The unknown type is a safer alternative to any that requires type checking before use, ensuring type safety while handling values of uncertain types.",
      "difficulty": "Easy",
      "code": "// Using unknown safely\nfunction processValue(value: unknown): void {\n  // Must check type before use\n  if (typeof value === 'string') {\n    console.log(value.toUpperCase());\n  } else if (typeof value === 'number') {\n    console.log(value.toFixed(2));\n  } else {\n    console.log('Unknown type');\n  }\n}\n\n// Type guard with unknown\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\nfunction handleInput(input: unknown) {\n  if (isString(input)) {\n    // TypeScript knows input is string here\n    console.log(input.length);\n  }\n}\n\n// API response handling\nasync function fetchData(url: string): Promise<unknown> {\n  const response = await fetch(url);\n  return response.json();\n}\n\nconst data = await fetchData('/api/users');\n// Must validate before use\nif (isValidUserData(data)) {\n  processUsers(data);\n}"
    },
    {
      "id": 11,
      "question": "What are type guards in TypeScript?",
      "answer": "Type guards are expressions that perform runtime checks to narrow down types within a conditional block.\n\nBuilt-in Type Guards:\n• typeof - checks primitive types\n• instanceof - checks class instances\n• in - checks for property existence\n• Array.isArray() - checks for arrays\n\nCustom Type Guards:\n• User-defined functions with type predicates\n• Return type: value is Type\n• Perform runtime validation\n• Enable type narrowing\n\nBenefits:\n• Safe type narrowing\n• Better IntelliSense\n• Avoid type assertions\n• Runtime safety with compile-time checking\n\nBest Practices:\n• Use built-in guards when possible\n• Create reusable custom guards\n• Name guards clearly (isType pattern)\n• Keep guard logic simple",
      "explanation": "Type guards are runtime checks that narrow down types in conditional blocks, enabling safe access to type-specific properties and methods.",
      "difficulty": "Medium",
      "code": "// Built-in type guards\nfunction process(value: string | number) {\n  if (typeof value === 'string') {\n    return value.toUpperCase();\n  }\n  return value.toFixed(2);\n}\n\nfunction handleEvent(event: MouseEvent | KeyboardEvent) {\n  if (event instanceof MouseEvent) {\n    console.log(event.clientX, event.clientY);\n  } else {\n    console.log(event.key);\n  }\n}\n\n// Custom type guard\ninterface Dog {\n  bark(): void;\n}\n\ninterface Cat {\n  meow(): void;\n}\n\nfunction isDog(animal: Dog | Cat): animal is Dog {\n  return (animal as Dog).bark !== undefined;\n}\n\nfunction makeSound(animal: Dog | Cat) {\n  if (isDog(animal)) {\n    animal.bark(); // TypeScript knows it's Dog\n  } else {\n    animal.meow(); // TypeScript knows it's Cat\n  }\n}"
    },
    {
      "id": 12,
      "question": "What are literal types in TypeScript?",
      "answer": "Literal types allow specifying exact values that a variable can hold, not just the general type.\n\nTypes of Literals:\n• String literals - specific string values\n• Numeric literals - specific number values\n• Boolean literals - true or false\n• Template literal types - pattern-based strings\n\nUse Cases:\n• Restricting values to specific options\n• Creating discriminated unions\n• Type-safe configuration\n• Enum alternatives\n• State management\n\nCombining Literals:\n• Use union types for multiple options\n• Combine with other types\n• Create complex type patterns\n• Enable exhaustive checking\n\nBenefits:\n• Better autocomplete\n• Compile-time validation\n• Self-documenting code\n• Prevents invalid values",
      "explanation": "Literal types specify exact values rather than general types, enabling precise type constraints and better type safety for specific value sets.",
      "difficulty": "Medium",
      "code": "// String literal types\ntype Direction = 'north' | 'south' | 'east' | 'west';\n\nfunction move(direction: Direction) {\n  console.log(`Moving ${direction}`);\n}\n\nmove('north'); // OK\n// move('up'); // Error: not assignable\n\n// Numeric literal types\ntype DiceRoll = 1 | 2 | 3 | 4 | 5 | 6;\n\nfunction rollDice(): DiceRoll {\n  return Math.floor(Math.random() * 6) + 1 as DiceRoll;\n}\n\n// Boolean literal type\ntype IsTrue = true;\n\n// Combining with other types\ntype Status = 'success' | 'error' | 'pending';\n\ninterface Response<T> {\n  status: Status;\n  data?: T;\n  message?: string;\n}\n\n// Template literal types\ntype HTTPMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';\ntype Endpoint = `/${string}`;\ntype APIRoute = `${HTTPMethod} ${Endpoint}`;\n\nconst route: APIRoute = 'GET /users';"
    },
    {
      "id": 13,
      "question": "What is the never type in TypeScript?",
      "answer": "The never type represents values that never occur, indicating code that never returns normally.\n\nUse Cases:\n• Functions that always throw errors\n• Functions with infinite loops\n• Exhaustive type checking\n• Unreachable code branches\n• Type guard narrowing to impossible types\n\nCharacteristics:\n• Bottom type in type hierarchy\n• No value can be assigned to never\n• Assignable to every type\n• No type assignable to never except never\n\nPractical Applications:\n• Exhaustiveness checking in switch statements\n• Error handling functions\n• Type-safe reducers\n• Impossible state representation\n\nCompiler Benefits:\n• Detects unreachable code\n• Ensures exhaustive checks\n• Prevents runtime errors\n• Improves code safety",
      "explanation": "The never type represents values that never occur, useful for functions that never return, exhaustive checks, and representing impossible states.",
      "difficulty": "Medium",
      "code": "// Function that never returns\nfunction throwError(message: string): never {\n  throw new Error(message);\n}\n\nfunction infiniteLoop(): never {\n  while (true) {\n    console.log('Running...');\n  }\n}\n\n// Exhaustive checking\ntype Shape = 'circle' | 'square' | 'triangle';\n\nfunction getArea(shape: Shape): number {\n  switch (shape) {\n    case 'circle':\n      return Math.PI * 10 * 10;\n    case 'square':\n      return 10 * 10;\n    case 'triangle':\n      return 0.5 * 10 * 10;\n    default:\n      // If new shape added, this causes compile error\n      const _exhaustive: never = shape;\n      return _exhaustive;\n  }\n}\n\n// Type narrowing\nfunction process(value: string | number) {\n  if (typeof value === 'string') {\n    return value.toUpperCase();\n  } else if (typeof value === 'number') {\n    return value.toFixed(2);\n  }\n  // value is type never here\n  const _impossible: never = value;\n}"
    },
    {
      "id": 14,
      "question": "What are enums in TypeScript?",
      "answer": "Enums define a set of named constants, providing a way to create readable and type-safe constant values.\n\nTypes of Enums:\n• Numeric enums - auto-incremented numbers\n• String enums - explicit string values\n• Heterogeneous enums - mixed types (not recommended)\n• Const enums - compiled away for performance\n\nFeatures:\n• Reverse mapping (numeric enums only)\n• Can have computed members\n• Can be used as types\n• Generate JavaScript code\n\nBenefits:\n• Readable code with meaningful names\n• Type safety\n• Autocomplete support\n• Self-documenting\n\nAlternatives:\n• Object with as const\n• Union of literal types\n• Better tree-shaking",
      "explanation": "Enums provide a way to define named constants with numeric or string values, offering type safety and readable code for fixed sets of values.",
      "difficulty": "Medium",
      "code": "// Numeric enum\nenum Direction {\n  Up = 1,\n  Down,\n  Left,\n  Right\n}\n\nconst dir: Direction = Direction.Up;\nconsole.log(Direction[1]); // 'Up' - reverse mapping\n\n// String enum\nenum Status {\n  Pending = 'PENDING',\n  Approved = 'APPROVED',\n  Rejected = 'REJECTED'\n}\n\nfunction updateStatus(status: Status) {\n  console.log(`Status: ${status}`);\n}\n\nupdateStatus(Status.Approved);\n\n// Const enum (no runtime code)\nconst enum Color {\n  Red,\n  Green,\n  Blue\n}\n\nconst c = Color.Red; // Compiled to: const c = 0;\n\n// Alternative: as const object\nconst StatusCode = {\n  Success: 200,\n  NotFound: 404,\n  ServerError: 500\n} as const;\n\ntype StatusCode = typeof StatusCode[keyof typeof StatusCode];"
    },
    {
      "id": 15,
      "question": "What is the void type in TypeScript?",
      "answer": "The void type represents the absence of any type, typically used for functions that do not return a value.\n\nCharacteristics:\n• Opposite of any\n• Functions with no return statement\n• Functions that return undefined explicitly\n• Cannot be assigned except undefined and null\n• Used primarily for function return types\n\nCommon Usage:\n• Event handlers\n• Callback functions\n• Procedures that perform actions\n• Functions with side effects only\n\nDifference from undefined:\n• void is for function return types\n• undefined is an actual value\n• void allows returning undefined implicitly\n• void indicates intentional lack of return\n\nBest Practices:\n• Use void for functions without return\n• Use undefined when value absence is meaningful\n• Explicit return undefined requires undefined type\n• void is more semantic for procedures",
      "explanation": "The void type indicates functions that do not return a value, representing the absence of any return type rather than a specific value.",
      "difficulty": "Easy",
      "code": "// Function returning void\nfunction logMessage(message: string): void {\n  console.log(message);\n  // No return statement\n}\n\nfunction updateUser(id: number, name: string): void {\n  // Perform update operation\n  database.update(id, name);\n  return; // OK, or can be omitted\n}\n\n// Callback with void\nfunction forEach<T>(array: T[], callback: (item: T) => void): void {\n  for (const item of array) {\n    callback(item);\n  }\n}\n\nforEach([1, 2, 3], (num) => {\n  console.log(num);\n});\n\n// void vs undefined\nfunction returnsVoid(): void {\n  // Can return undefined implicitly\n}\n\nfunction returnsUndefined(): undefined {\n  return undefined; // Must explicitly return undefined\n}\n\n// Variable with void type (rare)\nlet unusable: void = undefined;\n// unusable = 1; // Error"
    },
    {
      "id": 16,
      "question": "What are tuple types in TypeScript?",
      "answer": "Tuples are arrays with fixed length and types for each element at specific positions.\n\nKey Features:\n• Fixed number of elements\n• Each element has specific type\n• Order matters\n• Length is part of the type\n• Support optional and rest elements\n\nUse Cases:\n• Returning multiple values from functions\n• Representing coordinates or pairs\n• CSV data rows\n• Function parameters\n• Fixed-format data structures\n\nAdvanced Features:\n• Optional elements with ?\n• Rest elements with ...\n• Named tuple elements\n• Readonly tuples\n\nBenefits:\n• Type safety for structured data\n• Better than plain arrays for fixed data\n• Clear intent and documentation\n• Compile-time length checking",
      "explanation": "Tuples are typed arrays with fixed length where each element has a specific type at a known position, useful for representing structured data.",
      "difficulty": "Medium",
      "code": "// Basic tuple\nlet coordinate: [number, number] = [10, 20];\nlet user: [number, string] = [1, 'John'];\n\n// Tuple with optional elements\ntype Response = [number, string, boolean?];\nlet response1: Response = [200, 'OK'];\nlet response2: Response = [404, 'Not Found', false];\n\n// Named tuple elements\ntype Range = [start: number, end: number];\n\nfunction createRange(range: Range) {\n  const [start, end] = range;\n  console.log(`Range: ${start} to ${end}`);\n}\n\n// Rest elements\ntype StringArray = [string, ...string[]];\nconst names: StringArray = ['John', 'Jane', 'Bob'];\n\n// Readonly tuple\nconst point: readonly [number, number] = [10, 20];\n// point[0] = 5; // Error: readonly\n\n// Function returning tuple\nfunction useState<T>(initial: T): [T, (value: T) => void] {\n  let state = initial;\n  const setState = (value: T) => { state = value; };\n  return [state, setState];\n}"
    },
    {
      "id": 17,
      "question": "What is type narrowing in TypeScript?",
      "answer": "Type narrowing is the process of refining a broader type to a more specific type within a conditional block.\n\nNarrowing Techniques:\n• typeof checks for primitives\n• instanceof for class instances\n• in operator for properties\n• Equality checks for literals\n• Custom type guards\n• Truthiness checks\n• Discriminated unions\n\nControl Flow Analysis:\n• TypeScript analyzes code paths\n• Tracks type changes through branches\n• Updates type based on checks\n• Handles complex logic\n\nBenefits:\n• Safe access to type-specific members\n• Reduces need for type assertions\n• Better error messages\n• Improved IDE support\n\nBest Practices:\n• Use built-in narrowing when possible\n• Create custom guards for complex types\n• Keep narrowing logic clear\n• Leverage discriminated unions",
      "explanation": "Type narrowing refines union types to more specific types through conditional checks, enabling safe access to type-specific properties and methods.",
      "difficulty": "Medium",
      "code": "// typeof narrowing\nfunction padLeft(value: string, padding: string | number) {\n  if (typeof padding === 'number') {\n    return ' '.repeat(padding) + value;\n  }\n  return padding + value;\n}\n\n// instanceof narrowing\nclass Dog { bark() { console.log('Woof!'); } }\nclass Cat { meow() { console.log('Meow!'); } }\n\nfunction makeSound(animal: Dog | Cat) {\n  if (animal instanceof Dog) {\n    animal.bark();\n  } else {\n    animal.meow();\n  }\n}\n\n// in operator narrowing\ninterface User { name: string; email: string; }\ninterface Admin { name: string; role: string; }\n\nfunction greet(person: User | Admin) {\n  console.log(`Hello, ${person.name}`);\n  if ('role' in person) {\n    console.log(`Role: ${person.role}`);\n  }\n}\n\n// Truthiness narrowing\nfunction printLength(str: string | null) {\n  if (str) {\n    console.log(str.length); // str is string\n  }\n}"
    },
    {
      "id": 18,
      "question": "What are discriminated unions in TypeScript?",
      "answer": "Discriminated unions combine union types with a common discriminant property for type-safe pattern matching.\n\nComponents:\n• Common property (discriminant)\n• Literal types for discriminant\n• Union of types\n• Type narrowing using discriminant\n\nKey Features:\n• Type-safe exhaustiveness checking\n• Clear intent and structure\n• Excellent IDE support\n• Works with switch statements\n\nUse Cases:\n• State machines\n• Action types in Redux\n• API response handling\n• Result types with success/error\n• UI component states\n\nBenefits:\n• Eliminates invalid states\n• Compiler enforces exhaustiveness\n• Self-documenting code\n• Prevents runtime errors\n\nBest Practices:\n• Use literal types for discriminant\n• Name discriminant clearly (type, kind, status)\n• Add exhaustive checks\n• Keep union members focused",
      "explanation": "Discriminated unions use a common property with literal types to create type-safe pattern matching, enabling exhaustive checks and eliminating invalid states.",
      "difficulty": "Medium",
      "code": "// Basic discriminated union\ninterface Circle {\n  kind: 'circle';\n  radius: number;\n}\n\ninterface Square {\n  kind: 'square';\n  sideLength: number;\n}\n\ninterface Rectangle {\n  kind: 'rectangle';\n  width: number;\n  height: number;\n}\n\ntype Shape = Circle | Square | Rectangle;\n\nfunction getArea(shape: Shape): number {\n  switch (shape.kind) {\n    case 'circle':\n      return Math.PI * shape.radius ** 2;\n    case 'square':\n      return shape.sideLength ** 2;\n    case 'rectangle':\n      return shape.width * shape.height;\n    default:\n      const _exhaustive: never = shape;\n      throw new Error(`Unhandled shape: ${_exhaustive}`);\n  }\n}\n\n// Result type pattern\ntype Success<T> = { status: 'success'; data: T };\ntype Error = { status: 'error'; message: string };\ntype Result<T> = Success<T> | Error;\n\nfunction handleResult<T>(result: Result<T>) {\n  if (result.status === 'success') {\n    console.log(result.data);\n  } else {\n    console.error(result.message);\n  }\n}"
    },
    {
      "id": 19,
      "question": "What is the readonly modifier in TypeScript?",
      "answer": "The readonly modifier prevents properties from being modified after initialization, creating immutable properties.\n\nUsage:\n• Interface properties\n• Class properties\n• Array and tuple types\n• Mapped types\n• Index signatures\n\nCharacteristics:\n• Prevents reassignment after creation\n• Can be initialized in constructor\n• Compile-time only (no runtime effect)\n• Shallow immutability by default\n• Does not affect methods\n\nReadonly Utility Types:\n• Readonly<T> - makes all properties readonly\n• ReadonlyArray<T> - readonly array type\n• ReadonlyMap and ReadonlySet\n\nBenefits:\n• Prevents accidental mutations\n• Documents immutability intent\n• Safer concurrent code\n• Functional programming support\n\nLimitations:\n• Only compile-time checking\n• Shallow by default\n• Can be circumvented with type assertions",
      "explanation": "The readonly modifier creates immutable properties that cannot be reassigned after initialization, providing compile-time protection against mutations.",
      "difficulty": "Medium",
      "code": "// Readonly property\ninterface User {\n  readonly id: number;\n  name: string;\n}\n\nconst user: User = { id: 1, name: 'John' };\nuser.name = 'Jane'; // OK\n// user.id = 2; // Error: readonly property\n\n// Readonly class property\nclass Person {\n  readonly birthDate: Date;\n  \n  constructor(date: Date) {\n    this.birthDate = date; // OK in constructor\n  }\n}\n\n// ReadonlyArray\nconst numbers: ReadonlyArray<number> = [1, 2, 3];\n// numbers.push(4); // Error: no push method\n// numbers[0] = 10; // Error: index signature is readonly\n\n// Readonly<T> utility type\ninterface Mutable {\n  name: string;\n  age: number;\n}\n\ntype Immutable = Readonly<Mutable>;\n\n// Deep readonly (custom)\ntype DeepReadonly<T> = {\n  readonly [K in keyof T]: T[K] extends object\n    ? DeepReadonly<T[K]>\n    : T[K];\n};"
    },
    {
      "id": 20,
      "question": "What are optional properties and parameters in TypeScript?",
      "answer": "Optional properties and parameters use the ? modifier to indicate that a value may or may not be present.\n\nOptional Properties:\n• Mark interface/type properties as optional\n• Type becomes T | undefined\n• Must be checked before use\n• Different from required properties\n\nOptional Parameters:\n• Function parameters that can be omitted\n• Must come after required parameters\n• Type becomes T | undefined\n• Can have default values\n\nOptional Chaining:\n• Use ?. operator\n• Safely access nested properties\n• Short-circuits on null/undefined\n• Returns undefined if chain breaks\n\nNullish Coalescing:\n• Use ?? operator\n• Provides default for null/undefined\n• Different from || (only nullish values)\n\nBest Practices:\n• Use optional for truly optional values\n• Consider default values vs optional\n• Document when undefined is meaningful\n• Use optional chaining for nested access",
      "explanation": "Optional properties and parameters use ? to indicate values that may not be present, with type T becoming T | undefined automatically.",
      "difficulty": "Easy",
      "code": "// Optional properties\ninterface User {\n  id: number;\n  name: string;\n  email?: string; // optional\n  phone?: string; // optional\n}\n\nconst user1: User = { id: 1, name: 'John' }; // OK\nconst user2: User = { id: 2, name: 'Jane', email: 'jane@example.com' }; // OK\n\n// Optional parameters\nfunction greet(name: string, greeting?: string) {\n  console.log(`${greeting ?? 'Hello'}, ${name}`);\n}\n\ngreet('John'); // Uses default\ngreet('Jane', 'Hi'); // Uses provided value\n\n// Optional chaining\nconst email = user?.profile?.email; // undefined if any part is null/undefined\n\n// Nullish coalescing\nconst displayName = user.name ?? 'Anonymous';\nconst port = config.port ?? 3000;\n\n// Default parameters (alternative)\nfunction createUser(name: string, age: number = 18) {\n  return { name, age };\n}"
    },
    {
      "id": 21,
      "question": "What are index signatures in TypeScript?",
      "answer": "Index signatures define types for properties accessed using dynamic keys, allowing objects to have properties with unknown names.\n\nSyntax:\n• [key: string]: Type - string keys\n• [key: number]: Type - numeric keys\n• [key: symbol]: Type - symbol keys\n\nUse Cases:\n• Dynamic property names\n• Dictionary or map structures\n• Configuration objects\n• API responses with unknown keys\n• Flexible object shapes\n\nConstraints:\n• All properties must match signature type\n• Can combine with known properties\n• Known properties must be compatible\n• Index type must be string, number, or symbol\n\nBest Practices:\n• Use Record<K, V> utility type when possible\n• Combine with known properties carefully\n• Consider Map for truly dynamic data\n• Document expected structure",
      "explanation": "Index signatures enable defining types for objects with dynamic property names, allowing flexible object structures while maintaining type safety.",
      "difficulty": "Medium",
      "code": "// Basic index signature\ninterface StringDictionary {\n  [key: string]: string;\n}\n\nconst dict: StringDictionary = {\n  name: 'John',\n  city: 'New York',\n  country: 'USA'\n};\n\n// Combining with known properties\ninterface Config {\n  name: string;\n  version: number;\n  [key: string]: string | number; // Additional properties\n}\n\nconst config: Config = {\n  name: 'MyApp',\n  version: 1,\n  debug: true, // Error: boolean not assignable\n  timeout: 3000 // OK\n};\n\n// Using Record utility type\ntype UserRoles = Record<string, boolean>;\n\nconst roles: UserRoles = {\n  admin: true,\n  editor: false,\n  viewer: true\n};\n\n// Numeric index signature\ninterface NumberArray {\n  [index: number]: string;\n}\n\nconst items: NumberArray = ['a', 'b', 'c'];\n\n// Advanced pattern\ninterface Cache<T> {\n  [id: string]: T | undefined;\n  clear(): void;\n}\n\nconst cache: Cache<User> = {\n  user1: { id: 1, name: 'John' },\n  clear() { /* ... */ }\n};"
    },
    {
      "id": 22,
      "question": "What are mapped types in TypeScript?",
      "answer": "Mapped types create new types by transforming properties of existing types, enabling powerful type transformations.\n\nSyntax:\n• { [K in keyof T]: NewType }\n• Iterate over keys of a type\n• Transform property types\n• Add or remove modifiers\n\nCommon Patterns:\n• Making properties optional/required\n• Making properties readonly/mutable\n• Picking subset of properties\n• Changing property types\n\nBuilt-in Mapped Types:\n• Partial<T> - all properties optional\n• Required<T> - all properties required\n• Readonly<T> - all properties readonly\n• Pick<T, K> - select properties\n• Omit<T, K> - exclude properties\n• Record<K, V> - create object type\n\nAdvanced Features:\n• Key remapping with as clause\n• Conditional types in mapping\n• Template literal types\n• Filtering properties",
      "explanation": "Mapped types transform existing types by iterating over their properties and applying transformations, enabling powerful type manipulations and reusable type utilities.",
      "difficulty": "Medium",
      "code": "// Basic mapped type\ntype Nullable<T> = {\n  [K in keyof T]: T[K] | null;\n};\n\ninterface User {\n  id: number;\n  name: string;\n}\n\ntype NullableUser = Nullable<User>;\n// { id: number | null; name: string | null; }\n\n// Making properties optional\ntype MyPartial<T> = {\n  [K in keyof T]?: T[K];\n};\n\n// Making properties readonly\ntype MyReadonly<T> = {\n  readonly [K in keyof T]: T[K];\n};\n\n// Changing property types\ntype Stringify<T> = {\n  [K in keyof T]: string;\n};\n\ntype StringUser = Stringify<User>;\n// { id: string; name: string; }\n\n// Key remapping\ntype Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];\n};\n\ntype UserGetters = Getters<User>;\n// { getId(): number; getName(): string; }\n\n// Filtering properties\ntype PickByType<T, U> = {\n  [K in keyof T as T[K] extends U ? K : never]: T[K];\n};"
    },
    {
      "id": 23,
      "question": "What are conditional types in TypeScript?",
      "answer": "Conditional types select types based on conditions, similar to ternary operators for types.\n\nSyntax:\n• T extends U ? X : Y\n• Check if type T extends U\n• Return X if true, Y if false\n• Enable complex type logic\n\nKey Features:\n• Distributive over union types\n• Type inference with infer keyword\n• Nested conditions\n• Pattern matching on types\n\nCommon Patterns:\n• Extract types from unions\n• Infer return types\n• Filter types\n• Unwrap Promise types\n• Type-level if-else logic\n\nBuilt-in Conditional Types:\n• Exclude<T, U> - remove types from union\n• Extract<T, U> - extract types from union\n• NonNullable<T> - remove null/undefined\n• ReturnType<T> - extract return type\n• Parameters<T> - extract parameter types",
      "explanation": "Conditional types enable type-level logic using extends conditions, allowing types to be selected based on type relationships and enabling powerful type transformations.",
      "difficulty": "Hard",
      "code": "// Basic conditional type\ntype IsString<T> = T extends string ? true : false;\n\ntype A = IsString<string>; // true\ntype B = IsString<number>; // false\n\n// Distributive conditional types\ntype ToArray<T> = T extends any ? T[] : never;\n\ntype Result = ToArray<string | number>;\n// string[] | number[] (distributed over union)\n\n// Using infer keyword\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\n\ntype Func = () => string;\ntype FuncReturn = ReturnType<Func>; // string\n\n// Unwrap Promise\ntype Awaited<T> = T extends Promise<infer U> ? U : T;\n\ntype PromiseType = Awaited<Promise<string>>; // string\ntype RegularType = Awaited<number>; // number\n\n// Complex example\ntype Flatten<T> = T extends Array<infer U> ? U : T;\n\ntype Nested = Flatten<string[]>; // string\ntype NotNested = Flatten<number>; // number\n\n// Filtering types\ntype NonFunctionKeys<T> = {\n  [K in keyof T]: T[K] extends Function ? never : K;\n}[keyof T];"
    },
    {
      "id": 24,
      "question": "What is the infer keyword in TypeScript?",
      "answer": "The infer keyword introduces a type variable within conditional types, enabling type inference from other types.\n\nUsage:\n• Only within conditional type extends clause\n• Extracts types from complex structures\n• Creates type variables on the fly\n• Enables pattern matching on types\n\nCommon Patterns:\n• Extracting function return types\n• Extracting function parameter types\n• Unwrapping Promise types\n• Extracting array element types\n• Extracting generic type arguments\n\nBenefits:\n• Powerful type transformations\n• Reusable type utilities\n• Type-safe extractions\n• Reduces manual type definitions\n\nCombining with Other Features:\n• Mapped types\n• Template literal types\n• Recursive conditional types\n• Tuple manipulations",
      "explanation": "The infer keyword enables type inference within conditional types, allowing extraction and manipulation of types from complex type structures.",
      "difficulty": "Hard",
      "code": "// Extracting return type\ntype GetReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\n\nfunction greet(): string { return 'hello'; }\ntype GreetReturn = GetReturnType<typeof greet>; // string\n\n// Extracting parameter types\ntype GetFirstParam<T> = T extends (first: infer F, ...args: any[]) => any\n  ? F\n  : never;\n\nfunction process(name: string, age: number) {}\ntype FirstParam = GetFirstParam<typeof process>; // string\n\n// Unwrapping Promise\ntype UnwrapPromise<T> = T extends Promise<infer U> ? U : T;\n\ntype Value = UnwrapPromise<Promise<string>>; // string\n\n// Extracting array element type\ntype ArrayElement<T> = T extends (infer E)[] ? E : never;\n\ntype Element = ArrayElement<string[]>; // string\n\n// Multiple infer in tuple\ntype GetFirstAndLast<T> = T extends [infer First, ...any[], infer Last]\n  ? [First, Last]\n  : never;\n\ntype Result = GetFirstAndLast<[1, 2, 3, 4]>; // [1, 4]\n\n// Extracting generic type argument\ntype UnboxArray<T> = T extends Array<infer U> ? U : T;\ntype StringType = UnboxArray<Array<string>>; // string"
    },
    {
      "id": 25,
      "question": "What are utility types in TypeScript?",
      "answer": "Utility types are built-in generic types that facilitate common type transformations without writing custom mapped types.\n\nProperty Modifiers:\n• Partial<T> - all properties optional\n• Required<T> - all properties required\n• Readonly<T> - all properties readonly\n\nProperty Selection:\n• Pick<T, K> - select specific properties\n• Omit<T, K> - exclude specific properties\n\nType Manipulation:\n• Record<K, V> - create object type with keys K and values V\n• Exclude<T, U> - exclude types from union\n• Extract<T, U> - extract types from union\n• NonNullable<T> - remove null and undefined\n\nFunction Types:\n• ReturnType<T> - extract return type\n• Parameters<T> - extract parameter types as tuple\n• ConstructorParameters<T> - constructor parameters\n• InstanceType<T> - instance type of constructor\n\nString Manipulation:\n• Uppercase<S> - convert to uppercase\n• Lowercase<S> - convert to lowercase\n• Capitalize<S> - capitalize first letter\n• Uncapitalize<S> - lowercase first letter",
      "explanation": "Utility types are built-in generic types that provide common type transformations, making code more concise and maintainable without custom type definitions.",
      "difficulty": "Medium",
      "code": "// Partial - make all properties optional\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ntype PartialUser = Partial<User>;\nconst update: PartialUser = { name: 'John' }; // OK\n\n// Pick - select properties\ntype UserPreview = Pick<User, 'id' | 'name'>;\n// { id: number; name: string; }\n\n// Omit - exclude properties\ntype UserWithoutId = Omit<User, 'id'>;\n// { name: string; email: string; }\n\n// Record - create object type\ntype Roles = 'admin' | 'user' | 'guest';\ntype Permissions = Record<Roles, string[]>;\n\nconst perms: Permissions = {\n  admin: ['read', 'write', 'delete'],\n  user: ['read', 'write'],\n  guest: ['read']\n};\n\n// ReturnType - extract return type\nfunction createUser() {\n  return { id: 1, name: 'John' };\n}\n\ntype NewUser = ReturnType<typeof createUser>;\n// { id: number; name: string; }\n\n// Exclude - remove from union\ntype T1 = Exclude<'a' | 'b' | 'c', 'a'>; // 'b' | 'c'\n\n// NonNullable - remove null/undefined\ntype T2 = NonNullable<string | null | undefined>; // string"
    },
    {
      "id": 26,
      "question": "How do you implement function overloading in TypeScript?",
      "answer": "Function overloading allows defining multiple function signatures for the same function with different parameter types.\n\nImplementation:\n• Define multiple function signatures\n• Provide single implementation signature\n• Implementation must handle all cases\n• Overload signatures must be compatible\n\nOverload Signatures:\n• More specific signatures first\n• General implementation signature last\n• Implementation signature not callable directly\n• TypeScript chooses best match\n\nUse Cases:\n• Different parameter combinations\n• Different return types based on parameters\n• Better type safety than union types\n• Improved API documentation\n\nBest Practices:\n• Keep overloads simple and clear\n• Order from most to least specific\n• Use union types when possible\n• Document edge cases",
      "explanation": "Function overloading allows defining multiple function signatures with different parameter types, enabling type-safe functions that behave differently based on arguments.",
      "difficulty": "Medium",
      "code": "// Basic function overloading\nfunction process(value: string): string;\nfunction process(value: number): number;\nfunction process(value: string | number): string | number {\n  if (typeof value === 'string') {\n    return value.toUpperCase();\n  }\n  return value * 2;\n}\n\nconst result1 = process('hello'); // type: string\nconst result2 = process(42); // type: number\n\n// Overloading with different parameter counts\nfunction createElement(tag: string): HTMLElement;\nfunction createElement(tag: string, content: string): HTMLElement;\nfunction createElement(tag: string, content?: string): HTMLElement {\n  const element = document.createElement(tag);\n  if (content) {\n    element.textContent = content;\n  }\n  return element;\n}\n\n// Overloading for better return types\nfunction get(database: Database, id: number): User;\nfunction get(database: Database, query: Query): User[];\nfunction get(database: Database, idOrQuery: number | Query): User | User[] {\n  if (typeof idOrQuery === 'number') {\n    return database.findById(idOrQuery);\n  }\n  return database.findMany(idOrQuery);\n}"
    },
    {
      "id": 27,
      "question": "What are abstract classes in TypeScript?",
      "answer": "Abstract classes are base classes that cannot be instantiated directly and may contain abstract methods that must be implemented by derived classes.\n\nKey Features:\n• Cannot be instantiated\n• Can have abstract and concrete methods\n• Abstract methods have no implementation\n• Derived classes must implement abstract methods\n• Can have constructors and properties\n• Support access modifiers\n\nAbstract Methods:\n• Declared with abstract keyword\n• No method body\n• Must be implemented in derived classes\n• Define contract for subclasses\n\nUse Cases:\n• Defining common base functionality\n• Enforcing implementation contracts\n• Template method pattern\n• Sharing code among related classes\n\nComparison with Interfaces:\n• Interfaces define structure only\n• Abstract classes can have implementation\n• Classes can implement multiple interfaces\n• Classes can extend only one abstract class",
      "explanation": "Abstract classes provide partial implementations and define contracts through abstract methods that derived classes must implement, enabling code reuse and polymorphism.",
      "difficulty": "Medium",
      "code": "// Abstract class\nabstract class Animal {\n  constructor(protected name: string) {}\n  \n  // Concrete method\n  move(distance: number): void {\n    console.log(`${this.name} moved ${distance}m`);\n  }\n  \n  // Abstract method - must be implemented\n  abstract makeSound(): void;\n  abstract eat(food: string): void;\n}\n\n// Derived class\nclass Dog extends Animal {\n  makeSound(): void {\n    console.log('Woof! Woof!');\n  }\n  \n  eat(food: string): void {\n    console.log(`${this.name} is eating ${food}`);\n  }\n}\n\nconst dog = new Dog('Buddy');\ndog.makeSound(); // Woof! Woof!\ndog.move(10);\ndog.eat('bone');\n\n// Cannot instantiate abstract class\n// const animal = new Animal('Test'); // Error\n\n// Abstract class with constructor\nabstract class Shape {\n  constructor(protected color: string) {}\n  \n  abstract getArea(): number;\n  \n  describe(): string {\n    return `A ${this.color} shape with area ${this.getArea()}`;\n  }\n}"
    },
    {
      "id": 28,
      "question": "What are access modifiers in TypeScript?",
      "answer": "Access modifiers control the visibility and accessibility of class members from outside the class.\n\nTypes of Modifiers:\n• public - accessible from anywhere (default)\n• private - accessible only within the class\n• protected - accessible within class and subclasses\n• readonly - property cannot be modified after initialization\n\nPrivate (#) Syntax:\n• ES2022 private fields with # prefix\n• True runtime privacy\n• Different from TypeScript private\n• Not accessible even with type assertions\n\nParameter Properties:\n• Declare and initialize in constructor\n• Combine declaration with initialization\n• More concise class syntax\n• Works with all access modifiers\n\nBest Practices:\n• Use private for internal implementation\n• Use protected for extensible behavior\n• Default to public for API\n• Use readonly for immutable properties\n• Prefer # for true privacy",
      "explanation": "Access modifiers control member visibility in classes, with public being accessible everywhere, private only within the class, and protected in the class and subclasses.",
      "difficulty": "Medium",
      "code": "// Access modifiers\nclass Person {\n  public name: string; // accessible everywhere\n  private age: number; // only within Person\n  protected email: string; // within Person and subclasses\n  readonly id: number; // cannot be modified\n  \n  constructor(name: string, age: number, email: string, id: number) {\n    this.name = name;\n    this.age = age;\n    this.email = email;\n    this.id = id;\n  }\n  \n  private getAge(): number {\n    return this.age;\n  }\n  \n  public displayInfo(): void {\n    console.log(`${this.name}, ${this.getAge()} years old`);\n  }\n}\n\nconst person = new Person('John', 30, 'john@example.com', 1);\nconsole.log(person.name); // OK\n// console.log(person.age); // Error: private\n// person.id = 2; // Error: readonly\n\n// Parameter properties (shorthand)\nclass User {\n  constructor(\n    public id: number,\n    private password: string,\n    protected role: string\n  ) {}\n}\n\n// ES2022 private fields\nclass Account {\n  #balance: number = 0;\n  \n  deposit(amount: number) {\n    this.#balance += amount;\n  }\n}"
    },
    {
      "id": 29,
      "question": "What are decorators in TypeScript?",
      "answer": "Decorators are special declarations that can be attached to classes, methods, properties, or parameters to modify their behavior.\n\nTypes of Decorators:\n• Class decorators - modify class constructors\n• Method decorators - modify methods\n• Property decorators - modify properties\n• Parameter decorators - modify parameters\n• Accessor decorators - modify getters/setters\n\nDecorator Execution:\n• Evaluated top to bottom\n• Applied bottom to top\n• Execute at declaration time\n• Can return values to replace target\n\nCommon Use Cases:\n• Logging and debugging\n• Validation\n• Dependency injection\n• Metadata reflection\n• Access control\n• Memoization\n\nConfiguration:\n• Enable experimentalDecorators in tsconfig.json\n• Enable emitDecoratorMetadata for reflection\n• Stage 3 proposal (not yet standard)\n\nFrameworks Using Decorators:\n• Angular - components, services, modules\n• NestJS - controllers, providers\n• TypeORM - entities, columns\n• MobX - observables",
      "explanation": "Decorators are special functions that modify classes, methods, properties, or parameters, enabling metaprogramming patterns like dependency injection and validation.",
      "difficulty": "Hard",
      "code": "// Class decorator\nfunction Entity(tableName: string) {\n  return function <T extends { new(...args: any[]): {} }>(constructor: T) {\n    return class extends constructor {\n      tableName = tableName;\n    };\n  };\n}\n\n@Entity('users')\nclass User {\n  name: string;\n  email: string;\n}\n\n// Method decorator\nfunction Log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  const originalMethod = descriptor.value;\n  \n  descriptor.value = function(...args: any[]) {\n    console.log(`Calling ${propertyKey} with:`, args);\n    const result = originalMethod.apply(this, args);\n    console.log(`Result:`, result);\n    return result;\n  };\n  \n  return descriptor;\n}\n\nclass Calculator {\n  @Log\n  add(a: number, b: number): number {\n    return a + b;\n  }\n}\n\n// Property decorator\nfunction Required(target: any, propertyKey: string) {\n  let value: any;\n  \n  const getter = () => value;\n  const setter = (newValue: any) => {\n    if (!newValue) {\n      throw new Error(`${propertyKey} is required`);\n    }\n    value = newValue;\n  };\n  \n  Object.defineProperty(target, propertyKey, {\n    get: getter,\n    set: setter\n  });\n}"
    },
    {
      "id": 30,
      "question": "What is namespace in TypeScript?",
      "answer": "Namespaces provide a way to organize code into logical groups and prevent naming collisions in the global scope.\n\nKey Features:\n• Group related code together\n• Prevent global scope pollution\n• Support nesting\n• Can be split across files\n• Export members for external access\n\nSyntax:\n• namespace keyword\n• export keyword for public members\n• Dot notation for nested namespaces\n• Triple-slash directives for multi-file\n\nNamespaces vs Modules:\n• Namespaces are older approach\n• Modules are preferred in modern TypeScript\n• Modules use import/export\n• Modules have better tree-shaking\n• Use modules for new projects\n\nWhen to Use Namespaces:\n• Legacy code compatibility\n• Organizing global scripts\n• TypeScript definition files\n• Simple script files without bundler\n\nBest Practices:\n• Prefer ES6 modules over namespaces\n• Use namespaces only when necessary\n• Keep namespace hierarchies simple\n• Export only public API",
      "explanation": "Namespaces organize code into logical groups to prevent naming collisions, but ES6 modules are now preferred for modern TypeScript applications.",
      "difficulty": "Easy",
      "code": "// Basic namespace\nnamespace Utility {\n  export function log(message: string): void {\n    console.log(message);\n  }\n  \n  export class StringHelper {\n    static capitalize(str: string): string {\n      return str.charAt(0).toUpperCase() + str.slice(1);\n    }\n  }\n  \n  // Internal (not exported)\n  function internalHelper() {\n    // Only accessible within namespace\n  }\n}\n\n// Usage\nUtility.log('Hello');\nconst helper = new Utility.StringHelper();\n\n// Nested namespaces\nnamespace App {\n  export namespace Models {\n    export class User {\n      constructor(public name: string) {}\n    }\n  }\n  \n  export namespace Services {\n    export class UserService {\n      getUser(): Models.User {\n        return new Models.User('John');\n      }\n    }\n  }\n}\n\nconst user = new App.Models.User('Jane');\nconst service = new App.Services.UserService();\n\n// Modern alternative: ES6 modules\nexport class ModernHelper {\n  static log(msg: string) { console.log(msg); }\n}"
    },
    {
      "id": 31,
      "question": "What is the difference between type and interface for function types?",
      "answer": "Both type aliases and interfaces can define function types, but they have different syntax and capabilities.\n\nInterface Syntax:\n• Call signature syntax\n• Can extend other interfaces\n• Can be implemented by classes\n• Support declaration merging\n• More verbose for simple functions\n\nType Alias Syntax:\n• Arrow function syntax\n• More concise\n• Better for unions and intersections\n• Cannot be reopened\n• More flexible for complex types\n\nFunction Overloads:\n• Both support overloading\n• Interface uses call signatures\n• Type uses intersection types\n\nBest Practices:\n• Use type for simple functions\n• Use interface for object with methods\n• Prefer type for functional programming\n• Use interface for OOP patterns",
      "explanation": "Both types and interfaces can define function signatures, with types using arrow syntax and being more concise, while interfaces use call signatures and support declaration merging.",
      "difficulty": "Medium",
      "code": "// Type alias for function\ntype AddFunction = (a: number, b: number) => number;\n\nconst add: AddFunction = (a, b) => a + b;\n\n// Interface for function\ninterface SubtractFunction {\n  (a: number, b: number): number;\n}\n\nconst subtract: SubtractFunction = (a, b) => a - b;\n\n// Function with properties (type)\ntype LoggerType = {\n  (message: string): void;\n  level: string;\n};\n\n// Function with properties (interface)\ninterface LoggerInterface {\n  (message: string): void;\n  level: string;\n}\n\n// Overloading with type\ntype OverloadedType = {\n  (value: string): string;\n  (value: number): number;\n};\n\n// Overloading with interface\ninterface OverloadedInterface {\n  (value: string): string;\n  (value: number): number;\n}\n\n// Complex type (better with type alias)\ntype ComplexFunction = \n  | ((x: number) => number)\n  | ((x: string) => string);\n\n// Constructor function\ninterface Constructor {\n  new (name: string): { name: string };\n}"
    },
    {
      "id": 32,
      "question": "What are template literal types in TypeScript?",
      "answer": "Template literal types use template literal syntax to create new string literal types by combining and transforming string literals.\n\nKey Features:\n• Build types from string literals\n• Support string interpolation\n• Combine with union types\n• Enable pattern matching\n• Work with utility types\n\nString Manipulation Utilities:\n• Uppercase<S> - convert to uppercase\n• Lowercase<S> - convert to lowercase\n• Capitalize<S> - capitalize first letter\n• Uncapitalize<S> - lowercase first letter\n\nUse Cases:\n• Type-safe routing\n• CSS-in-JS property names\n• Event names\n• API endpoint types\n• Database column names\n• Form field names\n\nCombining Features:\n• Union distribution\n• Mapped types\n• Conditional types\n• Key remapping",
      "explanation": "Template literal types enable creating new string literal types using template syntax, allowing powerful string type manipulations and patterns for type-safe APIs.",
      "difficulty": "Hard",
      "code": "// Basic template literal type\ntype Greeting = `Hello ${string}`;\nconst greet: Greeting = 'Hello World'; // OK\n// const invalid: Greeting = 'Hi World'; // Error\n\n// Combining with unions\ntype Color = 'red' | 'blue' | 'green';\ntype Size = 'small' | 'medium' | 'large';\ntype Style = `${Color}-${Size}`;\n// Produces: 'red-small' | 'red-medium' | 'red-large' | ...\n\n// String manipulation\ntype EventName = 'click' | 'focus' | 'blur';\ntype EventHandler = `on${Capitalize<EventName>}`;\n// Produces: 'onClick' | 'onFocus' | 'onBlur'\n\n// Type-safe routes\ntype Route = '/users' | '/posts' | '/comments';\ntype Method = 'GET' | 'POST' | 'PUT' | 'DELETE';\ntype APIEndpoint = `${Method} ${Route}`;\n\n// Complex example with mapped types\ntype PropEventSource<T> = {\n  on<K extends string & keyof T>(\n    eventName: `${K}Changed`,\n    callback: (newValue: T[K]) => void\n  ): void;\n};\n\ntype Person = { name: string; age: number };\nconst source: PropEventSource<Person> = {\n  on(eventName, callback) {\n    // eventName: 'nameChanged' | 'ageChanged'\n  }\n};"
    },
    {
      "id": 33,
      "question": "What is the keyof operator in TypeScript?",
      "answer": "The keyof operator creates a union type of all property names (keys) of a given type.\n\nKey Features:\n• Produces union of string or number literals\n• Works with any object type\n• Essential for mapped types\n• Enables type-safe property access\n• Updates automatically when type changes\n\nCommon Patterns:\n• Type-safe property getters\n• Constraining function parameters\n• Dynamic property access\n• Mapped type transformations\n• Generic constraints\n\nCombining with Other Features:\n• Indexed access types T[K]\n• Mapped types\n• Conditional types\n• Generic constraints\n\nBenefits:\n• Compile-time property name checking\n• Refactoring safety\n• Better IntelliSense\n• Prevents typos in property names",
      "explanation": "The keyof operator extracts all property names from a type as a union of string literals, enabling type-safe property access and manipulation.",
      "difficulty": "Medium",
      "code": "// Basic keyof usage\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ntype UserKeys = keyof User; // 'id' | 'name' | 'email'\n\n// Type-safe property getter\nfunction getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\nconst user: User = { id: 1, name: 'John', email: 'john@example.com' };\nconst name = getProperty(user, 'name'); // type: string\nconst id = getProperty(user, 'id'); // type: number\n// const invalid = getProperty(user, 'age'); // Error: not a key\n\n// With mapped types\ntype Getters<T> = {\n  [K in keyof T]: () => T[K];\n};\n\ntype UserGetters = Getters<User>;\n// { id: () => number; name: () => string; email: () => string; }\n\n// Filtering keys by value type\ntype KeysOfType<T, U> = {\n  [K in keyof T]: T[K] extends U ? K : never;\n}[keyof T];\n\ntype StringKeys = KeysOfType<User, string>;\n// 'name' | 'email'\n\n// With utility types\ntype Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;"
    },
    {
      "id": 34,
      "question": "What is the typeof operator in TypeScript?",
      "answer": "The typeof operator extracts the type of a variable or property, allowing you to reference existing types without redefining them.\n\nType Context:\n• Used in type positions\n• Extracts type from value\n• Different from JavaScript typeof\n• Works with variables and properties\n• Captures inferred types\n\nCommon Patterns:\n• Extract types from objects\n• Get function types\n• Reference configuration types\n• Avoid type duplication\n• Work with third-party values\n\nCombining with Other Operators:\n• keyof typeof - get keys from value\n• ReturnType<typeof fn> - function return type\n• Parameters<typeof fn> - function parameters\n• typeof with indexed access\n\nBest Practices:\n• Use to avoid redundant type definitions\n• Extract types from constants\n• Reference existing implementations\n• Keep single source of truth",
      "explanation": "The typeof operator extracts the TypeScript type from a value, enabling type reuse without redundant type definitions and capturing inferred types.",
      "difficulty": "Medium",
      "code": "// Basic typeof usage\nconst user = {\n  id: 1,\n  name: 'John',\n  email: 'john@example.com'\n};\n\ntype User = typeof user;\n// { id: number; name: string; email: string; }\n\n// Get function type\nfunction createUser(name: string, age: number) {\n  return { name, age, createdAt: new Date() };\n}\n\ntype CreateUserFn = typeof createUser;\ntype CreatedUser = ReturnType<typeof createUser>;\n// { name: string; age: number; createdAt: Date; }\n\n// With const objects\nconst CONFIG = {\n  apiUrl: 'https://api.example.com',\n  timeout: 3000,\n  retries: 3\n} as const;\n\ntype Config = typeof CONFIG;\n// { readonly apiUrl: 'https://api.example.com'; ... }\n\n// keyof typeof pattern\nconst ROLES = {\n  ADMIN: 'admin',\n  USER: 'user',\n  GUEST: 'guest'\n} as const;\n\ntype RoleKey = keyof typeof ROLES; // 'ADMIN' | 'USER' | 'GUEST'\ntype RoleValue = typeof ROLES[RoleKey]; // 'admin' | 'user' | 'guest'\n\n// Extract type from class\nclass Person {\n  constructor(public name: string, public age: number) {}\n}\n\ntype PersonType = typeof Person; // constructor type\ntype PersonInstance = InstanceType<typeof Person>;"
    },
    {
      "id": 35,
      "question": "What are const assertions in TypeScript?",
      "answer": "Const assertions use 'as const' to create more specific literal types by treating values as immutable and inferring literal types.\n\nEffects of as const:\n• Properties become readonly\n• Array becomes readonly tuple\n• Literal types instead of primitive types\n• No literal type widening\n• Deeply immutable (nested objects too)\n\nUse Cases:\n• Creating enum-like objects\n• Defining constant configurations\n• Tuple types\n• Readonly data structures\n• Type-safe string unions\n• Template literal type sources\n\nBenefits:\n• More precise types\n• Prevents mutations\n• Better autocomplete\n• Type-safe constants\n• Reduce manual type definitions\n\nPattern:\n• Define value with as const\n• Extract type with typeof\n• Use keyof for union types\n• Better than enums for tree-shaking",
      "explanation": "Const assertions create deeply readonly and more specific literal types by preventing type widening, making values immutable and enabling precise type inference.",
      "difficulty": "Medium",
      "code": "// Without as const (type widening)\nconst config1 = {\n  host: 'localhost',\n  port: 3000\n};\n// Type: { host: string; port: number; }\n\n// With as const (no widening)\nconst config2 = {\n  host: 'localhost',\n  port: 3000\n} as const;\n// Type: { readonly host: 'localhost'; readonly port: 3000; }\n\n// Array to tuple\nconst colors = ['red', 'green', 'blue'] as const;\ntype Color = typeof colors[number]; // 'red' | 'green' | 'blue'\n\n// Enum-like object pattern\nconst STATUS = {\n  PENDING: 'pending',\n  APPROVED: 'approved',\n  REJECTED: 'rejected'\n} as const;\n\ntype StatusKey = keyof typeof STATUS;\ntype StatusValue = typeof STATUS[StatusKey];\n\nfunction updateStatus(status: StatusValue) {\n  // status: 'pending' | 'approved' | 'rejected'\n}\n\nupdateStatus(STATUS.APPROVED); // OK\n// updateStatus('unknown'); // Error\n\n// With arrays (tuple)\nconst point = [10, 20] as const;\n// Type: readonly [10, 20]\n\n// Nested objects\nconst routes = {\n  home: { path: '/', title: 'Home' },\n  about: { path: '/about', title: 'About' }\n} as const;"
    },
    {
      "id": 36,
      "question": "What are type predicates in TypeScript?",
      "answer": "Type predicates are special return types for functions that perform type narrowing, using the 'is' keyword to indicate type checking.\n\nSyntax:\n• parameterName is Type\n• Returns boolean\n• Enables type narrowing\n• Custom type guard functions\n\nKey Features:\n• User-defined type guards\n• Runtime type checking with compile-time benefits\n• Works with control flow analysis\n• More flexible than typeof/instanceof\n\nUse Cases:\n• Complex type checking logic\n• Discriminated union narrowing\n• Array filtering with type safety\n• Validating unknown types\n• API response validation\n\nBest Practices:\n• Ensure predicate matches implementation\n• Keep logic simple and clear\n• Name functions clearly (isType pattern)\n• Return boolean always\n• Document expected behavior",
      "explanation": "Type predicates enable custom type guard functions that tell TypeScript the type of a value, providing type narrowing based on runtime checks.",
      "difficulty": "Medium",
      "code": "// Basic type predicate\ninterface Fish {\n  swim(): void;\n}\n\ninterface Bird {\n  fly(): void;\n}\n\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined;\n}\n\nfunction move(pet: Fish | Bird) {\n  if (isFish(pet)) {\n    pet.swim(); // TypeScript knows it's Fish\n  } else {\n    pet.fly(); // TypeScript knows it's Bird\n  }\n}\n\n// Array filtering with type predicate\nfunction isNumber(value: unknown): value is number {\n  return typeof value === 'number';\n}\n\nconst mixed = [1, 'two', 3, 'four', 5];\nconst numbers: number[] = mixed.filter(isNumber);\n// Type is correctly inferred as number[]\n\n// Validating API response\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nfunction isUser(obj: unknown): obj is User {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    'id' in obj &&\n    'name' in obj &&\n    'email' in obj &&\n    typeof (obj as User).id === 'number' &&\n    typeof (obj as User).name === 'string'\n  );\n}\n\nasync function fetchUser(id: number): Promise<User> {\n  const response = await fetch(`/api/users/${id}`);\n  const data = await response.json();\n  \n  if (!isUser(data)) {\n    throw new Error('Invalid user data');\n  }\n  \n  return data; // TypeScript knows it's User\n}"
    },
    {
      "id": 37,
      "question": "What is the difference between type assertion and type casting?",
      "answer": "TypeScript uses type assertions, not type casting, which is an important distinction from other languages.\n\nType Assertion:\n• Compile-time only\n• No runtime conversion\n• Tells compiler how to treat a type\n• Uses 'as' or angle bracket syntax\n• No runtime overhead\n• Can be unsafe if incorrect\n\nType Casting (Other Languages):\n• Runtime conversion\n• Actual value transformation\n• May throw runtime errors\n• Different memory representation\n• Runtime overhead\n\nTypeScript Behavior:\n• Type assertions are removed at runtime\n• JavaScript output unchanged\n• Purely for type system\n• No value conversion occurs\n\nSafe Alternatives:\n• Type guards for runtime checks\n• Validation functions\n• unknown type with narrowing\n• User-defined type predicates",
      "explanation": "TypeScript has type assertions (compile-time only) not type casting, which means it only affects the type system without runtime conversion or validation.",
      "difficulty": "Medium",
      "code": "// Type assertion (TypeScript)\nconst input = document.getElementById('myInput') as HTMLInputElement;\n// No runtime conversion, just tells TypeScript the type\n\n// This is removed at runtime:\n// const input = document.getElementById('myInput');\n\n// Unsafe assertion (no runtime check)\nconst value: any = 'hello';\nconst num = value as number; // Compiles but wrong at runtime\n// console.log(num.toFixed(2)); // Runtime error\n\n// Better: Runtime validation\nfunction isNumber(value: unknown): value is number {\n  return typeof value === 'number';\n}\n\nfunction process(value: unknown): number {\n  if (isNumber(value)) {\n    return value.toFixed(2);\n  }\n  throw new Error('Not a number');\n}\n\n// Type assertion vs validation\nfunction assertIsNumber(value: unknown): asserts value is number {\n  if (typeof value !== 'number') {\n    throw new Error('Not a number');\n  }\n}\n\nfunction safeParse(input: string): number {\n  const result = JSON.parse(input);\n  assertIsNumber(result); // Throws if not number\n  return result; // TypeScript knows it's number\n}\n\n// C# style casting (for comparison - not TypeScript)\n// int num = (int)value; // Runtime conversion\n// string str = value.ToString(); // Runtime conversion"
    },
    {
      "id": 38,
      "question": "What are assertion functions in TypeScript?",
      "answer": "Assertion functions throw errors if conditions are not met and use 'asserts' return type to narrow types in subsequent code.\n\nSyntax:\n• asserts condition\n• asserts value is Type\n• Must throw on failure\n• Never returns false\n\nCharacteristics:\n• Throws error or returns void\n• Narrows types after successful return\n• Similar to type predicates but throws\n• Works with control flow analysis\n\nUse Cases:\n• Runtime validation\n• Precondition checking\n• Type narrowing with guarantees\n• API response validation\n• Null/undefined checks\n\nComparison with Type Predicates:\n• Type predicates return boolean\n• Assertion functions throw errors\n• Predicates allow branching\n• Assertions ensure or fail\n\nBest Practices:\n• Throw descriptive errors\n• Use for invariants\n• Document expected behavior\n• Name clearly (assert prefix)",
      "explanation": "Assertion functions use the 'asserts' keyword to throw errors if conditions fail, providing type narrowing with guaranteed type safety after successful return.",
      "difficulty": "Hard",
      "code": "// Basic assertion function\nfunction assert(condition: unknown, message?: string): asserts condition {\n  if (!condition) {\n    throw new Error(message || 'Assertion failed');\n  }\n}\n\nfunction processValue(value: string | null) {\n  assert(value !== null, 'Value must not be null');\n  // TypeScript knows value is string here\n  console.log(value.toUpperCase());\n}\n\n// Type assertion function\nfunction assertIsString(value: unknown): asserts value is string {\n  if (typeof value !== 'string') {\n    throw new Error('Value must be a string');\n  }\n}\n\nfunction print(value: unknown) {\n  assertIsString(value);\n  // TypeScript knows value is string now\n  console.log(value.toUpperCase());\n}\n\n// Null/undefined checks\nfunction assertNotNull<T>(value: T | null | undefined): asserts value is T {\n  if (value === null || value === undefined) {\n    throw new Error('Value is null or undefined');\n  }\n}\n\nfunction getUser(id: number): User | null {\n  return findUser(id);\n}\n\nconst user = getUser(1);\nassertNotNull(user);\nconsole.log(user.name); // Safe - user is definitely User\n\n// Array element assertion\nfunction assertIsArray<T>(value: unknown): asserts value is T[] {\n  if (!Array.isArray(value)) {\n    throw new Error('Value must be an array');\n  }\n}"
    },
    {
      "id": 39,
      "question": "What is the satisfies operator in TypeScript?",
      "answer": "The satisfies operator validates that a value matches a type without changing the inferred type, introduced in TypeScript 4.9.\n\nKey Features:\n• Checks type compatibility\n• Preserves literal types\n• No type widening\n• Maintains precise inference\n• Compile-time validation only\n\nDifference from Type Annotation:\n• Type annotation changes inferred type\n• satisfies validates without changing\n• Better type narrowing with satisfies\n• Preserves as const behavior\n• More flexible for literal types\n\nUse Cases:\n• Validating configuration objects\n• Ensuring object structure\n• Type-safe with precise types\n• Checking complex constraints\n• Runtime value validation\n\nBenefits:\n• Best of both worlds\n• Validation + precise types\n• Catches errors early\n• Better autocomplete\n• Type-safe defaults",
      "explanation": "The satisfies operator validates type compatibility without widening types, preserving precise literal types while ensuring structural correctness.",
      "difficulty": "Hard",
      "code": "// Problem with type annotation\ntype Color = 'red' | 'green' | 'blue' | { r: number; g: number; b: number };\n\nconst palette1: Record<string, Color> = {\n  primary: 'red',\n  secondary: { r: 0, g: 255, b: 0 }\n};\n// palette1.primary is Color (not 'red')\n// palette1.unknown is allowed\n\n// Solution with satisfies\nconst palette2 = {\n  primary: 'red',\n  secondary: { r: 0, g: 255, b: 0 }\n} satisfies Record<string, Color>;\n// palette2.primary is 'red' (literal type preserved)\n// palette2.unknown is error (exact properties)\n\n// With functions\ntype Route = { path: string; method: 'GET' | 'POST' };\n\nconst routes = {\n  home: { path: '/', method: 'GET' },\n  login: { path: '/login', method: 'POST' }\n} satisfies Record<string, Route>;\n\nroutes.home.method; // Type: 'GET' (not 'GET' | 'POST')\n\n// Validation with precise types\ntype Settings = {\n  theme: 'light' | 'dark';\n  fontSize: number;\n};\n\nconst config = {\n  theme: 'dark',\n  fontSize: 16,\n  // extra: true // Error: extra property not in Settings\n} satisfies Settings;\n\nconfig.theme; // Type: 'dark' (not 'light' | 'dark')\n\n// Comparison\nconst annotated: Settings = { theme: 'dark', fontSize: 16 };\nannotated.theme; // Type: 'light' | 'dark' (widened)"
    },
    {
      "id": 40,
      "question": "What is the difference between declare and export in TypeScript?",
      "answer": "Both declare and export are used in different contexts for type definitions and module systems.\n\nDeclare:\n• Ambient declarations\n• Tells TypeScript about existing code\n• No runtime code generated\n• Used in .d.ts files\n• Describes global variables\n• Works with third-party libraries\n\nExport:\n• Module system\n• Makes members available to other modules\n• Part of ES6 modules\n• Generates runtime code\n• Creates module scope\n\nDeclare Global:\n• Augments global scope\n• Adds to window/global object\n• Works in module context\n• Useful for polyfills\n\nUse Cases:\n• declare for existing JavaScript\n• export for TypeScript modules\n• declare global for global augmentation\n• export with declare in .d.ts\n\nBest Practices:\n• Use declare for type definitions\n• Use export for module code\n• Combine for typed modules\n• Keep declarations separate",
      "explanation": "Declare creates ambient declarations for existing code without generating runtime code, while export makes module members available to other modules with runtime output.",
      "difficulty": "Medium",
      "code": "// Declare - ambient declaration\ndeclare const API_URL: string;\ndeclare function legacyFunction(x: number): void;\n\n// No runtime code generated\n// Tells TypeScript these exist globally\n\n// Export - module export\nexport const config = { apiUrl: 'https://api.example.com' };\nexport function fetchData() { /* ... */ }\n\n// Generates runtime code:\n// export const config = ...;\n\n// Declaration file (.d.ts)\ndeclare module 'legacy-library' {\n  export function doSomething(x: number): string;\n  export class Helper {\n    constructor(name: string);\n    process(): void;\n  }\n}\n\n// Global augmentation\ndeclare global {\n  interface Window {\n    myCustomProperty: string;\n  }\n  \n  const MY_GLOBAL: number;\n}\n\n// Usage after declaration\nwindow.myCustomProperty = 'value';\nconsole.log(MY_GLOBAL);\n\n// Combining declare and export\n// types.d.ts\ndeclare module 'my-module' {\n  export interface Config {\n    host: string;\n    port: number;\n  }\n  \n  export function createConfig(): Config;\n}\n\n// Namespace declaration\ndeclare namespace MyLib {\n  function init(): void;\n  const version: string;\n}"
    },
    {
      "id": 41,
      "question": "How do you configure TypeScript using tsconfig.json?",
      "answer": "The tsconfig.json file configures TypeScript compiler options and project settings.\n\nKey Compiler Options:\n• target - ECMAScript version\n• module - module system\n• strict - enable strict type checking\n• outDir - output directory\n• rootDir - source directory\n• lib - library declarations\n• sourceMap - generate source maps\n\nStrict Mode Options:\n• strictNullChecks - null/undefined checking\n• strictFunctionTypes - function type checking\n• strictBindCallApply - strict bind/call/apply\n• noImplicitAny - no implicit any types\n• noImplicitThis - explicit this types\n\nProject Configuration:\n• include - files to include\n• exclude - files to exclude\n• extends - inherit from base config\n• files - explicit file list\n• references - project references\n\nBest Practices:\n• Enable strict mode\n• Use latest target when possible\n• Enable sourceMap for debugging\n• Configure paths for aliases\n• Use extends for shared config",
      "explanation": "The tsconfig.json configures TypeScript compilation including target version, module system, strict checking, and file inclusion/exclusion patterns.",
      "difficulty": "Medium",
      "code": "// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"commonjs\",\n    \"lib\": [\"ES2020\", \"DOM\"],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \n    // Strict checking\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true,\n    \n    // Module resolution\n    \"moduleResolution\": \"node\",\n    \"esModuleInterop\": true,\n    \"resolveJsonModule\": true,\n    \n    // Emit\n    \"declaration\": true,\n    \"sourceMap\": true,\n    \"removeComments\": true,\n    \n    // Advanced\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \n    // Path mapping\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\"src/*\"]\n    }\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}"
    },
    {
      "id": 42,
      "question": "What is module resolution in TypeScript?",
      "answer": "Module resolution is the process TypeScript uses to locate and load module declarations.\n\nResolution Strategies:\n• Classic - original TypeScript strategy\n• Node - mimics Node.js resolution\n• Node16/NodeNext - modern Node.js with ESM\n• Bundler - for modern bundlers\n\nNode Resolution:\n• Checks node_modules\n• Looks for package.json\n• Resolves index files\n• Supports nested node_modules\n• Most commonly used\n\nPath Mapping:\n• baseUrl for relative imports\n• paths for custom aliases\n• rootDirs for virtual directories\n• Helps organize large projects\n\nModule Specifiers:\n• Relative imports (./, ../)\n• Absolute imports\n• Package imports\n• Path-mapped imports\n\nConfiguration:\n• moduleResolution option\n• baseUrl and paths\n• typeRoots for type definitions\n• types for specific packages",
      "explanation": "Module resolution determines how TypeScript locates imported modules, with Node resolution being most common, mimicking Node.js module loading behavior.",
      "difficulty": "Medium",
      "code": "// tsconfig.json - Module resolution config\n{\n  \"compilerOptions\": {\n    \"moduleResolution\": \"node\",\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@app/*\": [\"src/app/*\"],\n      \"@components/*\": [\"src/components/*\"],\n      \"@utils/*\": [\"src/utils/*\"]\n    },\n    \"typeRoots\": [\"./types\", \"./node_modules/@types\"],\n    \"types\": [\"node\", \"jest\"]\n  }\n}\n\n// Using path-mapped imports\nimport { Button } from '@components/Button';\nimport { formatDate } from '@utils/date';\nimport { User } from '@app/models/User';\n\n// Relative imports\nimport { config } from './config';\nimport { helper } from '../utils/helper';\n\n// Package imports\nimport express from 'express';\nimport { Observable } from 'rxjs';\n\n// Type-only imports\nimport type { UserType } from '@app/types';\n\n// Resolution example\n// import { User } from 'models/User'\n// Looks in:\n// 1. ./models/User.ts\n// 2. ./models/User.tsx\n// 3. ./models/User.d.ts\n// 4. ./node_modules/models/User\n// 5. etc."
    },
    {
      "id": 43,
      "question": "What are declaration files (.d.ts) in TypeScript?",
      "answer": "Declaration files contain type definitions for JavaScript code, providing type information without implementation.\n\nPurpose:\n• Describe shape of JavaScript modules\n• Enable TypeScript for JS libraries\n• No runtime code\n• Only type information\n• Separate from implementation\n\nCreating Declarations:\n• Manual .d.ts files\n• Generate with declaration: true\n• Ambient declarations with declare\n• Module augmentation\n• Global declarations\n\nDistribution:\n• Include in npm packages\n• DefinitelyTyped repository\n• @types packages\n• Bundled with library\n\nFile Structure:\n• Matches JavaScript file structure\n• Uses declare keyword\n• Export type definitions\n• Can include interfaces, types, functions\n\nBest Practices:\n• Keep sync with implementation\n• Use triple-slash references sparingly\n• Document complex types\n• Version with code\n• Test declarations",
      "explanation": "Declaration files provide type definitions for JavaScript code, enabling TypeScript type checking and IntelliSense for libraries without TypeScript source.",
      "difficulty": "Medium",
      "code": "// math.js (JavaScript implementation)\nexport function add(a, b) {\n  return a + b;\n}\n\nexport function subtract(a, b) {\n  return a - b;\n}\n\n// math.d.ts (Type declarations)\nexport function add(a: number, b: number): number;\nexport function subtract(a: number, b: number): number;\n\n// More complex example\n// logger.d.ts\nexport interface LoggerOptions {\n  level: 'info' | 'warn' | 'error';\n  timestamp: boolean;\n}\n\nexport class Logger {\n  constructor(options?: LoggerOptions);\n  info(message: string): void;\n  warn(message: string): void;\n  error(message: string, error?: Error): void;\n}\n\nexport function createLogger(options?: LoggerOptions): Logger;\n\n// Global augmentation\n// global.d.ts\ndeclare global {\n  interface Window {\n    myApp: {\n      version: string;\n      config: Record<string, unknown>;\n    };\n  }\n}\n\nexport {};\n\n// Module augmentation\n// express.d.ts\nimport 'express';\n\ndeclare module 'express' {\n  interface Request {\n    user?: { id: number; name: string };\n  }\n}"
    },
    {
      "id": 44,
      "question": "What is the difference between interface merging and type intersection?",
      "answer": "Interface merging and type intersection combine types differently with distinct behaviors.\n\nInterface Merging:\n• Declaration merging feature\n• Multiple declarations combine automatically\n• Same interface name extends previous\n• Properties must be compatible\n• Used for augmentation\n• Works across files\n\nType Intersection:\n• Creates new type with & operator\n• Combines multiple types into one\n• All properties must be present\n• Conflicts create never type\n• More explicit\n• Single declaration\n\nMerging Rules:\n• Functions overload\n• Non-function properties must match\n• Interfaces merge globally\n• Types don't merge\n\nUse Cases:\n• Merging for library augmentation\n• Intersection for composing types\n• Merging for plugin patterns\n• Intersection for mixins",
      "explanation": "Interface merging automatically combines multiple interface declarations with the same name, while type intersection explicitly combines types using the & operator.",
      "difficulty": "Hard",
      "code": "// Interface merging\ninterface User {\n  name: string;\n}\n\ninterface User {\n  age: number;\n}\n\n// Merged automatically\nconst user: User = {\n  name: 'John',\n  age: 30\n};\n\n// Type intersection\ntype Named = { name: string };\ntype Aged = { age: number };\ntype Person = Named & Aged;\n\nconst person: Person = {\n  name: 'Jane',\n  age: 25\n};\n\n// Function overloading with merging\ninterface Calculator {\n  add(a: number, b: number): number;\n}\n\ninterface Calculator {\n  add(a: string, b: string): string;\n}\n\n// Both overloads available\nconst calc: Calculator = {\n  add(a: any, b: any) {\n    return a + b;\n  }\n};\n\n// Conflict handling\ninterface A { value: string; }\ninterface B { value: number; }\n\n// Interface merge would error\n// Type intersection creates never\ntype AB = { value: string } & { value: number };\n// value is type never (impossible)\n\n// Module augmentation with merging\ninterface Window {\n  myProperty: string;\n}\n\n// Later in another file\ninterface Window {\n  anotherProperty: number;\n}"
    },
    {
      "id": 45,
      "question": "What are recursive types in TypeScript?",
      "answer": "Recursive types are types that reference themselves in their definition, enabling complex nested structures.\n\nKey Features:\n• Self-referential type definitions\n• Model tree-like structures\n• Support arbitrary nesting\n• Enable complex data structures\n• Work with conditional types\n\nCommon Patterns:\n• Tree and graph structures\n• JSON-like objects\n• Nested arrays\n• Linked lists\n• File system structures\n\nLimitations:\n• Depth limits (50 levels default)\n• Instantiation limits\n• Performance considerations\n• Complexity in error messages\n\nUse Cases:\n• DOM tree representations\n• AST (Abstract Syntax Trees)\n• Nested menus\n• Comment threads\n• Organizational hierarchies\n\nBest Practices:\n• Keep recursion depth reasonable\n• Document expected structure\n• Consider alternative approaches\n• Test with realistic data",
      "explanation": "Recursive types reference themselves in their definition, enabling representation of nested structures like trees, graphs, and hierarchical data.",
      "difficulty": "Hard",
      "code": "// Tree structure\ninterface TreeNode<T> {\n  value: T;\n  children: TreeNode<T>[];\n}\n\nconst tree: TreeNode<string> = {\n  value: 'root',\n  children: [\n    {\n      value: 'child1',\n      children: [\n        { value: 'grandchild1', children: [] },\n        { value: 'grandchild2', children: [] }\n      ]\n    },\n    { value: 'child2', children: [] }\n  ]\n};\n\n// JSON type\ntype JSONValue = \n  | string\n  | number\n  | boolean\n  | null\n  | JSONValue[]\n  | { [key: string]: JSONValue };\n\nconst data: JSONValue = {\n  name: 'John',\n  age: 30,\n  address: {\n    city: 'New York',\n    coordinates: [40.7128, -74.0060]\n  },\n  hobbies: ['reading', 'coding']\n};\n\n// Linked list\ntype LinkedList<T> = {\n  value: T;\n  next: LinkedList<T> | null;\n};\n\nconst list: LinkedList<number> = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: null\n    }\n  }\n};\n\n// Deep readonly\ntype DeepReadonly<T> = {\n  readonly [K in keyof T]: T[K] extends object\n    ? DeepReadonly<T[K]>\n    : T[K];\n};"
    },
    {
      "id": 46,
      "question": "What is covariance and contravariance in TypeScript?",
      "answer": "Variance describes how type relationships are preserved in generic types, particularly for function parameters and return types.\n\nCovariance:\n• Preserves type ordering\n• Subtype can replace supertype\n• Return types are covariant\n• Array types are covariant\n• Safe for reading values\n\nContravariance:\n• Reverses type ordering\n• Supertype can replace subtype\n• Function parameters are contravariant\n• Safe for writing values\n• Controlled by strictFunctionTypes\n\nBivariance:\n• Works in both directions\n• Less type safe\n• Default for methods\n• Disabled with strictFunctionTypes\n\nInvariance:\n• No substitution allowed\n• Exact type required\n• Rare in TypeScript\n\nPractical Impact:\n• Affects function assignability\n• Important for callbacks\n• Impacts generic constraints\n• Determines type safety",
      "explanation": "Variance describes how subtype relationships are preserved: covariance preserves the relationship (return types), while contravariance reverses it (function parameters).",
      "difficulty": "Hard",
      "code": "// Covariance (return types)\nclass Animal { name: string; }\nclass Dog extends Animal { breed: string; }\n\nlet getAnimal: () => Animal;\nlet getDog: () => Dog = () => new Dog();\n\n// OK: Dog is subtype of Animal (covariant)\ngetAnimal = getDog;\n\n// Contravariance (parameters with strictFunctionTypes)\nlet feedAnimal: (animal: Animal) => void;\nlet feedDog: (dog: Dog) => void;\n\n// OK: can pass Animal where Dog expected (contravariant)\nfeedDog = feedAnimal;\n\n// Error: cannot pass Dog where Animal expected\n// feedAnimal = feedDog; // Type error\n\n// Array covariance\nlet animals: Animal[] = [];\nlet dogs: Dog[] = [new Dog()];\n\n// OK but potentially unsafe\nanimals = dogs;\n// animals.push(new Animal()); // Runtime ok, but breaks type safety\n\n// Function variance example\ntype Handler<T> = (value: T) => void;\n\nlet handleAnimal: Handler<Animal>;\nlet handleDog: Handler<Dog>;\n\n// With strictFunctionTypes: true\n// handleDog = handleAnimal; // OK (contravariant parameter)\n// handleAnimal = handleDog; // Error\n\n// Bivariance (methods)\ninterface Container<T> {\n  value: T;\n  setValue(value: T): void; // Bivariant in T\n}\n\nlet animalContainer: Container<Animal>;\nlet dogContainer: Container<Dog>;\n\n// Both work with methods (bivariant)\nanimalContainer = dogContainer;\ndogContainer = animalContainer;"
    },
    {
      "id": 47,
      "question": "What are branded types in TypeScript?",
      "answer": "Branded types (also called nominal types) create distinct types from the same primitive type using unique symbols or properties.\n\nPurpose:\n• Create nominally typed primitives\n• Prevent accidental type mixing\n• Add semantic meaning to primitives\n• Type-safe IDs and units\n• Compile-time only\n\nImplementation Techniques:\n• Intersection with unique brand\n• Private brand property\n• Symbol branding\n• Enum branding\n\nBenefits:\n• Prevents mixing similar types\n• Self-documenting code\n• Catches logic errors\n• No runtime overhead\n• Better type safety\n\nUse Cases:\n• User IDs vs Product IDs\n• Different unit types (meters, feet)\n• Currency types\n• Validated strings (email, URL)\n• Token types\n\nLimitations:\n• Compile-time only\n• Requires explicit branding\n• Can be verbose\n• Not true nominal typing",
      "explanation": "Branded types create distinct types from primitives by adding unique compile-time markers, preventing accidental mixing of semantically different values.",
      "difficulty": "Hard",
      "code": "// Basic branded type\ntype Brand<K, T> = K & { __brand: T };\n\ntype UserId = Brand<number, 'UserId'>;\ntype ProductId = Brand<number, 'ProductId'>;\n\n// Constructor functions\nfunction UserId(id: number): UserId {\n  return id as UserId;\n}\n\nfunction ProductId(id: number): ProductId {\n  return id as ProductId;\n}\n\nconst userId = UserId(123);\nconst productId = ProductId(456);\n\n// Type error: cannot mix branded types\n// function getUser(id: UserId) { }\n// getUser(productId); // Error: ProductId not assignable to UserId\n\n// Unit types with branding\ntype Meters = Brand<number, 'Meters'>;\ntype Feet = Brand<number, 'Feet'>;\n\nfunction meters(value: number): Meters {\n  return value as Meters;\n}\n\nfunction feet(value: number): Feet {\n  return value as Feet;\n}\n\nfunction convertToMeters(ft: Feet): Meters {\n  return meters((ft as number) * 0.3048);\n}\n\nconst distance1 = meters(100);\nconst distance2 = feet(328);\n// const sum = distance1 + distance2; // Error: incompatible types\n\n// Validated string types\ntype Email = Brand<string, 'Email'>;\n\nfunction Email(value: string): Email {\n  if (!value.includes('@')) {\n    throw new Error('Invalid email');\n  }\n  return value as Email;\n}\n\nfunction sendEmail(to: Email) {\n  // Guaranteed to be validated\n}\n\nconst email = Email('user@example.com');\nsendEmail(email); // OK\n// sendEmail('invalid'); // Error: string not assignable to Email"
    },
    {
      "id": 48,
      "question": "How do you implement builder pattern in TypeScript?",
      "answer": "The builder pattern in TypeScript uses method chaining with proper typing to construct complex objects step by step.\n\nKey Features:\n• Fluent API with method chaining\n• Type-safe construction\n• Required vs optional properties\n• Immutable intermediate states\n• Build method for final object\n\nAdvanced Techniques:\n• Conditional types for required fields\n• Builder state tracking\n• Compile-time validation\n• Type-safe build method\n• Method return type refinement\n\nBenefits:\n• Clear API\n• Enforces required fields\n• Flexible construction\n• Self-documenting\n• Catches errors at compile time\n\nImplementation Strategies:\n• Simple builder (all optional)\n• Strict builder (tracks state)\n• Generic builder\n• Fluent builder with types\n\nUse Cases:\n• Complex object creation\n• Configuration builders\n• Query builders\n• Test data builders\n• Request builders",
      "explanation": "The builder pattern enables fluent, type-safe object construction through method chaining, with TypeScript ensuring required properties are set before building.",
      "difficulty": "Hard",
      "code": "// Simple builder\nclass User {\n  constructor(\n    public name: string,\n    public email: string,\n    public age?: number,\n    public role?: string\n  ) {}\n}\n\nclass UserBuilder {\n  private name: string = '';\n  private email: string = '';\n  private age?: number;\n  private role?: string;\n\n  setName(name: string): this {\n    this.name = name;\n    return this;\n  }\n\n  setEmail(email: string): this {\n    this.email = email;\n    return this;\n  }\n\n  setAge(age: number): this {\n    this.age = age;\n    return this;\n  }\n\n  setRole(role: string): this {\n    this.role = role;\n    return this;\n  }\n\n  build(): User {\n    return new User(this.name, this.email, this.age, this.role);\n  }\n}\n\nconst user = new UserBuilder()\n  .setName('John')\n  .setEmail('john@example.com')\n  .setAge(30)\n  .build();\n\n// Advanced: Type-safe builder with state tracking\ninterface UserConfig {\n  name: string;\n  email: string;\n  age?: number;\n}\n\ntype RequiredKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? never : K;\n}[keyof T];\n\ntype Builder<T, S extends Partial<T> = {}> = {\n  set<K extends keyof T>(key: K, value: T[K]): Builder<T, S & Pick<T, K>>;\n} & (RequiredKeys<T> extends keyof S ? { build(): T } : {});\n\n// Usage ensures required fields are set\nconst builder: Builder<UserConfig, {}> = createBuilder<UserConfig>();\nconst result = builder\n  .set('name', 'John')\n  .set('email', 'john@example.com')\n  .build(); // Only available after required fields"
    },
    {
      "id": 49,
      "question": "What are phantom types in TypeScript?",
      "answer": "Phantom types are type parameters that don't appear in the runtime structure but provide compile-time type safety.\n\nCharacteristics:\n• Type parameter not used in fields\n• Only exists at compile time\n• Provides additional type information\n• Enables type-level state tracking\n• No runtime overhead\n\nUse Cases:\n• State machine types\n• Compile-time unit tracking\n• Protocol versioning\n• Type-level validation\n• API state tracking\n• Resource lifecycle management\n\nBenefits:\n• Type-safe state transitions\n• Prevents invalid operations\n• Self-documenting constraints\n• Zero runtime cost\n• Compile-time guarantees\n\nImplementation:\n• Generic type parameter\n• Not used in fields\n• Used in method signatures\n• Constrains operations\n• Tracks type-level state",
      "explanation": "Phantom types use type parameters that don't appear in the actual data structure to provide compile-time type safety and state tracking without runtime overhead.",
      "difficulty": "Hard",
      "code": "// State machine with phantom types\ntype Unvalidated = { _tag: 'unvalidated' };\ntype Validated = { _tag: 'validated' };\ntype Submitted = { _tag: 'submitted' };\n\nclass Form<State> {\n  constructor(private data: Record<string, any>) {}\n\n  validate(): Form<Validated> {\n    // Validation logic\n    return new Form<Validated>(this.data);\n  }\n\n  // Only available on validated forms\n  submit(this: Form<Validated>): Form<Submitted> {\n    // Submit logic\n    return new Form<Submitted>(this.data);\n  }\n\n  // Only available on submitted forms\n  getConfirmation(this: Form<Submitted>): string {\n    return 'Form submitted successfully';\n  }\n}\n\nconst form = new Form<Unvalidated>({ name: 'John' });\n// form.submit(); // Error: submit not available\n// form.getConfirmation(); // Error: getConfirmation not available\n\nconst validated = form.validate();\nconst submitted = validated.submit();\nconst confirmation = submitted.getConfirmation(); // OK\n\n// Unit types with phantom types\ntype Unit<T extends string> = { value: number; _unit?: T };\n\nfunction meters(value: number): Unit<'meters'> {\n  return { value };\n}\n\nfunction seconds(value: number): Unit<'seconds'> {\n  return { value };\n}\n\nfunction divide<A extends string, B extends string>(\n  a: Unit<A>,\n  b: Unit<B>\n): Unit<`${A}/${B}`> {\n  return { value: a.value / b.value };\n}\n\nconst distance = meters(100);\nconst time = seconds(10);\nconst speed = divide(distance, time);\n// Type: Unit<'meters/seconds'>\n\n// Connection state tracking\ntype Disconnected = { _state: 'disconnected' };\ntype Connected = { _state: 'connected' };\n\nclass Database<State> {\n  connect(this: Database<Disconnected>): Database<Connected> {\n    return new Database<Connected>();\n  }\n\n  query(this: Database<Connected>, sql: string): any {\n    // Can only query when connected\n  }\n\n  disconnect(this: Database<Connected>): Database<Disconnected> {\n    return new Database<Disconnected>();\n  }\n}"
    },
    {
      "id": 50,
      "question": "What is the difference between type narrowing and type widening?",
      "answer": "Type narrowing and widening describe how TypeScript refines or generalizes types during analysis.\n\nType Narrowing:\n• Refines types to more specific types\n• Happens in control flow\n• Uses type guards\n• Union to specific type\n• Increases type precision\n\nType Widening:\n• Generalizes literal types to primitive types\n• Happens during inference\n• let causes widening\n• const prevents widening\n• Can use as const to prevent\n\nNarrowing Techniques:\n• typeof checks\n• instanceof checks\n• in operator\n• Equality checks\n• Type predicates\n• Discriminated unions\n\nWidening Behavior:\n• let x = 'hello' → string\n• const x = 'hello' → 'hello'\n• Object properties widen\n• Array elements widen\n• as const prevents widening\n\nControl:\n• Use const for literals\n• Use as const for objects\n• Type annotations prevent widening\n• Type guards enable narrowing",
      "explanation": "Type narrowing refines types to more specific types through control flow analysis, while type widening generalizes literal types to primitive types during type inference.",
      "difficulty": "Medium",
      "code": "// Type widening\nlet str1 = 'hello'; // Type: string (widened)\nconst str2 = 'hello'; // Type: 'hello' (literal)\n\nlet num1 = 42; // Type: number (widened)\nconst num2 = 42; // Type: 42 (literal)\n\n// Object property widening\nconst obj1 = {\n  name: 'John', // Type: string (widened)\n  age: 30 // Type: number (widened)\n};\n\n// Prevent widening with as const\nconst obj2 = {\n  name: 'John',\n  age: 30\n} as const;\n// Type: { readonly name: 'John'; readonly age: 30; }\n\n// Type narrowing with typeof\nfunction process(value: string | number) {\n  // value: string | number (union)\n  \n  if (typeof value === 'string') {\n    // value: string (narrowed)\n    console.log(value.toUpperCase());\n  } else {\n    // value: number (narrowed)\n    console.log(value.toFixed(2));\n  }\n}\n\n// Narrowing with type guard\ninterface Cat { meow(): void; }\ninterface Dog { bark(): void; }\n\nfunction isDog(animal: Cat | Dog): animal is Dog {\n  return 'bark' in animal;\n}\n\nfunction handleAnimal(animal: Cat | Dog) {\n  // animal: Cat | Dog\n  \n  if (isDog(animal)) {\n    // animal: Dog (narrowed)\n    animal.bark();\n  } else {\n    // animal: Cat (narrowed)\n    animal.meow();\n  }\n}\n\n// Explicit type to prevent widening\nlet status: 'pending' | 'approved' = 'pending';\nstatus = 'approved'; // OK\n// status = 'rejected'; // Error"
    },
    {
      "id": 51,
      "question": "How do you handle null and undefined in TypeScript?",
      "answer": "TypeScript provides several ways to handle null and undefined safely with strictNullChecks enabled.\n\nStrict Null Checking:\n• Enabled with strictNullChecks\n• null and undefined are distinct types\n• Must explicitly allow in type annotations\n• Prevents common runtime errors\n• Required for type safety\n\nHandling Techniques:\n• Optional chaining (?.) for safe access\n• Nullish coalescing (??) for defaults\n• Type guards for checking\n• Non-null assertion (!) when certain\n• Type narrowing through checks\n\nNullable Types:\n• T | null - value or null\n• T | undefined - value or undefined\n• T | null | undefined - value or either\n• T? same as T | undefined for properties\n\nUtility Types:\n• NonNullable<T> - removes null/undefined\n• Required<T> - removes optional\n• Partial<T> - adds optional\n\nBest Practices:\n• Enable strictNullChecks\n• Avoid non-null assertion\n• Use optional chaining\n• Provide default values\n• Check before accessing",
      "explanation": "TypeScript handles null and undefined through strict null checking, optional chaining, nullish coalescing, and type guards for safe nullable value handling.",
      "difficulty": "Medium",
      "code": "// strictNullChecks: true\n// Variable declarations\nlet name: string = 'John'; // Cannot be null/undefined\nlet nullable: string | null = null; // Can be null\nlet optional: string | undefined = undefined; // Can be undefined\nlet both: string | null | undefined; // Can be both\n\n// Optional chaining\ninterface User {\n  name: string;\n  address?: {\n    city?: string;\n    zipCode?: string;\n  };\n}\n\nconst user: User = { name: 'John' };\nconst city = user.address?.city; // string | undefined\nconst zip = user.address?.zipCode ?? 'Unknown';\n\n// Nullish coalescing\nconst displayName = user.name ?? 'Anonymous';\nconst port = config.port ?? 3000;\n\n// Type guards\nfunction process(value: string | null) {\n  if (value !== null) {\n    // value: string\n    console.log(value.toUpperCase());\n  }\n}\n\nfunction safeDivide(a: number, b: number | null): number | null {\n  if (b === null || b === 0) {\n    return null;\n  }\n  return a / b;\n}\n\n// Non-null assertion (use carefully)\nfunction getName(user: User): string {\n  // Use only when absolutely certain\n  return user.address!.city!; // Asserts not null/undefined\n}\n\n// NonNullable utility\ntype Value = string | number | null | undefined;\ntype NonNullableValue = NonNullable<Value>; // string | number\n\n// Optional parameters\nfunction greet(name?: string) {\n  console.log(`Hello, ${name ?? 'Guest'}`);\n}\n\ngreet(); // Hello, Guest\ngreet('John'); // Hello, John"
    },
    {
      "id": 52,
      "question": "What are index access types in TypeScript?",
      "answer": "Index access types allow accessing the type of a property using bracket notation, similar to property access in JavaScript.\n\nSyntax:\n• T[K] - access property K's type from T\n• T[K1][K2] - nested access\n• T[keyof T] - union of all property types\n• Array<T>[number] - array element type\n\nUse Cases:\n• Extract property types\n• Work with mapped types\n• Generic constraints\n• Type transformations\n• Nested type access\n\nCombining Features:\n• With keyof operator\n• With mapped types\n• With conditional types\n• With utility types\n\nBenefits:\n• Type-safe property access\n• Automatic updates on changes\n• Reduces type duplication\n• Enables generic patterns\n• Better refactoring support\n\nBest Practices:\n• Use for type extraction\n• Combine with keyof\n• Keep expressions simple\n• Document complex patterns",
      "explanation": "Index access types enable extracting the type of a property using bracket notation, allowing type-safe property type access and manipulation.",
      "difficulty": "Medium",
      "code": "// Basic index access\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  address: {\n    city: string;\n    country: string;\n  };\n}\n\ntype UserId = User['id']; // number\ntype UserName = User['name']; // string\ntype Address = User['address']; // { city: string; country: string; }\ntype City = User['address']['city']; // string\n\n// Union of all property types\ntype UserPropertyTypes = User[keyof User];\n// number | string | { city: string; country: string; }\n\n// Array element type\nconst colors = ['red', 'green', 'blue'] as const;\ntype Color = typeof colors[number]; // 'red' | 'green' | 'blue'\n\ntype StringArray = string[];\ntype ArrayElement = StringArray[number]; // string\n\n// Generic function with index access\nfunction getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\nconst user: User = {\n  id: 1,\n  name: 'John',\n  email: 'john@example.com',\n  address: { city: 'NYC', country: 'USA' }\n};\n\nconst name = getProperty(user, 'name'); // Type: string\nconst address = getProperty(user, 'address'); // Type: Address\n\n// With mapped types\ntype Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];\n};\n\ntype UserGetters = Getters<User>;\n// { getId(): number; getName(): string; ... }\n\n// Multiple index access\ntype NestedProp = User['address']['city']; // string"
    },
    {
      "id": 53,
      "question": "What is excess property checking in TypeScript?",
      "answer": "Excess property checking prevents object literals from having properties not defined in the target type.\n\nWhen It Applies:\n• Object literals assigned directly\n• Object literals as arguments\n• Fresh object literals only\n• Not for existing variables\n\nBehavior:\n• Checks for extra properties\n• Errors on unexpected properties\n• Structural typing exception\n• Helps catch typos\n\nBypass Techniques:\n• Assign to variable first\n• Type assertion\n• Index signature\n• Add property to interface\n\nWhy It Exists:\n• Catch common mistakes\n• Detect typos\n• Prevent incorrect objects\n• Balance with structural typing\n\nFreshness:\n• Object literals are fresh\n• Stored variables lose freshness\n• Type assertions remove freshness\n• Helps detect errors early\n\nBest Practices:\n• Don't bypass unnecessarily\n• Fix the type or object\n• Use index signatures intentionally\n• Embrace the safety",
      "explanation": "Excess property checking catches extra properties in object literals to prevent typos and mistakes, applying only to fresh object literals assigned directly.",
      "difficulty": "Medium",
      "code": "// Excess property checking\ninterface User {\n  name: string;\n  email: string;\n}\n\n// Error: excess property 'age'\nconst user1: User = {\n  name: 'John',\n  email: 'john@example.com',\n  age: 30 // Error: Object literal may only specify known properties\n};\n\n// Bypass: assign to variable first\nconst temp = {\n  name: 'John',\n  email: 'john@example.com',\n  age: 30\n};\nconst user2: User = temp; // OK (not fresh)\n\n// Bypass: type assertion\nconst user3 = {\n  name: 'John',\n  email: 'john@example.com',\n  age: 30\n} as User; // OK but loses safety\n\n// Function arguments (also checked)\nfunction createUser(user: User) {\n  // ...\n}\n\n// Error: excess property\ncreateUser({\n  name: 'John',\n  email: 'john@example.com',\n  age: 30 // Error\n});\n\n// Bypass with variable\nconst userData = {\n  name: 'John',\n  email: 'john@example.com',\n  age: 30\n};\ncreateUser(userData); // OK\n\n// Allow with index signature\ninterface FlexibleUser {\n  name: string;\n  email: string;\n  [key: string]: any; // Allow additional properties\n}\n\nconst user4: FlexibleUser = {\n  name: 'John',\n  email: 'john@example.com',\n  age: 30, // OK with index signature\n  role: 'admin'\n};\n\n// Structural typing still works\ninterface Point { x: number; y: number; }\ninterface NamedPoint { x: number; y: number; name: string; }\n\nconst namedPoint: NamedPoint = { x: 1, y: 2, name: 'origin' };\nconst point: Point = namedPoint; // OK (not fresh)"
    },
    {
      "id": 54,
      "question": "What are import and export type modifiers?",
      "answer": "TypeScript supports type-only imports and exports using the 'type' modifier to separate type and value spaces.\n\nType-Only Imports:\n• import type syntax\n• Imports only types\n• Removed at runtime\n• Cannot be used as values\n• Better tree-shaking\n\nType-Only Exports:\n• export type syntax\n• Exports only types\n• Clarifies intent\n• Documentation benefit\n• Supports re-exports\n\nBenefits:\n• Explicit type/value separation\n• Prevents accidental value use\n• Enables optimizations\n• Clearer code intent\n• Better bundling\n\nCombined Syntax:\n• import { type A, B } from 'module'\n• Mix type and value imports\n• More concise\n• Available in TypeScript 4.5+\n\nConfiguration:\n• importsNotUsedAsValues option\n• verbatimModuleSyntax (modern)\n• Enforces type imports\n• Helps with bundling\n\nBest Practices:\n• Use for types only\n• Explicit is better\n• Helps bundlers\n• Avoid mixing when possible",
      "explanation": "Type-only imports and exports use the 'type' modifier to explicitly import/export types, which are removed at runtime for better optimization.",
      "difficulty": "Medium",
      "code": "// types.ts\nexport interface User {\n  id: number;\n  name: string;\n}\n\nexport type UserId = number;\n\nexport const DEFAULT_USER: User = {\n  id: 0,\n  name: 'Unknown'\n};\n\n// Type-only import\nimport type { User, UserId } from './types';\n// User and UserId removed at runtime\n\n// Cannot use as value\n// const user: User = DEFAULT_USER; // Error: User is type-only\n\n// Regular import for values\nimport { DEFAULT_USER } from './types';\nimport type { User } from './types';\n\nconst user: User = DEFAULT_USER; // OK\n\n// Mixed import (TypeScript 4.5+)\nimport { type User, DEFAULT_USER, type UserId } from './types';\n\n// Type-only export\n// types.ts\ntype Internal = { value: number };\nexport type { Internal }; // Only type exported\n\n// Re-export types\nexport type { User, UserId } from './types';\nexport { DEFAULT_USER } from './types'; // Value export\n\n// With classes (careful!)\nexport class Person {\n  constructor(public name: string) {}\n}\n\n// Type-only import of class\nimport type { Person } from './person';\n// Can use as type but not construct\nlet person: Person; // OK\n// person = new Person('John'); // Error: Person is type-only\n\n// For construction, need value import\nimport { Person } from './person';\nconst p = new Person('John'); // OK\n\n// tsconfig.json\n// {\n//   \"compilerOptions\": {\n//     \"verbatimModuleSyntax\": true // Enforce explicit imports\n//   }\n// }"
    },
    {
      "id": 55,
      "question": "What is the ThisType utility and how is it used?",
      "answer": "ThisType is a marker utility type that specifies the type of 'this' in object literal methods without affecting the object's type.\n\nPurpose:\n• Set contextual 'this' type\n• Object literal methods\n• Doesn't affect return type\n• Enables type-safe 'this'\n• Used in libraries and frameworks\n\nHow It Works:\n• Marker interface (no runtime)\n• Affects 'this' in methods\n• Requires noImplicitThis\n• Intersection with object type\n• Contextual typing\n\nUse Cases:\n• Vue-like component APIs\n• Plugin systems\n• Mixin patterns\n• Method context typing\n• Library APIs\n\nRequirements:\n• noImplicitThis enabled\n• Used in object literals\n• Intersection type\n• Compile-time only\n\nBenefits:\n• Type-safe 'this' access\n• Better IDE support\n• Catches errors early\n• Flexible patterns\n• Framework integration",
      "explanation": "ThisType is a utility that sets the type of 'this' in object literal methods, enabling type-safe context without affecting the object's structure.",
      "difficulty": "Hard",
      "code": "// Basic ThisType usage\ninterface Context {\n  name: string;\n  age: number;\n}\n\ntype Methods = {\n  greet(): void;\n  celebrateBirthday(): void;\n};\n\nconst obj: Methods & ThisType<Context> = {\n  greet() {\n    // 'this' is typed as Context\n    console.log(`Hello, I'm ${this.name}`);\n  },\n  celebrateBirthday() {\n    this.age++;\n    console.log(`Now ${this.age} years old`);\n  }\n};\n\n// Vue-like component example\ninterface ComponentData {\n  count: number;\n  message: string;\n}\n\ninterface ComponentMethods {\n  increment(): void;\n  updateMessage(msg: string): void;\n}\n\nfunction defineComponent<D, M>(\n  options: D & M & ThisType<D & M>\n) {\n  return options;\n}\n\nconst component = defineComponent({\n  // Data\n  count: 0,\n  message: 'Hello',\n  \n  // Methods - 'this' includes data and methods\n  increment() {\n    this.count++; // Type-safe access\n  },\n  updateMessage(msg: string) {\n    this.message = msg;\n    this.increment(); // Can call other methods\n  }\n});\n\n// Mixin factory\nfunction createMixin<T>() {\n  type MixinMethods = {\n    log(): void;\n    getData(): T;\n  };\n  \n  return {\n    log() {\n      console.log(this); // 'this' typed as T\n    },\n    getData(): T {\n      return this as unknown as T;\n    }\n  } as MixinMethods & ThisType<T>;\n}\n\n// Without ThisType (for comparison)\nconst objNoThis = {\n  greet() {\n    // 'this' is the object type\n    console.log(this); // Type: { greet(): void }\n  }\n};\n\n// Must enable noImplicitThis\n// tsconfig.json: { \"noImplicitThis\": true }"
    },
    {
      "id": 56,
      "question": "How do you handle errors in TypeScript?",
      "answer": "TypeScript provides several patterns for type-safe error handling beyond basic try-catch blocks.\n\nError Types:\n• Error class and subclasses\n• Custom error classes\n• Union types for errors\n• Result types (success/failure)\n• Maybe/Option types\n\nBasic Error Handling:\n• try-catch blocks\n• throw statements\n• Error constructors\n• Stack traces\n• Error messages\n\nType-Safe Patterns:\n• Result<T, E> type\n• Either<L, R> type\n• Option<T> type\n• Discriminated unions\n• Type guards for errors\n\nAsync Error Handling:\n• Promise rejection\n• async/await with try-catch\n• Error boundaries\n• Result types for async\n\nBest Practices:\n• Custom error classes\n• Type narrow caught errors\n• Use Result types for expected errors\n• Document thrown errors\n• Avoid throwing for control flow\n• Use unknown for catch blocks",
      "explanation": "TypeScript handles errors through try-catch blocks, custom error classes, and type-safe patterns like Result types that encode success/failure in the type system.",
      "difficulty": "Medium",
      "code": "// Basic error handling\nclass ValidationError extends Error {\n  constructor(\n    message: string,\n    public field: string,\n    public code: string\n  ) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\n\nfunction validateEmail(email: string): string {\n  if (!email.includes('@')) {\n    throw new ValidationError('Invalid email', 'email', 'INVALID_FORMAT');\n  }\n  return email;\n}\n\ntry {\n  const email = validateEmail('invalid');\n} catch (error) {\n  // error is unknown by default\n  if (error instanceof ValidationError) {\n    console.log(`${error.field}: ${error.message}`);\n  } else if (error instanceof Error) {\n    console.log(error.message);\n  }\n}\n\n// Result type pattern\ntype Success<T> = { success: true; data: T };\ntype Failure<E> = { success: false; error: E };\ntype Result<T, E = Error> = Success<T> | Failure<E>;\n\nfunction parseNumber(value: string): Result<number, string> {\n  const num = Number(value);\n  if (isNaN(num)) {\n    return { success: false, error: 'Invalid number' };\n  }\n  return { success: true, data: num };\n}\n\nconst result = parseNumber('123');\nif (result.success) {\n  console.log(result.data); // Type: number\n} else {\n  console.log(result.error); // Type: string\n}\n\n// Async error handling\nasync function fetchUser(id: number): Promise<Result<User, string>> {\n  try {\n    const response = await fetch(`/api/users/${id}`);\n    if (!response.ok) {\n      return { success: false, error: 'User not found' };\n    }\n    const data = await response.json();\n    return { success: true, data };\n  } catch (error) {\n    return { success: false, error: 'Network error' };\n  }\n}\n\n// Type guard for errors\nfunction isError(value: unknown): value is Error {\n  return value instanceof Error;\n}"
    },
    {
      "id": 57,
      "question": "What are module augmentation and declaration merging?",
      "answer": "Module augmentation extends existing modules with new declarations, while declaration merging combines multiple declarations.\n\nModule Augmentation:\n• Add to existing modules\n• Extend third-party types\n• Add properties to interfaces\n• Enhance library types\n• Global or module scope\n\nDeclaration Merging:\n• Combine multiple declarations\n• Interfaces merge automatically\n• Namespaces merge\n• Classes don't merge\n• Functions can merge with namespaces\n\nAugmentation Patterns:\n• Global augmentation with declare global\n• Module augmentation with declare module\n• Interface extension\n• Add properties to existing types\n\nUse Cases:\n• Extending Express Request\n• Adding to Window object\n• Plugin type definitions\n• Extending third-party libraries\n• Custom properties\n\nBest Practices:\n• Use for extending only\n• Keep augmentations focused\n• Document additions\n• Avoid conflicts\n• Use type-safe extensions",
      "explanation": "Module augmentation extends existing modules with new declarations, while declaration merging combines multiple declarations of the same name into a single definition.",
      "difficulty": "Hard",
      "code": "// Module augmentation - Express example\nimport 'express';\n\ndeclare module 'express' {\n  interface Request {\n    user?: {\n      id: number;\n      name: string;\n      role: string;\n    };\n    requestId: string;\n  }\n  \n  interface Response {\n    sendSuccess(data: any): void;\n  }\n}\n\n// Now can use extended types\nimport { Request, Response } from 'express';\n\nfunction authMiddleware(req: Request, res: Response) {\n  if (req.user) { // Type-safe\n    console.log(req.user.name);\n  }\n}\n\n// Global augmentation\ndeclare global {\n  interface Window {\n    myApp: {\n      version: string;\n      config: Record<string, unknown>;\n      init(): void;\n    };\n  }\n  \n  const APP_VERSION: string;\n}\n\n// Usage\nwindow.myApp.init();\nconsole.log(APP_VERSION);\n\n// Declaration merging - interfaces\ninterface User {\n  name: string;\n}\n\ninterface User {\n  email: string;\n}\n\ninterface User {\n  age: number;\n}\n\n// Merged into single interface\nconst user: User = {\n  name: 'John',\n  email: 'john@example.com',\n  age: 30\n};\n\n// Namespace merging\nnamespace Animals {\n  export class Dog {}\n}\n\nnamespace Animals {\n  export class Cat {}\n}\n\n// Both available\nconst dog = new Animals.Dog();\nconst cat = new Animals.Cat();\n\n// Function and namespace merging\nfunction buildUrl(path: string): string {\n  return `${buildUrl.baseUrl}${path}`;\n}\n\nnamespace buildUrl {\n  export let baseUrl = 'https://api.example.com';\n}\n\nconst url = buildUrl('/users');\nbuildUrl.baseUrl = 'https://new-api.example.com';\n\n// Augmenting library types\nimport 'react';\n\ndeclare module 'react' {\n  interface CSSProperties {\n    '--custom-property'?: string;\n  }\n}"
    },
    {
      "id": 58,
      "question": "What is structural typing vs nominal typing?",
      "answer": "TypeScript uses structural typing where type compatibility is based on structure, not names.\n\nStructural Typing:\n• Compatibility by shape/structure\n• Names don't matter\n• Duck typing at compile-time\n• If it looks right, it is right\n• TypeScript's approach\n\nNominal Typing:\n• Compatibility by explicit declaration\n• Names matter\n• Must explicitly inherit\n• Common in Java, C#\n• Can simulate in TypeScript\n\nTypeScript Behavior:\n• Two types compatible if structure matches\n• Extra properties allowed (with exceptions)\n• Private fields break compatibility\n• Methods checked structurally\n\nSimulating Nominal Types:\n• Branded types\n• Private fields\n• Symbol brands\n• Unique symbols\n\nBenefits of Structural:\n• More flexible\n• Better JavaScript interop\n• Less boilerplate\n• Natural for object literals\n\nDrawbacks:\n• Accidental compatibility\n• Less explicit intent\n• Can mix unrelated types",
      "explanation": "TypeScript uses structural typing where type compatibility is based on structure rather than names, allowing types with the same shape to be compatible.",
      "difficulty": "Medium",
      "code": "// Structural typing\ninterface Point {\n  x: number;\n  y: number;\n}\n\ninterface Coordinate {\n  x: number;\n  y: number;\n}\n\n// Compatible despite different names\nconst point: Point = { x: 10, y: 20 };\nconst coord: Coordinate = point; // OK - same structure\n\nfunction printPoint(p: Point) {\n  console.log(p.x, p.y);\n}\n\nconst coord2: Coordinate = { x: 5, y: 15 };\nprintPoint(coord2); // OK - structure matches\n\n// Extra properties accepted (from variables)\ninterface Person {\n  name: string;\n}\n\nconst person = {\n  name: 'John',\n  age: 30,\n  email: 'john@example.com'\n};\n\nconst p: Person = person; // OK - has name property\n\n// Simulating nominal typing with branding\ntype Brand<K, T> = K & { __brand: T };\n\ntype UserId = Brand<number, 'UserId'>;\ntype ProductId = Brand<number, 'ProductId'>;\n\nconst userId = 1 as UserId;\nconst productId = 1 as ProductId;\n\nfunction getUser(id: UserId) {}\n\n// getUser(productId); // Error - brands make them incompatible\ngetUser(userId); // OK\n\n// Private fields for nominal typing\nclass USD {\n  private __nominal: void;\n  constructor(public amount: number) {}\n}\n\nclass EUR {\n  private __nominal: void;\n  constructor(public amount: number) {}\n}\n\nconst dollars = new USD(100);\nconst euros = new EUR(100);\n\nfunction processUSD(money: USD) {}\n\nprocessUSD(dollars); // OK\n// processUSD(euros); // Error - different classes\n\n// Nominal typing in other languages (for comparison)\n// Java:\n// class Point { int x; int y; }\n// class Coordinate { int x; int y; }\n// Point p = new Coordinate(); // Error - different types"
    },
    {
      "id": 59,
      "question": "What are the differences between interface and class?",
      "answer": "Interfaces and classes serve different purposes in TypeScript's type system and runtime.\n\nInterface:\n• Compile-time only\n• No runtime code\n• Cannot be instantiated\n• Only type information\n• Can extend multiple interfaces\n• Support declaration merging\n• No implementation\n\nClass:\n• Runtime entity\n• Can be instantiated\n• Has implementation\n• Creates JavaScript code\n• Single inheritance (extends one)\n• Can implement interfaces\n• Has constructor\n• Has methods and properties\n\nCommon Use Cases:\n• Interface for contracts\n• Class for objects with behavior\n• Interface for API shapes\n• Class for entities and services\n\nCombining:\n• Class implements interface\n• Interface describes class shape\n• Multiple interfaces per class\n• Abstract classes as hybrid\n\nChoosing:\n• Use interface for pure types\n• Use class for instances\n• Use interface for flexibility\n• Use class for encapsulation",
      "explanation": "Interfaces are compile-time type definitions with no runtime code, while classes are runtime constructs with implementation that can be instantiated.",
      "difficulty": "Easy",
      "code": "// Interface - compile-time only\ninterface IUser {\n  id: number;\n  name: string;\n  email: string;\n  greet(): void;\n}\n\n// No runtime code generated for interface\n// Cannot do: new IUser()\n\n// Class - runtime entity\nclass User implements IUser {\n  constructor(\n    public id: number,\n    public name: string,\n    public email: string\n  ) {}\n  \n  greet(): void {\n    console.log(`Hello, I'm ${this.name}`);\n  }\n}\n\n// Can instantiate\nconst user = new User(1, 'John', 'john@example.com');\nuser.greet();\n\n// Interface for multiple implementations\nclass AdminUser implements IUser {\n  role: string = 'admin';\n  \n  constructor(\n    public id: number,\n    public name: string,\n    public email: string\n  ) {}\n  \n  greet(): void {\n    console.log(`Admin ${this.name}`);\n  }\n}\n\n// Multiple interfaces\ninterface Printable {\n  print(): void;\n}\n\ninterface Serializable {\n  serialize(): string;\n}\n\nclass Document implements Printable, Serializable {\n  print(): void {\n    console.log('Printing...');\n  }\n  \n  serialize(): string {\n    return JSON.stringify(this);\n  }\n}\n\n// Interface for function typing\ninterface Handler {\n  (event: Event): void;\n}\n\nconst handler: Handler = (event) => {\n  console.log(event);\n};\n\n// Class for state and behavior\nclass Counter {\n  private count: number = 0;\n  \n  increment(): void {\n    this.count++;\n  }\n  \n  getCount(): number {\n    return this.count;\n  }\n}\n\nconst counter = new Counter();\ncounter.increment();\nconsole.log(counter.getCount());"
    },
    {
      "id": 60,
      "question": "How do you work with third-party JavaScript libraries in TypeScript?",
      "answer": "TypeScript integrates with JavaScript libraries through type definitions and proper module configuration.\n\nType Definitions:\n• DefinitelyTyped repository\n• @types packages from npm\n• Library-bundled types\n• Custom .d.ts files\n• Ambient declarations\n\nInstalling Types:\n• npm install @types/library-name\n• Automatically used by TypeScript\n• Version matching recommended\n• Check DefinitelyTyped for availability\n\nNo Type Definitions:\n• Create custom .d.ts file\n• Use declare module\n• Type as any (last resort)\n• Contribute to DefinitelyTyped\n\nCommon Patterns:\n• Import with proper types\n• Module augmentation if needed\n• Global type declarations\n• Namespace imports\n\nConfiguration:\n• typeRoots in tsconfig.json\n• types array for specific packages\n• skipLibCheck for performance\n• Module resolution settings\n\nBest Practices:\n• Install types for libraries\n• Keep types version-synced\n• Create types if missing\n• Don't ignore type errors\n• Contribute missing types",
      "explanation": "TypeScript works with JavaScript libraries through type definitions from @types packages, bundled types, or custom declarations, enabling type safety for untyped code.",
      "difficulty": "Medium",
      "code": "// Install types for library\n// npm install lodash\n// npm install @types/lodash\n\nimport _ from 'lodash';\n\nconst numbers = [1, 2, 3, 4, 5];\nconst doubled = _.map(numbers, n => n * 2); // Fully typed\n\n// Library without types - create declaration\n// legacy-lib.d.ts\ndeclare module 'legacy-lib' {\n  export function doSomething(x: number): string;\n  export function processData(data: any[]): any;\n  \n  export interface Config {\n    timeout: number;\n    retries: number;\n  }\n  \n  export class Client {\n    constructor(config: Config);\n    connect(): Promise<void>;\n    disconnect(): void;\n  }\n}\n\n// Usage\nimport { Client, doSomething } from 'legacy-lib';\n\nconst client = new Client({ timeout: 3000, retries: 3 });\nconst result = doSomething(42);\n\n// Global library without modules\n// jquery.d.ts\ndeclare const $: {\n  (selector: string): any;\n  ajax(settings: any): any;\n};\n\n// Usage\n$('.button').click();\n$.ajax({ url: '/api' });\n\n// Augmenting existing types\nimport 'express';\n\ndeclare module 'express' {\n  interface Request {\n    user?: { id: number; name: string };\n  }\n}\n\n// tsconfig.json configuration\n// {\n//   \"compilerOptions\": {\n//     \"typeRoots\": [\n//       \"./node_modules/@types\",\n//       \"./types\"\n//     ],\n//     \"types\": [\"node\", \"jest\"],\n//     \"skipLibCheck\": true,\n//     \"esModuleInterop\": true\n//   }\n// }\n\n// Quick any declaration for unmaintained lib\ndeclare module 'old-library';\n// Imports as any (use temporarily)"
    },
    {
      "id": 61,
      "question": "What are higher-order types in TypeScript?",
      "answer": "Higher-order types are types that operate on other types, similar to higher-order functions operating on functions.\n\nConcepts:\n• Types that take type parameters\n• Generic types\n• Mapped types\n• Conditional types\n• Type-level functions\n\nCommon Patterns:\n• Type transformations\n• Type filtering\n• Type mapping\n• Type composition\n• Recursive type operations\n\nBuilt-in Examples:\n• Partial<T> - makes properties optional\n• Pick<T, K> - selects properties\n• Omit<T, K> - excludes properties\n• ReturnType<T> - extracts return type\n• Mapped and conditional types\n\nCustom Higher-Order Types:\n• Create reusable type utilities\n• Compose complex transformations\n• Build type libraries\n• Domain-specific type helpers\n\nBenefits:\n• Reusable type logic\n• Type-safe transformations\n• Reduce code duplication\n• Enable advanced patterns\n• Better abstraction",
      "explanation": "Higher-order types are types that operate on other types through generic parameters, enabling powerful type transformations and reusable type utilities.",
      "difficulty": "Hard",
      "code": "// Basic higher-order type\ntype Box<T> = { value: T };\n\ntype NumberBox = Box<number>; // { value: number }\ntype StringBox = Box<string>; // { value: string }\n\n// Type transformation\ntype Nullable<T> = T | null;\ntype Optional<T> = T | undefined;\n\ntype NullableString = Nullable<string>; // string | null\ntype OptionalNumber = Optional<number>; // number | undefined\n\n// Conditional higher-order type\ntype IsArray<T> = T extends any[] ? true : false;\n\ntype Test1 = IsArray<string[]>; // true\ntype Test2 = IsArray<string>; // false\n\n// Mapped higher-order type\ntype ReadonlyProps<T> = {\n  readonly [K in keyof T]: T[K];\n};\n\ninterface User {\n  name: string;\n  age: number;\n}\n\ntype ReadonlyUser = ReadonlyProps<User>;\n// { readonly name: string; readonly age: number; }\n\n// Composing higher-order types\ntype DeepPartial<T> = {\n  [K in keyof T]?: T[K] extends object\n    ? DeepPartial<T[K]>\n    : T[K];\n};\n\ninterface Config {\n  database: {\n    host: string;\n    port: number;\n  };\n  cache: {\n    enabled: boolean;\n  };\n}\n\ntype PartialConfig = DeepPartial<Config>;\n// All properties at all levels are optional\n\n// Custom utility type\ntype FunctionPropertyNames<T> = {\n  [K in keyof T]: T[K] extends Function ? K : never;\n}[keyof T];\n\ntype FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;\n\ninterface Mixed {\n  name: string;\n  age: number;\n  greet(): void;\n  calculate(x: number): number;\n}\n\ntype OnlyFunctions = FunctionProperties<Mixed>;\n// { greet(): void; calculate(x: number): number; }\n\n// Type-level recursion\ntype Awaited<T> = T extends Promise<infer U>\n  ? U extends Promise<any>\n    ? Awaited<U>\n    : U\n  : T;\n\ntype Result = Awaited<Promise<Promise<string>>>; // string"
    },
    {
      "id": 62,
      "question": "What is the never type used for in practice?",
      "answer": "The never type represents values that never occur and has several practical applications in TypeScript.\n\nPractical Uses:\n• Exhaustiveness checking\n• Unreachable code markers\n• Filtering types from unions\n• Type-level assertions\n• Impossible state representation\n\nExhaustiveness Checking:\n• Switch statement completion\n• Ensures all cases handled\n• Compiler error on missing cases\n• Prevents runtime errors\n\nType Filtering:\n• Remove types from unions\n• Filter mapped type keys\n• Exclude impossible values\n• Type-level conditionals\n\nUnreachable Code:\n• Functions that always throw\n• Infinite loops\n• Process.exit() calls\n• Assertion failures\n\nType System Benefits:\n• Bottom type (subtype of all)\n• No value assignable to never\n• Used in type algebra\n• Enables type-level logic\n\nBest Practices:\n• Use for exhaustiveness\n• Mark unreachable branches\n• Filter unwanted types\n• Document impossible states",
      "explanation": "The never type has practical uses in exhaustiveness checking, type filtering, marking unreachable code, and representing impossible states in the type system.",
      "difficulty": "Medium",
      "code": "// Exhaustiveness checking\ntype Status = 'pending' | 'approved' | 'rejected';\n\nfunction handleStatus(status: Status): string {\n  switch (status) {\n    case 'pending':\n      return 'Processing...';\n    case 'approved':\n      return 'Approved!';\n    case 'rejected':\n      return 'Rejected.';\n    default:\n      // If new status added, this causes error\n      const _exhaustive: never = status;\n      throw new Error(`Unhandled status: ${_exhaustive}`);\n  }\n}\n\n// Type filtering\ntype NonNullableKeys<T> = {\n  [K in keyof T]: null extends T[K] ? never : K;\n}[keyof T];\n\ninterface User {\n  id: number;\n  name: string;\n  email: string | null;\n  phone: string | null;\n}\n\ntype RequiredKeys = NonNullableKeys<User>; // 'id' | 'name'\n\n// Filtering union types\ntype Exclude<T, U> = T extends U ? never : T;\n\ntype Numbers = 1 | 2 | 3 | 4 | 5;\ntype OddNumbers = Exclude<Numbers, 2 | 4>; // 1 | 3 | 5\n\n// Functions that never return\nfunction throwError(message: string): never {\n  throw new Error(message);\n}\n\nfunction infiniteLoop(): never {\n  while (true) {\n    // ...\n  }\n}\n\nfunction exitProcess(): never {\n  process.exit(1);\n}\n\n// Narrowing to never\nfunction process(value: string | number) {\n  if (typeof value === 'string') {\n    return value.toUpperCase();\n  } else if (typeof value === 'number') {\n    return value.toFixed(2);\n  }\n  // value is never here (impossible)\n  const _impossible: never = value;\n}\n\n// Impossible intersection\ntype Impossible = string & number; // never\n\n// Type-level assertion\ntype Assert<T extends true> = T;\ntype IsTrue = Assert<true>; // OK\n// type IsFalse = Assert<false>; // Error\n\n// Unreachable code detection\nfunction example(x: number): number {\n  if (x > 0) {\n    return x;\n  } else {\n    return -x;\n  }\n  // Unreachable code\n  const unreachable: never = 'this never executes' as never;\n}"
    },
    {
      "id": 63,
      "question": "How do you implement dependency injection in TypeScript?",
      "answer": "Dependency injection in TypeScript can be implemented using several patterns with proper typing.\n\nImplementation Approaches:\n• Constructor injection\n• Property injection\n• Method injection\n• Interface-based injection\n• Decorator-based (with libraries)\n\nManual DI:\n• Interface for dependencies\n• Constructor parameters\n• Factory functions\n• Service containers\n\nDI Libraries:\n• InversifyJS\n• TSyringe\n• TypeDI\n• NestJS built-in DI\n\nBenefits:\n• Loose coupling\n• Testability\n• Flexibility\n• Type safety\n• Inversion of control\n\nPatterns:\n• Service locator\n• Dependency container\n• Factory pattern\n• Module pattern\n\nBest Practices:\n• Use interfaces for contracts\n• Inject dependencies via constructor\n• Keep dependencies explicit\n• Use DI container for complex apps\n• Mock dependencies in tests",
      "explanation": "Dependency injection in TypeScript uses constructor injection with interfaces for type-safe dependency management, enabling loose coupling and better testability.",
      "difficulty": "Hard",
      "code": "// Manual constructor injection\ninterface ILogger {\n  log(message: string): void;\n  error(message: string): void;\n}\n\nclass ConsoleLogger implements ILogger {\n  log(message: string): void {\n    console.log(`[LOG] ${message}`);\n  }\n  \n  error(message: string): void {\n    console.error(`[ERROR] ${message}`);\n  }\n}\n\ninterface IDatabase {\n  query(sql: string): Promise<any>;\n}\n\nclass PostgresDatabase implements IDatabase {\n  async query(sql: string): Promise<any> {\n    // Execute query\n    return [];\n  }\n}\n\n// Service with dependencies\nclass UserService {\n  constructor(\n    private logger: ILogger,\n    private database: IDatabase\n  ) {}\n  \n  async getUser(id: number) {\n    this.logger.log(`Fetching user ${id}`);\n    try {\n      const result = await this.database.query(`SELECT * FROM users WHERE id = ${id}`);\n      return result[0];\n    } catch (error) {\n      this.logger.error(`Failed to fetch user: ${error}`);\n      throw error;\n    }\n  }\n}\n\n// Manual wiring\nconst logger = new ConsoleLogger();\nconst database = new PostgresDatabase();\nconst userService = new UserService(logger, database);\n\n// Simple DI Container\ntype Constructor<T = any> = new (...args: any[]) => T;\n\nclass Container {\n  private services = new Map<Constructor, any>();\n  \n  register<T>(token: Constructor<T>, instance: T): void {\n    this.services.set(token, instance);\n  }\n  \n  resolve<T>(token: Constructor<T>): T {\n    const instance = this.services.get(token);\n    if (!instance) {\n      throw new Error(`Service not registered: ${token.name}`);\n    }\n    return instance;\n  }\n}\n\n// Usage with container\nconst container = new Container();\ncontainer.register(ConsoleLogger, new ConsoleLogger());\ncontainer.register(PostgresDatabase, new PostgresDatabase());\n\nconst logger2 = container.resolve(ConsoleLogger);\nconst db = container.resolve(PostgresDatabase);\nconst userService2 = new UserService(logger2, db);\n\n// Testing with mocks\nclass MockLogger implements ILogger {\n  log(message: string): void {}\n  error(message: string): void {}\n}\n\nclass MockDatabase implements IDatabase {\n  async query(sql: string): Promise<any> {\n    return [{ id: 1, name: 'Test User' }];\n  }\n}\n\nconst testService = new UserService(\n  new MockLogger(),\n  new MockDatabase()\n);"
    },
    {
      "id": 64,
      "question": "What are the performance implications of TypeScript?",
      "answer": "TypeScript has minimal runtime performance impact since types are erased during compilation.\n\nCompile-Time Impact:\n• Type checking takes time\n• Larger projects slower to compile\n• Incremental compilation helps\n• Watch mode for development\n• Project references speed up builds\n\nRuntime Impact:\n• Types erased in output\n• No runtime type checking\n• Same JavaScript performance\n• Potential for better optimization\n• Enums have small overhead\n\nOptimization Opportunities:\n• Better minification\n• Dead code elimination\n• Tree-shaking improvements\n• Inline optimizations\n• Compiler hints\n\nPerformance Considerations:\n• const enums inlined\n• Class vs interface (use interface)\n• Type complexity affects compile time\n• skipLibCheck for faster compilation\n• Proper tsconfig settings\n\nBest Practices:\n• Use incremental compilation\n• Enable project references\n• Keep type complexity reasonable\n• Use const enums when appropriate\n• Optimize tsconfig for build speed\n• Cache type checking results",
      "explanation": "TypeScript has virtually no runtime performance impact as types are erased during compilation, with only compile-time overhead for type checking.",
      "difficulty": "Medium",
      "code": "// No runtime overhead - types removed\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n// Compiles to:\n// function add(a, b) {\n//   return a + b;\n// }\n\n// Interface - no runtime code\ninterface User {\n  name: string;\n  age: number;\n}\nconst user: User = { name: 'John', age: 30 };\n// Compiles to:\n// const user = { name: 'John', age: 30 };\n\n// Enum - has runtime code\nenum Color {\n  Red,\n  Green,\n  Blue\n}\n// Compiles to:\n// var Color;\n// (function (Color) {\n//   Color[Color['Red'] = 0] = 'Red';\n//   Color[Color['Green'] = 1] = 'Green';\n//   Color[Color['Blue'] = 2] = 'Blue';\n// })(Color || (Color = {}));\n\n// Const enum - inlined (no runtime)\nconst enum Direction {\n  Up,\n  Down\n}\nconst dir = Direction.Up;\n// Compiles to:\n// const dir = 0; /* Up */\n\n// tsconfig.json for performance\n// {\n//   \"compilerOptions\": {\n//     \"incremental\": true,\n//     \"skipLibCheck\": true,\n//     \"isolatedModules\": true,\n//     \"composite\": true // for project references\n//   },\n//   \"exclude\": [\"node_modules\", \"dist\"]\n// }\n\n// Type complexity affects compile time, not runtime\ntype Complex<T> = T extends any\n  ? T extends any[]\n    ? Complex<T[number]>[]\n    : T extends object\n    ? { [K in keyof T]: Complex<T[K]> }\n    : T\n  : never;\n// Complex type but no runtime impact\n\n// Class vs Interface\nclass PersonClass {\n  constructor(public name: string) {}\n}\n// Generates class code\n\ninterface PersonInterface {\n  name: string;\n}\n// No code generated - prefer for performance"
    },
    {
      "id": 65,
      "question": "How do you implement factory pattern in TypeScript?",
      "answer": "The factory pattern creates objects without specifying exact classes, using type-safe implementations in TypeScript.\n\nFactory Types:\n• Simple factory - single creation method\n• Factory method - subclass decides creation\n• Abstract factory - families of objects\n• Static factory - class method\n\nImplementation Approaches:\n• Function factories\n• Class factories\n• Generic factories\n• Builder factories\n• Registry-based factories\n\nType Safety:\n• Return type inference\n• Generic parameters\n• Discriminated unions\n• Type guards\n• Interface-based contracts\n\nBenefits:\n• Encapsulates object creation\n• Loose coupling\n• Type-safe creation\n• Easy to extend\n• Single responsibility\n\nUse Cases:\n• Creating similar objects\n• Complex object construction\n• Different implementations\n• Plugin systems\n• Configurable instances",
      "explanation": "The factory pattern in TypeScript provides type-safe object creation through functions or classes that encapsulate instantiation logic and support multiple implementations.",
      "difficulty": "Medium",
      "code": "// Simple factory function\ninterface ILogger {\n  log(message: string): void;\n}\n\nclass ConsoleLogger implements ILogger {\n  log(message: string): void {\n    console.log(message);\n  }\n}\n\nclass FileLogger implements ILogger {\n  constructor(private filename: string) {}\n  \n  log(message: string): void {\n    // Write to file\n  }\n}\n\ntype LoggerType = 'console' | 'file';\n\nfunction createLogger(type: LoggerType, options?: { filename?: string }): ILogger {\n  switch (type) {\n    case 'console':\n      return new ConsoleLogger();\n    case 'file':\n      return new FileLogger(options?.filename || 'app.log');\n    default:\n      const _exhaustive: never = type;\n      throw new Error(`Unknown logger type: ${_exhaustive}`);\n  }\n}\n\nconst logger = createLogger('console');\nconst fileLogger = createLogger('file', { filename: 'errors.log' });\n\n// Generic factory\nclass Factory<T> {\n  private creators = new Map<string, () => T>();\n  \n  register(name: string, creator: () => T): void {\n    this.creators.set(name, creator);\n  }\n  \n  create(name: string): T {\n    const creator = this.creators.get(name);\n    if (!creator) {\n      throw new Error(`Unknown type: ${name}`);\n    }\n    return creator();\n  }\n}\n\n// Usage\ninterface IDatabase {\n  connect(): void;\n}\n\nclass MySQLDatabase implements IDatabase {\n  connect(): void { console.log('MySQL connected'); }\n}\n\nclass PostgresDatabase implements IDatabase {\n  connect(): void { console.log('Postgres connected'); }\n}\n\nconst dbFactory = new Factory<IDatabase>();\ndbFactory.register('mysql', () => new MySQLDatabase());\ndbFactory.register('postgres', () => new PostgresDatabase());\n\nconst db = dbFactory.create('mysql');\ndb.connect();\n\n// Abstract factory\ninterface IButton {\n  render(): void;\n}\n\ninterface IWindow {\n  open(): void;\n}\n\ninterface IUIFactory {\n  createButton(): IButton;\n  createWindow(): IWindow;\n}\n\nclass WindowsFactory implements IUIFactory {\n  createButton(): IButton {\n    return { render() { console.log('Windows button'); } };\n  }\n  \n  createWindow(): IWindow {\n    return { open() { console.log('Windows window'); } };\n  }\n}\n\nclass MacFactory implements IUIFactory {\n  createButton(): IButton {\n    return { render() { console.log('Mac button'); } };\n  }\n  \n  createWindow(): IWindow {\n    return { open() { console.log('Mac window'); } };\n  }\n}"
    },
    {
      "id": 66,
      "question": "What are the differences between unknown and any types?",
      "answer": "While both unknown and any represent values of uncertain types, they differ significantly in type safety.\n\nany Type:\n• Disables type checking\n• Can do anything with value\n• No compiler errors\n• Unsafe but flexible\n• Can assign to any type\n• Methods always available\n\nunknown Type:\n• Type-safe alternative\n• Requires type checking before use\n• Compiler enforces checks\n• Cannot assign to other types directly\n• No operations without narrowing\n• Prefer over any\n\nWhen to Use:\n• Use unknown for type-unsafe values\n• Use any only when absolutely necessary\n• unknown for user input\n• unknown for API responses\n• any for migration or extreme flexibility\n\nType Narrowing Required:\n• typeof checks\n• instanceof checks\n• Type predicates\n• Type assertions after validation\n\nBest Practices:\n• Prefer unknown over any\n• Always narrow before use\n• Use type guards\n• Validate unknown values\n• Document why any is used",
      "explanation": "Unknown is a type-safe alternative to any that requires type checking before use, while any completely disables type checking and allows any operation.",
      "difficulty": "Medium",
      "code": "// any - no type safety\nlet anyValue: any = 'hello';\nanyValue.toUpperCase(); // OK\nanyValue.toFixed(2); // OK (compiles but fails at runtime)\nanyValue.nonExistent(); // OK (compiles but fails at runtime)\nlet num: number = anyValue; // OK\n\n// unknown - type-safe\nlet unknownValue: unknown = 'hello';\n// unknownValue.toUpperCase(); // Error: Object is of type 'unknown'\n// let num2: number = unknownValue; // Error: Type 'unknown' not assignable\n\n// Must narrow unknown before use\nif (typeof unknownValue === 'string') {\n  console.log(unknownValue.toUpperCase()); // OK\n}\n\n// Type guard with unknown\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\nif (isString(unknownValue)) {\n  console.log(unknownValue.length); // OK\n}\n\n// API response handling\nasync function fetchData(url: string): Promise<unknown> {\n  const response = await fetch(url);\n  return response.json(); // Returns unknown\n}\n\nconst data = await fetchData('/api/users');\n\n// Must validate before use\nif (typeof data === 'object' && data !== null && 'users' in data) {\n  const users = (data as { users: any[] }).users;\n  console.log(users);\n}\n\n// Type assertion after validation\nfunction parseJSON(json: string): unknown {\n  return JSON.parse(json);\n}\n\nconst result = parseJSON('{\"name\": \"John\"}');\n\nif (isValidUser(result)) {\n  const user: User = result; // Safe after validation\n}\n\n// Function parameters\nfunction processAny(value: any) {\n  // Can do anything - unsafe\n  value.toString();\n  value.doSomething();\n}\n\nfunction processUnknown(value: unknown) {\n  // Must check first - safe\n  if (typeof value === 'number') {\n    console.log(value.toFixed(2));\n  } else if (typeof value === 'string') {\n    console.log(value.toUpperCase());\n  }\n}\n\n// Comparison\nlet x: any = 5;\nx.toUpperCase(); // Compiles but runtime error\n\nlet y: unknown = 5;\n// y.toUpperCase(); // Compile error (good!)\nif (typeof y === 'string') {\n  y.toUpperCase(); // OK\n}"
    },
    {
      "id": 67,
      "question": "How do you implement singleton pattern in TypeScript?",
      "answer": "The singleton pattern ensures a class has only one instance, implementable in TypeScript with private constructors.\n\nImplementation Approaches:\n• Private constructor\n• Static instance property\n• Static getInstance method\n• Lazy initialization\n• Eager initialization\n\nTypeScript Features:\n• Private constructor modifier\n• Static members\n• Type safety\n• Access control\n• Module singleton\n\nThreading Considerations:\n• JavaScript is single-threaded\n• No race conditions in browser\n• Node.js considerations\n• Module caching helps\n\nModern Alternatives:\n• ES6 modules (natural singletons)\n• Dependency injection\n• Service containers\n• Context providers\n\nBest Practices:\n• Use modules for simpler cases\n• Lazy initialization when needed\n• Make constructor private\n• Ensure thread safety if needed\n• Consider testability\n• Document singleton behavior",
      "explanation": "The singleton pattern uses a private constructor and static getInstance method to ensure only one instance exists, with TypeScript providing type-safe implementation.",
      "difficulty": "Medium",
      "code": "// Classic singleton\nclass Singleton {\n  private static instance: Singleton;\n  private constructor() {\n    // Private constructor prevents instantiation\n  }\n  \n  static getInstance(): Singleton {\n    if (!Singleton.instance) {\n      Singleton.instance = new Singleton();\n    }\n    return Singleton.instance;\n  }\n  \n  public someMethod(): void {\n    console.log('Singleton method');\n  }\n}\n\n// Usage\nconst instance1 = Singleton.getInstance();\nconst instance2 = Singleton.getInstance();\nconsole.log(instance1 === instance2); // true\n\n// Cannot instantiate directly\n// const instance = new Singleton(); // Error: constructor is private\n\n// Practical example - Database connection\nclass DatabaseConnection {\n  private static instance: DatabaseConnection;\n  private connected: boolean = false;\n  \n  private constructor() {}\n  \n  static getInstance(): DatabaseConnection {\n    if (!DatabaseConnection.instance) {\n      DatabaseConnection.instance = new DatabaseConnection();\n    }\n    return DatabaseConnection.instance;\n  }\n  \n  connect(): void {\n    if (!this.connected) {\n      console.log('Connecting to database...');\n      this.connected = true;\n    }\n  }\n  \n  query(sql: string): any[] {\n    if (!this.connected) {\n      throw new Error('Not connected');\n    }\n    console.log(`Executing: ${sql}`);\n    return [];\n  }\n}\n\nconst db1 = DatabaseConnection.getInstance();\nconst db2 = DatabaseConnection.getInstance();\ndb1.connect();\ndb2.query('SELECT * FROM users'); // Uses same connection\n\n// Module-based singleton (simpler)\n// logger.ts\nclass Logger {\n  log(message: string): void {\n    console.log(`[LOG] ${message}`);\n  }\n}\n\nexport const logger = new Logger();\n// Module caching ensures single instance\n\n// Usage\nimport { logger } from './logger';\nlogger.log('Hello');\n\n// Generic singleton\nclass SingletonBase {\n  private static instances = new Map<any, any>();\n  \n  protected constructor() {}\n  \n  static getInstance<T extends SingletonBase>(this: new () => T): T {\n    if (!SingletonBase.instances.has(this)) {\n      SingletonBase.instances.set(this, new this());\n    }\n    return SingletonBase.instances.get(this);\n  }\n}\n\nclass ConfigManager extends SingletonBase {\n  private config: Record<string, any> = {};\n  \n  setConfig(key: string, value: any): void {\n    this.config[key] = value;\n  }\n  \n  getConfig(key: string): any {\n    return this.config[key];\n  }\n}\n\nconst config = ConfigManager.getInstance();"
    },
    {
      "id": 68,
      "question": "What are numeric enums vs string enums?",
      "answer": "TypeScript supports both numeric and string enums with different characteristics and use cases.\n\nNumeric Enums:\n• Default enum type\n• Auto-incrementing values\n• Reverse mapping available\n• Compact runtime code\n• Can be bit flags\n\nString Enums:\n• Explicit string values\n• No reverse mapping\n• More readable at runtime\n• Better debugging\n• No auto-increment\n\nReverse Mapping:\n• Numeric enums support\n• Get name from value\n• String enums don't have it\n• Additional runtime cost\n\nUse Cases:\n• Numeric for bit flags\n• String for status codes\n• Numeric for internal state\n• String for API values\n• String for serialization\n\nBest Practices:\n• Use string enums for external APIs\n• Use numeric for performance\n• Consider const enums\n• Use union types as alternative\n• Document enum purpose",
      "explanation": "Numeric enums have auto-incrementing numeric values with reverse mapping, while string enums require explicit string values without reverse mapping but better debugging.",
      "difficulty": "Easy",
      "code": "// Numeric enum\nenum Direction {\n  Up,    // 0\n  Down,  // 1\n  Left,  // 2\n  Right  // 3\n}\n\nconst dir: Direction = Direction.Up;\nconsole.log(dir); // 0\nconsole.log(Direction[0]); // 'Up' (reverse mapping)\n\n// Custom numeric values\nenum FileAccess {\n  None = 0,\n  Read = 1,\n  Write = 2,\n  ReadWrite = Read | Write  // 3 (bitwise OR)\n}\n\n// String enum\nenum Status {\n  Pending = 'PENDING',\n  Approved = 'APPROVED',\n  Rejected = 'REJECTED'\n}\n\nconst status: Status = Status.Pending;\nconsole.log(status); // 'PENDING'\n// console.log(Status['PENDING']); // undefined (no reverse mapping)\n\n// Mixed enum (not recommended)\nenum Mixed {\n  No = 0,\n  Yes = 'YES'\n}\n\n// Const enum (inlined)\nconst enum Color {\n  Red = 'RED',\n  Green = 'GREEN',\n  Blue = 'BLUE'\n}\n\nconst color = Color.Red;\n// Compiles to: const color = 'RED';\n\n// Bit flags with numeric enum\nenum Permissions {\n  None = 0,\n  Read = 1 << 0,    // 1\n  Write = 1 << 1,   // 2\n  Execute = 1 << 2  // 4\n}\n\nlet userPerms = Permissions.Read | Permissions.Write;\nconsole.log(userPerms); // 3\n\nif (userPerms & Permissions.Read) {\n  console.log('Has read permission');\n}\n\n// Alternative: union of string literals\ntype StatusType = 'pending' | 'approved' | 'rejected';\n// Better tree-shaking, no runtime code\n\nconst myStatus: StatusType = 'pending';\n\n// Comparison of runtime code\n// Numeric enum generates:\n// var Direction;\n// (function (Direction) {\n//   Direction[Direction['Up'] = 0] = 'Up';\n//   Direction[Direction['Down'] = 1] = 'Down';\n// })(Direction || (Direction = {}));\n\n// String enum generates:\n// var Status;\n// (function (Status) {\n//   Status['Pending'] = 'PENDING';\n//   Status['Approved'] = 'APPROVED';\n// })(Status || (Status = {}));\n\n// String literal union generates:\n// Nothing! (compile-time only)"
    },
    {
      "id": 69,
      "question": "How do you handle optional chaining and nullish coalescing?",
      "answer": "Optional chaining and nullish coalescing are operators for safe navigation and default values.\n\nOptional Chaining (?.):\n• Safely access nested properties\n• Short-circuits on null/undefined\n• Returns undefined if chain breaks\n• Works with properties, methods, arrays\n• Prevents runtime errors\n\nNullish Coalescing (??):\n• Provides default for null/undefined\n• Different from || operator\n• Only triggers on nullish values\n• Doesn't trigger on 0, '', false\n• More precise than logical OR\n\nCombining Both:\n• Safe access with defaults\n• Clean, readable code\n• Reduces conditional logic\n• Type-safe operations\n\nDifference from ||:\n• || triggers on falsy values\n• ?? only on null/undefined\n• ?? preserves 0, '', false\n• ?? more semantically correct\n\nBest Practices:\n• Use ?. for uncertain paths\n• Use ?? for default values\n• Combine for safe defaults\n• Prefer over manual checks\n• Consider strictNullChecks",
      "explanation": "Optional chaining safely accesses nested properties that may be null/undefined, while nullish coalescing provides defaults only for null/undefined, not all falsy values.",
      "difficulty": "Easy",
      "code": "// Optional chaining\ninterface User {\n  name: string;\n  address?: {\n    street?: string;\n    city?: string;\n  };\n}\n\nconst user: User = { name: 'John' };\n\n// Without optional chaining\nconst city1 = user.address && user.address.city;\n\n// With optional chaining\nconst city2 = user.address?.city; // undefined\n\n// Method calls\nconst result = user.getProfile?.(); // Call if method exists\n\n// Array access\nconst arr: number[] | undefined = [1, 2, 3];\nconst first = arr?.[0]; // Safe array access\n\n// Nullish coalescing\nconst displayName = user.name ?? 'Anonymous';\n\n// Difference from ||\nconst value1 = 0;\nconst result1 = value1 || 100; // 100 (0 is falsy)\nconst result2 = value1 ?? 100; // 0 (0 is not nullish)\n\nconst value2 = '';\nconst result3 = value2 || 'default'; // 'default' ('' is falsy)\nconst result4 = value2 ?? 'default'; // '' ('' is not nullish)\n\nconst value3 = null;\nconst result5 = value3 || 'default'; // 'default'\nconst result6 = value3 ?? 'default'; // 'default'\n\n// Combining both\nconst port = config.server?.port ?? 3000;\nconst timeout = settings?.timeout ?? 30000;\n\n// Complex example\ninterface Config {\n  database?: {\n    connection?: {\n      host?: string;\n      port?: number;\n    };\n  };\n}\n\nconst config: Config = {};\n\n// Deeply nested with defaults\nconst host = config.database?.connection?.host ?? 'localhost';\nconst port2 = config.database?.connection?.port ?? 5432;\n\n// Function call with optional chaining\ninterface API {\n  fetchUser?(): Promise<User>;\n}\n\nconst api: API = {};\nconst userData = await api.fetchUser?.(); // undefined if method missing\n\n// Array methods\nconst users: User[] | null = null;\nconst count = users?.length ?? 0;\nconst names = users?.map(u => u.name) ?? [];\n\n// Type narrowing\nfunction process(value: string | null | undefined) {\n  const result = value ?? 'default';\n  // result is type: string (null/undefined replaced)\n}"
    },
    {
      "id": 70,
      "question": "What are project references in TypeScript?",
      "answer": "Project references allow organizing large codebases into smaller projects with dependencies between them.\n\nKey Features:\n• Split monorepo into projects\n• Define project dependencies\n• Incremental builds\n• Better build performance\n• Parallel compilation\n• Enforce module boundaries\n\nConfiguration:\n• composite: true in tsconfig.json\n• references array for dependencies\n• Separate tsconfig per project\n• Declaration files required\n• outDir for output location\n\nBenefits:\n• Faster incremental builds\n• Clear project structure\n• Better IDE performance\n• Enforce dependencies\n• Selective rebuilds\n• Parallel compilation\n\nBuild Commands:\n• tsc --build (or tsc -b)\n• Build with dependencies\n• Incremental by default\n• Clean with --clean\n• Dry run with --dry\n\nUse Cases:\n• Monorepo organization\n• Shared libraries\n• Multiple applications\n• Large codebases\n• Microservices\n\nBest Practices:\n• One tsconfig per project\n• Enable composite mode\n• Use tsc --build\n• Keep projects focused\n• Document dependencies",
      "explanation": "Project references enable splitting large TypeScript codebases into smaller, interconnected projects with incremental compilation and enforced boundaries.",
      "difficulty": "Hard",
      "code": "// Monorepo structure:\n// /packages\n//   /core\n//     /src\n//     /tsconfig.json\n//   /utils\n//     /src\n//     /tsconfig.json\n//   /app\n//     /src\n//     /tsconfig.json\n// /tsconfig.json (root)\n\n// packages/core/tsconfig.json\n{\n  \"compilerOptions\": {\n    \"composite\": true,\n    \"declaration\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\"\n  },\n  \"include\": [\"src/**/*\"]\n}\n\n// packages/utils/tsconfig.json\n{\n  \"compilerOptions\": {\n    \"composite\": true,\n    \"declaration\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\"\n  },\n  \"include\": [\"src/**/*\"],\n  \"references\": [\n    { \"path\": \"../core\" }\n  ]\n}\n\n// packages/app/tsconfig.json\n{\n  \"compilerOptions\": {\n    \"composite\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\"\n  },\n  \"include\": [\"src/**/*\"],\n  \"references\": [\n    { \"path\": \"../core\" },\n    { \"path\": \"../utils\" }\n  ]\n}\n\n// Root tsconfig.json\n{\n  \"files\": [],\n  \"references\": [\n    { \"path\": \"./packages/core\" },\n    { \"path\": \"./packages/utils\" },\n    { \"path\": \"./packages/app\" }\n  ]\n}\n\n// Build commands\n// Build all projects:\n// tsc --build\n\n// Build specific project with dependencies:\n// tsc --build packages/app\n\n// Clean build outputs:\n// tsc --build --clean\n\n// Dry run:\n// tsc --build --dry\n\n// Force rebuild:\n// tsc --build --force\n\n// Verbose output:\n// tsc --build --verbose\n\n// packages/core/src/index.ts\nexport interface Config {\n  apiUrl: string;\n}\n\n// packages/utils/src/index.ts\nimport { Config } from '@monorepo/core';\n\nexport function getApiUrl(config: Config): string {\n  return config.apiUrl;\n}\n\n// packages/app/src/index.ts\nimport { Config } from '@monorepo/core';\nimport { getApiUrl } from '@monorepo/utils';\n\nconst config: Config = { apiUrl: 'https://api.example.com' };\nconst url = getApiUrl(config);\n\n// package.json scripts\n{\n  \"scripts\": {\n    \"build\": \"tsc --build\",\n    \"clean\": \"tsc --build --clean\",\n    \"watch\": \"tsc --build --watch\"\n  }\n}"
    },
    {
      "id": 71,
      "question": "How do you implement observer pattern in TypeScript?",
      "answer": "The observer pattern implements a subscription mechanism with type-safe notifications in TypeScript.\n\nKey Components:\n• Subject (observable)\n• Observers (subscribers)\n• Subscribe/unsubscribe methods\n• Notification mechanism\n• Type-safe events\n\nImplementation Approaches:\n• Class-based observers\n• Function-based callbacks\n• Generic event emitters\n• RxJS observables\n• Custom implementations\n\nType Safety:\n• Generic event types\n• Type-safe subscriptions\n• Typed event data\n• IntelliSense support\n• Compile-time validation\n\nBenefits:\n• Loose coupling\n• Multiple observers\n• Dynamic subscriptions\n• Event-driven architecture\n• Separation of concerns\n\nBest Practices:\n• Unsubscribe to prevent leaks\n• Type event payloads\n• Handle errors in observers\n• Document events\n• Consider RxJS for complex cases",
      "explanation": "The observer pattern enables type-safe subscription and notification mechanisms where subjects notify multiple observers of state changes.",
      "difficulty": "Hard",
      "code": "// Basic observer interface\ninterface Observer<T> {\n  update(data: T): void;\n}\n\n// Subject (Observable)\nclass Subject<T> {\n  private observers: Observer<T>[] = [];\n  \n  subscribe(observer: Observer<T>): () => void {\n    this.observers.push(observer);\n    // Return unsubscribe function\n    return () => {\n      const index = this.observers.indexOf(observer);\n      if (index > -1) {\n        this.observers.splice(index, 1);\n      }\n    };\n  }\n  \n  notify(data: T): void {\n    this.observers.forEach(observer => observer.update(data));\n  }\n}\n\n// Example: Stock price observer\ninterface StockData {\n  symbol: string;\n  price: number;\n  timestamp: Date;\n}\n\nclass Stock extends Subject<StockData> {\n  constructor(private symbol: string, private price: number) {\n    super();\n  }\n  \n  setPrice(newPrice: number): void {\n    this.price = newPrice;\n    this.notify({\n      symbol: this.symbol,\n      price: newPrice,\n      timestamp: new Date()\n    });\n  }\n}\n\nclass StockDisplay implements Observer<StockData> {\n  update(data: StockData): void {\n    console.log(`${data.symbol}: $${data.price} at ${data.timestamp}`);\n  }\n}\n\nclass StockLogger implements Observer<StockData> {\n  update(data: StockData): void {\n    console.log(`[LOG] Price change: ${data.symbol} = ${data.price}`);\n  }\n}\n\n// Usage\nconst apple = new Stock('AAPL', 150);\nconst display = new StockDisplay();\nconst logger = new StockLogger();\n\nconst unsubDisplay = apple.subscribe(display);\napple.subscribe(logger);\n\napple.setPrice(155); // Both observers notified\nunsubDisplay(); // Unsubscribe display\napple.setPrice(160); // Only logger notified\n\n// Generic Event Emitter\ntype EventHandler<T = any> = (data: T) => void;\n\nclass EventEmitter<Events extends Record<string, any>> {\n  private handlers: {\n    [K in keyof Events]?: EventHandler<Events[K]>[];\n  } = {};\n  \n  on<K extends keyof Events>(event: K, handler: EventHandler<Events[K]>): void {\n    if (!this.handlers[event]) {\n      this.handlers[event] = [];\n    }\n    this.handlers[event]!.push(handler);\n  }\n  \n  off<K extends keyof Events>(event: K, handler: EventHandler<Events[K]>): void {\n    const handlers = this.handlers[event];\n    if (handlers) {\n      const index = handlers.indexOf(handler);\n      if (index > -1) {\n        handlers.splice(index, 1);\n      }\n    }\n  }\n  \n  emit<K extends keyof Events>(event: K, data: Events[K]): void {\n    const handlers = this.handlers[event];\n    if (handlers) {\n      handlers.forEach(handler => handler(data));\n    }\n  }\n}\n\n// Usage with typed events\ninterface AppEvents {\n  userLogin: { userId: number; name: string };\n  userLogout: { userId: number };\n  dataUpdate: { id: string; value: any };\n}\n\nconst emitter = new EventEmitter<AppEvents>();\n\nemitter.on('userLogin', (data) => {\n  // data is typed as { userId: number; name: string }\n  console.log(`User ${data.name} logged in`);\n});\n\nemitter.emit('userLogin', { userId: 1, name: 'John' });"
    },
    {
      "id": 72,
      "question": "What are mixins in TypeScript and how do you implement them?",
      "answer": "Mixins enable composing functionality from multiple sources into a single class using TypeScript's type system.\n\nMixin Concepts:\n• Compose behavior from multiple sources\n• Alternative to multiple inheritance\n• Class expression pattern\n• Type-safe composition\n• Reusable functionality\n\nImplementation Patterns:\n• Function that extends base class\n• Generic constructor types\n• Intersection types\n• Interface merging\n• Helper functions\n\nType Safety:\n• Proper type inference\n• Generic constraints\n• Type intersection\n• Constructor types\n• Method type checking\n\nUse Cases:\n• Sharing functionality\n• Cross-cutting concerns\n• Composition over inheritance\n• Plugin systems\n• Trait-like behavior\n\nLimitations:\n• More complex than inheritance\n• Can't access private members\n• Type complexity\n• IDE support varies\n\nBest Practices:\n• Keep mixins focused\n• Document mixin contracts\n• Use for composition\n• Consider alternatives\n• Test thoroughly",
      "explanation": "Mixins enable composing classes from reusable pieces by combining functionality through functions that extend base classes with proper TypeScript typing.",
      "difficulty": "Hard",
      "code": "// Mixin constructor type\ntype Constructor<T = {}> = new (...args: any[]) => T;\n\n// Mixin function\nfunction Timestamped<T extends Constructor>(Base: T) {\n  return class extends Base {\n    timestamp = new Date();\n    \n    getTimestamp() {\n      return this.timestamp;\n    }\n  };\n}\n\n// Another mixin\nfunction Activatable<T extends Constructor>(Base: T) {\n  return class extends Base {\n    isActive = false;\n    \n    activate() {\n      this.isActive = true;\n    }\n    \n    deactivate() {\n      this.isActive = false;\n    }\n  };\n}\n\n// Base class\nclass User {\n  constructor(public name: string) {}\n}\n\n// Compose with mixins\nconst TimestampedUser = Timestamped(User);\nconst ActiveUser = Activatable(TimestampedUser);\n\nconst user = new ActiveUser('John');\nconsole.log(user.name); // From User\nconsole.log(user.getTimestamp()); // From Timestamped\nuser.activate(); // From Activatable\n\n// Helper function for applying mixins\nfunction applyMixins(derivedCtor: any, constructors: any[]) {\n  constructors.forEach((baseCtor) => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {\n      Object.defineProperty(\n        derivedCtor.prototype,\n        name,\n        Object.getOwnPropertyDescriptor(baseCtor.prototype, name) ||\n        Object.create(null)\n      );\n    });\n  });\n}\n\n// Interface-based mixins\nclass Disposable {\n  isDisposed: boolean = false;\n  dispose() {\n    this.isDisposed = true;\n  }\n}\n\nclass Printable {\n  print() {\n    console.log('Printing...');\n  }\n}\n\n// Class that will use mixins\nclass Document implements Disposable, Printable {\n  // Placeholder properties\n  isDisposed: boolean = false;\n  dispose!: () => void;\n  print!: () => void;\n  \n  constructor(public content: string) {}\n}\n\napplyMixins(Document, [Disposable, Printable]);\n\nconst doc = new Document('Hello World');\ndoc.print(); // Works\ndoc.dispose(); // Works\n\n// Generic mixin with constraints\nfunction Serializable<T extends Constructor<{ toString(): string }>>(\n  Base: T\n) {\n  return class extends Base {\n    serialize(): string {\n      return JSON.stringify(this.toString());\n    }\n  };\n}\n\n// Mixin with additional properties\nfunction Taggable<T extends Constructor>(Base: T) {\n  return class extends Base {\n    private tags: string[] = [];\n    \n    addTag(tag: string) {\n      this.tags.push(tag);\n    }\n    \n    getTags(): string[] {\n      return [...this.tags];\n    }\n    \n    hasTag(tag: string): boolean {\n      return this.tags.includes(tag);\n    }\n  };\n}\n\nclass Article {\n  constructor(public title: string) {}\n}\n\nconst TaggableArticle = Taggable(Article);\nconst article = new TaggableArticle('TypeScript Tips');\narticle.addTag('typescript');\narticle.addTag('programming');\nconsole.log(article.getTags()); // ['typescript', 'programming']"
    },
    {
      "id": 73,
      "question": "How do you handle async/await with TypeScript?",
      "answer": "TypeScript provides full type support for async/await with proper Promise typing and error handling.\n\nAsync Functions:\n• Return Promise<T> automatically\n• Can await Promise values\n• Try-catch for error handling\n• Type inference works\n• Generic promise types\n\nType Safety:\n• Promise return types\n• Awaited values typed\n• Error typing\n• Type guards in async\n• Generic async functions\n\nError Handling:\n• Try-catch blocks\n• Typed error handling\n• Result type patterns\n• Error boundaries\n• Promise rejection\n\nAsync Patterns:\n• Parallel execution\n• Sequential execution\n• Error propagation\n• Timeout handling\n• Retry logic\n\nBest Practices:\n• Always handle errors\n• Type async functions\n• Use try-catch\n• Consider Result types\n• Handle promise rejections\n• Use Promise.all for parallel",
      "explanation": "TypeScript provides type-safe async/await with proper Promise typing, automatic return type inference, and comprehensive error handling support.",
      "difficulty": "Medium",
      "code": "// Basic async function\nasync function fetchUser(id: number): Promise<User> {\n  const response = await fetch(`/api/users/${id}`);\n  if (!response.ok) {\n    throw new Error('User not found');\n  }\n  return response.json();\n}\n\n// Type inference\nconst user = await fetchUser(1); // Type: User\n\n// Error handling\nasync function safeF fetchUser(id: number): Promise<User | null> {\n  try {\n    const response = await fetch(`/api/users/${id}`);\n    if (!response.ok) {\n      return null;\n    }\n    return await response.json();\n  } catch (error) {\n    console.error('Failed to fetch user:', error);\n    return null;\n  }\n}\n\n// Result type pattern\ntype Result<T, E = Error> = \n  | { success: true; data: T }\n  | { success: false; error: E };\n\nasync function fetchUserSafe(id: number): Promise<Result<User, string>> {\n  try {\n    const response = await fetch(`/api/users/${id}`);\n    if (!response.ok) {\n      return { success: false, error: 'User not found' };\n    }\n    const data = await response.json();\n    return { success: true, data };\n  } catch (error) {\n    return { success: false, error: 'Network error' };\n  }\n}\n\nconst result = await fetchUserSafe(1);\nif (result.success) {\n  console.log(result.data); // Type: User\n} else {\n  console.error(result.error); // Type: string\n}\n\n// Generic async function\nasync function fetchData<T>(url: string): Promise<T> {\n  const response = await fetch(url);\n  return response.json() as Promise<T>;\n}\n\ninterface Post {\n  id: number;\n  title: string;\n}\n\nconst posts = await fetchData<Post[]>('/api/posts');\n\n// Parallel execution\nasync function fetchMultiple() {\n  const [users, posts, comments] = await Promise.all([\n    fetchData<User[]>('/api/users'),\n    fetchData<Post[]>('/api/posts'),\n    fetchData<Comment[]>('/api/comments')\n  ]);\n  \n  return { users, posts, comments };\n}\n\n// Sequential with dependencies\nasync function createUserWithProfile(name: string) {\n  const user = await createUser(name);\n  const profile = await createProfile(user.id);\n  return { user, profile };\n}\n\n// Timeout helper\nfunction timeout<T>(promise: Promise<T>, ms: number): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) =>\n      setTimeout(() => reject(new Error('Timeout')), ms)\n    )\n  ]);\n}\n\nconst data = await timeout(fetchUser(1), 5000);\n\n// Retry logic\nasync function retry<T>(\n  fn: () => Promise<T>,\n  maxRetries: number = 3\n): Promise<T> {\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      return await fn();\n    } catch (error) {\n      if (i === maxRetries - 1) throw error;\n      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));\n    }\n  }\n  throw new Error('Max retries exceeded');\n}\n\nconst userData = await retry(() => fetchUser(1));"
    },
    {
      "id": 74,
      "question": "What are ambient declarations in TypeScript?",
      "answer": "Ambient declarations describe the shape of existing JavaScript code without providing implementation.\n\nPurpose:\n• Declare types for JS code\n• No implementation code\n• Tell TypeScript what exists\n• Used in .d.ts files\n• Global or module scope\n\nDeclare Keyword:\n• declare variable/function\n• declare class/interface\n• declare module\n• declare namespace\n• declare global\n\nUse Cases:\n• Third-party libraries\n• Global variables\n• Browser APIs\n• Node.js modules\n• Environment variables\n• Build tool injected values\n\nDeclaration Files:\n• .d.ts extension\n• Type definitions only\n• No runtime code\n• Distributed with packages\n• @types packages\n\nBest Practices:\n• Match actual implementation\n• Keep declarations updated\n• Use DefinitelyTyped when possible\n• Document assumptions\n• Test type definitions\n• Version with code",
      "explanation": "Ambient declarations use the declare keyword to describe existing JavaScript code types without implementation, enabling TypeScript to type-check external code.",
      "difficulty": "Medium",
      "code": "// Declare global variables\ndeclare const API_KEY: string;\ndeclare const VERSION: number;\n\n// Usage\nconsole.log(API_KEY); // TypeScript knows it exists\n\n// Declare global functions\ndeclare function gtag(command: string, ...args: any[]): void;\n\n// Usage\ngtag('event', 'page_view');\n\n// Declare global classes\ndeclare class Analytics {\n  constructor(apiKey: string);\n  track(event: string, properties?: Record<string, any>): void;\n  identify(userId: string, traits?: Record<string, any>): void;\n}\n\nconst analytics = new Analytics('key');\n\n// Declare module\ndeclare module 'legacy-library' {\n  export function doSomething(x: number): string;\n  export class Helper {\n    constructor(name: string);\n    process(): void;\n  }\n  export interface Options {\n    timeout: number;\n    retries: number;\n  }\n}\n\n// Usage\nimport { doSomething, Helper } from 'legacy-library';\nconst result = doSomething(42);\n\n// Declare namespace\ndeclare namespace jQuery {\n  function ajax(settings: any): any;\n  \n  interface jQueryStatic {\n    (selector: string): any;\n  }\n}\n\n// Usage\njQuery.ajax({ url: '/api' });\n\n// Declare global augmentation\ndeclare global {\n  interface Window {\n    myApp: {\n      config: Record<string, unknown>;\n      init(): void;\n    };\n  }\n  \n  namespace NodeJS {\n    interface ProcessEnv {\n      DATABASE_URL: string;\n      PORT: string;\n      NODE_ENV: 'development' | 'production';\n    }\n  }\n}\n\n// Usage\nwindow.myApp.init();\nconsole.log(process.env.DATABASE_URL);\n\n// Wildcard module declaration\ndeclare module '*.css' {\n  const content: { [className: string]: string };\n  export default content;\n}\n\ndeclare module '*.png' {\n  const value: string;\n  export default value;\n}\n\n// Usage\nimport styles from './App.css';\nimport logo from './logo.png';\n\n// Declaration file example: types.d.ts\ndeclare module 'my-library' {\n  export interface Config {\n    host: string;\n    port: number;\n  }\n  \n  export function connect(config: Config): Promise<Connection>;\n  \n  export class Connection {\n    query(sql: string): Promise<any[]>;\n    close(): Promise<void>;\n  }\n}\n\n// UMD global library\nexport as namespace MyLib;\n\nexport function init(config: any): void;\nexport class Client {\n  constructor(apiKey: string);\n}"
    },
    {
      "id": 75,
      "question": "How do you implement strategy pattern in TypeScript?",
      "answer": "The strategy pattern encapsulates algorithms in separate classes with a common interface for interchangeable behavior.\n\nKey Components:\n• Strategy interface\n• Concrete strategies\n• Context class\n• Runtime selection\n• Type-safe switching\n\nImplementation Approaches:\n• Interface-based strategies\n• Function-based strategies\n• Class-based strategies\n• Generic strategies\n• Factory for creation\n\nType Safety:\n• Common interface\n• Type-checked strategies\n• Generic contexts\n• Compile-time validation\n• IntelliSense support\n\nBenefits:\n• Open/closed principle\n• Runtime algorithm selection\n• Easy to test\n• Reduces conditionals\n• Flexible behavior\n\nUse Cases:\n• Sorting algorithms\n• Validation strategies\n• Payment methods\n• Compression algorithms\n• Routing strategies\n\nBest Practices:\n• Define clear interface\n• Keep strategies focused\n• Use dependency injection\n• Consider function strategies\n• Document strategy purpose",
      "explanation": "The strategy pattern defines a family of interchangeable algorithms through a common interface, enabling runtime selection with TypeScript type safety.",
      "difficulty": "Hard",
      "code": "// Strategy interface\ninterface PaymentStrategy {\n  pay(amount: number): void;\n  validate(): boolean;\n}\n\n// Concrete strategies\nclass CreditCardPayment implements PaymentStrategy {\n  constructor(\n    private cardNumber: string,\n    private cvv: string\n  ) {}\n  \n  validate(): boolean {\n    return this.cardNumber.length === 16 && this.cvv.length === 3;\n  }\n  \n  pay(amount: number): void {\n    if (!this.validate()) {\n      throw new Error('Invalid credit card');\n    }\n    console.log(`Paid $${amount} with credit card`);\n  }\n}\n\nclass PayPalPayment implements PaymentStrategy {\n  constructor(private email: string) {}\n  \n  validate(): boolean {\n    return this.email.includes('@');\n  }\n  \n  pay(amount: number): void {\n    if (!this.validate()) {\n      throw new Error('Invalid email');\n    }\n    console.log(`Paid $${amount} with PayPal`);\n  }\n}\n\nclass CryptoPayment implements PaymentStrategy {\n  constructor(private walletAddress: string) {}\n  \n  validate(): boolean {\n    return this.walletAddress.startsWith('0x');\n  }\n  \n  pay(amount: number): void {\n    if (!this.validate()) {\n      throw new Error('Invalid wallet');\n    }\n    console.log(`Paid $${amount} with crypto`);\n  }\n}\n\n// Context\nclass PaymentProcessor {\n  constructor(private strategy: PaymentStrategy) {}\n  \n  setStrategy(strategy: PaymentStrategy): void {\n    this.strategy = strategy;\n  }\n  \n  processPayment(amount: number): void {\n    if (this.strategy.validate()) {\n      this.strategy.pay(amount);\n    } else {\n      throw new Error('Invalid payment method');\n    }\n  }\n}\n\n// Usage\nconst processor = new PaymentProcessor(\n  new CreditCardPayment('1234567890123456', '123')\n);\nprocessor.processPayment(100);\n\nprocessor.setStrategy(new PayPalPayment('user@example.com'));\nprocessor.processPayment(50);\n\n// Function-based strategy pattern\ntype SortStrategy<T> = (a: T, b: T) => number;\n\nclass Sorter<T> {\n  constructor(private strategy: SortStrategy<T>) {}\n  \n  setStrategy(strategy: SortStrategy<T>): void {\n    this.strategy = strategy;\n  }\n  \n  sort(items: T[]): T[] {\n    return [...items].sort(this.strategy);\n  }\n}\n\n// Usage with functions\nconst numberSorter = new Sorter<number>((a, b) => a - b);\nconst numbers = [3, 1, 4, 1, 5, 9];\nconsole.log(numberSorter.sort(numbers));\n\nnumberSorter.setStrategy((a, b) => b - a); // Descending\nconsole.log(numberSorter.sort(numbers));\n\n// Generic strategy\ninterface CompressionStrategy<T> {\n  compress(data: T): string;\n  decompress(compressed: string): T;\n}\n\nclass GzipCompression implements CompressionStrategy<string> {\n  compress(data: string): string {\n    // Gzip implementation\n    return `gzipped:${data}`;\n  }\n  \n  decompress(compressed: string): string {\n    return compressed.replace('gzipped:', '');\n  }\n}\n\nclass Compressor<T> {\n  constructor(private strategy: CompressionStrategy<T>) {}\n  \n  compress(data: T): string {\n    return this.strategy.compress(data);\n  }\n  \n  decompress(compressed: string): T {\n    return this.strategy.decompress(compressed);\n  }\n}"
    },
    {
      "id": 76,
      "question": "What are advanced conditional types and distributive conditional types?",
      "answer": "Advanced conditional types enable complex type transformations using conditional logic and distribution over unions.\n\nDistributive Behavior:\n• Distributes over union types\n• Applies to naked type parameters\n• Creates union of results\n• Can be disabled with brackets\n• Powerful for type manipulation\n\nAdvanced Patterns:\n• Nested conditionals\n• Multiple infer clauses\n• Recursive conditional types\n• Type filtering\n• Type transformations\n\nNon-Distributive:\n• Wrap type parameter in tuple/array\n• [T] extends [U] pattern\n• Prevents distribution\n• Treats union as single type\n\nPractical Applications:\n• Filtering union types\n• Extracting types\n• Type predicates\n• Recursive type operations\n• Complex transformations\n\nPerformance:\n• Can be expensive\n• Limit recursion depth\n• Cache when possible\n• Keep conditions simple\n• Test thoroughly",
      "explanation": "Distributive conditional types automatically distribute over union types when checking naked type parameters, enabling powerful type transformations and filtering.",
      "difficulty": "Hard",
      "code": "// Distributive conditional type\ntype ToArray<T> = T extends any ? T[] : never;\n\n// Distributes over union\ntype Result1 = ToArray<string | number>;\n// string[] | number[] (distributed)\n\n// Non-distributive (wrapped)\ntype ToArrayNonDist<T> = [T] extends [any] ? T[] : never;\n\ntype Result2 = ToArrayNonDist<string | number>;\n// (string | number)[] (not distributed)\n\n// Filtering with distributive types\ntype NonNullable<T> = T extends null | undefined ? never : T;\n\ntype Result3 = NonNullable<string | null | number | undefined>;\n// string | number\n\n// Extract specific types from union\ntype ExtractStrings<T> = T extends string ? T : never;\n\ntype StringLiterals = ExtractStrings<'a' | 'b' | 1 | 2 | true>;\n// 'a' | 'b'\n\n// Complex filtering\ntype FunctionPropertyNames<T> = {\n  [K in keyof T]: T[K] extends Function ? K : never;\n}[keyof T];\n\ninterface Example {\n  name: string;\n  age: number;\n  greet(): void;\n  calculate(x: number): number;\n}\n\ntype FuncProps = FunctionPropertyNames<Example>;\n// 'greet' | 'calculate'\n\n// Nested conditionals\ntype TypeName<T> = \n  T extends string ? 'string' :\n  T extends number ? 'number' :\n  T extends boolean ? 'boolean' :\n  T extends undefined ? 'undefined' :\n  T extends Function ? 'function' :\n  'object';\n\ntype T1 = TypeName<string>; // 'string'\ntype T2 = TypeName<string | number>; // 'string' | 'number' (distributed)\n\n// Multiple infer clauses\ntype Unpromisify<T> = T extends Promise<infer R>\n  ? R extends Promise<infer U>\n    ? Unpromisify<U>\n    : R\n  : T;\n\ntype Unwrapped = Unpromisify<Promise<Promise<Promise<string>>>>;\n// string\n\n// Distributive with constraints\ntype BoxedValue<T> = T extends { value: infer V } ? V : T;\n\ntype Test1 = BoxedValue<{ value: number }>; // number\ntype Test2 = BoxedValue<string>; // string\ntype Test3 = BoxedValue<{ value: number } | { value: string }>;\n// number | string (distributed)\n\n// Preventing distribution\ntype IsUnion<T> = [T] extends [never]\n  ? false\n  : T extends T\n  ? [Exclude<T, T>] extends [never]\n    ? false\n    : true\n  : false;\n\ntype Test4 = IsUnion<string | number>; // true\ntype Test5 = IsUnion<string>; // false\n\n// Recursive distributive type\ntype DeepReadonly<T> = T extends object\n  ? T extends Function\n    ? T\n    : { readonly [K in keyof T]: DeepReadonly<T[K]> }\n  : T;\n\ninterface Nested {\n  a: { b: { c: number } };\n  arr: number[];\n}\n\ntype ReadonlyNested = DeepReadonly<Nested>;\n// All properties at all levels readonly"
    },
    {
      "id": 77,
      "question": "How do you work with complex union and intersection type manipulations?",
      "answer": "Complex union and intersection manipulations enable sophisticated type transformations and compositions.\n\nUnion Operations:\n• Combine types with |\n• Extract/Exclude members\n• Discriminated unions\n• Union to intersection\n• Filtering unions\n\nIntersection Operations:\n• Combine types with &\n• Merge properties\n• Conflict resolution\n• Intersection to union\n• Property merging\n\nAdvanced Patterns:\n• Union to intersection conversion\n• Intersection to union conversion\n• Type algebra\n• Distributive operations\n• Recursive transformations\n\nType Algebra:\n• Union is OR operation\n• Intersection is AND operation\n• never as identity for union\n• unknown as identity for intersection\n\nPractical Uses:\n• Combining interfaces\n• Merging configurations\n• Type-safe overloads\n• Complex API types\n• State machines\n\nCaveats:\n• Property conflicts\n• Performance impact\n• Complexity management\n• Error messages\n• Maintenance overhead",
      "explanation": "Complex union and intersection manipulations enable powerful type compositions, transformations, and algebra operations for sophisticated type-level programming.",
      "difficulty": "Hard",
      "code": "// Union to Intersection\ntype UnionToIntersection<U> = \n  (U extends any ? (k: U) => void : never) extends\n  ((k: infer I) => void) ? I : never;\n\ntype Union = { a: string } | { b: number };\ntype Intersection = UnionToIntersection<Union>;\n// { a: string } & { b: number }\n\n// Merge all union members\ntype A = { a: string };\ntype B = { b: number };\ntype C = { c: boolean };\n\ntype Merged = UnionToIntersection<A | B | C>;\n// { a: string } & { b: number } & { c: boolean }\n\n// Extract common properties\ntype CommonKeys<T extends object> = keyof UnionToIntersection<\n  T extends any ? { [K in keyof T]: K } : never\n>[keyof T];\n\ninterface User { id: number; name: string; }\ninterface Admin { id: number; role: string; }\n\ntype Common = CommonKeys<User | Admin>; // 'id'\n\n// Intersection of all values\ntype IntersectValues<T> = T extends Record<string, infer U>\n  ? U extends any\n    ? UnionToIntersection<U>\n    : never\n  : never;\n\ntype Values = {\n  a: { x: string };\n  b: { y: number };\n};\n\ntype Intersected = IntersectValues<Values>;\n// { x: string } & { y: number }\n\n// Distributed conditional with intersection\ntype FilterByValue<T, V> = {\n  [K in keyof T as T[K] extends V ? K : never]: T[K];\n};\n\ninterface Mixed {\n  name: string;\n  age: number;\n  active: boolean;\n  email: string;\n}\n\ntype Strings = FilterByValue<Mixed, string>;\n// { name: string; email: string }\n\n// Deep merge types\ntype DeepMerge<T, U> = {\n  [K in keyof T | keyof U]: K extends keyof T\n    ? K extends keyof U\n      ? T[K] extends object\n        ? U[K] extends object\n          ? DeepMerge<T[K], U[K]>\n          : U[K]\n        : U[K]\n      : T[K]\n    : K extends keyof U\n    ? U[K]\n    : never;\n};\n\ntype Config1 = {\n  server: { host: string; port: number };\n  debug: boolean;\n};\n\ntype Config2 = {\n  server: { ssl: boolean };\n  cache: { enabled: boolean };\n};\n\ntype MergedConfig = DeepMerge<Config1, Config2>;\n// {\n//   server: { host: string; port: number; ssl: boolean };\n//   debug: boolean;\n//   cache: { enabled: boolean };\n// }\n\n// Union of all function parameters\ntype UnionOfParameters<T extends (...args: any[]) => any> =\n  T extends (...args: infer P) => any\n    ? P[number]\n    : never;\n\ntype Fn1 = (a: string, b: number) => void;\ntype Fn2 = (x: boolean, y: string) => void;\n\ntype AllParams = UnionOfParameters<Fn1 | Fn2>;\n// string | number | boolean\n\n// Complex type algebra\ntype OptionalKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? K : never;\n}[keyof T];\n\ntype RequiredKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? never : K;\n}[keyof T];\n\ninterface UserProfile {\n  id: number;\n  name: string;\n  email?: string;\n  phone?: string;\n}\n\ntype Optional = OptionalKeys<UserProfile>; // 'email' | 'phone'\ntype Required = RequiredKeys<UserProfile>; // 'id' | 'name'"
    },
    {
      "id": 78,
      "question": "What are advanced mapped type techniques?",
      "answer": "Advanced mapped types enable sophisticated type transformations through key remapping, filtering, and composition.\n\nKey Remapping:\n• as clause for renaming keys\n• Template literals in keys\n• Filtering keys with never\n• Conditional key transformations\n• Dynamic property names\n\nModifier Operations:\n• Adding/removing readonly\n• Adding/removing optional\n• -readonly removes readonly\n• -? removes optional\n• +readonly, +? explicit addition\n\nAdvanced Patterns:\n• Recursive mapped types\n• Conditional value types\n• Key filtering\n• Property transformation\n• Nested mapping\n\nTemplate Literal Keys:\n• String manipulation in keys\n• Prefix/suffix patterns\n• Camel/snake case conversion\n• Generate getter/setter names\n\nPractical Applications:\n• API type generation\n• Form state types\n• Event handler types\n• Database models\n• Type-safe builders\n\nPerformance:\n• Can be computationally expensive\n• Limit nesting depth\n• Cache complex types\n• Use carefully in large codebases",
      "explanation": "Advanced mapped types use key remapping, modifiers, and template literals to create sophisticated type transformations and property manipulations.",
      "difficulty": "Hard",
      "code": "// Key remapping with as\ntype Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];\n};\n\ninterface User {\n  name: string;\n  age: number;\n}\n\ntype UserGetters = Getters<User>;\n// { getName(): string; getAge(): number; }\n\n// Filtering keys\ntype RemoveKindField<T> = {\n  [K in keyof T as Exclude<K, 'kind'>]: T[K];\n};\n\ninterface Circle {\n  kind: 'circle';\n  radius: number;\n}\n\ntype CircleWithoutKind = RemoveKindField<Circle>;\n// { radius: number }\n\n// Conditional filtering\ntype PickByType<T, U> = {\n  [K in keyof T as T[K] extends U ? K : never]: T[K];\n};\n\ninterface Mixed {\n  name: string;\n  age: number;\n  active: boolean;\n  email: string;\n}\n\ntype StringProps = PickByType<Mixed, string>;\n// { name: string; email: string }\n\n// Remove readonly modifier\ntype Mutable<T> = {\n  -readonly [K in keyof T]: T[K];\n};\n\ntype ReadonlyUser = {\n  readonly id: number;\n  readonly name: string;\n};\n\ntype MutableUser = Mutable<ReadonlyUser>;\n// { id: number; name: string }\n\n// Remove optional modifier\ntype Concrete<T> = {\n  [K in keyof T]-?: T[K];\n};\n\ntype PartialUser = {\n  name?: string;\n  age?: number;\n};\n\ntype CompleteUser = Concrete<PartialUser>;\n// { name: string; age: number }\n\n// Multiple transformations\ntype EventHandlers<T> = {\n  [K in keyof T as `on${Capitalize<string & K>}Changed`]:\n    (newValue: T[K]) => void;\n};\n\ninterface FormState {\n  username: string;\n  password: string;\n  rememberMe: boolean;\n}\n\ntype FormHandlers = EventHandlers<FormState>;\n// {\n//   onUsernameChanged(newValue: string): void;\n//   onPasswordChanged(newValue: string): void;\n//   onRememberMeChanged(newValue: boolean): void;\n// }\n\n// Recursive mapped type\ntype DeepPartial<T> = {\n  [K in keyof T]?: T[K] extends object\n    ? DeepPartial<T[K]>\n    : T[K];\n};\n\ninterface Config {\n  database: {\n    host: string;\n    port: number;\n    credentials: {\n      username: string;\n      password: string;\n    };\n  };\n}\n\ntype PartialConfig = DeepPartial<Config>;\n// All properties at all levels optional\n\n// Camel to snake case\ntype CamelToSnake<S extends string> = \n  S extends `${infer T}${infer U}`\n    ? `${T extends Capitalize<T>\n        ? '_'\n        : ''}${Lowercase<T>}${CamelToSnake<U>}`\n    : S;\n\ntype SnakeCase<T> = {\n  [K in keyof T as CamelToSnake<string & K>]: T[K];\n};\n\ninterface CamelCase {\n  firstName: string;\n  lastName: string;\n  emailAddress: string;\n}\n\ntype Snake = SnakeCase<CamelCase>;\n// { first_name: string; last_name: string; email_address: string }\n\n// Combining patterns\ntype ApiResponse<T> = {\n  [K in keyof T as K extends string\n    ? `${K}_response`\n    : never\n  ]: {\n    data: T[K];\n    status: number;\n    timestamp: Date;\n  };\n};\n\ninterface Endpoints {\n  users: User[];\n  posts: Post[];\n}\n\ntype Responses = ApiResponse<Endpoints>;\n// {\n//   users_response: { data: User[]; status: number; timestamp: Date };\n//   posts_response: { data: Post[]; status: number; timestamp: Date };\n// }"
    },
    {
      "id": 79,
      "question": "How do you implement type-safe event emitters in TypeScript?",
      "answer": "Type-safe event emitters enforce event names and payload types at compile time for robust event-driven architectures.\n\nType Safety Features:\n• Typed event names\n• Typed event payloads\n• Compile-time validation\n• IntelliSense support\n• Type inference\n\nImplementation Approaches:\n• Mapped types for events\n• Generic event emitter\n• Discriminated unions\n• Template literal types\n• Strict function signatures\n\nEvent Definitions:\n• Interface for event map\n• Event name as key\n• Payload type as value\n• Optional vs required data\n• Union types for variants\n\nAdvanced Features:\n• Once listeners\n• Remove listeners\n• Event wildcards\n• Async handlers\n• Error handling\n\nBest Practices:\n• Define event interface upfront\n• Type all handlers\n• Handle unsubscription\n• Document events\n• Use discriminated unions for complex events",
      "explanation": "Type-safe event emitters use mapped types and generics to enforce compile-time checking of event names and payloads, ensuring type-safe event handling.",
      "difficulty": "Hard",
      "code": "// Event map definition\ninterface AppEvents {\n  'user:login': { userId: number; timestamp: Date };\n  'user:logout': { userId: number };\n  'data:update': { id: string; data: unknown };\n  'error': { message: string; code: string };\n}\n\n// Type-safe event emitter\ntype EventHandler<T = any> = (data: T) => void | Promise<void>;\n\nclass TypedEventEmitter<Events extends Record<string, any>> {\n  private handlers: {\n    [K in keyof Events]?: Set<EventHandler<Events[K]>>;\n  } = {};\n  \n  on<K extends keyof Events>(\n    event: K,\n    handler: EventHandler<Events[K]>\n  ): () => void {\n    if (!this.handlers[event]) {\n      this.handlers[event] = new Set();\n    }\n    this.handlers[event]!.add(handler);\n    \n    // Return unsubscribe function\n    return () => this.off(event, handler);\n  }\n  \n  off<K extends keyof Events>(\n    event: K,\n    handler: EventHandler<Events[K]>\n  ): void {\n    this.handlers[event]?.delete(handler);\n  }\n  \n  emit<K extends keyof Events>(\n    event: K,\n    data: Events[K]\n  ): void {\n    const handlers = this.handlers[event];\n    if (handlers) {\n      handlers.forEach(handler => handler(data));\n    }\n  }\n  \n  once<K extends keyof Events>(\n    event: K,\n    handler: EventHandler<Events[K]>\n  ): void {\n    const wrappedHandler = (data: Events[K]) => {\n      handler(data);\n      this.off(event, wrappedHandler);\n    };\n    this.on(event, wrappedHandler);\n  }\n  \n  removeAllListeners<K extends keyof Events>(event?: K): void {\n    if (event) {\n      delete this.handlers[event];\n    } else {\n      this.handlers = {};\n    }\n  }\n}\n\n// Usage\nconst emitter = new TypedEventEmitter<AppEvents>();\n\n// Type-safe event listening\nemitter.on('user:login', (data) => {\n  // data is typed as { userId: number; timestamp: Date }\n  console.log(`User ${data.userId} logged in at ${data.timestamp}`);\n});\n\n// Compile error for wrong payload\n// emitter.emit('user:login', { userId: '123' }); // Error: string not number\n\n// Type-safe emission\nemitter.emit('user:login', {\n  userId: 1,\n  timestamp: new Date()\n});\n\n// Advanced: Async event emitter\nclass AsyncEventEmitter<Events extends Record<string, any>> {\n  private handlers = new Map<keyof Events, Set<EventHandler<any>>>();\n  \n  on<K extends keyof Events>(\n    event: K,\n    handler: EventHandler<Events[K]>\n  ): () => void {\n    if (!this.handlers.has(event)) {\n      this.handlers.set(event, new Set());\n    }\n    this.handlers.get(event)!.add(handler);\n    return () => this.off(event, handler);\n  }\n  \n  off<K extends keyof Events>(\n    event: K,\n    handler: EventHandler<Events[K]>\n  ): void {\n    this.handlers.get(event)?.delete(handler);\n  }\n  \n  async emit<K extends keyof Events>(\n    event: K,\n    data: Events[K]\n  ): Promise<void> {\n    const handlers = this.handlers.get(event);\n    if (handlers) {\n      await Promise.all(\n        Array.from(handlers).map(handler => handler(data))\n      );\n    }\n  }\n}\n\n// With discriminated unions\ntype UserEvent =\n  | { type: 'login'; userId: number; timestamp: Date }\n  | { type: 'logout'; userId: number }\n  | { type: 'update'; userId: number; changes: Record<string, any> };\n\ninterface DomainEvents {\n  user: UserEvent;\n  system: { type: 'shutdown' | 'restart' };\n}\n\nconst domainEmitter = new TypedEventEmitter<DomainEvents>();\n\ndomainEmitter.on('user', (event) => {\n  // event is UserEvent union\n  switch (event.type) {\n    case 'login':\n      console.log(event.timestamp); // Type-safe\n      break;\n    case 'logout':\n      console.log(event.userId);\n      break;\n  }\n});"
    },
    {
      "id": 80,
      "question": "What are variadic tuple types and how do you use them?",
      "answer": "Variadic tuple types enable working with tuples of unknown length using spread syntax in type positions.\n\nKey Features:\n• Spread types in tuples\n• Generic rest elements\n• Type inference\n• Tuple concatenation\n• Dynamic tuple types\n\nSyntax:\n• ...T in tuple positions\n• Generic type parameters\n• Rest element patterns\n• Leading and trailing elements\n• Multiple rest elements\n\nUse Cases:\n• Function composition\n• Curry functions\n• Argument manipulation\n• Tuple operations\n• Type-safe wrappers\n\nType Operations:\n• Concatenate tuples\n• Prepend/append elements\n• Extract parts\n• Transform tuples\n• Recursive operations\n\nBenefits:\n• Type-safe variadic functions\n• Better function typing\n• Compose types safely\n• Flexible tuple types\n• Powerful abstractions\n\nLimitations:\n• Complexity increases\n• Error messages harder\n• Performance considerations\n• Learning curve\n• Tool support varies",
      "explanation": "Variadic tuple types use spread syntax in type positions to work with tuples of unknown length, enabling type-safe variadic functions and tuple operations.",
      "difficulty": "Hard",
      "code": "// Basic variadic tuple\ntype Concat<T extends unknown[], U extends unknown[]> = [...T, ...U];\n\ntype Result1 = Concat<[1, 2], [3, 4]>; // [1, 2, 3, 4]\ntype Result2 = Concat<[string], [number, boolean]>;\n// [string, number, boolean]\n\n// Prepend to tuple\ntype Prepend<T, U extends unknown[]> = [T, ...U];\n\ntype Result3 = Prepend<string, [number, boolean]>;\n// [string, number, boolean]\n\n// Function argument manipulation\ntype DropFirst<T extends unknown[]> = T extends [any, ...infer Rest]\n  ? Rest\n  : [];\n\ntype Result4 = DropFirst<[string, number, boolean]>;\n// [number, boolean]\n\n// Type-safe curry function\ntype Curry<P extends unknown[], R> = \n  P extends [infer First, ...infer Rest]\n    ? (arg: First) => Curry<Rest, R>\n    : R;\n\nfunction curry<P extends unknown[], R>(\n  fn: (...args: P) => R\n): Curry<P, R> {\n  return ((...args: any[]) => {\n    if (args.length >= fn.length) {\n      return fn(...args as any);\n    }\n    return curry((fn as any).bind(null, ...args));\n  }) as any;\n}\n\n// Usage\nfunction add(a: number, b: number, c: number): number {\n  return a + b + c;\n}\n\nconst curriedAdd = curry(add);\nconst result = curriedAdd(1)(2)(3); // Type-safe!\n\n// Variadic tuple with constraints\ntype AllStrings<T extends unknown[]> = T extends [infer First, ...infer Rest]\n  ? First extends string\n    ? [First, ...AllStrings<Rest>]\n    : never\n  : [];\n\ntype Result5 = AllStrings<['a', 'b', 'c']>; // ['a', 'b', 'c']\n// type Result6 = AllStrings<['a', 1, 'c']>; // never\n\n// Function composition with variadic tuples\ntype Compose<Fns extends Array<(arg: any) => any>> = \n  Fns extends [infer First, ...infer Rest]\n    ? First extends (arg: infer A) => infer B\n      ? Rest extends Array<(arg: any) => any>\n        ? Rest extends []\n          ? (arg: A) => B\n          : (arg: A) => ReturnType<Compose<Rest>>\n        : never\n      : never\n    : never;\n\n// Tuple partition\ntype Partition<\n  T extends unknown[],\n  N extends number,\n  Acc extends unknown[] = []\n> = Acc['length'] extends N\n  ? [Acc, T]\n  : T extends [infer First, ...infer Rest]\n  ? Partition<Rest, N, [...Acc, First]>\n  : [Acc, T];\n\ntype Result7 = Partition<[1, 2, 3, 4, 5], 3>;\n// [[1, 2, 3], [4, 5]]\n\n// Type-safe push/pop operations\ntype Push<T extends unknown[], U> = [...T, U];\ntype Pop<T extends unknown[]> = T extends [...infer Rest, any] ? Rest : [];\n\ntype Arr = [1, 2, 3];\ntype WithFour = Push<Arr, 4>; // [1, 2, 3, 4]\ntype WithoutLast = Pop<Arr>; // [1, 2]\n\n// Reverse tuple\ntype Reverse<T extends unknown[]> = T extends [infer First, ...infer Rest]\n  ? [...Reverse<Rest>, First]\n  : [];\n\ntype Result8 = Reverse<[1, 2, 3, 4]>; // [4, 3, 2, 1]\n\n// Type-safe spread in functions\nfunction merge<T extends unknown[], U extends unknown[]>(\n  arr1: T,\n  arr2: U\n): [...T, ...U] {\n  return [...arr1, ...arr2] as [...T, ...U];\n}\n\nconst merged = merge([1, 2], ['a', 'b']);\n// Type: [number, number, string, string]"
    },
    {
      "id": 81,
      "question": "How do you implement advanced type guards with assertion signatures?",
      "answer": "Advanced type guards combine assertion signatures with complex type narrowing for robust type checking.\n\nAssertion Signatures:\n• asserts condition\n• asserts value is Type\n• Throws on failure\n• Narrows type after return\n• No boolean return\n\nComplex Type Guards:\n• Multiple property checks\n• Nested object validation\n• Array element validation\n• Discriminated union narrowing\n• Generic type guards\n\nValidation Patterns:\n• Runtime type checking\n• Schema validation\n• API response validation\n• User input validation\n• Type narrowing helpers\n\nCombining Techniques:\n• Assertion with type predicates\n• Recursive validation\n• Composable guards\n• Error messages\n• Type-safe validation\n\nBest Practices:\n• Throw descriptive errors\n• Validate completely\n• Use for invariants\n• Document expectations\n• Test thoroughly\n• Chain validations",
      "explanation": "Advanced type guards use assertion signatures and complex validation logic to provide robust runtime checks with compile-time type narrowing.",
      "difficulty": "Hard",
      "code": "// Basic assertion signature\nfunction assertIsDefined<T>(value: T): asserts value is NonNullable<T> {\n  if (value === null || value === undefined) {\n    throw new Error('Value is null or undefined');\n  }\n}\n\nfunction process(value: string | null) {\n  assertIsDefined(value);\n  // TypeScript knows value is string here\n  console.log(value.toUpperCase());\n}\n\n// Complex object validation\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  age?: number;\n}\n\nfunction assertIsUser(value: unknown): asserts value is User {\n  if (\n    typeof value !== 'object' ||\n    value === null ||\n    !('id' in value) ||\n    typeof (value as any).id !== 'number' ||\n    !('name' in value) ||\n    typeof (value as any).name !== 'string' ||\n    !('email' in value) ||\n    typeof (value as any).email !== 'string'\n  ) {\n    throw new Error('Invalid user object');\n  }\n  \n  if ('age' in value && typeof (value as any).age !== 'number') {\n    throw new Error('User age must be number');\n  }\n}\n\n// Usage\nasync function fetchUser(id: number): Promise<User> {\n  const response = await fetch(`/api/users/${id}`);\n  const data: unknown = await response.json();\n  assertIsUser(data);\n  return data; // Safely typed as User\n}\n\n// Array validation\nfunction assertIsStringArray(value: unknown): asserts value is string[] {\n  if (!Array.isArray(value)) {\n    throw new Error('Not an array');\n  }\n  \n  if (!value.every(item => typeof item === 'string')) {\n    throw new Error('Array contains non-string elements');\n  }\n}\n\n// Generic array validation\nfunction assertIsArrayOf<T>(\n  value: unknown,\n  guard: (item: unknown) => item is T\n): asserts value is T[] {\n  if (!Array.isArray(value)) {\n    throw new Error('Not an array');\n  }\n  \n  if (!value.every(guard)) {\n    throw new Error('Array contains invalid elements');\n  }\n}\n\nfunction isUser(value: unknown): value is User {\n  try {\n    assertIsUser(value);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n// Usage\nconst data: unknown = await fetchData();\nassertIsArrayOf(data, isUser);\n// data is User[]\n\n// Discriminated union narrowing\ntype Shape =\n  | { kind: 'circle'; radius: number }\n  | { kind: 'square'; sideLength: number }\n  | { kind: 'rectangle'; width: number; height: number };\n\nfunction assertIsCircle(shape: Shape): asserts shape is Extract<Shape, { kind: 'circle' }> {\n  if (shape.kind !== 'circle') {\n    throw new Error('Shape is not a circle');\n  }\n}\n\nfunction processShape(shape: Shape) {\n  assertIsCircle(shape);\n  // shape is { kind: 'circle'; radius: number }\n  console.log(shape.radius);\n}\n\n// Composable validation\nfunction assertHasProperty<K extends string>(\n  obj: unknown,\n  key: K\n): asserts obj is Record<K, unknown> {\n  if (\n    typeof obj !== 'object' ||\n    obj === null ||\n    !(key in obj)\n  ) {\n    throw new Error(`Object missing property: ${key}`);\n  }\n}\n\nfunction assertPropertyType<K extends string, T>(\n  obj: Record<K, unknown>,\n  key: K,\n  guard: (value: unknown) => value is T\n): asserts obj is Record<K, T> {\n  if (!guard(obj[key])) {\n    throw new Error(`Invalid type for property: ${key}`);\n  }\n}\n\n// Chain validations\nfunction validateUser(data: unknown): User {\n  assertHasProperty(data, 'id');\n  assertHasProperty(data, 'name');\n  assertHasProperty(data, 'email');\n  \n  assertPropertyType(data, 'id', (v): v is number => typeof v === 'number');\n  assertPropertyType(data, 'name', (v): v is string => typeof v === 'string');\n  assertPropertyType(data, 'email', (v): v is string => typeof v === 'string');\n  \n  return data as User;\n}\n\n// Recursive validation\ntype DeepPartial<T> = T extends object\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : T;\n\nfunction assertDeepEqual<T>(\n  value: unknown,\n  schema: T\n): asserts value is T {\n  // Complex recursive validation logic\n  if (typeof schema !== typeof value) {\n    throw new Error('Type mismatch');\n  }\n  \n  if (typeof schema === 'object' && schema !== null) {\n    for (const key in schema) {\n      assertDeepEqual((value as any)[key], schema[key]);\n    }\n  }\n}"
    },
    {
      "id": 82,
      "question": "What are the TypeScript 5.x features and improvements?",
      "answer": "TypeScript 5.x introduces significant performance improvements and new type system features.\n\nMajor Features:\n• Decorators (Stage 3)\n• const type parameters\n• satisfies operator enhancements\n• Multiple configuration files\n• Performance improvements\n• Smaller package size\n\nPerformance Improvements:\n• Faster type checking\n• Reduced memory usage\n• Better incremental builds\n• Optimized module resolution\n• Improved watch mode\n\nNew Type Features:\n• Better inference\n• Enhanced template literals\n• Improved variance annotations\n• Better narrowing\n• Type predicates enhancements\n\nBreaking Changes:\n• Stricter checks\n• Deprecated features removed\n• Updated lib files\n• Module resolution changes\n• Configuration updates\n\nEcosystem:\n• Better bundler support\n• Improved IDE integration\n• Enhanced tooling\n• Better error messages\n• Documentation improvements",
      "explanation": "TypeScript 5.x brings major performance improvements, Stage 3 decorators, const type parameters, and enhanced type system features with breaking changes.",
      "difficulty": "Medium",
      "code": "// Decorators (Stage 3) - TypeScript 5.0\nfunction logged(target: any, context: ClassMethodDecoratorContext) {\n  const methodName = String(context.name);\n  \n  return function (this: any, ...args: any[]) {\n    console.log(`Calling ${methodName} with:`, args);\n    const result = target.call(this, ...args);\n    console.log(`Result:`, result);\n    return result;\n  };\n}\n\nclass Calculator {\n  @logged\n  add(a: number, b: number): number {\n    return a + b;\n  }\n}\n\n// Const type parameters - TypeScript 5.0\nfunction processArray<const T extends readonly unknown[]>(arr: T): T {\n  return arr;\n}\n\nconst result = processArray([1, 2, 3] as const);\n// Type: readonly [1, 2, 3] (preserves literal types)\n\n// Enhanced satisfies\ntype Color = 'red' | 'green' | 'blue';\n\nconst palette = {\n  primary: 'red',\n  secondary: 'blue'\n} satisfies Record<string, Color>;\n\npalette.primary; // Type: 'red' (not Color)\n\n// Better const parameter inference\nfunction createConfig<const T extends Record<string, any>>(config: T): T {\n  return config;\n}\n\nconst config = createConfig({\n  host: 'localhost',\n  port: 3000\n});\n// Type preserves literal values\n\n// Import attributes (5.3)\nimport data from './data.json' with { type: 'json' };\n\n// Resolution mode (5.0)\nimport type { User } from './types.js' with { 'resolution-mode': 'import' };\n\n// Better narrowing in switch true\nfunction process(value: string | number) {\n  switch (true) {\n    case typeof value === 'string':\n      // TypeScript 5.x correctly narrows\n      return value.toUpperCase();\n    case typeof value === 'number':\n      return value.toFixed(2);\n  }\n}\n\n// Improved type parameter inference\nfunction map<T, U>(\n  array: T[],\n  fn: (item: T) => U\n): U[] {\n  return array.map(fn);\n}\n\nconst numbers = [1, 2, 3];\nconst strings = map(numbers, n => n.toString());\n// Better inference in TS 5.x\n\n// tsconfig.json improvements\n// {\n//   \"compilerOptions\": {\n//     \"verbatimModuleSyntax\": true, // New in 5.0\n//     \"allowImportingTsExtensions\": true, // New in 5.0\n//     \"resolvePackageJsonExports\": true, // Improved\n//     \"resolvePackageJsonImports\": true, // Improved\n//     \"allowArbitraryExtensions\": true // New in 5.0\n//   }\n// }\n\n// Performance optimizations\n// Faster type checking\n// Better memory usage\n// Improved watch mode\n// Optimized module resolution\n\n// ESM/CommonJS interop improvements\nexport { something } from './module';\n// Better handling of module formats"
    },
    {
      "id": 83,
      "question": "How do you implement type-safe state machines in TypeScript?",
      "answer": "Type-safe state machines encode valid states and transitions in the type system for compile-time verification.\n\nKey Components:\n• State definitions\n• Event definitions\n• Transition functions\n• State context\n• Type-safe guards\n\nImplementation Patterns:\n• Discriminated unions for states\n• Mapped types for transitions\n• Generic state machine\n• Phantom types for state\n• Builder pattern\n\nType Safety:\n• Valid transitions only\n• State-specific actions\n• Event type checking\n• Context typing\n• Compile-time validation\n\nAdvanced Features:\n• Nested state machines\n• Parallel states\n• History states\n• Guards and actions\n• Side effects\n\nLibraries:\n• XState for complex machines\n• Robot for simple cases\n• Custom implementations\n• Functional approaches\n\nBest Practices:\n• Model all states explicitly\n• Define valid transitions\n• Type contexts properly\n• Document state meaning\n• Test transitions\n• Handle errors",
      "explanation": "Type-safe state machines use discriminated unions and mapped types to encode valid states and transitions, preventing invalid state changes at compile time.",
      "difficulty": "Hard",
      "code": "// State definitions with discriminated unions\ntype TrafficLightState =\n  | { status: 'red'; timer: number }\n  | { status: 'yellow'; timer: number }\n  | { status: 'green'; timer: number };\n\ntype TrafficLightEvent =\n  | { type: 'TIMER_EXPIRED' }\n  | { type: 'MANUAL_OVERRIDE'; newStatus: 'red' | 'yellow' | 'green' };\n\n// Transition function\nfunction transition(\n  state: TrafficLightState,\n  event: TrafficLightEvent\n): TrafficLightState {\n  switch (state.status) {\n    case 'red':\n      if (event.type === 'TIMER_EXPIRED') {\n        return { status: 'green', timer: 30 };\n      }\n      break;\n    case 'green':\n      if (event.type === 'TIMER_EXPIRED') {\n        return { status: 'yellow', timer: 5 };\n      }\n      break;\n    case 'yellow':\n      if (event.type === 'TIMER_EXPIRED') {\n        return { status: 'red', timer: 20 };\n      }\n      break;\n  }\n  \n  if (event.type === 'MANUAL_OVERRIDE') {\n    return { status: event.newStatus, timer: 10 };\n  }\n  \n  return state;\n}\n\n// Generic state machine\ntype StateConfig<\n  TState extends { type: string },\n  TEvent extends { type: string }\n> = {\n  [K in TState['type']]: {\n    on: {\n      [E in TEvent['type']]?: (state: Extract<TState, { type: K }>, event: Extract<TEvent, { type: E }>) => TState;\n    };\n  };\n};\n\nclass StateMachine<\n  TState extends { type: string },\n  TEvent extends { type: string }\n> {\n  constructor(\n    private state: TState,\n    private config: StateConfig<TState, TEvent>\n  ) {}\n  \n  send(event: TEvent): void {\n    const stateConfig = this.config[this.state.type];\n    const handler = stateConfig.on[event.type];\n    \n    if (handler) {\n      this.state = handler(this.state as any, event as any);\n    }\n  }\n  \n  getState(): TState {\n    return this.state;\n  }\n}\n\n// Usage example: Door state machine\ntype DoorState =\n  | { type: 'closed'; locked: boolean }\n  | { type: 'open' }\n  | { type: 'closing'; progress: number };\n\ntype DoorEvent =\n  | { type: 'OPEN' }\n  | { type: 'CLOSE' }\n  | { type: 'LOCK' }\n  | { type: 'UNLOCK' };\n\nconst doorConfig: StateConfig<DoorState, DoorEvent> = {\n  closed: {\n    on: {\n      OPEN: (state, event) => ({ type: 'open' }),\n      LOCK: (state, event) => ({ type: 'closed', locked: true }),\n      UNLOCK: (state, event) => ({ type: 'closed', locked: false })\n    }\n  },\n  open: {\n    on: {\n      CLOSE: (state, event) => ({ type: 'closing', progress: 0 })\n    }\n  },\n  closing: {\n    on: {\n      OPEN: (state, event) => ({ type: 'open' })\n    }\n  }\n};\n\nconst door = new StateMachine<DoorState, DoorEvent>(\n  { type: 'closed', locked: false },\n  doorConfig\n);\n\ndoor.send({ type: 'OPEN' });\nconsole.log(door.getState()); // { type: 'open' }\n\n// With phantom types for compile-time state tracking\ntype StateType = 'idle' | 'loading' | 'success' | 'error';\n\nclass TypedStateMachine<S extends StateType> {\n  private constructor(private _state: S) {}\n  \n  static create(): TypedStateMachine<'idle'> {\n    return new TypedStateMachine('idle');\n  }\n  \n  startLoading(\n    this: TypedStateMachine<'idle'>\n  ): TypedStateMachine<'loading'> {\n    return new TypedStateMachine('loading');\n  }\n  \n  succeed(\n    this: TypedStateMachine<'loading'>\n  ): TypedStateMachine<'success'> {\n    return new TypedStateMachine('success');\n  }\n  \n  fail(\n    this: TypedStateMachine<'loading'>\n  ): TypedStateMachine<'error'> {\n    return new TypedStateMachine('error');\n  }\n  \n  reset(\n    this: TypedStateMachine<'success' | 'error'>\n  ): TypedStateMachine<'idle'> {\n    return new TypedStateMachine('idle');\n  }\n}\n\n// Usage enforces valid transitions\nconst machine = TypedStateMachine.create();\nconst loading = machine.startLoading();\nconst success = loading.succeed();\nconst idle = success.reset();\n// machine.succeed(); // Error: only available on loading state"
    },
    {
      "id": 84,
      "question": "How do you optimize TypeScript compilation and build performance?",
      "answer": "Optimizing TypeScript compilation involves configuration, code organization, and tooling choices.\n\nConfiguration Optimizations:\n• Enable incremental: true\n• Use project references\n• Enable composite mode\n• Set skipLibCheck: true\n• Optimize include/exclude\n• Use isolatedModules\n\nCode Organization:\n• Split into smaller projects\n• Reduce circular dependencies\n• Minimize type complexity\n• Use const enums\n• Avoid deep type recursion\n• Simplify generic constraints\n\nBuild Tools:\n• Use faster transpilers (esbuild, swc)\n• Parallel compilation\n• Cache compiled outputs\n• Watch mode optimizations\n• Separate type checking\n\nDevelopment Workflow:\n• IDE settings optimization\n• Selective compilation\n• Module resolution strategy\n• Source map configuration\n• Declaration file generation\n\nProduction Builds:\n• Disable source maps\n• Remove comments\n• Enable optimization flags\n• Tree-shaking configuration\n• Minimize output size\n\nMonitoring:\n• Use --diagnostics flag\n• Measure compilation time\n• Profile type checking\n• Identify bottlenecks\n• Track build metrics",
      "explanation": "TypeScript compilation can be optimized through proper configuration, code organization, faster build tools, and strategic use of features like project references and incremental compilation.",
      "difficulty": "Hard",
      "code": "// Optimized tsconfig.json\n{\n  \"compilerOptions\": {\n    // Performance optimizations\n    \"incremental\": true,\n    \"tsBuildInfoFile\": \"./.tsbuildinfo\",\n    \"composite\": true,\n    \n    // Skip type checking for libraries\n    \"skipLibCheck\": true,\n    \n    // Faster module resolution\n    \"moduleResolution\": \"bundler\", // or \"node16\"\n    \n    // Isolated modules for faster transpilation\n    \"isolatedModules\": true,\n    \n    // Disable features if not needed\n    \"declaration\": false, // Enable only when needed\n    \"declarationMap\": false,\n    \"sourceMap\": false, // For production\n    \n    // Optimize type checking\n    \"strict\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \n    // Target modern environments\n    \"target\": \"ES2020\",\n    \"module\": \"ESNext\",\n    \"lib\": [\"ES2020\", \"DOM\"]\n  },\n  \n  // Carefully manage included files\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"**/*.spec.ts\",\n    \"**/*.test.ts\"\n  ]\n}\n\n// Project references for monorepo\n// Root tsconfig.json\n{\n  \"files\": [],\n  \"references\": [\n    { \"path\": \"./packages/core\" },\n    { \"path\": \"./packages/utils\" },\n    { \"path\": \"./packages/app\" }\n  ]\n}\n\n// Package tsconfig.json\n{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"composite\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\"\n  },\n  \"references\": [\n    { \"path\": \"../core\" }\n  ]\n}\n\n// Build scripts optimization\n// package.json\n{\n  \"scripts\": {\n    // Use tsc --build for project references\n    \"build\": \"tsc --build\",\n    \"build:watch\": \"tsc --build --watch\",\n    \"clean\": \"tsc --build --clean\",\n    \n    // Parallel builds\n    \"build:all\": \"tsc --build --force\",\n    \n    // Use faster transpilers\n    \"dev\": \"esbuild src/index.ts --bundle --watch\",\n    \"build:fast\": \"swc src -d dist\",\n    \n    // Type checking only (no emit)\n    \"typecheck\": \"tsc --noEmit\",\n    \n    // With diagnostics\n    \"build:profile\": \"tsc --diagnostics --extendedDiagnostics\"\n  }\n}\n\n// Code optimization patterns\n// Use const enums (inlined)\nconst enum Direction {\n  Up,\n  Down,\n  Left,\n  Right\n}\n\nconst dir = Direction.Up; // Compiles to: const dir = 0;\n\n// Avoid deep type recursion\n// Bad: Deep recursion\ntype DeepBad<T, N extends number = 10> = N extends 0\n  ? T\n  : DeepBad<DeepBad<T, Prev<N>>, Prev<N>>;\n\n// Good: Limited depth\ntype DeepGood<T, N extends number = 3> = N extends 0\n  ? T\n  : { nested: DeepGood<T, Prev<N>> };\n\n// Minimize type complexity\n// Bad: Complex union\ntype ComplexUnion = A | B | C | D | E | F | G | H;\n\n// Good: Simpler types\ntype Group1 = A | B | C;\ntype Group2 = D | E | F;\ntype SimpleUnion = Group1 | Group2;\n\n// Use faster build tools\n// vite.config.ts\nimport { defineConfig } from 'vite';\n\nexport default defineConfig({\n  esbuild: {\n    // Use esbuild for faster transpilation\n    tsconfigRaw: {\n      compilerOptions: {\n        experimentalDecorators: true\n      }\n    }\n  }\n});\n\n// Webpack with ts-loader optimization\n// webpack.config.js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.tsx?$/,\n        use: [\n          {\n            loader: 'ts-loader',\n            options: {\n              transpileOnly: true, // Skip type checking\n              experimentalWatchApi: true\n            }\n          }\n        ]\n      }\n    ]\n  },\n  plugins: [\n    // Separate type checking process\n    new ForkTsCheckerWebpackPlugin()\n  ]\n};\n\n// Monitor build performance\n// tsc --diagnostics output analysis\n// Files: 1234\n// Lines of code: 45678\n// Identifiers: 23456\n// Symbols: 12345\n// Types: 6789\n// Instantiations: 34567\n// Time: 5.23s"
    },
    {
      "id": 85,
      "question": "What are advanced patterns for working with React and TypeScript?",
      "answer": "React with TypeScript enables type-safe component development through proper typing of props, state, and hooks.\n\nComponent Typing:\n• FC vs function components\n• Props interface definitions\n• Generic components\n• Children typing\n• Event handlers\n• Ref typing\n\nHooks Typing:\n• useState with inference\n• useReducer with actions\n• useContext with typed context\n• useRef with element types\n• Custom hooks typing\n• Generic hooks\n\nAdvanced Patterns:\n• Higher-order components\n• Render props\n• Compound components\n• Polymorphic components\n• As prop pattern\n• Discriminated props\n\nForm Handling:\n• Type-safe form events\n• Controlled components\n• Form validation\n• Generic form components\n\nState Management:\n• Redux with TypeScript\n• Context API typing\n• Zustand/Jotai typing\n• Type-safe actions\n\nBest Practices:\n• Define prop interfaces\n• Use discriminated unions\n• Type event handlers\n• Generic components when needed\n• Avoid any types\n• Document complex types",
      "explanation": "React with TypeScript requires proper typing of components, props, hooks, and events, enabling type-safe development through interfaces, generics, and advanced patterns.",
      "difficulty": "Hard",
      "code": "import React, { useState, useReducer, useContext, useRef, ReactNode } from 'react';\n\n// Basic component with props\ninterface ButtonProps {\n  label: string;\n  onClick: () => void;\n  disabled?: boolean;\n  variant?: 'primary' | 'secondary';\n}\n\nconst Button: React.FC<ButtonProps> = ({ label, onClick, disabled, variant = 'primary' }) => {\n  return (\n    <button onClick={onClick} disabled={disabled} className={variant}>\n      {label}\n    </button>\n  );\n};\n\n// Generic component\ninterface ListProps<T> {\n  items: T[];\n  renderItem: (item: T, index: number) => ReactNode;\n  keyExtractor: (item: T) => string | number;\n}\n\nfunction List<T>({ items, renderItem, keyExtractor }: ListProps<T>) {\n  return (\n    <ul>\n      {items.map((item, index) => (\n        <li key={keyExtractor(item)}>\n          {renderItem(item, index)}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// Usage\ninterface User { id: number; name: string; }\nconst users: User[] = [{ id: 1, name: 'John' }];\n\n<List\n  items={users}\n  renderItem={(user) => <span>{user.name}</span>}\n  keyExtractor={(user) => user.id}\n/>;\n\n// Discriminated union props\ntype InputProps =\n  | { type: 'text'; value: string; onChange: (value: string) => void }\n  | { type: 'number'; value: number; onChange: (value: number) => void }\n  | { type: 'checkbox'; checked: boolean; onChange: (checked: boolean) => void };\n\nconst Input: React.FC<InputProps> = (props) => {\n  switch (props.type) {\n    case 'text':\n      return <input type=\"text\" value={props.value} onChange={(e) => props.onChange(e.target.value)} />;\n    case 'number':\n      return <input type=\"number\" value={props.value} onChange={(e) => props.onChange(Number(e.target.value))} />;\n    case 'checkbox':\n      return <input type=\"checkbox\" checked={props.checked} onChange={(e) => props.onChange(e.target.checked)} />;\n  }\n};\n\n// useReducer with typed actions\ntype State = { count: number; loading: boolean };\n\ntype Action =\n  | { type: 'INCREMENT' }\n  | { type: 'DECREMENT' }\n  | { type: 'SET_LOADING'; payload: boolean };\n\nfunction reducer(state: State, action: Action): State {\n  switch (action.type) {\n    case 'INCREMENT':\n      return { ...state, count: state.count + 1 };\n    case 'DECREMENT':\n      return { ...state, count: state.count - 1 };\n    case 'SET_LOADING':\n      return { ...state, loading: action.payload };\n    default:\n      return state;\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, { count: 0, loading: false });\n  \n  return (\n    <div>\n      <p>{state.count}</p>\n      <button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>\n      <button onClick={() => dispatch({ type: 'DECREMENT' })}>-</button>\n    </div>\n  );\n}\n\n// Typed context\ninterface ThemeContext {\n  theme: 'light' | 'dark';\n  setTheme: (theme: 'light' | 'dark') => void;\n}\n\nconst ThemeContext = React.createContext<ThemeContext | undefined>(undefined);\n\nfunction useTheme() {\n  const context = useContext(ThemeContext);\n  if (!context) {\n    throw new Error('useTheme must be used within ThemeProvider');\n  }\n  return context;\n}\n\n// Ref typing\nfunction TextInput() {\n  const inputRef = useRef<HTMLInputElement>(null);\n  \n  const focus = () => {\n    inputRef.current?.focus();\n  };\n  \n  return (\n    <>\n      <input ref={inputRef} />\n      <button onClick={focus}>Focus</button>\n    </>\n  );\n}\n\n// Polymorphic component (as prop)\ntype PolymorphicProps<E extends React.ElementType> = {\n  as?: E;\n  children: ReactNode;\n} & React.ComponentPropsWithoutRef<E>;\n\nfunction Text<E extends React.ElementType = 'span'>(\n  { as, children, ...props }: PolymorphicProps<E>\n) {\n  const Component = as || 'span';\n  return <Component {...props}>{children}</Component>;\n}\n\n// Usage\n<Text as=\"h1\" style={{ color: 'red' }}>Title</Text>;\n<Text as=\"button\" onClick={() => {}}>Click</Text>;"
    },
    {
      "id": 86,
      "question": "How do you implement type-safe API clients in TypeScript?",
      "answer": "Type-safe API clients ensure compile-time validation of requests and responses through proper typing.\n\nClient Structure:\n• Type-safe endpoints\n• Request/response types\n• HTTP method typing\n• URL parameter typing\n• Query string typing\n• Header typing\n\nImplementation Approaches:\n• Generic fetch wrapper\n• Axios with types\n• Code generation from OpenAPI\n• Type-safe route builders\n• Discriminated API calls\n\nValidation:\n• Runtime response validation\n• Type guards for responses\n• Error typing\n• Status code handling\n• Schema validation\n\nAdvanced Features:\n• Generic CRUD operations\n• Type-safe query builders\n• Request interceptors\n• Response transformers\n• Retry logic\n\nCode Generation:\n• OpenAPI/Swagger codegen\n• GraphQL code generation\n• tRPC for end-to-end typing\n• Automatic type sync\n\nBest Practices:\n• Validate responses\n• Type error cases\n• Use discriminated unions\n• Handle loading states\n• Document endpoints\n• Version API types",
      "explanation": "Type-safe API clients use TypeScript generics, discriminated unions, and validation to ensure compile-time type checking for all API interactions.",
      "difficulty": "Hard",
      "code": "// API response types\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface Post {\n  id: number;\n  title: string;\n  content: string;\n  authorId: number;\n}\n\ntype APIResponse<T> =\n  | { success: true; data: T }\n  | { success: false; error: string; code: number };\n\n// Generic HTTP client\nclass APIClient {\n  constructor(private baseURL: string) {}\n  \n  private async request<T>(\n    endpoint: string,\n    options?: RequestInit\n  ): Promise<APIResponse<T>> {\n    try {\n      const response = await fetch(`${this.baseURL}${endpoint}`, options);\n      \n      if (!response.ok) {\n        return {\n          success: false,\n          error: `HTTP ${response.status}`,\n          code: response.status\n        };\n      }\n      \n      const data = await response.json();\n      return { success: true, data };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        code: 0\n      };\n    }\n  }\n  \n  async get<T>(endpoint: string): Promise<APIResponse<T>> {\n    return this.request<T>(endpoint, { method: 'GET' });\n  }\n  \n  async post<T, D = unknown>(\n    endpoint: string,\n    data: D\n  ): Promise<APIResponse<T>> {\n    return this.request<T>(endpoint, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(data)\n    });\n  }\n  \n  async put<T, D = unknown>(\n    endpoint: string,\n    data: D\n  ): Promise<APIResponse<T>> {\n    return this.request<T>(endpoint, {\n      method: 'PUT',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(data)\n    });\n  }\n  \n  async delete<T>(endpoint: string): Promise<APIResponse<T>> {\n    return this.request<T>(endpoint, { method: 'DELETE' });\n  }\n}\n\n// Type-safe API endpoints\nclass UserAPI {\n  constructor(private client: APIClient) {}\n  \n  async getUser(id: number): Promise<APIResponse<User>> {\n    return this.client.get<User>(`/users/${id}`);\n  }\n  \n  async getUsers(): Promise<APIResponse<User[]>> {\n    return this.client.get<User[]>('/users');\n  }\n  \n  async createUser(\n    data: Omit<User, 'id'>\n  ): Promise<APIResponse<User>> {\n    return this.client.post<User, Omit<User, 'id'>>('/users', data);\n  }\n  \n  async updateUser(\n    id: number,\n    data: Partial<Omit<User, 'id'>>\n  ): Promise<APIResponse<User>> {\n    return this.client.put<User, Partial<Omit<User, 'id'>>>(\n      `/users/${id}`,\n      data\n    );\n  }\n  \n  async deleteUser(id: number): Promise<APIResponse<void>> {\n    return this.client.delete<void>(`/users/${id}`);\n  }\n}\n\n// Usage\nconst client = new APIClient('https://api.example.com');\nconst userAPI = new UserAPI(client);\n\nconst result = await userAPI.getUser(1);\nif (result.success) {\n  console.log(result.data.name); // Type-safe\n} else {\n  console.error(result.error);\n}\n\n// Type-safe route builder\ntype RouteParams = Record<string, string | number>;\ntype QueryParams = Record<string, string | number | boolean | undefined>;\n\nclass RouteBuilder {\n  private path: string;\n  private params: RouteParams = {};\n  private query: QueryParams = {};\n  \n  constructor(path: string) {\n    this.path = path;\n  }\n  \n  param<K extends string>(\n    key: K,\n    value: string | number\n  ): RouteBuilder {\n    this.params[key] = value;\n    return this;\n  }\n  \n  queryParam<K extends string>(\n    key: K,\n    value: string | number | boolean | undefined\n  ): RouteBuilder {\n    if (value !== undefined) {\n      this.query[key] = value;\n    }\n    return this;\n  }\n  \n  build(): string {\n    let url = this.path;\n    \n    // Replace path parameters\n    for (const [key, value] of Object.entries(this.params)) {\n      url = url.replace(`:${key}`, String(value));\n    }\n    \n    // Add query parameters\n    const queryString = Object.entries(this.query)\n      .map(([key, value]) => `${key}=${encodeURIComponent(String(value))}`)\n      .join('&');\n    \n    return queryString ? `${url}?${queryString}` : url;\n  }\n}\n\n// Usage\nconst route = new RouteBuilder('/users/:id/posts')\n  .param('id', 123)\n  .queryParam('limit', 10)\n  .queryParam('offset', 0)\n  .build();\n// '/users/123/posts?limit=10&offset=0'\n\n// Advanced: Type-safe endpoint definitions\ntype HTTPMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\n\ninterface EndpointDefinition<TResponse, TRequest = void> {\n  method: HTTPMethod;\n  path: string;\n  request?: TRequest;\n  response: TResponse;\n}\n\ntype APISchema = {\n  getUser: EndpointDefinition<User, { id: number }>;\n  createUser: EndpointDefinition<User, Omit<User, 'id'>>;\n  updateUser: EndpointDefinition<User, { id: number; data: Partial<User> }>;\n  deleteUser: EndpointDefinition<void, { id: number }>;\n};\n\nclass TypedAPI<Schema extends Record<string, EndpointDefinition<any, any>>> {\n  constructor(private baseURL: string) {}\n  \n  async call<K extends keyof Schema>(\n    endpoint: K,\n    ...args: Schema[K]['request'] extends void\n      ? []\n      : [Schema[K]['request']]\n  ): Promise<APIResponse<Schema[K]['response']>> {\n    // Implementation\n    return { success: true, data: {} as Schema[K]['response'] };\n  }\n}\n\nconst api = new TypedAPI<APISchema>('https://api.example.com');\n\n// Type-safe calls\nawait api.call('getUser', { id: 1 });\nawait api.call('createUser', { name: 'John', email: 'john@example.com' });\n// await api.call('getUser'); // Error: missing argument"
    },
    {
      "id": 87,
      "question": "What are advanced TypeScript testing patterns and techniques?",
      "answer": "Advanced TypeScript testing ensures type safety in tests while providing robust verification patterns.\n\nType Testing:\n• Type assertions\n• Expect type helpers\n• Type-level tests\n• Generic test utilities\n• Compiler tests\n\nMocking Patterns:\n• Type-safe mocks\n• Partial mocks\n• Generic mock factories\n• Mock type inference\n• jest.Mock typing\n\nTest Utilities:\n• Type-safe test builders\n• Fixture factories\n• Type-safe matchers\n• Custom assertions\n• Helper functions\n\nAsynchronous Testing:\n• Promise typing\n• Async/await patterns\n• Error handling\n• Type-safe timeouts\n• Race conditions\n\nFramework Integration:\n• Jest with TypeScript\n• Vitest typing\n• Testing Library types\n• Playwright typing\n• Cypress typing\n\nBest Practices:\n• Type test data\n• Mock with types\n• Test type narrowing\n• Use type assertions\n• Avoid any in tests\n• Document test types",
      "explanation": "Advanced TypeScript testing combines type-safe mocks, fixtures, and utilities with framework-specific typing to ensure robust, maintainable test suites.",
      "difficulty": "Hard",
      "code": "import { describe, it, expect, jest } from '@jest/globals';\n\n// Type-safe mock factory\nfunction createMock<T>(\n  partial?: Partial<T>\n): jest.Mocked<Required<T>> {\n  return partial as jest.Mocked<Required<T>>;\n}\n\ninterface UserService {\n  getUser(id: number): Promise<User>;\n  updateUser(id: number, data: Partial<User>): Promise<User>;\n  deleteUser(id: number): Promise<void>;\n}\n\n// Usage\nconst mockUserService = createMock<UserService>({\n  getUser: jest.fn().mockResolvedValue({\n    id: 1,\n    name: 'John',\n    email: 'john@example.com'\n  }),\n  updateUser: jest.fn(),\n  deleteUser: jest.fn()\n});\n\n// Type-safe fixture factory\nclass FixtureFactory<T> {\n  private defaults: T;\n  \n  constructor(defaults: T) {\n    this.defaults = defaults;\n  }\n  \n  create(overrides?: Partial<T>): T {\n    return { ...this.defaults, ...overrides };\n  }\n  \n  createMany(count: number, overrides?: Partial<T>): T[] {\n    return Array.from({ length: count }, () => this.create(overrides));\n  }\n}\n\n// Usage\nconst userFactory = new FixtureFactory<User>({\n  id: 1,\n  name: 'Test User',\n  email: 'test@example.com'\n});\n\nconst user = userFactory.create({ name: 'John' });\nconst users = userFactory.createMany(5);\n\n// Type-level testing\ntype Expect<T extends true> = T;\ntype Equal<X, Y> =\n  (<T>() => T extends X ? 1 : 2) extends\n  (<T>() => T extends Y ? 1 : 2) ? true : false;\n\n// Test types at compile time\ntype TestCases = [\n  Expect<Equal<string, string>>,\n  Expect<Equal<number[], number[]>>,\n  // Expect<Equal<string, number>>, // Would cause compile error\n];\n\n// Type-safe test builders\nclass TestBuilder<T> {\n  private data: Partial<T> = {};\n  \n  with<K extends keyof T>(key: K, value: T[K]): this {\n    this.data[key] = value;\n    return this;\n  }\n  \n  build(required: Required<T>): T {\n    return { ...required, ...this.data };\n  }\n}\n\n// Usage\nconst testUser = new TestBuilder<User>()\n  .with('name', 'John')\n  .with('email', 'john@example.com')\n  .build({ id: 1, name: '', email: '' });\n\n// Custom type-safe matchers\ninterface CustomMatchers<R = unknown> {\n  toBeUser(expected: User): R;\n  toHaveValidEmail(): R;\n}\n\ndeclare global {\n  namespace jest {\n    interface Expect extends CustomMatchers {}\n    interface Matchers<R> extends CustomMatchers<R> {}\n  }\n}\n\nexpect.extend({\n  toBeUser(received: unknown, expected: User) {\n    const pass = \n      typeof received === 'object' &&\n      received !== null &&\n      'id' in received &&\n      'name' in received &&\n      'email' in received &&\n      (received as User).id === expected.id;\n    \n    return {\n      pass,\n      message: () => pass\n        ? `Expected ${received} not to be user ${expected}`\n        : `Expected ${received} to be user ${expected}`\n    };\n  },\n  \n  toHaveValidEmail(received: unknown) {\n    const pass = \n      typeof received === 'object' &&\n      received !== null &&\n      'email' in received &&\n      typeof (received as any).email === 'string' &&\n      (received as any).email.includes('@');\n    \n    return {\n      pass,\n      message: () => pass\n        ? 'Expected not to have valid email'\n        : 'Expected to have valid email'\n    };\n  }\n});\n\n// Usage\nexpect(user).toBeUser({ id: 1, name: 'John', email: 'john@example.com' });\nexpect(user).toHaveValidEmail();\n\n// Async testing patterns\ndescribe('UserService', () => {\n  it('should fetch user', async () => {\n    const service = new UserService();\n    const user = await service.getUser(1);\n    \n    expect(user).toBeDefined();\n    expect(user.id).toBe(1);\n  });\n  \n  it('should handle errors', async () => {\n    const service = new UserService();\n    \n    await expect(service.getUser(-1))\n      .rejects\n      .toThrow('User not found');\n  });\n});\n\n// Type-safe spy\nfunction createSpy<T extends (...args: any[]) => any>(\n  implementation?: T\n): jest.MockedFunction<T> {\n  return jest.fn(implementation) as jest.MockedFunction<T>;\n}\n\nconst getUserSpy = createSpy<UserService['getUser']>();\ngetUserSpy.mockResolvedValue({\n  id: 1,\n  name: 'John',\n  email: 'john@example.com'\n});\n\n// Testing type guards\nfunction isUser(value: unknown): value is User {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    'id' in value &&\n    'name' in value &&\n    'email' in value\n  );\n}\n\ndescribe('isUser', () => {\n  it('should validate user objects', () => {\n    const validUser = { id: 1, name: 'John', email: 'john@example.com' };\n    const invalidUser = { id: 1, name: 'John' };\n    \n    expect(isUser(validUser)).toBe(true);\n    expect(isUser(invalidUser)).toBe(false);\n  });\n});"
    },
    {
      "id": 88,
      "question": "How do you handle complex data transformations with TypeScript?",
      "answer": "Complex data transformations in TypeScript use mapped types, generics, and utilities for type-safe operations.\n\nTransformation Patterns:\n• Mapped type transformations\n• Recursive transformations\n• Conditional transformations\n• Key remapping\n• Value transformations\n\nUtility Types:\n• Pick, Omit, Partial\n• Record, Extract, Exclude\n• Custom utility types\n• Recursive utilities\n• Generic transformers\n\nData Mapping:\n• Type-safe mappers\n• Schema transformations\n• DTO conversions\n• Normalization\n• Denormalization\n\nValidation:\n• Runtime validation\n• Schema validation libraries\n• Type narrowing\n• Assertion functions\n• Parser combinators\n\nPerformance:\n• Lazy transformations\n• Memoization\n• Batch processing\n• Stream processing\n• Optimization strategies\n\nBest Practices:\n• Type transformations at boundaries\n• Validate external data\n• Immutable transformations\n• Pure functions\n• Document complex types\n• Test edge cases",
      "explanation": "Complex data transformations use TypeScript's type system with mapped types, generics, and validation to ensure type-safe conversions and manipulations.",
      "difficulty": "Hard",
      "code": "// API to Domain transformation\ninterface UserAPI {\n  user_id: number;\n  full_name: string;\n  email_address: string;\n  created_at: string;\n  is_active: boolean;\n}\n\ninterface UserDomain {\n  id: number;\n  name: string;\n  email: string;\n  createdAt: Date;\n  active: boolean;\n}\n\n// Type-safe transformer\nclass Transformer<TSource, TTarget> {\n  constructor(\n    private transform: (source: TSource) => TTarget\n  ) {}\n  \n  map(source: TSource): TTarget {\n    return this.transform(source);\n  }\n  \n  mapArray(sources: TSource[]): TTarget[] {\n    return sources.map(this.transform);\n  }\n}\n\nconst userTransformer = new Transformer<UserAPI, UserDomain>((api) => ({\n  id: api.user_id,\n  name: api.full_name,\n  email: api.email_address,\n  createdAt: new Date(api.created_at),\n  active: api.is_active\n}));\n\n// Deep transformation\ntype DeepTransform<T, TFrom, TTo> = {\n  [K in keyof T]: T[K] extends TFrom\n    ? TTo\n    : T[K] extends object\n    ? DeepTransform<T[K], TFrom, TTo>\n    : T[K];\n};\n\ntype APIData = {\n  created: string;\n  updated: string;\n  user: {\n    joined: string;\n    lastLogin: string;\n  };\n};\n\ntype DomainData = DeepTransform<APIData, string, Date>;\n// All string dates become Date objects\n\n// Generic normalization\ntype Normalized<T, K extends keyof T> = {\n  byId: Record<T[K] & (string | number), T>;\n  allIds: Array<T[K] & (string | number)>;\n};\n\nfunction normalize<T, K extends keyof T>(\n  items: T[],\n  key: K\n): Normalized<T, K> {\n  const byId: any = {};\n  const allIds: any[] = [];\n  \n  for (const item of items) {\n    const id = item[key];\n    byId[id as any] = item;\n    allIds.push(id);\n  }\n  \n  return { byId, allIds };\n}\n\n// Usage\nconst users: UserDomain[] = [\n  { id: 1, name: 'John', email: 'john@example.com', createdAt: new Date(), active: true },\n  { id: 2, name: 'Jane', email: 'jane@example.com', createdAt: new Date(), active: true }\n];\n\nconst normalized = normalize(users, 'id');\n// { byId: { 1: User, 2: User }, allIds: [1, 2] }\n\n// Schema-based transformation\ntype Schema<T> = {\n  [K in keyof T]: {\n    from: string | ((data: any) => T[K]);\n    validate?: (value: T[K]) => boolean;\n    transform?: (value: any) => T[K];\n  };\n};\n\nclass SchemaTransformer<T> {\n  constructor(private schema: Schema<T>) {}\n  \n  transform(data: Record<string, any>): T {\n    const result: Partial<T> = {};\n    \n    for (const [key, config] of Object.entries(this.schema)) {\n      const sourceKey = typeof config.from === 'string' ? config.from : null;\n      const value = sourceKey ? data[sourceKey] : config.from(data);\n      \n      if (config.validate && !config.validate(value)) {\n        throw new Error(`Validation failed for ${key}`);\n      }\n      \n      result[key as keyof T] = config.transform\n        ? config.transform(value)\n        : value;\n    }\n    \n    return result as T;\n  }\n}\n\n// Usage\nconst userSchema: Schema<UserDomain> = {\n  id: {\n    from: 'user_id',\n    validate: (v) => typeof v === 'number'\n  },\n  name: {\n    from: 'full_name'\n  },\n  email: {\n    from: 'email_address',\n    validate: (v) => v.includes('@')\n  },\n  createdAt: {\n    from: 'created_at',\n    transform: (v) => new Date(v)\n  },\n  active: {\n    from: 'is_active'\n  }\n};\n\nconst transformer = new SchemaTransformer(userSchema);\n\n// Partial updates\ntype UpdatePayload<T> = {\n  [K in keyof T]?: {\n    value: T[K];\n    timestamp: Date;\n  };\n};\n\nfunction applyUpdate<T extends object>(\n  target: T,\n  updates: UpdatePayload<T>\n): T {\n  const result = { ...target };\n  \n  for (const [key, update] of Object.entries(updates)) {\n    if (update && 'value' in update) {\n      (result as any)[key] = update.value;\n    }\n  }\n  \n  return result;\n}\n\n// Flatten nested objects\ntype Flatten<T, Prefix extends string = ''> = T extends object\n  ? {\n      [K in keyof T as K extends string\n        ? `${Prefix}${K}`\n        : never\n      ]: T[K] extends object\n        ? Flatten<T[K], `${Prefix}${K & string}.`>\n        : T[K];\n    }[keyof T]\n  : T;\n\ntype Nested = {\n  user: {\n    profile: {\n      name: string;\n    };\n  };\n};\n\ntype Flat = Flatten<Nested>;\n// { 'user.profile.name': string }"
    },
    {
      "id": 89,
      "question": "What are best practices for TypeScript in large-scale applications?",
      "answer": "Large-scale TypeScript applications require careful architecture, organization, and tooling for maintainability.\n\nCode Organization:\n• Feature-based structure\n• Layered architecture\n• Module boundaries\n• Clear dependencies\n• Shared code libraries\n• Monorepo strategies\n\nType Management:\n• Centralized type definitions\n• Shared types package\n• Avoid type duplication\n• Version types with APIs\n• Document complex types\n• Type testing\n\nPerformance:\n• Project references\n• Incremental compilation\n• Build caching\n• Lazy loading\n• Code splitting\n• Optimization\n\nCode Quality:\n• Strict mode enabled\n• ESLint configuration\n• Prettier formatting\n• Pre-commit hooks\n• Code review practices\n• Documentation\n\nTesting:\n• Type testing\n• Unit tests\n• Integration tests\n• E2E tests\n• Test coverage\n• CI/CD integration\n\nTeam Practices:\n• Style guide\n• Architecture decisions\n• Code ownership\n• Knowledge sharing\n• Onboarding materials\n• Regular reviews",
      "explanation": "Large-scale TypeScript applications require structured organization, centralized type management, performance optimization, quality standards, and strong team practices.",
      "difficulty": "Hard",
      "code": "// Project structure\n// /packages\n//   /types         - Shared type definitions\n//   /utils         - Shared utilities\n//   /core          - Core business logic\n//   /api           - API client\n//   /ui            - UI components\n//   /app           - Application\n\n// Centralized types package\n// packages/types/src/domain/index.ts\nexport interface User {\n  id: string;\n  name: string;\n  email: string;\n  role: UserRole;\n}\n\nexport type UserRole = 'admin' | 'user' | 'guest';\n\nexport interface ApiResponse<T> {\n  data: T;\n  meta: ResponseMeta;\n}\n\nexport interface ResponseMeta {\n  timestamp: Date;\n  requestId: string;\n}\n\n// Strict tsconfig.json\n{\n  \"compilerOptions\": {\n    // Strict checks\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true,\n    \"strictFunctionTypes\": true,\n    \"strictBindCallApply\": true,\n    \"strictPropertyInitialization\": true,\n    \"noImplicitThis\": true,\n    \"alwaysStrict\": true,\n    \n    // Additional checks\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"noImplicitReturns\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"noUncheckedIndexedAccess\": true,\n    \"noImplicitOverride\": true,\n    \"allowUnusedLabels\": false,\n    \"allowUnreachableCode\": false,\n    \n    // Module system\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"bundler\",\n    \"esModuleInterop\": true,\n    \"resolveJsonModule\": true,\n    \n    // Performance\n    \"incremental\": true,\n    \"composite\": true,\n    \"skipLibCheck\": true,\n    \n    // Output\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true,\n    \"outDir\": \"./dist\"\n  }\n}\n\n// ESLint configuration\n// .eslintrc.json\n{\n  \"extends\": [\n    \"eslint:recommended\",\n    \"plugin:@typescript-eslint/recommended\",\n    \"plugin:@typescript-eslint/recommended-requiring-type-checking\"\n  ],\n  \"parser\": \"@typescript-eslint/parser\",\n  \"parserOptions\": {\n    \"project\": \"./tsconfig.json\"\n  },\n  \"rules\": {\n    \"@typescript-eslint/explicit-function-return-type\": \"warn\",\n    \"@typescript-eslint/no-explicit-any\": \"error\",\n    \"@typescript-eslint/no-unused-vars\": \"error\",\n    \"@typescript-eslint/strict-boolean-expressions\": \"warn\"\n  }\n}\n\n// Layered architecture\n// Domain layer\nexport class UserEntity {\n  constructor(\n    public readonly id: string,\n    public readonly email: string,\n    private _name: string\n  ) {}\n  \n  get name(): string {\n    return this._name;\n  }\n  \n  changeName(newName: string): void {\n    if (newName.length < 2) {\n      throw new Error('Name too short');\n    }\n    this._name = newName;\n  }\n}\n\n// Repository pattern\nexport interface IUserRepository {\n  findById(id: string): Promise<UserEntity | null>;\n  save(user: UserEntity): Promise<void>;\n  delete(id: string): Promise<void>;\n}\n\n// Service layer\nexport class UserService {\n  constructor(private repository: IUserRepository) {}\n  \n  async updateUserName(id: string, name: string): Promise<void> {\n    const user = await this.repository.findById(id);\n    if (!user) {\n      throw new Error('User not found');\n    }\n    \n    user.changeName(name);\n    await this.repository.save(user);\n  }\n}\n\n// Dependency injection\nclass Container {\n  private services = new Map<string, any>();\n  \n  register<T>(key: string, factory: () => T): void {\n    this.services.set(key, factory);\n  }\n  \n  resolve<T>(key: string): T {\n    const factory = this.services.get(key);\n    if (!factory) {\n      throw new Error(`Service not found: ${key}`);\n    }\n    return factory();\n  }\n}\n\nconst container = new Container();\ncontainer.register('userRepository', () => new UserRepository());\ncontainer.register('userService', () => \n  new UserService(container.resolve('userRepository'))\n);\n\n// Error handling strategy\nexport class ApplicationError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string,\n    public readonly statusCode: number\n  ) {\n    super(message);\n    this.name = 'ApplicationError';\n  }\n}\n\nexport class NotFoundError extends ApplicationError {\n  constructor(resource: string) {\n    super(`${resource} not found`, 'NOT_FOUND', 404);\n  }\n}\n\nexport class ValidationError extends ApplicationError {\n  constructor(message: string) {\n    super(message, 'VALIDATION_ERROR', 400);\n  }\n}\n\n// Type guards for runtime checking\nexport function isUser(value: unknown): value is User {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    'id' in value &&\n    'email' in value &&\n    'name' in value\n  );\n}\n\n// CI/CD integration\n// .github/workflows/ci.yml\n// name: CI\n// on: [push, pull_request]\n// jobs:\n//   test:\n//     runs-on: ubuntu-latest\n//     steps:\n//       - uses: actions/checkout@v2\n//       - uses: actions/setup-node@v2\n//       - run: npm ci\n//       - run: npm run typecheck\n//       - run: npm run lint\n//       - run: npm run test\n//       - run: npm run build"
    },
    {
      "id": 90,
      "question": "How do you implement custom utility types for domain-specific problems?",
      "answer": "Custom utility types solve domain-specific problems through type-level programming and advanced TypeScript features.\n\nUtility Type Patterns:\n• Recursive types\n• Conditional types\n• Mapped types\n• Template literals\n• Type inference\n• Variadic tuples\n\nDomain Applications:\n• Database models\n• API contracts\n• Form validation\n• State management\n• Event systems\n• Configuration\n\nComposition:\n• Building complex types\n• Reusable utilities\n• Type transformations\n• Generic constraints\n• Type algebra\n\nPerformance:\n• Type complexity limits\n• Recursion depth\n• Instantiation limits\n• Optimization techniques\n• Caching strategies\n\nDocumentation:\n• JSDoc comments\n• Usage examples\n• Type constraints\n• Edge cases\n• Performance notes\n\nBest Practices:\n• Keep types focused\n• Document thoroughly\n• Test with examples\n• Consider alternatives\n• Version carefully\n• Maintain compatibility",
      "explanation": "Custom utility types leverage TypeScript's type system to solve domain-specific problems through recursive, conditional, and mapped type patterns.",
      "difficulty": "Hard",
      "code": "// Database query builder types\ntype WhereOperator = '=' | '!=' | '>' | '<' | '>=' | '<=' | 'LIKE' | 'IN';\n\ntype WhereCondition<T> = {\n  [K in keyof T]?: {\n    operator: WhereOperator;\n    value: T[K] | T[K][];\n  } | T[K];\n};\n\ntype SelectFields<T> = (keyof T)[] | '*';\n\ntype QueryBuilder<T> = {\n  select: SelectFields<T>;\n  where?: WhereCondition<T>;\n  orderBy?: Array<{ field: keyof T; direction: 'ASC' | 'DESC' }>;\n  limit?: number;\n};\n\n// Usage\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  age: number;\n}\n\nconst query: QueryBuilder<User> = {\n  select: ['id', 'name', 'email'],\n  where: {\n    age: { operator: '>', value: 18 },\n    email: { operator: 'LIKE', value: '%@example.com' }\n  },\n  orderBy: [{ field: 'name', direction: 'ASC' }],\n  limit: 10\n};\n\n// Deep partial with specific paths\ntype PathsToStringProps<T> = T extends string\n  ? []\n  : {\n      [K in Extract<keyof T, string>]: [K, ...PathsToStringProps<T[K]>];\n    }[Extract<keyof T, string>];\n\ntype Join<T extends string[], D extends string = '.'> = \n  T extends []\n    ? never\n    : T extends [infer F]\n    ? F\n    : T extends [infer F, ...infer R]\n    ? F extends string\n      ? R extends string[]\n        ? `${F}${D}${Join<R, D>}`\n        : never\n      : never\n    : string;\n\ntype DeepPartialByPath<T, P extends string> = \n  P extends `${infer K}.${infer Rest}`\n    ? K extends keyof T\n      ? { [Key in K]: DeepPartialByPath<T[Key], Rest> }\n      : never\n    : P extends keyof T\n    ? { [Key in P]?: T[Key] }\n    : never;\n\n// Form state types\ntype FormField<T> = {\n  value: T;\n  error?: string;\n  touched: boolean;\n  dirty: boolean;\n};\n\ntype FormState<T> = {\n  [K in keyof T]: FormField<T[K]>;\n};\n\ntype FormActions<T> = {\n  [K in keyof T as `set${Capitalize<string & K>}`]: (\n    value: T[K]\n  ) => void;\n} & {\n  [K in keyof T as `${string & K}Error`]: string | undefined;\n};\n\n// Usage\ninterface LoginForm {\n  email: string;\n  password: string;\n}\n\nconst formState: FormState<LoginForm> = {\n  email: {\n    value: '',\n    touched: false,\n    dirty: false\n  },\n  password: {\n    value: '',\n    touched: false,\n    dirty: false\n  }\n};\n\n// Event emitter with typed events\ntype EventMap = Record<string, any>;\n\ntype EventKey<T extends EventMap> = string & keyof T;\ntype EventReceiver<T> = (params: T) => void;\n\ninterface TypedEventEmitter<T extends EventMap> {\n  on<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): void;\n  off<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): void;\n  emit<K extends EventKey<T>>(eventName: K, params: T[K]): void;\n}\n\n// Required by keys\ntype RequireByKeys<T, K extends keyof T> = \n  Omit<T, K> & Required<Pick<T, K>>;\n\ntype OptionalUser = {\n  id: number;\n  name?: string;\n  email?: string;\n};\n\ntype UserWithName = RequireByKeys<OptionalUser, 'name'>;\n// { id: number; email?: string; name: string }\n\n// Mutable version\ntype Mutable<T> = {\n  -readonly [K in keyof T]: T[K] extends object\n    ? Mutable<T[K]>\n    : T[K];\n};\n\ntype ReadonlyConfig = {\n  readonly host: string;\n  readonly port: number;\n  readonly db: {\n    readonly name: string;\n  };\n};\n\ntype MutableConfig = Mutable<ReadonlyConfig>;\n// All readonly modifiers removed\n\n// Exact type (no extra properties)\ntype Exact<T, Shape> = T extends Shape\n  ? Exclude<keyof T, keyof Shape> extends never\n    ? T\n    : never\n  : never;\n\nfunction create<T, Shape>(data: Exact<T, Shape>): Shape {\n  return data;\n}\n\n// OK\ncreate<{ id: number; name: string }, { id: number; name: string }>({\n  id: 1,\n  name: 'test'\n});\n\n// Error: extra property\n// create<{ id: number; name: string; extra: string }, { id: number; name: string }>({\n//   id: 1,\n//   name: 'test',\n//   extra: 'value'\n// });\n\n// Type-safe enum from object\nconst Colors = {\n  Red: 'red',\n  Green: 'green',\n  Blue: 'blue'\n} as const;\n\ntype Color = typeof Colors[keyof typeof Colors];\n// 'red' | 'green' | 'blue'\n\n// Function that returns itself for chaining\ntype Chainable<T = {}> = {\n  option<K extends string, V>(\n    key: K,\n    value: V\n  ): Chainable<T & { [P in K]: V }>;\n  get(): T;\n};\n\nconst config: Chainable = {\n  option(key, value) {\n    return this;\n  },\n  get() {\n    return {} as any;\n  }\n};\n\nconst result = config\n  .option('host', 'localhost')\n  .option('port', 3000)\n  .get();\n// Type: { host: string; port: number }"
    },
    {
      "id": 91,
      "question": "What are TypeScript compiler internals and how does type checking work?",
      "answer": "Understanding TypeScript compiler internals helps optimize code and understand compilation behavior.\n\nCompilation Phases:\n• Parsing (source to AST)\n• Binding (symbol creation)\n• Type checking\n• Transformation\n• Emit (JavaScript output)\n\nType Checking:\n• Structural type system\n• Type inference\n• Control flow analysis\n• Type compatibility\n• Constraint resolution\n\nAST Structure:\n• Syntax nodes\n• Symbol tables\n• Type information\n• Source locations\n• Comments preservation\n\nProgram API:\n• createProgram function\n• Type checker\n• Source files\n• Compiler options\n• Diagnostics\n\nOptimizations:\n• Incremental checking\n• Project references\n• Watch mode caching\n• Skip lib check\n• Module resolution cache\n\nCustomization:\n• Custom transformers\n• Plugin system\n• Language service\n• Compiler API\n• Build tools integration",
      "explanation": "TypeScript compiler processes code through parsing, binding, type checking, transformation, and emit phases, using a structural type system with control flow analysis.",
      "difficulty": "Hard",
      "code": "// Using TypeScript Compiler API\nimport * as ts from 'typescript';\n\n// Create program\nconst configFileName = 'tsconfig.json';\nconst configFile = ts.readConfigFile(\n  configFileName,\n  ts.sys.readFile\n);\n\nconst parsedConfig = ts.parseJsonConfigFileContent(\n  configFile.config,\n  ts.sys,\n  './'\n);\n\nconst program = ts.createProgram({\n  rootNames: parsedConfig.fileNames,\n  options: parsedConfig.options\n});\n\n// Get type checker\nconst checker = program.getTypeChecker();\n\n// Analyze source file\nfunction analyzeFile(sourceFile: ts.SourceFile) {\n  // Visit AST nodes\n  function visit(node: ts.Node) {\n    // Check for function declarations\n    if (ts.isFunctionDeclaration(node) && node.name) {\n      const symbol = checker.getSymbolAtLocation(node.name);\n      if (symbol) {\n        const type = checker.getTypeOfSymbolAtLocation(\n          symbol,\n          symbol.valueDeclaration!\n        );\n        console.log(`Function: ${symbol.name}`);\n        console.log(`Type: ${checker.typeToString(type)}`);\n      }\n    }\n    \n    // Recursively visit children\n    ts.forEachChild(node, visit);\n  }\n  \n  visit(sourceFile);\n}\n\n// Get diagnostics\nconst diagnostics = [\n  ...program.getSyntacticDiagnostics(),\n  ...program.getSemanticDiagnostics(),\n  ...program.getDeclarationDiagnostics()\n];\n\ndiagnostics.forEach(diagnostic => {\n  const message = ts.flattenDiagnosticMessageText(\n    diagnostic.messageText,\n    '\\n'\n  );\n  \n  if (diagnostic.file) {\n    const { line, character } = diagnostic.file.getLineAndCharacterOfPosition(\n      diagnostic.start!\n    );\n    console.log(\n      `${diagnostic.file.fileName} (${line + 1},${character + 1}): ${message}`\n    );\n  } else {\n    console.log(message);\n  }\n});\n\n// Custom transformer\nconst transformer: ts.TransformerFactory<ts.SourceFile> = (context) => {\n  return (sourceFile) => {\n    const visitor = (node: ts.Node): ts.Node => {\n      // Transform console.log calls\n      if (\n        ts.isCallExpression(node) &&\n        ts.isPropertyAccessExpression(node.expression) &&\n        node.expression.expression.getText() === 'console' &&\n        node.expression.name.getText() === 'log'\n      ) {\n        // Add file and line info\n        const { line } = sourceFile.getLineAndCharacterOfPosition(\n          node.getStart()\n        );\n        \n        const newArgs = [\n          ts.factory.createStringLiteral(\n            `[${sourceFile.fileName}:${line + 1}]`\n          ),\n          ...node.arguments\n        ];\n        \n        return ts.factory.updateCallExpression(\n          node,\n          node.expression,\n          node.typeArguments,\n          newArgs\n        );\n      }\n      \n      return ts.visitEachChild(node, visitor, context);\n    };\n    \n    return ts.visitNode(sourceFile, visitor);\n  };\n};\n\n// Emit with transformer\nprogram.emit(\n  undefined,\n  undefined,\n  undefined,\n  undefined,\n  { before: [transformer] }\n);\n\n// Type checker utilities\nfunction getTypeInfo(node: ts.Node) {\n  const type = checker.getTypeAtLocation(node);\n  \n  return {\n    typeString: checker.typeToString(type),\n    isAny: type.flags & ts.TypeFlags.Any,\n    isUnknown: type.flags & ts.TypeFlags.Unknown,\n    isNever: type.flags & ts.TypeFlags.Never,\n    isString: type.flags & ts.TypeFlags.String,\n    isNumber: type.flags & ts.TypeFlags.Number,\n    isBoolean: type.flags & ts.TypeFlags.Boolean,\n    properties: type.getProperties().map(prop => ({\n      name: prop.name,\n      type: checker.typeToString(\n        checker.getTypeOfSymbolAtLocation(prop, node)\n      )\n    }))\n  };\n}\n\n// Language service\nconst services = ts.createLanguageService(\n  {\n    getScriptFileNames: () => parsedConfig.fileNames,\n    getScriptVersion: () => '0',\n    getScriptSnapshot: (fileName) => {\n      const content = ts.sys.readFile(fileName);\n      return content\n        ? ts.ScriptSnapshot.fromString(content)\n        : undefined;\n    },\n    getCurrentDirectory: () => process.cwd(),\n    getCompilationSettings: () => parsedConfig.options,\n    getDefaultLibFileName: (options) =>\n      ts.getDefaultLibFilePath(options)\n  },\n  ts.createDocumentRegistry()\n);\n\n// Get completions\nconst completions = services.getCompletionsAtPosition(\n  'src/index.ts',\n  100, // position\n  {}\n);\n\nif (completions) {\n  completions.entries.forEach(entry => {\n    console.log(`${entry.name}: ${entry.kind}`);\n  });\n}\n\n// Get quick info\nconst quickInfo = services.getQuickInfoAtPosition(\n  'src/index.ts',\n  100\n);\n\nif (quickInfo) {\n  console.log(ts.displayPartsToString(quickInfo.displayParts));\n}\n\n// Control flow analysis\nfunction analyzeControlFlow(node: ts.Node) {\n  // Get flow nodes for narrowing\n  const flowNode = (node as any).flowNode;\n  if (flowNode) {\n    // Analyze type narrowing\n    console.log('Control flow node:', flowNode.flags);\n  }\n}"
    },
    {
      "id": 92,
      "question": "How do you implement schema validation with TypeScript?",
      "answer": "Schema validation combines runtime validation with compile-time type safety through various libraries and patterns.\n\nValidation Libraries:\n• Zod for schema validation\n• Yup for object schemas\n• Joi for validation\n• io-ts for runtime types\n• AJV for JSON schema\n• Custom validators\n\nType Inference:\n• Infer types from schemas\n• Runtime to compile-time\n• Automatic type generation\n• Type narrowing\n• Generic validation\n\nPatterns:\n• Schema-first approach\n• Type-first approach\n• Hybrid approach\n• Parser combinators\n• Builder patterns\n\nError Handling:\n• Typed error messages\n• Error paths\n• Custom error types\n• Error aggregation\n• User-friendly messages\n\nIntegration:\n• API validation\n• Form validation\n• Config validation\n• Database models\n• Environment variables\n\nBest Practices:\n• Validate at boundaries\n• Type from schema\n• Compose validators\n• Reuse schemas\n• Test validation\n• Document constraints",
      "explanation": "Schema validation in TypeScript combines runtime checking with type inference from schemas, using libraries like Zod or io-ts for type-safe validation.",
      "difficulty": "Hard",
      "code": "// Using Zod\nimport { z } from 'zod';\n\n// Define schema\nconst UserSchema = z.object({\n  id: z.number(),\n  name: z.string().min(2).max(50),\n  email: z.string().email(),\n  age: z.number().min(0).max(120).optional(),\n  role: z.enum(['admin', 'user', 'guest']),\n  tags: z.array(z.string()),\n  metadata: z.record(z.unknown())\n});\n\n// Infer type from schema\ntype User = z.infer<typeof UserSchema>;\n// Type automatically matches schema\n\n// Validate data\nfunction validateUser(data: unknown): User {\n  return UserSchema.parse(data); // Throws on invalid\n}\n\n// Safe parse (no throw)\nconst result = UserSchema.safeParse(data);\nif (result.success) {\n  const user: User = result.data;\n} else {\n  console.error(result.error.errors);\n}\n\n// Custom validation\nconst PasswordSchema = z\n  .string()\n  .min(8)\n  .regex(/[A-Z]/, 'Must contain uppercase')\n  .regex(/[a-z]/, 'Must contain lowercase')\n  .regex(/[0-9]/, 'Must contain number');\n\n// Refinements\nconst RegisterSchema = z.object({\n  email: z.string().email(),\n  password: PasswordSchema,\n  confirmPassword: z.string()\n}).refine(\n  (data) => data.password === data.confirmPassword,\n  {\n    message: 'Passwords must match',\n    path: ['confirmPassword']\n  }\n);\n\n// Transformations\nconst DateSchema = z.string().transform((str) => new Date(str));\n\nconst EventSchema = z.object({\n  name: z.string(),\n  date: DateSchema // String in, Date out\n});\n\ntype Event = z.infer<typeof EventSchema>;\n// { name: string; date: Date }\n\n// Using io-ts\nimport * as t from 'io-ts';\nimport { isRight } from 'fp-ts/Either';\n\n// Define codec\nconst UserCodec = t.type({\n  id: t.number,\n  name: t.string,\n  email: t.string,\n  age: t.union([t.number, t.undefined]),\n  role: t.keyof({\n    admin: null,\n    user: null,\n    guest: null\n  })\n});\n\n// Infer type\ntype UserType = t.TypeOf<typeof UserCodec>;\n\n// Validate\nfunction decodeUser(input: unknown): UserType {\n  const result = UserCodec.decode(input);\n  if (isRight(result)) {\n    return result.right;\n  }\n  throw new Error('Validation failed');\n}\n\n// Custom validator pattern\nclass Validator<T> {\n  private rules: Array<(value: T) => string | null> = [];\n  \n  rule(fn: (value: T) => boolean, message: string): this {\n    this.rules.push((value) => fn(value) ? null : message);\n    return this;\n  }\n  \n  validate(value: T): { valid: boolean; errors: string[] } {\n    const errors = this.rules\n      .map(rule => rule(value))\n      .filter((error): error is string => error !== null);\n    \n    return {\n      valid: errors.length === 0,\n      errors\n    };\n  }\n}\n\n// Usage\nconst emailValidator = new Validator<string>()\n  .rule(v => v.length > 0, 'Email required')\n  .rule(v => v.includes('@'), 'Invalid email format')\n  .rule(v => v.length <= 100, 'Email too long');\n\nconst result2 = emailValidator.validate('test@example.com');\n\n// Generic schema builder\ninterface Schema<T> {\n  parse(value: unknown): T;\n  validate(value: unknown): { valid: boolean; errors: string[] };\n}\n\nclass ObjectSchema<T extends Record<string, any>> implements Schema<T> {\n  constructor(\n    private fields: {\n      [K in keyof T]: Schema<T[K]>;\n    }\n  ) {}\n  \n  parse(value: unknown): T {\n    if (typeof value !== 'object' || value === null) {\n      throw new Error('Expected object');\n    }\n    \n    const result: any = {};\n    for (const [key, schema] of Object.entries(this.fields)) {\n      result[key] = schema.parse((value as any)[key]);\n    }\n    \n    return result as T;\n  }\n  \n  validate(value: unknown): { valid: boolean; errors: string[] } {\n    const errors: string[] = [];\n    \n    if (typeof value !== 'object' || value === null) {\n      return { valid: false, errors: ['Expected object'] };\n    }\n    \n    for (const [key, schema] of Object.entries(this.fields)) {\n      const fieldResult = schema.validate((value as any)[key]);\n      if (!fieldResult.valid) {\n        errors.push(...fieldResult.errors.map(e => `${key}: ${e}`));\n      }\n    }\n    \n    return { valid: errors.length === 0, errors };\n  }\n}\n\nclass StringSchema implements Schema<string> {\n  parse(value: unknown): string {\n    if (typeof value !== 'string') {\n      throw new Error('Expected string');\n    }\n    return value;\n  }\n  \n  validate(value: unknown): { valid: boolean; errors: string[] } {\n    if (typeof value !== 'string') {\n      return { valid: false, errors: ['Expected string'] };\n    }\n    return { valid: true, errors: [] };\n  }\n}\n\n// Usage\nconst schema = new ObjectSchema({\n  name: new StringSchema(),\n  email: new StringSchema()\n});\n\nconst parsed = schema.parse({ name: 'John', email: 'john@example.com' });"
    },
    {
      "id": 93,
      "question": "What are TypeScript's memory and performance considerations?",
      "answer": "Memory and performance optimization in TypeScript involves understanding compilation costs and runtime implications.\n\nCompile-Time Memory:\n• Type complexity cost\n• AST size\n• Symbol table size\n• Type instantiations\n• Recursion depth\n• Cache usage\n\nRuntime Performance:\n• No type overhead\n• Enum implementation\n• Class vs interface\n• Getter/setter cost\n• Decorators overhead\n• Async/await impact\n\nOptimization Strategies:\n• Simplify types\n• Limit recursion\n• Use const enums\n• Prefer interfaces\n• Skip lib check\n• Project references\n\nMemory Leaks:\n• Event listeners\n• Circular references\n• Large closures\n• Cached data\n• Unsubscribed observables\n\nMonitoring:\n• Compiler diagnostics\n• Build time tracking\n• Memory profiling\n• Bundle size analysis\n• Performance testing\n\nBest Practices:\n• Profile before optimizing\n• Measure impact\n• Use appropriate types\n• Clean up resources\n• Monitor build times\n• Optimize hot paths",
      "explanation": "TypeScript performance involves compile-time costs from type checking and minimal runtime overhead, with optimization through type simplification and proper configuration.",
      "difficulty": "Medium",
      "code": "// Compile-time optimization\n// Bad: Deep recursion (expensive)\ntype DeepBad<T, N extends number = 50> = N extends 0\n  ? T\n  : { nested: DeepBad<T, Prev<N>> };\n\n// Good: Limited depth\ntype DeepGood<T, N extends number = 5> = N extends 0\n  ? T\n  : { nested: DeepGood<T, Prev<N>> };\n\n// Bad: Complex union (slow type checking)\ntype ComplexUnion = \n  | TypeA\n  | TypeB\n  | TypeC\n  | TypeD\n  | TypeE\n  | TypeF\n  | TypeG\n  | TypeH;\n\n// Good: Grouped unions\ntype Group1 = TypeA | TypeB | TypeC | TypeD;\ntype Group2 = TypeE | TypeF | TypeG | TypeH;\ntype SimpleUnion = Group1 | Group2;\n\n// Runtime optimization\n// const enum (inlined, no runtime cost)\nconst enum Direction {\n  Up,\n  Down,\n  Left,\n  Right\n}\n\nconst dir = Direction.Up; // Compiles to: const dir = 0;\n\n// Regular enum (runtime object)\nenum Status {\n  Pending,\n  Active,\n  Completed\n}\n// Generates runtime code\n\n// Alternative: Union type (no runtime cost)\ntype State = 'pending' | 'active' | 'completed';\n\n// Interface vs Type (interface is faster)\ninterface User {\n  id: number;\n  name: string;\n}\n// Preferred for simple shapes\n\ntype UserType = {\n  id: number;\n  name: string;\n};\n// Use for unions/intersections\n\n// Avoid complex computed types in hot paths\n// Bad: Type computed on every access\ntype ComputedType<T> = T extends string\n  ? { stringProp: T }\n  : { otherProp: T };\n\n// Good: Pre-compute if possible\ntype StringType = { stringProp: string };\ntype OtherType = { otherProp: unknown };\n\n// Memory leak prevention\nclass EventEmitter {\n  private listeners = new Map<string, Function[]>();\n  \n  on(event: string, handler: Function): () => void {\n    const handlers = this.listeners.get(event) || [];\n    handlers.push(handler);\n    this.listeners.set(event, handlers);\n    \n    // Return cleanup function\n    return () => this.off(event, handler);\n  }\n  \n  off(event: string, handler: Function): void {\n    const handlers = this.listeners.get(event);\n    if (handlers) {\n      const index = handlers.indexOf(handler);\n      if (index > -1) {\n        handlers.splice(index, 1);\n      }\n    }\n  }\n  \n  // Clean up all listeners\n  removeAllListeners(): void {\n    this.listeners.clear();\n  }\n}\n\n// Usage pattern\nconst emitter = new EventEmitter();\nconst unsubscribe = emitter.on('event', () => {});\n\n// Always clean up\nunsubscribe();\n// or\nemitter.removeAllListeners();\n\n// Efficient property access\nclass OptimizedClass {\n  // Direct property (faster)\n  public directProp: string = '';\n  \n  // Getter (slower, but sometimes necessary)\n  private _computedProp: string = '';\n  get computedProp(): string {\n    return this._computedProp;\n  }\n  \n  // Avoid expensive getters in loops\n  process(items: string[]): void {\n    // Bad: getter called every iteration\n    // for (let i = 0; i < items.length; i++) {\n    //   console.log(this.computedProp);\n    // }\n    \n    // Good: cache getter result\n    const prop = this.computedProp;\n    for (let i = 0; i < items.length; i++) {\n      console.log(prop);\n    }\n  }\n}\n\n// Measure compilation performance\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"diagnostics\": true, // Show timing info\n    \"extendedDiagnostics\": true, // Detailed timing\n    \"generateCpuProfile\": \"profile.cpuprofile\" // CPU profile\n  }\n}\n\n// Command line\n// tsc --diagnostics --extendedDiagnostics\n\n// Bundle size optimization\n// Use dynamic imports for code splitting\nasync function loadFeature() {\n  const module = await import('./feature');\n  return module.default;\n}\n\n// Tree-shaking friendly exports\nexport { specificFunction } from './utils';\n// Instead of: export * from './utils';\n\n// Avoid large type definitions in bundles\n// types.d.ts (not included in bundle)\nexport interface LargeType {\n  // Many properties\n}\n\n// Memory profiling\nfunction profileMemory() {\n  if (performance.memory) {\n    console.log({\n      usedJSHeapSize: performance.memory.usedJSHeapSize,\n      totalJSHeapSize: performance.memory.totalJSHeapSize,\n      jsHeapSizeLimit: performance.memory.jsHeapSizeLimit\n    });\n  }\n}"
    },
    {
      "id": 94,
      "question": "How do you implement GraphQL with TypeScript?",
      "answer": "GraphQL with TypeScript provides end-to-end type safety from schema to resolvers to client queries.\n\nCode Generation:\n• GraphQL Code Generator\n• Type-safe resolvers\n• Client types from operations\n• Schema types\n• Fragment types\n\nServer Implementation:\n• Apollo Server types\n• Type-safe resolvers\n• Context typing\n• Input validation\n• Error handling\n\nClient Implementation:\n• Apollo Client types\n• Type-safe queries\n• Mutation typing\n• Cache typing\n• Hook types\n\nSchema Definition:\n• SDL to TypeScript\n• Type-first approach\n• Code-first approach\n• Schema stitching\n• Federation types\n\nAdvanced Patterns:\n• Generic resolvers\n• DataLoader typing\n• Subscription types\n• Custom scalars\n• Directive types\n\nBest Practices:\n• Generate types\n• Validate inputs\n• Type resolvers\n• Handle nullability\n• Document schema\n• Version APIs",
      "explanation": "GraphQL with TypeScript combines schema-driven development with code generation for end-to-end type safety from server resolvers to client queries.",
      "difficulty": "Hard",
      "code": "// GraphQL schema\nconst typeDefs = `\n  type User {\n    id: ID!\n    name: String!\n    email: String!\n    posts: [Post!]!\n  }\n  \n  type Post {\n    id: ID!\n    title: String!\n    content: String!\n    author: User!\n  }\n  \n  type Query {\n    user(id: ID!): User\n    users: [User!]!\n    post(id: ID!): Post\n  }\n  \n  type Mutation {\n    createUser(input: CreateUserInput!): User!\n    updateUser(id: ID!, input: UpdateUserInput!): User!\n  }\n  \n  input CreateUserInput {\n    name: String!\n    email: String!\n  }\n  \n  input UpdateUserInput {\n    name: String\n    email: String\n  }\n`;\n\n// Generated types (from GraphQL Code Generator)\ntype Maybe<T> = T | null;\n\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n};\n\nexport type User = {\n  __typename?: 'User';\n  id: Scalars['ID'];\n  name: Scalars['String'];\n  email: Scalars['String'];\n  posts: Array<Post>;\n};\n\nexport type Post = {\n  __typename?: 'Post';\n  id: Scalars['ID'];\n  title: Scalars['String'];\n  content: Scalars['String'];\n  author: User;\n};\n\nexport type CreateUserInput = {\n  name: Scalars['String'];\n  email: Scalars['String'];\n};\n\nexport type UpdateUserInput = {\n  name?: Maybe<Scalars['String']>;\n  email?: Maybe<Scalars['String']>;\n};\n\n// Resolver types\nimport { GraphQLResolveInfo } from 'graphql';\n\nexport type ResolverFn<TResult, TParent, TContext, TArgs> = (\n  parent: TParent,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo\n) => Promise<TResult> | TResult;\n\nexport type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = \n  ResolverFn<TResult, TParent, TContext, TArgs>;\n\nexport type ResolverTypeWrapper<T> = Promise<T> | T;\n\nexport type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {\n  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;\n};\n\nexport type Resolvers<TContext = {}> = {\n  Query?: QueryResolvers<TContext>;\n  Mutation?: MutationResolvers<TContext>;\n  User?: UserResolvers<TContext>;\n  Post?: PostResolvers<TContext>;\n};\n\nexport type QueryResolvers<TContext = {}> = {\n  user?: Resolver<Maybe<User>, {}, TContext, { id: Scalars['ID'] }>;\n  users?: Resolver<Array<User>, {}, TContext>;\n  post?: Resolver<Maybe<Post>, {}, TContext, { id: Scalars['ID'] }>;\n};\n\nexport type MutationResolvers<TContext = {}> = {\n  createUser?: Resolver<User, {}, TContext, { input: CreateUserInput }>;\n  updateUser?: Resolver<\n    User,\n    {},\n    TContext,\n    { id: Scalars['ID']; input: UpdateUserInput }\n  >;\n};\n\nexport type UserResolvers<TContext = {}> = {\n  id?: Resolver<Scalars['ID'], User, TContext>;\n  name?: Resolver<Scalars['String'], User, TContext>;\n  email?: Resolver<Scalars['String'], User, TContext>;\n  posts?: Resolver<Array<Post>, User, TContext>;\n};\n\n// Context type\ninterface Context {\n  db: Database;\n  userId?: string;\n}\n\n// Type-safe resolvers\nconst resolvers: Resolvers<Context> = {\n  Query: {\n    user: async (_, { id }, context) => {\n      return context.db.users.findById(id);\n    },\n    users: async (_, __, context) => {\n      return context.db.users.findAll();\n    }\n  },\n  \n  Mutation: {\n    createUser: async (_, { input }, context) => {\n      // input is typed as CreateUserInput\n      return context.db.users.create(input);\n    },\n    updateUser: async (_, { id, input }, context) => {\n      // input is typed as UpdateUserInput\n      return context.db.users.update(id, input);\n    }\n  },\n  \n  User: {\n    posts: async (user, _, context) => {\n      // user is typed as User\n      return context.db.posts.findByAuthorId(user.id);\n    }\n  }\n};\n\n// Apollo Server setup\nimport { ApolloServer } from '@apollo/server';\n\nconst server = new ApolloServer<Context>({\n  typeDefs,\n  resolvers\n});\n\n// Client types (generated)\nimport { gql } from '@apollo/client';\n\nconst GET_USER = gql`\n  query GetUser($id: ID!) {\n    user(id: $id) {\n      id\n      name\n      email\n      posts {\n        id\n        title\n      }\n    }\n  }\n`;\n\n// Generated query types\nexport type GetUserQueryVariables = {\n  id: Scalars['ID'];\n};\n\nexport type GetUserQuery = {\n  __typename?: 'Query';\n  user?: Maybe<{\n    __typename?: 'User';\n    id: string;\n    name: string;\n    email: string;\n    posts: Array<{\n      __typename?: 'Post';\n      id: string;\n      title: string;\n    }>;\n  }>;\n};\n\n// Type-safe query hook\nimport { useQuery } from '@apollo/client';\n\nfunction UserProfile({ userId }: { userId: string }) {\n  const { data, loading, error } = useQuery<\n    GetUserQuery,\n    GetUserQueryVariables\n  >(GET_USER, {\n    variables: { id: userId }\n  });\n  \n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n  \n  // data is fully typed\n  return (\n    <div>\n      <h1>{data?.user?.name}</h1>\n      <p>{data?.user?.email}</p>\n      <ul>\n        {data?.user?.posts.map(post => (\n          <li key={post.id}>{post.title}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}"
    },
    {
      "id": 95,
      "question": "What are advanced patterns for error handling and result types in TypeScript?",
      "answer": "Advanced error handling uses result types and functional patterns for type-safe error management.\n\nResult Type Patterns:\n• Result<T, E> type\n• Either monad\n• Option/Maybe type\n• Railway-oriented programming\n• Error accumulation\n\nError Types:\n• Discriminated error unions\n• Tagged errors\n• Error hierarchies\n• Domain errors\n• Infrastructure errors\n\nFunctional Patterns:\n• Monadic error handling\n• Error composition\n• Error transformation\n• Chaining operations\n• Error recovery\n\nAsync Errors:\n• Promise-based results\n• Async result types\n• Error boundaries\n• Retry mechanisms\n• Timeout handling\n\nLibraries:\n• fp-ts for functional types\n• neverthrow for Result\n• ts-results\n• Custom implementations\n\nBest Practices:\n• Type all errors\n• Avoid throwing for control flow\n• Use Result for expected errors\n• Document error cases\n• Compose error handlers\n• Test error paths",
      "explanation": "Advanced error handling uses Result types and functional patterns to encode success/failure in the type system, enabling safer and more composable error management.",
      "difficulty": "Hard",
      "code": "// Result type implementation\ntype Ok<T> = { success: true; value: T };\ntype Err<E> = { success: false; error: E };\ntype Result<T, E = Error> = Ok<T> | Err<E>;\n\n// Constructor functions\nfunction ok<T>(value: T): Ok<T> {\n  return { success: true, value };\n}\n\nfunction err<E>(error: E): Err<E> {\n  return { success: false, error };\n}\n\n// Result class with methods\nclass ResultClass<T, E> {\n  private constructor(\n    private readonly result: Result<T, E>\n  ) {}\n  \n  static ok<T>(value: T): ResultClass<T, never> {\n    return new ResultClass(ok(value));\n  }\n  \n  static err<E>(error: E): ResultClass<never, E> {\n    return new ResultClass(err(error));\n  }\n  \n  isOk(): boolean {\n    return this.result.success;\n  }\n  \n  isErr(): boolean {\n    return !this.result.success;\n  }\n  \n  unwrap(): T {\n    if (!this.result.success) {\n      throw new Error('Called unwrap on an Err value');\n    }\n    return this.result.value;\n  }\n  \n  unwrapOr(defaultValue: T): T {\n    return this.result.success\n      ? this.result.value\n      : defaultValue;\n  }\n  \n  map<U>(fn: (value: T) => U): ResultClass<U, E> {\n    if (this.result.success) {\n      return ResultClass.ok(fn(this.result.value));\n    }\n    return ResultClass.err(this.result.error);\n  }\n  \n  mapErr<F>(fn: (error: E) => F): ResultClass<T, F> {\n    if (!this.result.success) {\n      return ResultClass.err(fn(this.result.error));\n    }\n    return ResultClass.ok(this.result.value);\n  }\n  \n  andThen<U>(fn: (value: T) => ResultClass<U, E>): ResultClass<U, E> {\n    if (this.result.success) {\n      return fn(this.result.value);\n    }\n    return ResultClass.err(this.result.error);\n  }\n  \n  match<U>(\n    patterns: {\n      ok: (value: T) => U;\n      err: (error: E) => U;\n    }\n  ): U {\n    return this.result.success\n      ? patterns.ok(this.result.value)\n      : patterns.err(this.result.error);\n  }\n}\n\n// Domain error types\ntype ValidationError = {\n  type: 'validation';\n  field: string;\n  message: string;\n};\n\ntype NotFoundError = {\n  type: 'notFound';\n  resource: string;\n  id: string;\n};\n\ntype UnauthorizedError = {\n  type: 'unauthorized';\n  message: string;\n};\n\ntype AppError = ValidationError | NotFoundError | UnauthorizedError;\n\n// Usage example\nfunction validateEmail(email: string): Result<string, ValidationError> {\n  if (!email.includes('@')) {\n    return err({\n      type: 'validation',\n      field: 'email',\n      message: 'Invalid email format'\n    });\n  }\n  return ok(email);\n}\n\nfunction findUser(id: string): Result<User, NotFoundError> {\n  const user = database.users.find(u => u.id === id);\n  if (!user) {\n    return err({\n      type: 'notFound',\n      resource: 'User',\n      id\n    });\n  }\n  return ok(user);\n}\n\n// Chaining operations\nfunction updateUserEmail(\n  userId: string,\n  newEmail: string\n): Result<User, AppError> {\n  const emailResult = validateEmail(newEmail);\n  if (!emailResult.success) {\n    return emailResult;\n  }\n  \n  const userResult = findUser(userId);\n  if (!userResult.success) {\n    return userResult;\n  }\n  \n  const user = userResult.value;\n  user.email = emailResult.value;\n  return ok(user);\n}\n\n// With ResultClass\nfunction updateUserEmailClass(\n  userId: string,\n  newEmail: string\n): ResultClass<User, AppError> {\n  return validateEmailClass(newEmail)\n    .andThen(() => findUserClass(userId))\n    .map(user => {\n      user.email = newEmail;\n      return user;\n    });\n}\n\n// Async Result\ntype AsyncResult<T, E> = Promise<Result<T, E>>;\n\nasync function fetchUserAsync(\n  id: string\n): AsyncResult<User, AppError> {\n  try {\n    const response = await fetch(`/api/users/${id}`);\n    \n    if (!response.ok) {\n      if (response.status === 404) {\n        return err({\n          type: 'notFound',\n          resource: 'User',\n          id\n        });\n      }\n      throw new Error(`HTTP ${response.status}`);\n    }\n    \n    const data = await response.json();\n    return ok(data);\n  } catch (error) {\n    return err({\n      type: 'notFound',\n      resource: 'User',\n      id\n    });\n  }\n}\n\n// Error accumulation\ntype ValidationErrors = ValidationError[];\n\nfunction validateUser(\n  data: unknown\n): Result<User, ValidationErrors> {\n  const errors: ValidationError[] = [];\n  \n  if (!isValidName(data)) {\n    errors.push({\n      type: 'validation',\n      field: 'name',\n      message: 'Invalid name'\n    });\n  }\n  \n  if (!isValidEmail(data)) {\n    errors.push({\n      type: 'validation',\n      field: 'email',\n      message: 'Invalid email'\n    });\n  }\n  \n  if (errors.length > 0) {\n    return err(errors);\n  }\n  \n  return ok(data as User);\n}\n\n// Railway-oriented programming\nfunction processOrder(\n  orderId: string\n): Result<Order, AppError> {\n  return findOrder(orderId)\n    .andThen(validateOrder)\n    .andThen(processPayment)\n    .andThen(sendConfirmation)\n    .map(order => {\n      console.log('Order processed successfully');\n      return order;\n    });\n}"
    },
    {
      "id": 96,
      "question": "How do you implement plugin architectures in TypeScript?",
      "answer": "Plugin architectures enable extensible systems through well-defined interfaces and dynamic loading.\n\nCore Components:\n• Plugin interface\n• Plugin registry\n• Plugin loader\n• Hook system\n• Event system\n• Lifecycle management\n\nImplementation Patterns:\n• Interface-based plugins\n• Abstract base classes\n• Decorator pattern\n• Strategy pattern\n• Observer pattern\n• Factory pattern\n\nType Safety:\n• Generic plugin types\n• Typed hooks\n• Typed events\n• Plugin metadata\n• Compile-time checks\n\nDynamic Loading:\n• Runtime imports\n• Module resolution\n• Dependency injection\n• Lazy loading\n• Hot reloading\n\nPlugin Communication:\n• Message passing\n• Shared state\n• Event emitters\n• Service locator\n• Dependency graph\n\nBest Practices:\n• Define clear contracts\n• Version plugins\n• Isolate plugins\n• Handle errors\n• Document hooks\n• Test plugins",
      "explanation": "Plugin architectures use interfaces, registries, and hook systems to enable extensible applications with type-safe plugin development and dynamic loading.",
      "difficulty": "Hard",
      "code": "// Plugin interface\ninterface Plugin<TConfig = any> {\n  name: string;\n  version: string;\n  config?: TConfig;\n  init(context: PluginContext): void | Promise<void>;\n  destroy?(): void | Promise<void>;\n}\n\n// Plugin context\ninterface PluginContext {\n  registerHook<T>(name: string, handler: HookHandler<T>): void;\n  emit(event: string, data: any): void;\n  getService<T>(name: string): T;\n  config: Record<string, any>;\n}\n\n// Hook system\ntype HookHandler<T = any> = (data: T) => T | Promise<T>;\n\nclass HookRegistry {\n  private hooks = new Map<string, HookHandler<any>[]>();\n  \n  register<T>(name: string, handler: HookHandler<T>): void {\n    const handlers = this.hooks.get(name) || [];\n    handlers.push(handler);\n    this.hooks.set(name, handlers);\n  }\n  \n  async execute<T>(name: string, data: T): Promise<T> {\n    const handlers = this.hooks.get(name) || [];\n    let result = data;\n    \n    for (const handler of handlers) {\n      result = await handler(result);\n    }\n    \n    return result;\n  }\n}\n\n// Plugin registry\nclass PluginRegistry {\n  private plugins = new Map<string, Plugin>();\n  private hooks = new HookRegistry();\n  private services = new Map<string, any>();\n  \n  async register(plugin: Plugin): Promise<void> {\n    if (this.plugins.has(plugin.name)) {\n      throw new Error(`Plugin ${plugin.name} already registered`);\n    }\n    \n    const context: PluginContext = {\n      registerHook: (name, handler) => {\n        this.hooks.register(name, handler);\n      },\n      emit: (event, data) => {\n        this.emit(event, data);\n      },\n      getService: (name) => {\n        return this.services.get(name);\n      },\n      config: plugin.config || {}\n    };\n    \n    await plugin.init(context);\n    this.plugins.set(plugin.name, plugin);\n  }\n  \n  async unregister(name: string): Promise<void> {\n    const plugin = this.plugins.get(name);\n    if (!plugin) {\n      throw new Error(`Plugin ${name} not found`);\n    }\n    \n    if (plugin.destroy) {\n      await plugin.destroy();\n    }\n    \n    this.plugins.delete(name);\n  }\n  \n  registerService<T>(name: string, service: T): void {\n    this.services.set(name, service);\n  }\n  \n  async executeHook<T>(name: string, data: T): Promise<T> {\n    return this.hooks.execute(name, data);\n  }\n  \n  private emit(event: string, data: any): void {\n    // Event emission logic\n  }\n}\n\n// Example plugins\ninterface LoggerConfig {\n  level: 'debug' | 'info' | 'warn' | 'error';\n  prefix?: string;\n}\n\nclass LoggerPlugin implements Plugin<LoggerConfig> {\n  name = 'logger';\n  version = '1.0.0';\n  config?: LoggerConfig;\n  \n  constructor(config?: LoggerConfig) {\n    this.config = config;\n  }\n  \n  init(context: PluginContext): void {\n    // Register hooks\n    context.registerHook('request', (data) => {\n      console.log(`[${this.config?.prefix || 'LOG'}] Request:`, data);\n      return data;\n    });\n    \n    context.registerHook('response', (data) => {\n      console.log(`[${this.config?.prefix || 'LOG'}] Response:`, data);\n      return data;\n    });\n  }\n}\n\nclass CachePlugin implements Plugin {\n  name = 'cache';\n  version = '1.0.0';\n  private cache = new Map<string, any>();\n  \n  init(context: PluginContext): void {\n    // Register cache service\n    const cacheService = {\n      get: (key: string) => this.cache.get(key),\n      set: (key: string, value: any) => this.cache.set(key, value),\n      delete: (key: string) => this.cache.delete(key),\n      clear: () => this.cache.clear()\n    };\n    \n    // Hook into request\n    context.registerHook('request', async (data) => {\n      const cached = this.cache.get(data.url);\n      if (cached) {\n        return { ...data, fromCache: true, result: cached };\n      }\n      return data;\n    });\n    \n    // Hook into response\n    context.registerHook('response', async (data) => {\n      if (!data.fromCache) {\n        this.cache.set(data.url, data.result);\n      }\n      return data;\n    });\n  }\n  \n  destroy(): void {\n    this.cache.clear();\n  }\n}\n\n// Usage\nconst registry = new PluginRegistry();\n\n// Register plugins\nawait registry.register(new LoggerPlugin({ level: 'info', prefix: 'API' }));\nawait registry.register(new CachePlugin());\n\n// Execute hooks\nconst request = { url: '/api/users', method: 'GET' };\nconst processedRequest = await registry.executeHook('request', request);\n\n// Type-safe plugin with generics\ninterface DataTransformer<TInput, TOutput> {\n  transform(data: TInput): TOutput | Promise<TOutput>;\n}\n\nclass TransformPlugin<TInput, TOutput> implements Plugin {\n  name = 'transformer';\n  version = '1.0.0';\n  \n  constructor(\n    private transformer: DataTransformer<TInput, TOutput>\n  ) {}\n  \n  init(context: PluginContext): void {\n    context.registerHook('transform', async (data: TInput) => {\n      return this.transformer.transform(data);\n    });\n  }\n}\n\n// Plugin with dependencies\ninterface PluginDependency {\n  name: string;\n  version?: string;\n}\n\ninterface ExtendedPlugin extends Plugin {\n  dependencies?: PluginDependency[];\n}\n\nclass DependencyResolver {\n  resolve(plugins: ExtendedPlugin[]): ExtendedPlugin[] {\n    const sorted: ExtendedPlugin[] = [];\n    const visited = new Set<string>();\n    \n    function visit(plugin: ExtendedPlugin) {\n      if (visited.has(plugin.name)) return;\n      visited.add(plugin.name);\n      \n      if (plugin.dependencies) {\n        for (const dep of plugin.dependencies) {\n          const depPlugin = plugins.find(p => p.name === dep.name);\n          if (depPlugin) {\n            visit(depPlugin);\n          }\n        }\n      }\n      \n      sorted.push(plugin);\n    }\n    \n    plugins.forEach(visit);\n    return sorted;\n  }\n}\n\n// Plugin loader with dynamic imports\nclass PluginLoader {\n  async load(path: string): Promise<Plugin> {\n    const module = await import(path);\n    const PluginClass = module.default || module.Plugin;\n    \n    if (!PluginClass) {\n      throw new Error(`No plugin found in ${path}`);\n    }\n    \n    return new PluginClass();\n  }\n  \n  async loadMany(paths: string[]): Promise<Plugin[]> {\n    return Promise.all(paths.map(path => this.load(path)));\n  }\n}"
    },
    {
      "id": 97,
      "question": "What are TypeScript declaration files best practices and patterns?",
      "answer": "Declaration files provide type information for JavaScript libraries and require careful design for accuracy and usability.\n\nStructure:\n• Ambient declarations\n• Module declarations\n• Global augmentation\n• Triple-slash directives\n• Export patterns\n\nBest Practices:\n• Match implementation\n• Use declare keyword\n• Export all public APIs\n• Version with package\n• Include JSDoc comments\n• Test declarations\n\nModule Patterns:\n• UMD declarations\n• ES modules\n• CommonJS\n• Global libraries\n• Module augmentation\n\nAdvanced Features:\n• Generic declarations\n• Overload signatures\n• Conditional types\n• Template literals\n• Mapped types\n\nDistribution:\n• Include in package\n• Publish to DefinitelyTyped\n• types field in package.json\n• typesVersions for versions\n• Type checking in CI\n\nMaintenance:\n• Keep in sync\n• Document changes\n• Semantic versioning\n• Breaking change handling\n• Community contributions",
      "explanation": "Declaration files provide type definitions for JavaScript code, requiring careful design to match implementation while maintaining usability and type safety.",
      "difficulty": "Hard",
      "code": "// Basic declaration file structure\n// types/index.d.ts\n\n// Global type declarations\ndeclare namespace MyLibrary {\n  interface Options {\n    timeout?: number;\n    retries?: number;\n  }\n  \n  interface Response<T> {\n    data: T;\n    status: number;\n  }\n}\n\n// Module declarations\ndeclare module 'my-library' {\n  // Class declaration\n  export class Client {\n    constructor(config: MyLibrary.Options);\n    request<T>(url: string): Promise<MyLibrary.Response<T>>;\n    get<T>(url: string): Promise<T>;\n    post<T, D>(url: string, data: D): Promise<T>;\n  }\n  \n  // Function declarations with overloads\n  export function createClient(config: MyLibrary.Options): Client;\n  export function createClient(apiKey: string): Client;\n  \n  // Const declarations\n  export const version: string;\n  export const defaultTimeout: number;\n  \n  // Type exports\n  export type { MyLibrary };\n}\n\n// UMD declaration\nexport as namespace MyLib;\n\nexport = MyLib;\nexport as namespace MyLib;\n\ndeclare namespace MyLib {\n  function doSomething(x: number): string;\n  \n  namespace utils {\n    function helper(s: string): boolean;\n  }\n}\n\n// Global augmentation\nimport 'express';\n\ndeclare global {\n  namespace Express {\n    interface Request {\n      user?: {\n        id: string;\n        name: string;\n      };\n    }\n    \n    interface Response {\n      sendSuccess<T>(data: T): void;\n    }\n  }\n}\n\n// Module augmentation\ndeclare module 'existing-library' {\n  interface ExistingInterface {\n    newMethod(): void;\n  }\n  \n  export function newFunction(): void;\n}\n\n// Generic library declarations\ndeclare module 'generic-library' {\n  export interface Container<T> {\n    value: T;\n    map<U>(fn: (value: T) => U): Container<U>;\n    flatMap<U>(fn: (value: T) => Container<U>): Container<U>;\n  }\n  \n  export function of<T>(value: T): Container<T>;\n}\n\n// Wildcard module declarations\ndeclare module '*.css' {\n  const content: { [className: string]: string };\n  export default content;\n}\n\ndeclare module '*.json' {\n  const value: any;\n  export default value;\n}\n\ndeclare module '*.svg' {\n  const content: React.FunctionComponent<React.SVGProps<SVGSVGElement>>;\n  export default content;\n}\n\n// Plugin declarations\ndeclare module 'plugin-system' {\n  export interface Plugin {\n    name: string;\n    version: string;\n    init(): void;\n  }\n  \n  export interface PluginRegistry {\n    register(plugin: Plugin): void;\n    get(name: string): Plugin | undefined;\n  }\n  \n  export function createRegistry(): PluginRegistry;\n}\n\n// Declaration with conditional types\ndeclare module 'conditional-lib' {\n  export type Unwrap<T> = T extends Promise<infer U>\n    ? U\n    : T extends Array<infer V>\n    ? V\n    : T;\n  \n  export function unwrap<T>(value: T): Unwrap<T>;\n}\n\n// JSDoc in declarations\n/**\n * Creates a new client instance.\n * @param config - Configuration options\n * @returns A new client instance\n * @example\n * ```ts\n * const client = createClient({ timeout: 5000 });\n * ```\n */\ndeclare function createClient(\n  config: ClientConfig\n): Client;\n\n/**\n * Client configuration options.\n */\ninterface ClientConfig {\n  /**\n   * Request timeout in milliseconds.\n   * @default 3000\n   */\n  timeout?: number;\n  \n  /**\n   * Number of retry attempts.\n   * @default 3\n   */\n  retries?: number;\n  \n  /**\n   * Base URL for requests.\n   */\n  baseURL: string;\n}\n\n// Package.json configuration\n// {\n//   \"name\": \"my-library\",\n//   \"version\": \"1.0.0\",\n//   \"main\": \"dist/index.js\",\n//   \"types\": \"dist/index.d.ts\",\n//   \"typesVersions\": {\n//     \">=4.0\": {\n//       \"*\": [\"ts4.0/*\"]\n//     },\n//     \">=3.7\": {\n//       \"*\": [\"ts3.7/*\"]\n//     }\n//   },\n//   \"files\": [\n//     \"dist\",\n//     \"types\"\n//   ]\n// }\n\n// Testing declarations\n// types-test.ts\nimport { Client, createClient } from 'my-library';\n\n// Test basic usage\nconst client = createClient({ baseURL: 'https://api.example.com' });\n\n// Test generic types\ninterface User {\n  id: number;\n  name: string;\n}\n\nconst user: Promise<User> = client.get<User>('/users/1');\n\n// Test type compatibility\nconst config: ClientConfig = {\n  baseURL: 'https://api.example.com',\n  timeout: 5000\n};\n\n// Should cause type errors (for testing)\n// const bad: Client = 'not a client'; // Error\n// const badConfig: ClientConfig = { }; // Error: missing baseURL"
    },
    {
      "id": 98,
      "question": "How do you implement code generation with TypeScript?",
      "answer": "Code generation automates creation of boilerplate, types, and implementations from schemas or templates.\n\nGeneration Approaches:\n• Template-based generation\n• AST manipulation\n• Schema-driven generation\n• Compiler API usage\n• Custom transformers\n\nCommon Use Cases:\n• API client generation\n• GraphQL types\n• Database models\n• Form types\n• Validation schemas\n• Mock data\n\nTools and Libraries:\n• TypeScript Compiler API\n• ts-morph for AST\n• Handlebars/EJS templates\n• GraphQL Code Generator\n• OpenAPI generators\n• Custom generators\n\nType Generation:\n• From JSON schema\n• From database schema\n• From API specs\n• From GraphQL schema\n• From protobuf\n\nBest Practices:\n• Generate into separate files\n• Version generated code\n• Add generation markers\n• Exclude from git optionally\n• Document generation process\n• Validate generated code",
      "explanation": "Code generation automates creation of types and code from schemas using templates, AST manipulation, or the TypeScript Compiler API.",
      "difficulty": "Hard",
      "code": "// Using TypeScript Compiler API\nimport * as ts from 'typescript';\n\n// Generate interface from JSON schema\ninterface JsonSchema {\n  type: string;\n  properties?: Record<string, JsonSchema>;\n  items?: JsonSchema;\n  required?: string[];\n}\n\nfunction generateInterface(\n  name: string,\n  schema: JsonSchema\n): ts.InterfaceDeclaration {\n  const properties: ts.PropertySignature[] = [];\n  \n  if (schema.properties) {\n    for (const [propName, propSchema] of Object.entries(schema.properties)) {\n      const isRequired = schema.required?.includes(propName) ?? false;\n      const typeNode = jsonSchemaToType(propSchema);\n      \n      properties.push(\n        ts.factory.createPropertySignature(\n          undefined,\n          propName,\n          isRequired ? undefined : ts.factory.createToken(ts.SyntaxKind.QuestionToken),\n          typeNode\n        )\n      );\n    }\n  }\n  \n  return ts.factory.createInterfaceDeclaration(\n    [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n    name,\n    undefined,\n    undefined,\n    properties\n  );\n}\n\nfunction jsonSchemaToType(schema: JsonSchema): ts.TypeNode {\n  switch (schema.type) {\n    case 'string':\n      return ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);\n    case 'number':\n      return ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);\n    case 'boolean':\n      return ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);\n    case 'array':\n      if (schema.items) {\n        const elementType = jsonSchemaToType(schema.items);\n        return ts.factory.createArrayTypeNode(elementType);\n      }\n      return ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);\n    case 'object':\n      // Generate inline type or reference\n      return ts.factory.createKeywordTypeNode(ts.SyntaxKind.ObjectKeyword);\n    default:\n      return ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);\n  }\n}\n\n// Generate source file\nfunction generateSourceFile(interfaces: ts.InterfaceDeclaration[]): string {\n  const sourceFile = ts.factory.createSourceFile(\n    interfaces,\n    ts.factory.createToken(ts.SyntaxKind.EndOfFileToken),\n    ts.NodeFlags.None\n  );\n  \n  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });\n  return printer.printFile(sourceFile as any);\n}\n\n// Using ts-morph\nimport { Project, VariableDeclarationKind } from 'ts-morph';\n\nfunction generateWithTsMorph() {\n  const project = new Project();\n  const sourceFile = project.createSourceFile('generated.ts');\n  \n  // Add interface\n  sourceFile.addInterface({\n    name: 'User',\n    isExported: true,\n    properties: [\n      { name: 'id', type: 'number' },\n      { name: 'name', type: 'string' },\n      { name: 'email', type: 'string' }\n    ]\n  });\n  \n  // Add class\n  sourceFile.addClass({\n    name: 'UserService',\n    isExported: true,\n    methods: [\n      {\n        name: 'getUser',\n        parameters: [{ name: 'id', type: 'number' }],\n        returnType: 'Promise<User>',\n        statements: 'return fetch(`/api/users/${id}`).then(r => r.json());'\n      }\n    ]\n  });\n  \n  // Add function\n  sourceFile.addFunction({\n    name: 'createUser',\n    isExported: true,\n    parameters: [\n      { name: 'data', type: 'Omit<User, \"id\">' }\n    ],\n    returnType: 'Promise<User>',\n    statements: writer => {\n      writer.writeLine('return fetch(\"/api/users\", {');\n      writer.indent(() => {\n        writer.writeLine('method: \"POST\",');\n        writer.writeLine('body: JSON.stringify(data)');\n      });\n      writer.writeLine('}).then(r => r.json());');\n    }\n  });\n  \n  return sourceFile.getFullText();\n}\n\n// Template-based generation\nimport Handlebars from 'handlebars';\n\nconst interfaceTemplate = `\nexport interface {{name}} {\n{{#each properties}}\n  {{name}}{{#if optional}}?{{/if}}: {{type}};\n{{/each}}\n}\n`;\n\ninterface PropertyDef {\n  name: string;\n  type: string;\n  optional?: boolean;\n}\n\nfunction generateFromTemplate(\n  name: string,\n  properties: PropertyDef[]\n): string {\n  const template = Handlebars.compile(interfaceTemplate);\n  return template({ name, properties });\n}\n\n// Usage\nconst code = generateFromTemplate('User', [\n  { name: 'id', type: 'number' },\n  { name: 'name', type: 'string' },\n  { name: 'email', type: 'string', optional: true }\n]);\n\n// Generate CRUD operations\nfunction generateCRUD(entityName: string): string {\n  const singular = entityName;\n  const plural = `${entityName}s`;\n  const lowerSingular = singular.toLowerCase();\n  const lowerPlural = plural.toLowerCase();\n  \n  return `\nexport class ${singular}Service {\n  async get${singular}(id: string): Promise<${singular}> {\n    const response = await fetch(\\`/api/${lowerPlural}/\\${id}\\`);\n    return response.json();\n  }\n  \n  async get${plural}(): Promise<${singular}[]> {\n    const response = await fetch('/api/${lowerPlural}');\n    return response.json();\n  }\n  \n  async create${singular}(data: Omit<${singular}, 'id'>): Promise<${singular}> {\n    const response = await fetch('/api/${lowerPlural}', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(data)\n    });\n    return response.json();\n  }\n  \n  async update${singular}(id: string, data: Partial<${singular}>): Promise<${singular}> {\n    const response = await fetch(\\`/api/${lowerPlural}/\\${id}\\`, {\n      method: 'PUT',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(data)\n    });\n    return response.json();\n  }\n  \n  async delete${singular}(id: string): Promise<void> {\n    await fetch(\\`/api/${lowerPlural}/\\${id}\\`, {\n      method: 'DELETE'\n    });\n  }\n}\n  `.trim();\n}\n\n// CLI tool for generation\nimport { writeFileSync } from 'fs';\nimport { join } from 'path';\n\nfunction generateFiles(config: GeneratorConfig) {\n  const outputDir = config.outputDir || './generated';\n  \n  for (const entity of config.entities) {\n    // Generate interface\n    const interfaceCode = generateInterface(entity.name, entity.schema);\n    writeFileSync(\n      join(outputDir, `${entity.name}.ts`),\n      interfaceCode\n    );\n    \n    // Generate service\n    const serviceCode = generateCRUD(entity.name);\n    writeFileSync(\n      join(outputDir, `${entity.name}Service.ts`),\n      serviceCode\n    );\n  }\n}\n\ninterface GeneratorConfig {\n  outputDir?: string;\n  entities: Array<{\n    name: string;\n    schema: JsonSchema;\n  }>;\n}"
    },
    {
      "id": 99,
      "question": "What are TypeScript security considerations and best practices?",
      "answer": "TypeScript security involves preventing type-based vulnerabilities and secure coding practices.\n\nType Safety:\n• Strict null checks\n• No implicit any\n• Strict mode enabled\n• Type assertions carefully\n• Validate external data\n\nInput Validation:\n• Runtime validation\n• Schema validation\n• Type guards\n• Sanitization\n• Boundary checking\n\nCommon Vulnerabilities:\n• Type coercion issues\n• Prototype pollution\n• XSS from any types\n• SQL injection\n• Command injection\n• Path traversal\n\nSafe Patterns:\n• Branded types for IDs\n• Validated types\n• Immutable data\n• Type-safe APIs\n• Secure defaults\n\nDependency Security:\n• Audit dependencies\n• Keep updated\n• Check types packages\n• Use lock files\n• SBOM generation\n\nBest Practices:\n• Enable strict mode\n• Validate inputs\n• Sanitize outputs\n• Use type guards\n• Avoid any\n• Review type assertions\n• Document assumptions\n• Security testing",
      "explanation": "TypeScript security requires strict type checking, input validation, safe coding patterns, and careful handling of external data to prevent vulnerabilities.",
      "difficulty": "Hard",
      "code": "// Strict type checking configuration\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true,\n    \"strictFunctionTypes\": true,\n    \"noUncheckedIndexedAccess\": true,\n    \"noImplicitOverride\": true\n  }\n}\n\n// Branded types for security\ntype UserId = string & { __brand: 'UserId' };\ntype ProductId = string & { __brand: 'ProductId' };\n\nfunction createUserId(id: string): UserId {\n  // Validate format\n  if (!/^[a-zA-Z0-9-]+$/.test(id)) {\n    throw new Error('Invalid user ID format');\n  }\n  return id as UserId;\n}\n\nfunction getUser(id: UserId): User {\n  // Type system ensures only validated IDs are used\n  return database.users.get(id);\n}\n\n// Cannot mix different ID types\nconst userId = createUserId('user-123');\nconst productId = 'product-456' as ProductId;\n// getUser(productId); // Type error\n\n// Input validation with type guards\nfunction isValidEmail(value: unknown): value is string {\n  return (\n    typeof value === 'string' &&\n    /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value) &&\n    value.length <= 255\n  );\n}\n\nfunction isValidUsername(value: unknown): value is string {\n  return (\n    typeof value === 'string' &&\n    /^[a-zA-Z0-9_-]{3,20}$/.test(value)\n  );\n}\n\n// Safe API handling\ninterface CreateUserRequest {\n  username: string;\n  email: string;\n  password: string;\n}\n\nfunction validateCreateUserRequest(\n  data: unknown\n): CreateUserRequest {\n  if (typeof data !== 'object' || data === null) {\n    throw new Error('Invalid request data');\n  }\n  \n  const { username, email, password } = data as any;\n  \n  if (!isValidUsername(username)) {\n    throw new Error('Invalid username');\n  }\n  \n  if (!isValidEmail(email)) {\n    throw new Error('Invalid email');\n  }\n  \n  if (typeof password !== 'string' || password.length < 8) {\n    throw new Error('Invalid password');\n  }\n  \n  return { username, email, password };\n}\n\n// Prevent prototype pollution\nfunction safeMerge<T extends object>(\n  target: T,\n  source: unknown\n): T {\n  if (typeof source !== 'object' || source === null) {\n    return target;\n  }\n  \n  const result = { ...target };\n  \n  for (const [key, value] of Object.entries(source)) {\n    // Prevent prototype pollution\n    if (\n      key === '__proto__' ||\n      key === 'constructor' ||\n      key === 'prototype'\n    ) {\n      continue;\n    }\n    \n    (result as any)[key] = value;\n  }\n  \n  return result;\n}\n\n// SQL injection prevention\nclass SafeQueryBuilder {\n  private params: any[] = [];\n  private query: string = '';\n  \n  select(table: string, columns: string[]): this {\n    // Whitelist table and column names\n    const safeTable = this.escapeIdentifier(table);\n    const safeColumns = columns.map(c => this.escapeIdentifier(c));\n    this.query = `SELECT ${safeColumns.join(', ')} FROM ${safeTable}`;\n    return this;\n  }\n  \n  where(column: string, value: any): this {\n    const safeColumn = this.escapeIdentifier(column);\n    this.params.push(value);\n    this.query += ` WHERE ${safeColumn} = $${this.params.length}`;\n    return this;\n  }\n  \n  private escapeIdentifier(name: string): string {\n    // Only allow alphanumeric and underscore\n    if (!/^[a-zA-Z0-9_]+$/.test(name)) {\n      throw new Error('Invalid identifier');\n    }\n    return name;\n  }\n  \n  build(): { query: string; params: any[] } {\n    return { query: this.query, params: this.params };\n  }\n}\n\n// XSS prevention\nfunction escapeHtml(unsafe: string): string {\n  return unsafe\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#039;');\n}\n\nfunction sanitizeUserInput(input: unknown): string {\n  if (typeof input !== 'string') {\n    throw new Error('Input must be string');\n  }\n  \n  // Remove potentially dangerous content\n  let sanitized = input\n    .replace(/<script[^>]*>.*?<\\/script>/gi, '')\n    .replace(/on\\w+\\s*=\\s*[\"'][^\"']*[\"']/gi, '')\n    .replace(/javascript:/gi, '');\n  \n  return escapeHtml(sanitized);\n}\n\n// Path traversal prevention\nfunction safeJoinPath(base: string, userPath: string): string {\n  const path = require('path');\n  const resolved = path.resolve(base, userPath);\n  \n  // Ensure result is within base directory\n  if (!resolved.startsWith(base)) {\n    throw new Error('Path traversal detected');\n  }\n  \n  return resolved;\n}\n\n// Secure configuration\ninterface SecureConfig {\n  readonly apiKey: string;\n  readonly dbPassword: string;\n  readonly jwtSecret: string;\n}\n\n// Never log sensitive data\nfunction logConfig(config: SecureConfig): void {\n  console.log({\n    // Mask sensitive values\n    apiKey: '***',\n    dbPassword: '***',\n    jwtSecret: '***'\n  });\n}\n\n// Type-safe environment variables\nfunction getEnv(key: string): string {\n  const value = process.env[key];\n  if (value === undefined) {\n    throw new Error(`Environment variable ${key} not set`);\n  }\n  return value;\n}\n\nconst config: SecureConfig = {\n  apiKey: getEnv('API_KEY'),\n  dbPassword: getEnv('DB_PASSWORD'),\n  jwtSecret: getEnv('JWT_SECRET')\n};"
    },
    {
      "id": 100,
      "question": "What are the latest TypeScript ecosystem trends and future directions?",
      "answer": "TypeScript ecosystem continues evolving with new features, tools, and community practices shaping modern development.\n\nLanguage Evolution:\n• Stage 3 decorators\n• Performance improvements\n• Better inference\n• Type system enhancements\n• ECMAScript alignment\n\nTooling Trends:\n• Faster build tools (esbuild, swc)\n• Better IDE integration\n• Enhanced debugging\n• Type-aware linters\n• AI-assisted development\n\nFramework Integration:\n• React Server Components\n• Next.js app router\n• SvelteKit\n• Solid.js\n• Astro\n\nArchitectural Patterns:\n• Monorepo with project references\n• Micro-frontends\n• Edge computing\n• Serverless TypeScript\n• WebAssembly integration\n\nType-Safety Trends:\n• End-to-end typing\n• Runtime validation libraries\n• Schema-first development\n• Type-safe routing\n• tRPC adoption\n\nBest Practices:\n• Strict mode default\n• Smaller bundles\n• Better tree-shaking\n• Native ESM\n• Modern target versions\n• Type-only imports\n\nCommunity Focus:\n• DX improvements\n• Learning resources\n• Type definitions quality\n• Migration guides\n• Best practices sharing",
      "explanation": "TypeScript's future involves performance improvements, better tooling, framework integration, enhanced type safety patterns, and evolving best practices for modern development.",
      "difficulty": "Medium",
      "code": "// Modern TypeScript features\n// Stage 3 decorators (TypeScript 5.0+)\nfunction logged(\n  target: any,\n  context: ClassMethodDecoratorContext\n) {\n  const methodName = String(context.name);\n  return function (this: any, ...args: any[]) {\n    console.log(`Calling ${methodName}`);\n    return target.call(this, ...args);\n  };\n}\n\nclass Service {\n  @logged\n  async fetchData() {\n    // Method implementation\n  }\n}\n\n// Satisfies operator (TypeScript 4.9+)\ntype Config = {\n  host: string;\n  port: number;\n};\n\nconst config = {\n  host: 'localhost',\n  port: 3000\n} satisfies Config;\n// Preserves literal types while ensuring shape\n\n// Const type parameters (TypeScript 5.0+)\nfunction tuple<const T extends readonly unknown[]>(...args: T): T {\n  return args;\n}\n\nconst result = tuple(1, 'hello', true);\n// Type: readonly [1, \"hello\", true]\n\n// Modern module syntax\n// Use type-only imports for better tree-shaking\nimport type { User } from './types';\nimport { fetchUser } from './api';\n\n// verbatimModuleSyntax (TypeScript 5.0+)\n// tsconfig.json\n// {\n//   \"compilerOptions\": {\n//     \"verbatimModuleSyntax\": true\n//   }\n// }\n\n// tRPC for end-to-end type safety\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\nconst t = initTRPC.create();\n\nconst appRouter = t.router({\n  userById: t.procedure\n    .input(z.object({ id: z.string() }))\n    .query(({ input }) => {\n      // Fully typed input\n      return getUserById(input.id);\n    }),\n  \n  createUser: t.procedure\n    .input(z.object({\n      name: z.string(),\n      email: z.string().email()\n    }))\n    .mutation(({ input }) => {\n      // Fully typed input\n      return createUser(input);\n    })\n});\n\nexport type AppRouter = typeof appRouter;\n\n// Client automatically gets types\nimport { createTRPCProxyClient } from '@trpc/client';\nimport type { AppRouter } from './server';\n\nconst client = createTRPCProxyClient<AppRouter>({\n  // ... config\n});\n\n// Fully typed!\nconst user = await client.userById.query({ id: '123' });\n\n// Modern bundler config\n// vite.config.ts\nimport { defineConfig } from 'vite';\n\nexport default defineConfig({\n  build: {\n    target: 'es2020',\n    minify: 'esbuild',\n    rollupOptions: {\n      output: {\n        manualChunks: {\n          vendor: ['react', 'react-dom']\n        }\n      }\n    }\n  },\n  esbuild: {\n    target: 'es2020',\n    tsconfigRaw: {\n      compilerOptions: {\n        useDefineForClassFields: true\n      }\n    }\n  }\n});\n\n// Edge computing with TypeScript\nexport default {\n  async fetch(request: Request): Promise<Response> {\n    // Runs on edge\n    const url = new URL(request.url);\n    return new Response(`Hello from ${url.pathname}`);\n  }\n} satisfies ExportedHandler;\n\n// React Server Components typing\n// app/page.tsx\nasync function ServerComponent() {\n  // Async component - only on server\n  const data = await fetchData();\n  \n  return (\n    <div>\n      <ClientComponent data={data} />\n    </div>\n  );\n}\n\n// Monorepo with pnpm workspaces\n// pnpm-workspace.yaml\n// packages:\n//   - 'packages/*'\n\n// Modern tsconfig.json\n// {\n//   \"compilerOptions\": {\n//     \"target\": \"ES2022\",\n//     \"module\": \"ESNext\",\n//     \"moduleResolution\": \"bundler\",\n//     \"strict\": true,\n//     \"verbatimModuleSyntax\": true,\n//     \"skipLibCheck\": true,\n//     \"esModuleInterop\": true,\n//     \"resolveJsonModule\": true,\n//     \"isolatedModules\": true,\n//     \"incremental\": true,\n//     \"noUncheckedIndexedAccess\": true\n//   }\n// }\n\n// Type-safe environment variables\nimport { z } from 'zod';\n\nconst envSchema = z.object({\n  DATABASE_URL: z.string().url(),\n  API_KEY: z.string().min(1),\n  NODE_ENV: z.enum(['development', 'production', 'test'])\n});\n\nexport const env = envSchema.parse(process.env);\n// Fully typed and validated!"
    }
  ]
}
